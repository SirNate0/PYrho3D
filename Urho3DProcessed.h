


namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}


typedef long int ptrdiff_t;
typedef long unsigned int size_t;
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;


namespace std
{

  using ::max_align_t;
}


namespace Urho3D
{

struct AllocatorBlock;
struct AllocatorNode;


struct AllocatorBlock
{

    unsigned nodeSize_;

    unsigned capacity_;

    AllocatorNode* free_;

    AllocatorBlock* next_;

};


struct AllocatorNode
{

    AllocatorNode* next_;

};


__attribute__((visibility("default"))) AllocatorBlock* AllocatorInitialize(unsigned nodeSize, unsigned initialCapacity = 1);

__attribute__((visibility("default"))) void AllocatorUninitialize(AllocatorBlock* allocator);

__attribute__((visibility("default"))) void* AllocatorReserve(AllocatorBlock* allocator);

__attribute__((visibility("default"))) void AllocatorFree(AllocatorBlock* allocator, void* ptr);


template <class T> class Allocator
{
public:

    explicit Allocator(unsigned initialCapacity = 0) :
        allocator_(nullptr)
    {
        if (initialCapacity)
            allocator_ = AllocatorInitialize((unsigned)sizeof(T), initialCapacity);
    }


    ~Allocator()
    {
        AllocatorUninitialize(allocator_);
    }


    Allocator(const Allocator<T>& rhs) = delete;

    Allocator<T>& operator =(const Allocator<T>& rhs) = delete;


    T* Reserve()
    {
        if (!allocator_)
            allocator_ = AllocatorInitialize((unsigned)sizeof(T));
        auto* newObject = static_cast<T*>(AllocatorReserve(allocator_));
        new(newObject) T();

        return newObject;
    }


    T* Reserve(const T& object)
    {
        if (!allocator_)
            allocator_ = AllocatorInitialize((unsigned)sizeof(T));
        auto* newObject = static_cast<T*>(AllocatorReserve(allocator_));
        new(newObject) T(object);

        return newObject;
    }


    void Free(T* object)
    {
        (object)->~T();
        AllocatorFree(allocator_, object);
    }

private:

    AllocatorBlock* allocator_;
};

}

namespace Urho3D
{


template <class T> unsigned MakeHash(T* value)
{
    return (unsigned)((size_t)value / sizeof(T));
}


template <class T> unsigned MakeHash(const T* value)
{
    return (unsigned)((size_t)value / sizeof(T));
}


template <class T> unsigned MakeHash(const T& value)
{
    return value.ToHash();
}


template <> inline unsigned MakeHash(void* value)
{
    return (unsigned)(size_t)value;
}


template <> inline unsigned MakeHash(const void* value)
{
    return (unsigned)(size_t)value;
}


template <> inline unsigned MakeHash(const long long& value)
{
    return (unsigned)((value >> 32u) | (value & 0xffffffffu));
}


template <> inline unsigned MakeHash(const unsigned long long& value)
{
    return (unsigned)((value >> 32u) | (value & 0xffffffffu));
}


template <> inline unsigned MakeHash(const int& value)
{
    return (unsigned)value;
}


template <> inline unsigned MakeHash(const unsigned& value)
{
    return value;
}


template <> inline unsigned MakeHash(const short& value)
{
    return (unsigned)value;
}


template <> inline unsigned MakeHash(const unsigned short& value)
{
    return value;
}


template <> inline unsigned MakeHash(const char& value)
{
    return (unsigned)value;
}


template <> inline unsigned MakeHash(const unsigned char& value)
{
    return value;
}

}

namespace Urho3D
{

class HashBase;
class ListBase;
class String;
class VectorBase;


template <class T> inline void Swap(T& first, T& second)
{
    T temp = first;
    first = second;
    second = temp;
}

template <> __attribute__((visibility("default"))) void Swap<String>(String& first, String& second);
template <> __attribute__((visibility("default"))) void Swap<VectorBase>(VectorBase& first, VectorBase& second);
template <> __attribute__((visibility("default"))) void Swap<ListBase>(ListBase& first, ListBase& second);
template <> __attribute__((visibility("default"))) void Swap<HashBase>(HashBase& first, HashBase& second);

}


namespace Urho3D
{


struct HashNodeBase
{

    HashNodeBase() :
        down_(nullptr),
        prev_(nullptr),
        next_(nullptr)
    {
    }


    HashNodeBase* down_;

    HashNodeBase* prev_;

    HashNodeBase* next_;
};


struct HashIteratorBase
{

    HashIteratorBase() :
        ptr_(nullptr)
    {
    }


    explicit HashIteratorBase(HashNodeBase* ptr) :
        ptr_(ptr)
    {
    }


    bool operator ==(const HashIteratorBase& rhs) const { return ptr_ == rhs.ptr_; }


    bool operator !=(const HashIteratorBase& rhs) const { return ptr_ != rhs.ptr_; }


    void GotoNext()
    {
        if (ptr_)
            ptr_ = ptr_->next_;
    }


    void GotoPrev()
    {
        if (ptr_)
            ptr_ = ptr_->prev_;
    }


    HashNodeBase* ptr_;
};





class __attribute__((visibility("default"))) HashBase
{
public:

    static const unsigned MIN_BUCKETS = 8;

    static const unsigned MAX_LOAD_FACTOR = 4;


    HashBase() :
        head_(nullptr),
        tail_(nullptr),
        ptrs_(nullptr),
        allocator_(nullptr)
    {
    }


    void Swap(HashBase& rhs)
    {
        Urho3D::Swap(head_, rhs.head_);
        Urho3D::Swap(tail_, rhs.tail_);
        Urho3D::Swap(ptrs_, rhs.ptrs_);
        Urho3D::Swap(allocator_, rhs.allocator_);
    }


    unsigned Size() const { return ptrs_ ? (reinterpret_cast<unsigned*>(ptrs_))[0] : 0; }


    unsigned NumBuckets() const { return ptrs_ ? (reinterpret_cast<unsigned*>(ptrs_))[1] : 0; }


    bool Empty() const { return Size() == 0; }

protected:

    void AllocateBuckets(unsigned size, unsigned numBuckets);


    void ResetPtrs();


    void SetSize(unsigned size) { if (ptrs_) (reinterpret_cast<unsigned*>(ptrs_))[0] = size; }


    HashNodeBase** Ptrs() const { return ptrs_ ? ptrs_ + 2 : nullptr; }


    HashNodeBase* head_;

    HashNodeBase* tail_;

    HashNodeBase** ptrs_;

    AllocatorBlock* allocator_;
};

}

namespace Urho3D
{


template <class T, class U> class Pair
{
public:

    Pair() = default;


    Pair(const T& first, const U& second) :
        first_(first),
        second_(second)
    {
    }


    bool operator ==(const Pair<T, U>& rhs) const { return first_ == rhs.first_ && second_ == rhs.second_; }


    bool operator !=(const Pair<T, U>& rhs) const { return first_ != rhs.first_ || second_ != rhs.second_; }


    bool operator <(const Pair<T, U>& rhs) const
    {
        if (first_ < rhs.first_)
            return true;
        if (first_ != rhs.first_)
            return false;
        return second_ < rhs.second_;
    }


    bool operator >(const Pair<T, U>& rhs) const
    {
        if (first_ > rhs.first_)
            return true;
        if (first_ != rhs.first_)
            return false;
        return second_ > rhs.second_;
    }


    unsigned ToHash() const { return (MakeHash(first_) & 0xffff) | (MakeHash(second_) << 16); }


    T first_;

    U second_;
};


template <class T, class U> Pair<T, U> MakePair(const T& first, const U& second)
{
    return Pair<T, U>(first, second);
}

template <class T> T begin(Urho3D::Pair<T, T>& range) { return range.first_; }

template <class T> T end(Urho3D::Pair<T, T>& range) { return range.second_; }

template <class T> T begin(const Urho3D::Pair<T, T>& range) { return range.first_; }

template <class T> T end(const Urho3D::Pair<T, T>& range) { return range.second_; }

}

namespace Urho3D
{


template <class T> struct RandomAccessIterator
{

    RandomAccessIterator() :
        ptr_(nullptr)
    {
    }


    explicit RandomAccessIterator(T* ptr) :
        ptr_(ptr)
    {
    }


    T* operator ->() const { return ptr_; }


    T& operator *() const { return *ptr_; }


    RandomAccessIterator<T>& operator ++()
    {
        ++ptr_;
        return *this;
    }


    RandomAccessIterator<T> operator ++(int)
    {
        RandomAccessIterator<T> it = *this;
        ++ptr_;
        return it;
    }


    RandomAccessIterator<T>& operator --()
    {
        --ptr_;
        return *this;
    }


    RandomAccessIterator<T> operator --(int)
    {
        RandomAccessIterator<T> it = *this;
        --ptr_;
        return it;
    }


    RandomAccessIterator<T>& operator +=(int value)
    {
        ptr_ += value;
        return *this;
    }


    RandomAccessIterator<T>& operator -=(int value)
    {
        ptr_ -= value;
        return *this;
    }


    RandomAccessIterator<T> operator +(int value) const { return RandomAccessIterator<T>(ptr_ + value); }


    RandomAccessIterator<T> operator -(int value) const { return RandomAccessIterator<T>(ptr_ - value); }


    int operator -(const RandomAccessIterator& rhs) const { return (int)(ptr_ - rhs.ptr_); }


    bool operator ==(const RandomAccessIterator& rhs) const { return ptr_ == rhs.ptr_; }


    bool operator !=(const RandomAccessIterator& rhs) const { return ptr_ != rhs.ptr_; }


    bool operator <(const RandomAccessIterator& rhs) const { return ptr_ < rhs.ptr_; }


    bool operator >(const RandomAccessIterator& rhs) const { return ptr_ > rhs.ptr_; }


    bool operator <=(const RandomAccessIterator& rhs) const { return ptr_ <= rhs.ptr_; }


    bool operator >=(const RandomAccessIterator& rhs) const { return ptr_ >= rhs.ptr_; }


    T* ptr_;
};


template <class T> struct RandomAccessConstIterator
{

    RandomAccessConstIterator() :
        ptr_(0)
    {
    }


    explicit RandomAccessConstIterator(const T* ptr) :
        ptr_(ptr)
    {
    }


    RandomAccessConstIterator(const RandomAccessIterator<T>& rhs) :
        ptr_(rhs.ptr_)
    {
    }


    RandomAccessConstIterator<T>& operator =(const RandomAccessIterator<T>& rhs)
    {
        ptr_ = rhs.ptr_;
        return *this;
    }


    const T* operator ->() const { return ptr_; }


    const T& operator *() const { return *ptr_; }


    RandomAccessConstIterator<T>& operator ++()
    {
        ++ptr_;
        return *this;
    }


    RandomAccessConstIterator<T> operator ++(int)
    {
        RandomAccessConstIterator<T> it = *this;
        ++ptr_;
        return it;
    }


    RandomAccessConstIterator<T>& operator --()
    {
        --ptr_;
        return *this;
    }


    RandomAccessConstIterator<T> operator --(int)
    {
        RandomAccessConstIterator<T> it = *this;
        --ptr_;
        return it;
    }


    RandomAccessConstIterator<T>& operator +=(int value)
    {
        ptr_ += value;
        return *this;
    }


    RandomAccessConstIterator<T>& operator -=(int value)
    {
        ptr_ -= value;
        return *this;
    }


    RandomAccessConstIterator<T> operator +(int value) const { return RandomAccessConstIterator<T>(ptr_ + value); }


    RandomAccessConstIterator<T> operator -(int value) const { return RandomAccessConstIterator<T>(ptr_ - value); }


    int operator -(const RandomAccessConstIterator& rhs) const { return (int)(ptr_ - rhs.ptr_); }


    bool operator ==(const RandomAccessConstIterator& rhs) const { return ptr_ == rhs.ptr_; }


    bool operator !=(const RandomAccessConstIterator& rhs) const { return ptr_ != rhs.ptr_; }


    bool operator <(const RandomAccessConstIterator& rhs) const { return ptr_ < rhs.ptr_; }


    bool operator >(const RandomAccessConstIterator& rhs) const { return ptr_ > rhs.ptr_; }


    bool operator <=(const RandomAccessConstIterator& rhs) const { return ptr_ <= rhs.ptr_; }


    bool operator >=(const RandomAccessConstIterator& rhs) const { return ptr_ >= rhs.ptr_; }


    const T* ptr_;
};


template <class TRandomAccessIterator, class T>
TRandomAccessIterator LowerBound(TRandomAccessIterator first, TRandomAccessIterator last, const T& value)
{
    unsigned count = last - first;

    while (count > 0)
    {
        const unsigned step = count / 2;
        const TRandomAccessIterator it = first + step;
        if (*it < value)
        {
            first = it + 1;
            count -= step + 1;
        }
        else
        {
            count = step;
        }
    }
    return first;
}


template <class TRandomAccessIterator, class T>
TRandomAccessIterator UpperBound(TRandomAccessIterator first, TRandomAccessIterator last, const T& value)
{
    unsigned count = last - first;

    while (count > 0)
    {
        const unsigned step = count / 2;
        const TRandomAccessIterator it = first + step;
        if (!(value < *it))
        {
            first = it + 1;
            count -= step + 1;
        }
        else
        {
            count = step;
        };
    }
    return first;
}





class __attribute__((visibility("default"))) VectorBase
{
public:

    VectorBase() noexcept :
        size_(0),
        capacity_(0),
        buffer_(nullptr)
    {
    }


    void Swap(VectorBase& rhs)
    {
        Urho3D::Swap(size_, rhs.size_);
        Urho3D::Swap(capacity_, rhs.capacity_);
        Urho3D::Swap(buffer_, rhs.buffer_);
    }

protected:
    static unsigned char* AllocateBuffer(unsigned size);


    unsigned size_;

    unsigned capacity_;

    unsigned char* buffer_;
};

}


namespace Urho3D
{

static const int QUICKSORT_THRESHOLD = 16;





template <class T> void InsertionSort(RandomAccessIterator<T> begin, RandomAccessIterator<T> end)
{
    for (RandomAccessIterator<T> i = begin + 1; i < end; ++i)
    {
        T temp = *i;
        RandomAccessIterator<T> j = i;
        while (j > begin && temp < *(j - 1))
        {
            *j = *(j - 1);
            --j;
        }
        *j = temp;
    }
}


template <class T, class U> void InsertionSort(RandomAccessIterator<T> begin, RandomAccessIterator<T> end, U compare)
{
    for (RandomAccessIterator<T> i = begin + 1; i < end; ++i)
    {
        T temp = *i;
        RandomAccessIterator<T> j = i;
        while (j > begin && compare(temp, *(j - 1)))
        {
            *j = *(j - 1);
            --j;
        }
        *j = temp;
    }
}


template <class T> void InitialQuickSort(RandomAccessIterator<T> begin, RandomAccessIterator<T> end)
{
    while (end - begin > QUICKSORT_THRESHOLD)
    {

        RandomAccessIterator<T> pivot = begin + ((end - begin) / 2);
        if (*begin < *pivot && *(end - 1) < *begin)
            pivot = begin;
        else if (*(end - 1) < *pivot && *begin < *(end - 1))
            pivot = end - 1;


        RandomAccessIterator<T> i = begin - 1;
        RandomAccessIterator<T> j = end;
        T pivotValue = *pivot;
        for (;;)
        {
            while (pivotValue < *(--j));
            while (*(++i) < pivotValue);
            if (i < j)
                Swap(*i, *j);
            else
                break;
        }

        InitialQuickSort(begin, j + 1);
        begin = j + 1;
    }
}


template <class T, class U> void InitialQuickSort(RandomAccessIterator<T> begin, RandomAccessIterator<T> end, U compare)
{
    while (end - begin > QUICKSORT_THRESHOLD)
    {

        RandomAccessIterator<T> pivot = begin + ((end - begin) / 2);
        if (compare(*begin, *pivot) && compare(*(end - 1), *begin))
            pivot = begin;
        else if (compare(*(end - 1), *pivot) && compare(*begin, *(end - 1)))
            pivot = end - 1;


        RandomAccessIterator<T> i = begin - 1;
        RandomAccessIterator<T> j = end;
        T pivotValue = *pivot;
        for (;;)
        {
            while (compare(pivotValue, *(--j)));
            while (compare(*(++i), pivotValue));
            if (i < j)
                Swap(*i, *j);
            else
                break;
        }

        InitialQuickSort(begin, j + 1, compare);
        begin = j + 1;
    }
}


template <class T> void Sort(RandomAccessIterator<T> begin, RandomAccessIterator<T> end)
{
    InitialQuickSort(begin, end);
    InsertionSort(begin, end);
}


template <class T, class U> void Sort(RandomAccessIterator<T> begin, RandomAccessIterator<T> end, U compare)
{
    InitialQuickSort(begin, end, compare);
    InsertionSort(begin, end, compare);
}

}


extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}



extern "C" {





extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern void *rawmemchr (const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern void *memrchr (const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));







typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
extern char *strchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strrchr (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *strchrnul (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strpbrk (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *strstr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
extern char *strcasestr (const char *__haystack, const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *index (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern char *rindex (const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
extern char *basename (const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
}
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}


namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }


  }

}

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}



namespace std
{
  typedef unsigned short uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>::type
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>::type
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<wchar_t> : __make_unsigned<int>
    { };
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;






  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __success_type<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}





namespace std __attribute__ ((__visibility__ ("default")))
{
  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }







      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<class _U1, class = typename
        enable_if<is_convertible<_U1, _T1>::value>::type>
 constexpr pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        enable_if<is_convertible<_U2, _T2>::value>::type>
 constexpr pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
        && noexcept(swap(second, __p.second)))
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
}









#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<class _Tp>
    class tuple_size;

  template<std::size_t _Int, class _Tp>
    class tuple_element;




  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes>
    struct _Index_tuple
    {
      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    {
      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



}

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}








namespace std __attribute__ ((__visibility__ ("default")))
{
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}


namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


                                     ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp, typename = __void_t<>> struct __has_element_type : false_type { }; template<typename _Tp> struct __has_element_type<_Tp, __void_t<typename _Tp::element_type>> : true_type { };
template<typename _Tp, typename = __void_t<>> struct __has_difference_type : false_type { }; template<typename _Tp> struct __has_difference_type<_Tp, __void_t<typename _Tp::difference_type>> : true_type { };

  template<typename _Tp, bool = __has_element_type<_Tp>::value>
    struct __ptrtr_elt_type;

  template<typename _Tp>
    struct __ptrtr_elt_type<_Tp, true>
    {
      typedef typename _Tp::element_type __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Tp,
            typename... _Args>
    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>
    {
      typedef _Tp __type;
    };

  template<typename _Tp, bool = __has_difference_type<_Tp>::value>
    struct __ptrtr_diff_type
    {
      typedef typename _Tp::difference_type __type;
    };

  template<typename _Tp>
    struct __ptrtr_diff_type<_Tp, false>
    {
      typedef ptrdiff_t __type;
    };

  template<typename _Ptr, typename _Up>
    class __ptrtr_rebind_helper
    {
      template<typename _Ptr2, typename _Up2>
 static constexpr true_type
 _S_chk(typename _Ptr2::template rebind<_Up2>*);

      template<typename, typename>
 static constexpr false_type
 _S_chk(...);

    public:
      using __type = decltype(_S_chk<_Ptr, _Up>(nullptr));
    };

  template<typename _Tp, typename _Up,
           bool = __ptrtr_rebind_helper<_Tp, _Up>::__type::value>
    struct __ptrtr_rebind;

  template<typename _Tp, typename _Up>
    struct __ptrtr_rebind<_Tp, _Up, true>
    {
      typedef typename _Tp::template rebind<_Up> __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Up,
            typename _Tp, typename... _Args>
    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false>
    {
      typedef _SomePtr<_Up, _Args...> __type;
    };

  template<typename _Tp, typename = typename remove_cv<_Tp>::type>
    struct __ptrtr_not_void
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __ptrtr_not_void<_Tp, void>
    {
      struct __type { };
    };

  template<typename _Ptr>
    class __ptrtr_pointer_to
    {
      typedef typename __ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;

    public:
      static _Ptr pointer_to(__element_type& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptrtr_pointer_to<_Ptr>
    {

      typedef _Ptr pointer;

      typedef typename __ptrtr_elt_type<_Ptr>::__type element_type;

      typedef typename __ptrtr_diff_type<_Ptr>::__type difference_type;

      template<typename _Up>
        using rebind = typename __ptrtr_rebind<_Ptr, _Up>::__type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r) noexcept
      { return std::addressof(__r); }
    };


}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }




}



namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      swap(*__a, *__b);

    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




                                                                  ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {






                                                       ;
                                                       ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {



                                                       ;
                                                       ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {



                                                       ;
                                                       ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {



                                                       ;
                                                       ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}

extern "C" {







typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;







union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;









typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;



typedef __sigset_t sigset_t;






struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };

struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };








typedef long int __fd_mask;
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
extern "C" {
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
}


extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
}





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;


}






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();





extern "C" {





extern void *alloca (size_t __size) throw ();





}





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();
extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));



}
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}








namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    ;

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    ;

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
   __gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
 __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                  ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_less_val());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                         ;
                                                     ;
                                              ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_less_iter());
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                         ;
                                                           ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                              ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;

      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last),
        __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {



                                                     ;

      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last),
          __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}



#pragma GCC visibility push(default)




extern "C++" {

namespace std
{
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char* what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char* what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
  bool uncaught_exception() noexcept __attribute__ ((__pure__));


}

namespace __gnu_cxx
{
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop



#pragma GCC visibility push(default)








extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }



    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
#pragma GCC visibility push(default)
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Tp,
    bool __with_nested = !__is_base_of(nested_exception, _Tp)>
    struct _Throw_with_nested_impl
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }
    };

  template<typename _Tp>
    struct _Throw_with_nested_impl<_Tp, false>
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw static_cast<_Up&&>(__t); }
    };

  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>
    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp, false>
    : _Throw_with_nested_impl<_Tp, false>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&, false>
    : _Throw_with_nested_helper<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&&, false>
    : _Throw_with_nested_helper<_Tp>
    { };



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));
    }

  template<typename _Tp, bool = __is_polymorphic(_Tp)>
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow(const _Tp& __t)
      {
 if (auto __tp = dynamic_cast<const nested_exception*>(&__t))
   __tp->rethrow_nested();
      }
    };

  template<typename _Tp>
    struct _Rethrow_if_nested_impl<_Tp, false>
    {
      static void _S_rethrow(const _Tp&) { }
    };


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
    }


}

}



#pragma GCC visibility pop

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };


  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop







namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc, typename _Tp>
    class __alloctr_rebind_helper
    {
      template<typename _Alloc2, typename _Tp2>
 static constexpr true_type
 _S_chk(typename _Alloc2::template rebind<_Tp2>::other*);

      template<typename, typename>
 static constexpr false_type
 _S_chk(...);

    public:
      using __type = decltype(_S_chk<_Alloc, _Tp>(nullptr));
    };

  template<typename _Alloc, typename _Tp,
    bool = __alloctr_rebind_helper<_Alloc, _Tp>::__type::value>
    struct __alloctr_rebind;

  template<typename _Alloc, typename _Tp>
    struct __alloctr_rebind<_Alloc, _Tp, true>
    {
      typedef typename _Alloc::template rebind<_Tp>::other __type;
    };

  template<template<typename, typename...> class _Alloc, typename _Tp,
    typename _Up, typename... _Args>
    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>
    {
      typedef _Alloc<_Tp, _Args...> __type;
    };

  template<typename _Alloc, typename _Tp>
    using __alloc_rebind = typename __alloctr_rebind<_Alloc, _Tp>::__type;





  template<typename _Alloc>
    struct allocator_traits
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;
private: template<typename _Tp> static typename _Tp::pointer _S_pointer_helper(_Tp*); static value_type* _S_pointer_helper(...); typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer; public:






      typedef __pointer pointer;

private: template<typename _Tp> static typename _Tp::const_pointer _S_const_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const value_type> _S_const_pointer_helper(...); typedef decltype(_S_const_pointer_helper((_Alloc*)0)) __const_pointer; public:
      typedef __const_pointer const_pointer;

private: template<typename _Tp> static typename _Tp::void_pointer _S_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<void> _S_void_pointer_helper(...); typedef decltype(_S_void_pointer_helper((_Alloc*)0)) __void_pointer; public:
      typedef __void_pointer void_pointer;

private: template<typename _Tp> static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const void> _S_const_void_pointer_helper(...); typedef decltype(_S_const_void_pointer_helper((_Alloc*)0)) __const_void_pointer; public:
      typedef __const_void_pointer const_void_pointer;

private: template<typename _Tp> static typename _Tp::difference_type _S_difference_type_helper(_Tp*); static typename pointer_traits<pointer>::difference_type _S_difference_type_helper(...); typedef decltype(_S_difference_type_helper((_Alloc*)0)) __difference_type; public:
      typedef __difference_type difference_type;

private: template<typename _Tp> static typename _Tp::size_type _S_size_type_helper(_Tp*); static typename make_unsigned<difference_type>::type _S_size_type_helper(...); typedef decltype(_S_size_type_helper((_Alloc*)0)) __size_type; public:
      typedef __size_type size_type;

private: template<typename _Tp> static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp*); static false_type _S_propagate_on_container_copy_assignment_helper(...); typedef decltype(_S_propagate_on_container_copy_assignment_helper((_Alloc*)0)) __propagate_on_container_copy_assignment; public:
      typedef __propagate_on_container_copy_assignment
 propagate_on_container_copy_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp*); static false_type _S_propagate_on_container_move_assignment_helper(...); typedef decltype(_S_propagate_on_container_move_assignment_helper((_Alloc*)0)) __propagate_on_container_move_assignment; public:
      typedef __propagate_on_container_move_assignment
 propagate_on_container_move_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp*); static false_type _S_propagate_on_container_swap_helper(...); typedef decltype(_S_propagate_on_container_swap_helper((_Alloc*)0)) __propagate_on_container_swap; public:
      typedef __propagate_on_container_swap propagate_on_container_swap;



      template<typename _Tp>
 using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 struct __allocate_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->allocate(
    std::declval<size_type>(),
    std::declval<const_void_pointer>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Alloc2>
 using __has_allocate = typename __allocate_helper<_Alloc2>::type;

      template<typename _Alloc2,
        typename = _Require<__has_allocate<_Alloc2>>>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2, typename _UnusedHint,
        typename = _Require<__not_<__has_allocate<_Alloc2>>>>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, _UnusedHint)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Tp>
 struct __destroy_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->destroy(
    std::declval<_Tp*>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp>
 using __has_destroy = typename __destroy_helper<_Tp>::type;

      template<typename _Tp>
 static _Require<__has_destroy<_Tp>>
 _S_destroy(_Alloc& __a, _Tp* __p)
 { __a.destroy(__p); }

      template<typename _Tp>
 static _Require<__not_<__has_destroy<_Tp>>>
 _S_destroy(_Alloc&, _Tp* __p)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 struct __maxsize_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->max_size())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc2>(0));
 };

      template<typename _Alloc2>
 using __has_max_size = typename __maxsize_helper<_Alloc2>::type;

      template<typename _Alloc2,
        typename = _Require<__has_max_size<_Alloc2>>>
 static size_type
 _S_max_size(_Alloc2& __a, int)
 { return __a.max_size(); }

      template<typename _Alloc2,
        typename = _Require<__not_<__has_max_size<_Alloc2>>>>
 static size_type
 _S_max_size(_Alloc2&, ...)
 { return __gnu_cxx::__numeric_traits<size_type>::__max; }

      template<typename _Alloc2>
 struct __select_helper
 {
   template<typename _Alloc3, typename
     = decltype(std::declval<_Alloc3*>()
  ->select_on_container_copy_construction())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc2>(0));
 };

      template<typename _Alloc2>
 using __has_soccc = typename __select_helper<_Alloc2>::type;

      template<typename _Alloc2,
        typename = _Require<__has_soccc<_Alloc2>>>
 static _Alloc2
 _S_select(_Alloc2& __a, int)
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2,
        typename = _Require<__not_<__has_soccc<_Alloc2>>>>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint); }
      static void deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p); }
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocator_always_compares_equal : std::false_type { };

  template<typename _Tp>
    struct __allocator_always_compares_equal<std::allocator<_Tp>>
    : std::true_type { };

  template<typename, typename> struct array_allocator;

  template<typename _Tp, typename _Array>
    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
    : std::true_type { };

  template<typename> struct bitmap_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct malloc_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct mt_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct new_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<new_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct pool_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
    : std::true_type { };






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return __allocator_always_compares_equal<_Alloc>::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    static constexpr bool _S_nothrow_swap()
    {
      using std::swap;
      return !_S_propagate_on_swap()
        || noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
  };


}

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}












extern "C" {














typedef float float_t;
typedef double double_t;
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();
 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();
extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));






extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();
 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));
extern int isinff (float __value) throw () __attribute__ ((__const__));



extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));






extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();
extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));






extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();
 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));
extern int isinfl (long double __value) throw () __attribute__ ((__const__));



extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));






extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();
extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));






extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
extern int signgam;
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
}
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbitf(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbitl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
}
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}






namespace std __attribute__ ((__visibility__ ("default")))
{
  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}







struct _IO_FILE;



typedef struct _IO_FILE FILE;
typedef struct _IO_FILE __FILE;


typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;

typedef unsigned int wint_t;
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
extern "C" {




struct tm;
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();
extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));






extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     throw () __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
}
namespace std
{
  using ::mbstate_t;
}
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
namespace std __attribute__ ((__visibility__ ("default")))
{
  typedef long streamoff;
  typedef ptrdiff_t streamsize;
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}













typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}


namespace std
{
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}





namespace std __attribute__ ((__visibility__ ("default")))
{
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

    };
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}







extern "C" {
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}








namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}





namespace std __attribute__ ((__visibility__ ("default")))
{
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}


extern "C" {
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();
extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
}
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}



#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}



namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };






  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop





namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<class _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<class _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<class _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<class _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<class _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<class _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<class _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<class _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<class _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<class _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<class _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<class _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }




}



#pragma GCC visibility push(default)













struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
extern "C" {











struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
extern int getdate_err;
extern struct tm *getdate (const char *__string);
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}






typedef long int __jmp_buf[8];



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}


#pragma GCC visibility pop
typedef int _Atomic_word;

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}






namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;



      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }

 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)"),

       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(), __str._M_get_allocator())
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str.get_allocator() == __a)
   *this = std::move(__str);
 else
   _M_construct(__str.begin(), __str.end());
      }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }




      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
      basic_string&
      operator=(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
      void
      resize(size_type __n, _CharT __c);
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
      const_reference
      operator[] (size_type __pos) const noexcept
      {
                                       ;
 return _M_data()[__pos];
      }
      reference
      operator[](size_type __pos)
      {


                                       ;

                                                                   ;
 return _M_data()[__pos];
      }
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      { return operator[](0); }





      const_reference
      front() const noexcept
      { return operator[](0); }





      reference
      back() noexcept
      { return operator[](this->size() - 1); }





      const_reference
      back() const noexcept
      { return operator[](this->size() - 1); }
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
                                        ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
      basic_string&
      assign(basic_string&& __str)
      {


 return *this = std::move(__str);
      }
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
                                        ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
                                                           ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
                                                         ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
                                                         ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 this->_M_erase(_M_check(__pos, "basic_string::erase"),
         _M_limit(__pos, __n));
 return *this;
      }
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      { _M_erase(size()-1, 1); }
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
                                         ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                        ;
                                             ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
                                           ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
      void
      swap(basic_string& __s) noexcept;
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
      int
      compare(const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
}
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}


















extern "C" {








typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
}




typedef __gnuc_va_list va_list;
typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
extern FILE *tmpfile (void) ;
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
extern int fflush_unlocked (FILE *__stream);
extern int fcloseall (void);
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;
extern void perror (const char *__s);







extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
}
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx
{
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}

extern "C" {







extern int *__errno_location (void) throw () __attribute__ ((__const__));
extern char *program_invocation_name, *program_invocation_short_name;



}
typedef int error_t;

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {


  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}










namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };






  inline namespace literals
  {
  inline namespace string_literals
  {

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


  }
  }




}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;




      std::__alloc_swap<allocator_type>::_S_do_it(_M_get_allocator(),
        __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid"));


 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   _CharT* __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   _CharT* __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}

namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}










namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
      vector&
      operator=(const vector& __x);
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x),
                       integral_constant<bool, __move_storage>());
 return *this;
      }
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
      void
      reserve(size_type __n);
      reference
      operator[](size_type __n) noexcept
      { return *(this->_M_impl._M_start + __n); }
      const_reference
      operator[](size_type __n) const noexcept
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      { return *(end() - 1); }





      const_reference
      back() const noexcept
      { return *(end() - 1); }
      _Tp*



      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }


      const _Tp*



      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
      void
      pop_back() noexcept
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
      iterator
      insert(const_iterator __position, const value_type& __x);
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      { return this->insert(__position, __l.begin(), __l.end()); }
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
      void
      swap(vector& __x)

      noexcept(_Alloc_traits::_S_nothrow_swap())

      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }



      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const
 { return __ptr; }

      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }






    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"),


     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)

      noexcept(_Bit_alloc_traits::_S_nothrow_swap())

    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>
      void
      emplace_back(_Args&&... __args)
      { push_back(bool(__args...)); }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}





namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   const auto __pos = begin() + (__position - cbegin());
   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__pos, std::move(__x_copy));
     }
   else
     _M_insert_aux(__pos, __x);



 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + (__position - cbegin()),
   std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);





   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = pointer();

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 try
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = pointer();

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 catch(...)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     throw;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    __new_finish =
      std::__uninitialized_default_n_a(__new_finish, __n,
           _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };
  }
  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
                                      ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }


}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __g);






  namespace __detail
  {


    template<typename _UIntType, size_t __w,
      bool = __w < static_cast<size_t>
     (std::numeric_limits<_UIntType>::digits)>
      struct _Shift
      { static const _UIntType __value = 0; };

    template<typename _UIntType, size_t __w>
      struct _Shift<_UIntType, __w, true>
      { static const _UIntType __value = _UIntType(1) << __w; };

    template<int __s,
      int __which = ((__s <= 8 * sizeof (int))
       + (__s <= 8 * sizeof (long))
       + (__s <= 8 * sizeof (long long))

       + (__s <= 128))>
      struct _Select_uint_least_t
      {
 static_assert(__which < 0,
        "sorry, would be too much trouble for a slow result");
      };

    template<int __s>
      struct _Select_uint_least_t<__s, 4>
      { typedef unsigned int type; };

    template<int __s>
      struct _Select_uint_least_t<__s, 3>
      { typedef unsigned long type; };

    template<int __s>
      struct _Select_uint_least_t<__s, 2>
      { typedef unsigned long long type; };


    template<int __s>
      struct _Select_uint_least_t<__s, 1>
      { typedef unsigned __int128 type; };



    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c,
      bool __big_enough = (!(__m & (__m - 1))
      || (_Tp(-1) - __c) / __a >= __m - 1),
             bool __schrage_ok = __m % __a < __m / __a>
      struct _Mod
      {
 typedef typename _Select_uint_least_t<std::__lg(__a)
           + std::__lg(__m) + 2>::type _Tp2;
 static _Tp
 __calc(_Tp __x)
 { return static_cast<_Tp>((_Tp2(__a) * __x + __c) % __m); }
      };


    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
      struct _Mod<_Tp, __m, __a, __c, false, true>
      {
 static _Tp
 __calc(_Tp __x);
      };




    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool __s>
      struct _Mod<_Tp, __m, __a, __c, true, __s>
      {
 static _Tp
 __calc(_Tp __x)
 {
   _Tp __res = __a * __x + __c;
   if (__m)
     __res %= __m;
   return __res;
 }
      };

    template<typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0>
      inline _Tp
      __mod(_Tp __x)
      { return _Mod<_Tp, __m, __a, __c>::__calc(__x); }





    template<typename _Engine, typename _DInputType>
      struct _Adaptor
      {
 static_assert(std::is_floating_point<_DInputType>::value,
        "template argument not a floating point type");

      public:
 _Adaptor(_Engine& __g)
 : _M_g(__g) { }

 _DInputType
 min() const
 { return _DInputType(0); }

 _DInputType
 max() const
 { return _DInputType(1); }






 _DInputType
 operator()()
 {
   return std::generate_canonical<_DInputType,
                             std::numeric_limits<_DInputType>::digits,
                             _Engine>(_M_g);
 }

      private:
 _Engine& _M_g;
      };


  }
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    class linear_congruential_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(__m == 0u || (__a < __m && __c < __m),
      "template argument substituting __m out of bounds");

    public:

      typedef _UIntType result_type;


      static constexpr result_type multiplier = __a;

      static constexpr result_type increment = __c;

      static constexpr result_type modulus = __m;
      static constexpr result_type default_seed = 1u;
      explicit
      linear_congruential_engine(result_type __s = default_seed)
      { seed(__s); }







      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, linear_congruential_engine>::value>
        ::type>
        explicit
        linear_congruential_engine(_Sseq& __q)
        { seed(__q); }







      void
      seed(result_type __s = default_seed);
      template<typename _Sseq>
        typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);







      static constexpr result_type
      min()
      { return __c == 0u ? 1u : 0u; }




      static constexpr result_type
      max()
      { return __m - 1u; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()()
      {
 _M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
 return _M_x;
      }
      friend bool
      operator==(const linear_congruential_engine& __lhs,
   const linear_congruential_engine& __rhs)
      { return __lhs._M_x == __rhs._M_x; }
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::linear_congruential_engine<_UIntType1,
     __a1, __c1, __m1>& __lcr);
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::linear_congruential_engine<_UIntType1, __a1,
     __c1, __m1>& __lcr);

    private:
      _UIntType _M_x;
    };
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    inline bool
    operator!=(const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __lhs,
        const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    class mersenne_twister_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(1u <= __m && __m <= __n,
      "template argument substituting __m out of bounds");
      static_assert(__r <= __w, "template argument substituting "
      "__r out of bound");
      static_assert(__u <= __w, "template argument substituting "
      "__u out of bound");
      static_assert(__s <= __w, "template argument substituting "
      "__s out of bound");
      static_assert(__t <= __w, "template argument substituting "
      "__t out of bound");
      static_assert(__l <= __w, "template argument substituting "
      "__l out of bound");
      static_assert(__w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bound");
      static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __a out of bound");
      static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __b out of bound");
      static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __c out of bound");
      static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __d out of bound");
      static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __f out of bound");

    public:

      typedef _UIntType result_type;


      static constexpr size_t word_size = __w;
      static constexpr size_t state_size = __n;
      static constexpr size_t shift_size = __m;
      static constexpr size_t mask_bits = __r;
      static constexpr result_type xor_mask = __a;
      static constexpr size_t tempering_u = __u;
      static constexpr result_type tempering_d = __d;
      static constexpr size_t tempering_s = __s;
      static constexpr result_type tempering_b = __b;
      static constexpr size_t tempering_t = __t;
      static constexpr result_type tempering_c = __c;
      static constexpr size_t tempering_l = __l;
      static constexpr result_type initialization_multiplier = __f;
      static constexpr result_type default_seed = 5489u;


      explicit
      mersenne_twister_engine(result_type __sd = default_seed)
      { seed(__sd); }







      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
        ::type>
        explicit
        mersenne_twister_engine(_Sseq& __q)
        { seed(__q); }

      void
      seed(result_type __sd = default_seed);

      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);




      static constexpr result_type
      min()
      { return 0; };




      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z);

      result_type
      operator()();
      friend bool
      operator==(const mersenne_twister_engine& __lhs,
   const mersenne_twister_engine& __rhs)
      { return (std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x)
  && __lhs._M_p == __rhs._M_p); }
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
     __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>& __x);
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
     __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>& __x);

    private:
      void _M_gen_rand();

      _UIntType _M_x[state_size];
      size_t _M_p;
    };
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    inline bool
    operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
        const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    class subtract_with_carry_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __s && __s < __r,
      "template argument substituting __s out of bounds");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");

    public:

      typedef _UIntType result_type;


      static constexpr size_t word_size = __w;
      static constexpr size_t short_lag = __s;
      static constexpr size_t long_lag = __r;
      static constexpr result_type default_seed = 19780503u;





      explicit
      subtract_with_carry_engine(result_type __sd = default_seed)
      { seed(__sd); }







      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, subtract_with_carry_engine>::value>
        ::type>
        explicit
        subtract_with_carry_engine(_Sseq& __q)
        { seed(__q); }
      void
      seed(result_type __sd = default_seed);





      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);





      static constexpr result_type
      min()
      { return 0; }





      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
      friend bool
      operator==(const subtract_with_carry_engine& __lhs,
   const subtract_with_carry_engine& __rhs)
      { return (std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x)
  && __lhs._M_carry == __rhs._M_carry
  && __lhs._M_p == __rhs._M_p); }
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>& __x);
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>& __x);

    private:

      _UIntType _M_x[long_lag];
      _UIntType _M_carry;
      size_t _M_p;
    };
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    inline bool
    operator!=(const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __lhs,
        const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    class discard_block_engine
    {
      static_assert(1 <= __r && __r <= __p,
      "template argument substituting __r out of bounds");

    public:

      typedef typename _RandomNumberEngine::result_type result_type;


      static constexpr size_t block_size = __p;
      static constexpr size_t used_block = __r;






      discard_block_engine()
      : _M_b(), _M_n(0) { }







      explicit
      discard_block_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng), _M_n(0) { }







      explicit
      discard_block_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng)), _M_n(0) { }







      explicit
      discard_block_engine(result_type __s)
      : _M_b(__s), _M_n(0) { }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, discard_block_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        discard_block_engine(_Sseq& __q)
 : _M_b(__q), _M_n(0)
        { }





      void
      seed()
      {
 _M_b.seed();
 _M_n = 0;
      }





      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_n = 0;
      }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_n = 0;
 }





      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return _RandomNumberEngine::min(); }




      static constexpr result_type
      max()
      { return _RandomNumberEngine::max(); }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
      friend bool
      operator==(const discard_block_engine& __lhs,
   const discard_block_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b && __lhs._M_n == __rhs._M_n; }
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>& __x);
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>& __x);

    private:
      _RandomNumberEngine _M_b;
      size_t _M_n;
    };
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    inline bool
    operator!=(const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __lhs,
        const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __rhs)
    { return !(__lhs == __rhs); }






  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    class independent_bits_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");

    public:

      typedef _UIntType result_type;






      independent_bits_engine()
      : _M_b() { }







      explicit
      independent_bits_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng) { }







      explicit
      independent_bits_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng)) { }







      explicit
      independent_bits_engine(result_type __s)
      : _M_b(__s) { }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, independent_bits_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
               ::type>
        explicit
        independent_bits_engine(_Sseq& __q)
        : _M_b(__q)
        { }





      void
      seed()
      { _M_b.seed(); }





      void
      seed(result_type __s)
      { _M_b.seed(__s); }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        { _M_b.seed(__q); }





      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return 0U; }




      static constexpr result_type
      max()
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
      friend bool
      operator==(const independent_bits_engine& __lhs,
   const independent_bits_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b; }
      template<typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::independent_bits_engine<_RandomNumberEngine,
     __w, _UIntType>& __x)
 {
   __is >> __x._M_b;
   return __is;
 }

    private:
      _RandomNumberEngine _M_b;
    };
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    inline bool
    operator!=(const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __lhs,
        const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::independent_bits_engine<_RandomNumberEngine,
        __w, _UIntType>& __x)
    {
      __os << __x.base();
      return __os;
    }







  template<typename _RandomNumberEngine, size_t __k>
    class shuffle_order_engine
    {
      static_assert(1u <= __k, "template argument substituting "
      "__k out of bound");

    public:

      typedef typename _RandomNumberEngine::result_type result_type;

      static constexpr size_t table_size = __k;






      shuffle_order_engine()
      : _M_b()
      { _M_initialize(); }







      explicit
      shuffle_order_engine(const _RandomNumberEngine& __rng)
      : _M_b(__rng)
      { _M_initialize(); }







      explicit
      shuffle_order_engine(_RandomNumberEngine&& __rng)
      : _M_b(std::move(__rng))
      { _M_initialize(); }







      explicit
      shuffle_order_engine(result_type __s)
      : _M_b(__s)
      { _M_initialize(); }






      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, shuffle_order_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        shuffle_order_engine(_Sseq& __q)
        : _M_b(__q)
        { _M_initialize(); }





      void
      seed()
      {
 _M_b.seed();
 _M_initialize();
      }





      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_initialize();
      }






      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_initialize();
 }




      const _RandomNumberEngine&
      base() const noexcept
      { return _M_b; }




      static constexpr result_type
      min()
      { return _RandomNumberEngine::min(); }




      static constexpr result_type
      max()
      { return _RandomNumberEngine::max(); }




      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }




      result_type
      operator()();
      friend bool
      operator==(const shuffle_order_engine& __lhs,
   const shuffle_order_engine& __rhs)
      { return (__lhs._M_b == __rhs._M_b
  && std::equal(__lhs._M_v, __lhs._M_v + __k, __rhs._M_v)
  && __lhs._M_y == __rhs._M_y); }
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::shuffle_order_engine<_RandomNumberEngine1,
     __k1>& __x);
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::shuffle_order_engine<_RandomNumberEngine1, __k1>& __x);

    private:
      void _M_initialize()
      {
 for (size_t __i = 0; __i < __k; ++__i)
   _M_v[__i] = _M_b();
 _M_y = _M_b();
      }

      _RandomNumberEngine _M_b;
      result_type _M_v[__k];
      result_type _M_y;
    };
  template<typename _RandomNumberEngine, size_t __k>
    inline bool
    operator!=(const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __lhs,
        const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __rhs)
    { return !(__lhs == __rhs); }





  typedef linear_congruential_engine<uint_fast32_t, 16807UL, 0UL, 2147483647UL>
  minstd_rand0;




  typedef linear_congruential_engine<uint_fast32_t, 48271UL, 0UL, 2147483647UL>
  minstd_rand;
  typedef mersenne_twister_engine<
    uint_fast32_t,
    32, 624, 397, 31,
    0x9908b0dfUL, 11,
    0xffffffffUL, 7,
    0x9d2c5680UL, 15,
    0xefc60000UL, 18, 1812433253UL> mt19937;




  typedef mersenne_twister_engine<
    uint_fast64_t,
    64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29,
    0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37,
    0xfff7eee000000000ULL, 43,
    6364136223846793005ULL> mt19937_64;

  typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>
    ranlux24_base;

  typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>
    ranlux48_base;

  typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;

  typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;

  typedef shuffle_order_engine<minstd_rand0, 256> knuth_b;

  typedef minstd_rand0 default_random_engine;





  class random_device
  {
  public:

    typedef unsigned int result_type;





    explicit
    random_device(const std::string& __token = "default")
    {
      _M_init(__token);
    }

    ~random_device()
    { _M_fini(); }
    static constexpr result_type
    min()
    { return std::numeric_limits<result_type>::min(); }

    static constexpr result_type
    max()
    { return std::numeric_limits<result_type>::max(); }

    double
    entropy() const noexcept
    { return 0.0; }

    result_type
    operator()()
    {

      return this->_M_getval();



    }


    random_device(const random_device&) = delete;
    void operator=(const random_device&) = delete;

  private:

    void _M_init(const std::string& __token);
    void _M_init_pretr1(const std::string& __token);
    void _M_fini();

    result_type _M_getval();
    result_type _M_getval_pretr1();

    union
    {
      void* _M_file;
      mt19937 _M_mt;
    };
  };
  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_int_distribution<_IntType>& __d1,
        const std::uniform_int_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_int_distribution<_IntType>&);
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_int_distribution<_IntType>&);
  template<typename _RealType = double>
    class uniform_real_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef uniform_real_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 {
                                      ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

    public:






      explicit
      uniform_real_distribution(_RealType __a = _RealType(0),
    _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      uniform_real_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return (__aurng() * (__p.b() - __p.a())) + __p.a();
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_real_distribution& __d1,
   const uniform_real_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_real_distribution<_IntType>& __d1,
        const std::uniform_real_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_real_distribution<_RealType>&);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_real_distribution<_RealType>&);
  template<typename _RealType = double>
    class normal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef normal_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __mean = _RealType(0),
     _RealType __stddev = _RealType(1))
 : _M_mean(__mean), _M_stddev(__stddev)
 {
                                                  ;
 }

 _RealType
 mean() const
 { return _M_mean; }

 _RealType
 stddev() const
 { return _M_stddev; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_mean == __p2._M_mean
    && __p1._M_stddev == __p2._M_stddev); }

      private:
 _RealType _M_mean;
 _RealType _M_stddev;
      };

    public:




      explicit
      normal_distribution(result_type __mean = result_type(0),
     result_type __stddev = result_type(1))
      : _M_param(__mean, __stddev), _M_saved_available(false)
      { }

      explicit
      normal_distribution(const param_type& __p)
      : _M_param(__p), _M_saved_available(false)
      { }




      void
      reset()
      { _M_saved_available = false; }




      _RealType
      mean() const
      { return _M_param.mean(); }




      _RealType
      stddev() const
      { return _M_param.stddev(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      template<typename _RealType1>
 friend bool
        operator==(const std::normal_distribution<_RealType1>& __d1,
     const std::normal_distribution<_RealType1>& __d2);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::normal_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::normal_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
      result_type _M_saved;
      bool _M_saved_available;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class lognormal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef lognormal_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __m = _RealType(0),
     _RealType __s = _RealType(1))
 : _M_m(__m), _M_s(__s)
 { }

 _RealType
 m() const
 { return _M_m; }

 _RealType
 s() const
 { return _M_s; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_s == __p2._M_s; }

      private:
 _RealType _M_m;
 _RealType _M_s;
      };

      explicit
      lognormal_distribution(_RealType __m = _RealType(0),
        _RealType __s = _RealType(1))
      : _M_param(__m, __s), _M_nd()
      { }

      explicit
      lognormal_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _RealType
      m() const
      { return _M_param.m(); }

      _RealType
      s() const
      { return _M_param.s(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        { return std::exp(__p.s() * _M_nd(__urng) + __p.m()); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const lognormal_distribution& __d1,
   const lognormal_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_nd == __d2._M_nd); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::lognormal_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::lognormal_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::lognormal_distribution<_RealType>& __d1,
        const std::lognormal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class gamma_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef gamma_distribution<_RealType> distribution_type;
 friend class gamma_distribution<_RealType>;

 explicit
 param_type(_RealType __alpha_val = _RealType(1),
     _RealType __beta_val = _RealType(1))
 : _M_alpha(__alpha_val), _M_beta(__beta_val)
 {
                                                 ;
   _M_initialize();
 }

 _RealType
 alpha() const
 { return _M_alpha; }

 _RealType
 beta() const
 { return _M_beta; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_alpha == __p2._M_alpha
    && __p1._M_beta == __p2._M_beta); }

      private:
 void
 _M_initialize();

 _RealType _M_alpha;
 _RealType _M_beta;

 _RealType _M_malpha, _M_a2;
      };

    public:




      explicit
      gamma_distribution(_RealType __alpha_val = _RealType(1),
    _RealType __beta_val = _RealType(1))
      : _M_param(__alpha_val, __beta_val), _M_nd()
      { }

      explicit
      gamma_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _RealType
      alpha() const
      { return _M_param.alpha(); }




      _RealType
      beta() const
      { return _M_param.beta(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const gamma_distribution& __d1,
   const gamma_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_nd == __d2._M_nd); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::gamma_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::gamma_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
    };




   template<typename _RealType>
     inline bool
     operator!=(const std::gamma_distribution<_RealType>& __d1,
  const std::gamma_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class chi_squared_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef chi_squared_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_n;
      };

      explicit
      chi_squared_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_gd(__n / 2)
      { }

      explicit
      chi_squared_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.n() / 2)
      { }




      void
      reset()
      { _M_gd.reset(); }




      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return 2 * _M_gd(__urng); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return 2 * _M_gd(__urng, param_type(__p.n() / 2));
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
        { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { typename std::gamma_distribution<result_type>::param_type
     __p2(__p.n() / 2);
   this->__generate_impl(__f, __t, __urng, __p2); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
        { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { typename std::gamma_distribution<result_type>::param_type
     __p2(__p.n() / 2);
   this->__generate_impl(__f, __t, __urng, __p2); }






      friend bool
      operator==(const chi_squared_distribution& __d1,
   const chi_squared_distribution& __d2)
      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::chi_squared_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::chi_squared_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const typename
   std::gamma_distribution<result_type>::param_type& __p);

      param_type _M_param;

      std::gamma_distribution<result_type> _M_gd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::chi_squared_distribution<_RealType>& __d1,
        const std::chi_squared_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class cauchy_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef cauchy_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      cauchy_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      cauchy_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }

      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const cauchy_distribution& __d1,
   const cauchy_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::cauchy_distribution<_RealType>& __d1,
        const std::cauchy_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::cauchy_distribution<_RealType>& __x);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::cauchy_distribution<_RealType>& __x);
  template<typename _RealType = double>
    class fisher_f_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef fisher_f_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __m = _RealType(1),
     _RealType __n = _RealType(1))
 : _M_m(__m), _M_n(__n)
 { }

 _RealType
 m() const
 { return _M_m; }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_m;
 _RealType _M_n;
      };

      explicit
      fisher_f_distribution(_RealType __m = _RealType(1),
       _RealType __n = _RealType(1))
      : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)
      { }

      explicit
      fisher_f_distribution(const param_type& __p)
      : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)
      { }




      void
      reset()
      {
 _M_gd_x.reset();
 _M_gd_y.reset();
      }




      _RealType
      m() const
      { return _M_param.m(); }

      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return (_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return ((_M_gd_x(__urng, param_type(__p.m() / 2)) * n())
    / (_M_gd_y(__urng, param_type(__p.n() / 2)) * m()));
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const fisher_f_distribution& __d1,
   const fisher_f_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_gd_x == __d2._M_gd_x
  && __d1._M_gd_y == __d2._M_gd_y); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::fisher_f_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::fisher_f_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::gamma_distribution<result_type> _M_gd_x, _M_gd_y;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::fisher_f_distribution<_RealType>& __d1,
        const std::fisher_f_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class student_t_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef student_t_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }

 _RealType
 n() const
 { return _M_n; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }

      private:
 _RealType _M_n;
      };

      explicit
      student_t_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)
      { }

      explicit
      student_t_distribution(const param_type& __p)
      : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)
      { }




      void
      reset()
      {
 _M_nd.reset();
 _M_gd.reset();
      }




      _RealType
      n() const
      { return _M_param.n(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng)
        { return _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng)); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;

   const result_type __g = _M_gd(__urng, param_type(__p.n() / 2, 2));
   return _M_nd(__urng) * std::sqrt(__p.n() / __g);
        }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const student_t_distribution& __d1,
   const student_t_distribution& __d2)
      { return (__d1._M_param == __d2._M_param
  && __d1._M_nd == __d2._M_nd && __d1._M_gd == __d2._M_gd); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::student_t_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::student_t_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::normal_distribution<result_type> _M_nd;
      std::gamma_distribution<result_type> _M_gd;
    };




  template<typename _RealType>
    inline bool
    operator!=(const std::student_t_distribution<_RealType>& __d1,
        const std::student_t_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  class bernoulli_distribution
  {
  public:

    typedef bool result_type;

    struct param_type
    {
      typedef bernoulli_distribution distribution_type;

      explicit
      param_type(double __p = 0.5)
      : _M_p(__p)
      {
                                                      ;
      }

      double
      p() const
      { return _M_p; }

      friend bool
      operator==(const param_type& __p1, const param_type& __p2)
      { return __p1._M_p == __p2._M_p; }

    private:
      double _M_p;
    };

  public:






    explicit
    bernoulli_distribution(double __p = 0.5)
    : _M_param(__p)
    { }

    explicit
    bernoulli_distribution(const param_type& __p)
    : _M_param(__p)
    { }






    void
    reset() { }




    double
    p() const
    { return _M_param.p(); }




    param_type
    param() const
    { return _M_param; }





    void
    param(const param_type& __param)
    { _M_param = __param; }




    result_type
    min() const
    { return std::numeric_limits<result_type>::min(); }




    result_type
    max() const
    { return std::numeric_limits<result_type>::max(); }




    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng)
      { return this->operator()(__urng, _M_param); }

    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 if ((__aurng() - __aurng.min())
      < __p.p() * (__aurng.max() - __aurng.min()))
   return true;
 return false;
      }

    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      __generate(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng)
      { this->__generate(__f, __t, __urng, _M_param); }

    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      __generate(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng, const param_type& __p)
      { this->__generate_impl(__f, __t, __urng, __p); }

    template<typename _UniformRandomNumberGenerator>
      void
      __generate(result_type* __f, result_type* __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      { this->__generate_impl(__f, __t, __urng, __p); }





    friend bool
    operator==(const bernoulli_distribution& __d1,
        const bernoulli_distribution& __d2)
    { return __d1._M_param == __d2._M_param; }

  private:
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p);

    param_type _M_param;
  };





  inline bool
  operator!=(const std::bernoulli_distribution& __d1,
      const std::bernoulli_distribution& __d2)
  { return !(__d1 == __d2); }
  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::bernoulli_distribution& __x);
  template<typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::bernoulli_distribution& __x)
    {
      double __p;
      __is >> __p;
      __x.param(bernoulli_distribution::param_type(__p));
      return __is;
    }
  template<typename _IntType = int>
    class binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef binomial_distribution<_IntType> distribution_type;
 friend class binomial_distribution<_IntType>;

 explicit
 param_type(_IntType __t = _IntType(1), double __p = 0.5)
 : _M_t(__t), _M_p(__p)
 {


                     ;
   _M_initialize();
 }

 _IntType
 t() const
 { return _M_t; }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p; }

      private:
 void
 _M_initialize();

 _IntType _M_t;
 double _M_p;

 double _M_q;

 double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,
        _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;

 bool _M_easy;
      };


      explicit
      binomial_distribution(_IntType __t = _IntType(1),
       double __p = 0.5)
      : _M_param(__t, __p), _M_nd()
      { }

      explicit
      binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      _IntType
      t() const
      { return _M_param.t(); }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return _M_param.t(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






 friend bool
        operator==(const binomial_distribution& __d1,
     const binomial_distribution& __d2)

 { return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::binomial_distribution<_IntType1>& __x);
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::binomial_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      template<typename _UniformRandomNumberGenerator>
 result_type
 _M_waiting(_UniformRandomNumberGenerator& __urng,
     _IntType __t, double __q);

      param_type _M_param;


      std::normal_distribution<double> _M_nd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::binomial_distribution<_IntType>& __d1,
        const std::binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType = int>
    class geometric_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef geometric_distribution<_IntType> distribution_type;
 friend class geometric_distribution<_IntType>;

 explicit
 param_type(double __p = 0.5)
 : _M_p(__p)
 {
                                                      ;
   _M_initialize();
 }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_p == __p2._M_p; }

      private:
 void
 _M_initialize()
 { _M_log_1_p = std::log(1.0 - _M_p); }

 double _M_p;

 double _M_log_1_p;
      };


      explicit
      geometric_distribution(double __p = 0.5)
      : _M_param(__p)
      { }

      explicit
      geometric_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const geometric_distribution& __d1,
   const geometric_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::geometric_distribution<_IntType>& __d1,
        const std::geometric_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::geometric_distribution<_IntType>& __x);
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::geometric_distribution<_IntType>& __x);
  template<typename _IntType = int>
    class negative_binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef negative_binomial_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __k = 1, double __p = 0.5)
 : _M_k(__k), _M_p(__p)
 {
                                                                     ;
 }

 _IntType
 k() const
 { return _M_k; }

 double
 p() const
 { return _M_p; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p; }

      private:
 _IntType _M_k;
 double _M_p;
      };

      explicit
      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
      : _M_param(__k, __p), _M_gd(__k, (1.0 - __p) / __p)
      { }

      explicit
      negative_binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.k(), (1.0 - __p.p()) / __p.p())
      { }




      void
      reset()
      { _M_gd.reset(); }




      _IntType
      k() const
      { return _M_param.k(); }




      double
      p() const
      { return _M_param.p(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng);

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate_impl(__f, __t, __urng); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const negative_binomial_distribution& __d1,
   const negative_binomial_distribution& __d2)
      { return __d1._M_param == __d2._M_param && __d1._M_gd == __d2._M_gd; }
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::negative_binomial_distribution<_IntType1>& __x);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::negative_binomial_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng);
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;

      std::gamma_distribution<double> _M_gd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::negative_binomial_distribution<_IntType>& __d1,
        const std::negative_binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType = int>
    class poisson_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef poisson_distribution<_IntType> distribution_type;
 friend class poisson_distribution<_IntType>;

 explicit
 param_type(double __mean = 1.0)
 : _M_mean(__mean)
 {
                                       ;
   _M_initialize();
 }

 double
 mean() const
 { return _M_mean; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_mean == __p2._M_mean; }

      private:

 void
 _M_initialize();

 double _M_mean;

 double _M_lm_thr;

 double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;

      };


      explicit
      poisson_distribution(double __mean = 1.0)
      : _M_param(__mean), _M_nd()
      { }

      explicit
      poisson_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }




      void
      reset()
      { _M_nd.reset(); }




      double
      mean() const
      { return _M_param.mean(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return 0; }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }






      friend bool
      operator==(const poisson_distribution& __d1,
   const poisson_distribution& __d2)

      { return __d1._M_param == __d2._M_param && __d1._M_nd == __d2._M_nd; }
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::poisson_distribution<_IntType1>& __x);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::poisson_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;


      std::normal_distribution<double> _M_nd;
    };




  template<typename _IntType>
    inline bool
    operator!=(const std::poisson_distribution<_IntType>& __d1,
        const std::poisson_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class exponential_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef exponential_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __lambda = _RealType(1))
 : _M_lambda(__lambda)
 {
                                                  ;
 }

 _RealType
 lambda() const
 { return _M_lambda; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_lambda == __p2._M_lambda; }

      private:
 _RealType _M_lambda;
      };

    public:




      explicit
      exponential_distribution(const result_type& __lambda = result_type(1))
      : _M_param(__lambda)
      { }

      explicit
      exponential_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }




      _RealType
      lambda() const
      { return _M_param.lambda(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return -std::log(result_type(1) - __aurng()) / __p.lambda();
 }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const exponential_distribution& __d1,
   const exponential_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::exponential_distribution<_RealType>& __d1,
        const std::exponential_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::exponential_distribution<_RealType>& __x);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::exponential_distribution<_RealType>& __x);
  template<typename _RealType = double>
    class weibull_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef weibull_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(1),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      weibull_distribution(_RealType __a = _RealType(1),
      _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      weibull_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }




      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const weibull_distribution& __d1,
   const weibull_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::weibull_distribution<_RealType>& __d1,
        const std::weibull_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::weibull_distribution<_RealType>& __x);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::weibull_distribution<_RealType>& __x);
  template<typename _RealType = double>
    class extreme_value_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef extreme_value_distribution<_RealType> distribution_type;

 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }

 _RealType
 a() const
 { return _M_a; }

 _RealType
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _RealType _M_a;
 _RealType _M_b;
      };

      explicit
      extreme_value_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }

      explicit
      extreme_value_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      _RealType
      a() const
      { return _M_param.a(); }




      _RealType
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return std::numeric_limits<result_type>::lowest(); }




      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const extreme_value_distribution& __d1,
   const extreme_value_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::extreme_value_distribution<_RealType>& __d1,
        const std::extreme_value_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::extreme_value_distribution<_RealType>& __x);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::extreme_value_distribution<_RealType>& __x);
  template<typename _IntType = int>
    class discrete_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef discrete_distribution<_IntType> distribution_type;
 friend class discrete_distribution<_IntType>;

 param_type()
 : _M_prob(), _M_cp()
 { }

 template<typename _InputIterator>
   param_type(_InputIterator __wbegin,
       _InputIterator __wend)
   : _M_prob(__wbegin, __wend), _M_cp()
   { _M_initialize(); }

 param_type(initializer_list<double> __wil)
 : _M_prob(__wil.begin(), __wil.end()), _M_cp()
 { _M_initialize(); }

 template<typename _Func>
   param_type(size_t __nw, double __xmin, double __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<double>
 probabilities() const
 { return _M_prob.empty() ? std::vector<double>(1, 1.0) : _M_prob; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_prob == __p2._M_prob; }

      private:
 void
 _M_initialize();

 std::vector<double> _M_prob;
 std::vector<double> _M_cp;
      };

      discrete_distribution()
      : _M_param()
      { }

      template<typename _InputIterator>
 discrete_distribution(_InputIterator __wbegin,
         _InputIterator __wend)
 : _M_param(__wbegin, __wend)
 { }

      discrete_distribution(initializer_list<double> __wl)
      : _M_param(__wl)
      { }

      template<typename _Func>
 discrete_distribution(size_t __nw, double __xmin, double __xmax,
         _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      discrete_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<double>
      probabilities() const
      {
 return _M_param._M_prob.empty()
   ? std::vector<double>(1, 1.0) : _M_param._M_prob;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return result_type(0); }




      result_type
      max() const
      {
 return _M_param._M_prob.empty()
   ? result_type(0) : result_type(_M_param._M_prob.size() - 1);
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const discrete_distribution& __d1,
   const discrete_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::discrete_distribution<_IntType1>& __x);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::discrete_distribution<_IntType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _IntType>
    inline bool
    operator!=(const std::discrete_distribution<_IntType>& __d1,
        const std::discrete_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class piecewise_constant_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef piecewise_constant_distribution<_RealType> distribution_type;
 friend class piecewise_constant_distribution<_RealType>;

 param_type()
 : _M_int(), _M_den(), _M_cp()
 { }

 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);

 template<typename _Func>
   param_type(initializer_list<_RealType> __bi, _Func __fw);

 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<_RealType>
 intervals() const
 {
   if (_M_int.empty())
     {
       std::vector<_RealType> __tmp(2);
       __tmp[1] = _RealType(1);
       return __tmp;
     }
   else
     return _M_int;
 }

 std::vector<double>
 densities() const
 { return _M_den.empty() ? std::vector<double>(1, 1.0) : _M_den; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den; }

      private:
 void
 _M_initialize();

 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
      };

      explicit
      piecewise_constant_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_constant_distribution(_InputIteratorB __bfirst,
     _InputIteratorB __bend,
     _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }

      template<typename _Func>
 piecewise_constant_distribution(initializer_list<_RealType> __bl,
     _Func __fw)
 : _M_param(__bl, __fw)
 { }

      template<typename _Func>
 piecewise_constant_distribution(size_t __nw,
     _RealType __xmin, _RealType __xmax,
     _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      piecewise_constant_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<_RealType>
      intervals() const
      {
 if (_M_param._M_int.empty())
   {
     std::vector<_RealType> __tmp(2);
     __tmp[1] = _RealType(1);
     return __tmp;
   }
 else
   return _M_param._M_int;
      }




      std::vector<double>
      densities() const
      {
 return _M_param._M_den.empty()
   ? std::vector<double>(1, 1.0) : _M_param._M_den;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      {
 return _M_param._M_int.empty()
   ? result_type(0) : _M_param._M_int.front();
      }




      result_type
      max() const
      {
 return _M_param._M_int.empty()
   ? result_type(1) : _M_param._M_int.back();
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const piecewise_constant_distribution& __d1,
   const piecewise_constant_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::piecewise_constant_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::piecewise_constant_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_constant_distribution<_RealType>& __d1,
        const std::piecewise_constant_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class piecewise_linear_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

    public:

      typedef _RealType result_type;

      struct param_type
      {
 typedef piecewise_linear_distribution<_RealType> distribution_type;
 friend class piecewise_linear_distribution<_RealType>;

 param_type()
 : _M_int(), _M_den(), _M_cp(), _M_m()
 { }

 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);

 template<typename _Func>
   param_type(initializer_list<_RealType> __bl, _Func __fw);

 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);


 param_type(const param_type&) = default;
 param_type& operator=(const param_type&) = default;

 std::vector<_RealType>
 intervals() const
 {
   if (_M_int.empty())
     {
       std::vector<_RealType> __tmp(2);
       __tmp[1] = _RealType(1);
       return __tmp;
     }
   else
     return _M_int;
 }

 std::vector<double>
 densities() const
 { return _M_den.empty() ? std::vector<double>(2, 1.0) : _M_den; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_int == __p2._M_int
    && __p1._M_den == __p2._M_den); }

      private:
 void
 _M_initialize();

 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
 std::vector<double> _M_m;
      };

      explicit
      piecewise_linear_distribution()
      : _M_param()
      { }

      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_linear_distribution(_InputIteratorB __bfirst,
          _InputIteratorB __bend,
          _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }

      template<typename _Func>
 piecewise_linear_distribution(initializer_list<_RealType> __bl,
          _Func __fw)
 : _M_param(__bl, __fw)
 { }

      template<typename _Func>
 piecewise_linear_distribution(size_t __nw,
          _RealType __xmin, _RealType __xmax,
          _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }

      explicit
      piecewise_linear_distribution(const param_type& __p)
      : _M_param(__p)
      { }




      void
      reset()
      { }




      std::vector<_RealType>
      intervals() const
      {
 if (_M_param._M_int.empty())
   {
     std::vector<_RealType> __tmp(2);
     __tmp[1] = _RealType(1);
     return __tmp;
   }
 else
   return _M_param._M_int;
      }





      std::vector<double>
      densities() const
      {
 return _M_param._M_den.empty()
   ? std::vector<double>(2, 1.0) : _M_param._M_den;
      }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      {
 return _M_param._M_int.empty()
   ? result_type(0) : _M_param._M_int.front();
      }




      result_type
      max() const
      {
 return _M_param._M_int.empty()
   ? result_type(1) : _M_param._M_int.back();
      }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const piecewise_linear_distribution& __d1,
   const piecewise_linear_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>& __os,
     const std::piecewise_linear_distribution<_RealType1>& __x);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::piecewise_linear_distribution<_RealType1>& __x);

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };





  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_linear_distribution<_RealType>& __d1,
        const std::piecewise_linear_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  class seed_seq
  {

  public:

    typedef uint_least32_t result_type;


    seed_seq()
    : _M_v()
    { }

    template<typename _IntType>
      seed_seq(std::initializer_list<_IntType> il);

    template<typename _InputIterator>
      seed_seq(_InputIterator __begin, _InputIterator __end);


    template<typename _RandomAccessIterator>
      void
      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);


    size_t size() const
    { return _M_v.size(); }

    template<typename OutputIterator>
      void
      param(OutputIterator __dest) const
      { std::copy(_M_v.begin(), _M_v.end(), __dest); }

  private:

    std::vector<result_type> _M_v;
  };






}
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__readeflags(void)
{
  return __builtin_ia32_readeflags_u64();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
__writeeflags(unsigned long long __f)
{
  __builtin_ia32_writeeflags_u64(__f);
}
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdpmc(int __A) {
  return __builtin_ia32_rdpmc(__A);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtsc(void) {
  return __builtin_ia32_rdtsc();
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__rdtscp(unsigned int *__A) {
  return __builtin_ia32_rdtscp(__A);
}

typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));




static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("mmx")))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));





extern "C" int posix_memalign(void **__memptr, size_t __alignment, size_t __size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t __size, size_t __align)
{
  if (__align == 1) {
    return malloc(__size);
  }

  if (!(__align & (__align - 1)) && __align < sizeof(void *))
    __align = sizeof(void *);

  void *__mallocedMemory;





  if (posix_memalign(&__mallocedMemory, __align, __size))
    return 0;


  return __mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *__p)
{
  free(__p);
}





static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_add_ss(__m128 __a, __m128 __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_add_ps(__m128 __a, __m128 __b)
{
  return __a + __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sub_ss(__m128 __a, __m128 __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sub_ps(__m128 __a, __m128 __b)
{
  return __a - __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_mul_ss(__m128 __a, __m128 __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_mul_ps(__m128 __a, __m128 __b)
{
  return __a * __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_div_ss(__m128 __a, __m128 __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_div_ps(__m128 __a, __m128 __b)
{
  return __a / __b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_sqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sqrt_ps(__m128 __a)
{
  return __builtin_ia32_sqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rcp_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rcpss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rcp_ps(__m128 __a)
{
  return __builtin_ia32_rcpps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rsqrt_ss(__m128 __a)
{
  __m128 __c = __builtin_ia32_rsqrtss(__a);
  return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_rsqrt_ps(__m128 __a)
{
  return __builtin_ia32_rsqrtps(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_minps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_maxps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_and_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_andnot_ps(__m128 __a, __m128 __b)
{
  return (__m128)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_or_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_xor_ps(__m128 __a, __m128 __b)
{
  return (__m128)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpeq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpeq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpeqps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmplt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmplt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmple_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpless(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmple_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpgt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpltss(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpgt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpltps(__b, __a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpless(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpleps(__b, __a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpneq_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpneq_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpneqps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnlt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnlt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnle_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnless(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnle_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpngt_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpnltss(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpngt_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnltps(__b, __a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnge_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_shufflevector(__a,
                                         __builtin_ia32_cmpnless(__b, __a),
                                         4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpnge_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpnleps(__b, __a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpordps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpunord_ss(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordss(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cmpunord_ps(__m128 __a, __m128 __b)
{
  return (__m128)__builtin_ia32_cmpunordps(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_comineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_comineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomieq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomieq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomilt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomilt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomile_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomile(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomigt_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomigt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomige_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomige(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_ucomineq_ss(__m128 __a, __m128 __b)
{
  return __builtin_ia32_ucomineq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtss_si32(__m128 __a)
{
  return __builtin_ia32_cvtss2si(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_ss2si(__m128 __a)
{
  return _mm_cvtss_si32(__a);
}



static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtss_si64(__m128 __a)
{
  return __builtin_ia32_cvtss2si64(__a);
}



static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvtps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_ps2pi(__m128 __a)
{
  return _mm_cvtps_pi32(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvttss_si32(__m128 __a)
{
  return __a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtt_ss2si(__m128 __a)
{
  return _mm_cvttss_si32(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvttss_si64(__m128 __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvttps_pi32(__m128 __a)
{
  return (__m64)__builtin_ia32_cvttps2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtt_ps2pi(__m128 __a)
{
  return _mm_cvttps_pi32(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtsi32_ss(__m128 __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_si2ss(__m128 __a, int __b)
{
  return _mm_cvtsi32_ss(__a, __b);
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtsi64_ss(__m128 __a, long long __b)
{
  __a[0] = __b;
  return __a;
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi32_ps(__m128 __a, __m64 __b)
{
  return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvt_pi2ps(__m128 __a, __m64 __b)
{
  return _mm_cvtpi32_ps(__a, __b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtss_f32(__m128 __a)
{
  return __a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadh_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 __b = ((struct __mm_loadh_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadl_pi(__m128 __a, const __m64 *__p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 __u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 __b = ((struct __mm_loadl_pi_struct*)__p)->__u;
  __m128 __bb = __builtin_shufflevector(__b, __b, 0, 1, 0, 1);
  return __builtin_shufflevector(__a, __bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_load_ss(const float *__p)
{
  struct __mm_load_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load_ss_struct*)__p)->__u;
  return (__m128){ __u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_load1_ps(const float *__p)
{
  struct __mm_load1_ps_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  float __u = ((struct __mm_load1_ps_struct*)__p)->__u;
  return (__m128){ __u, __u, __u, __u };
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_load_ps(const float *__p)
{
  return *(__m128*)__p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadu_ps(const float *__p)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_loadr_ps(const float *__p)
{
  __m128 __a = _mm_load_ps(__p);
  return __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_undefined_ps()
{
  return (__m128)__builtin_ia32_undef128();
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set_ss(float __w)
{
  return (__m128){ __w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set1_ps(float __w)
{
  return (__m128){ __w, __w, __w, __w };
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set_ps1(float __w)
{
    return _mm_set1_ps(__w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_set_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __w, __x, __y, __z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_setr_ps(float __z, float __y, float __x, float __w)
{
  return (__m128){ __z, __y, __x, __w };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storeh_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storehps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storel_pi(__m64 *__p, __m128 __a)
{
  __builtin_ia32_storelps((__v2si *)__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store_ss(float *__p, __m128 __a)
{
  struct __mm_store_ss_struct {
    float __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storeu_ps(float *__p, __m128 __a)
{
  __builtin_ia32_storeups(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store1_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 0, 0, 0, 0);
  _mm_storeu_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store_ps1(float *__p, __m128 __a)
{
    return _mm_store1_ps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_store_ps(float *__p, __m128 __a)
{
  *(__m128 *)__p = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_storer_ps(float *__p, __m128 __a)
{
  __a = __builtin_shufflevector(__a, __a, 3, 2, 1, 0);
  _mm_store_ps(__p, __a);
}
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_stream_pi(__m64 *__p, __m64 __a)
{
  __builtin_ia32_movntq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_stream_ps(float *__p, __m128 __a)
{
  __builtin_ia32_movntps(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_extract_pi16(__m64 __a, int __n)
{
  __v4hi __b = (__v4hi)__a;
  return (unsigned short)__b[__n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_insert_pi16(__m64 __a, int __d, int __n)
{
   __v4hi __b = (__v4hi)__a;
   __b[__n & 3] = __d;
   return (__m64)__b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_max_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_pi16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_min_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)__a, (__v8qi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movemask_pi8(__m64 __a)
{
  return __builtin_ia32_pmovmskb((__v8qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_mulhi_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)__a, (__v4hi)__b);
}




static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_maskmove_si64(__m64 __d, __m64 __n, char *__p)
{
  __builtin_ia32_maskmovq((__v8qi)__d, (__v8qi)__n, __p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_avg_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_avg_pu16(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_sad_pu8(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_setcsr(unsigned int __i)
{
  __builtin_ia32_ldmxcsr(__i);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_unpackhi_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_unpacklo_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_move_ss(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movehl_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movelh_ps(__m128 __a, __m128 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi16(__b, __a);
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpu16_ps(__m64 __a)
{
  __m64 __b, __c;
  __m128 __r;

  __b = _mm_setzero_si64();
  __c = _mm_unpackhi_pi16(__a, __b);
  __r = _mm_setzero_ps();
  __r = _mm_cvtpi32_ps(__r, __c);
  __r = _mm_movelh_ps(__r, __r);
  __c = _mm_unpacklo_pi16(__a, __b);
  __r = _mm_cvtpi32_ps(__r, __c);

  return __r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_cmpgt_pi8(__b, __a);
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpu8_ps(__m64 __a)
{
  __m64 __b;

  __b = _mm_setzero_si64();
  __b = _mm_unpacklo_pi8(__a, __b);

  return _mm_cvtpi16_ps(__b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtpi32x2_ps(__m64 __a, __m64 __b)
{
  __m128 __c;

  __c = _mm_setzero_ps();
  __c = _mm_cvtpi32_ps(__c, __b);
  __c = _mm_movelh_ps(__c, __c);

  return _mm_cvtpi32_ps(__c, __a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtps_pi16(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi32(__a);
  __a = _mm_movehl_ps(__a, __a);
  __c = _mm_cvtps_pi32(__a);

  return _mm_packs_pi32(__b, __c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_cvtps_pi8(__m128 __a)
{
  __m64 __b, __c;

  __b = _mm_cvtps_pi16(__a);
  __c = _mm_setzero_si64();

  return _mm_packs_pi16(__b, __c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse")))
_mm_movemask_ps(__m128 __a)
{
  return __builtin_ia32_movmskps(__a);
}

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));



typedef signed char __v16qs __attribute__((__vector_size__(16)));


static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("f16c")))
_mm_cvtph_ps(__m128i __a)
{
  return (__m128)__builtin_ia32_vcvtph2ps((__v8hi)__a);
}




static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_sd(__m128d __a, __m128d __b)
{
  __a[0] += __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_pd(__m128d __a, __m128d __b)
{
  return __a + __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_sd(__m128d __a, __m128d __b)
{
  __a[0] -= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_pd(__m128d __a, __m128d __b)
{
  return __a - __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_sd(__m128d __a, __m128d __b)
{
  __a[0] *= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_pd(__m128d __a, __m128d __b)
{
  return __a * __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_div_sd(__m128d __a, __m128d __b)
{
  __a[0] /= __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_div_pd(__m128d __a, __m128d __b)
{
  return __a / __b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sqrt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_sqrtsd(__b);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sqrt_pd(__m128d __a)
{
  return __builtin_ia32_sqrtpd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_minpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_maxpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_and_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_andnot_pd(__m128d __a, __m128d __b)
{
  return (__m128d)(~(__v4si)__a & (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_or_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a | (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_xor_pd(__m128d __a, __m128d __b)
{
  return (__m128d)((__v4si)__a ^ (__v4si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmple_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltpd(__b, __a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplepd(__b, __a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpunord_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpneq_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnlt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnle_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpngt_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltpd(__b, __a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnge_pd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlepd(__b, __a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpeqsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpltsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmple_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmplesd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpltsd(__b, __a);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmplesd(__b, __a);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpordsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpunord_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpunordsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpneq_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpneqsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnlt_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnltsd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnle_sd(__m128d __a, __m128d __b)
{
  return (__m128d)__builtin_ia32_cmpnlesd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpngt_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnltsd(__b, __a);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpnge_sd(__m128d __a, __m128d __b)
{
  __m128d __c = __builtin_ia32_cmpnlesd(__b, __a);
  return (__m128d) { __c[0], __a[1] };
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_comineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_comisdneq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomieq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdeq(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomilt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdlt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomile_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdle(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomigt_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdgt(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomige_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdge(__a, __b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_ucomineq_sd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_ucomisdneq(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpd_ps(__m128d __a)
{
  return __builtin_ia32_cvtpd2ps(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtps_pd(__m128 __a)
{
  return __builtin_ia32_cvtps2pd(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtepi32_pd(__m128i __a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpd_epi32(__m128d __a)
{
  return __builtin_ia32_cvtpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_si32(__m128d __a)
{
  return __builtin_ia32_cvtsd2si(__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_ss(__m128 __a, __m128d __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi32_sd(__m128d __a, int __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtss_sd(__m128d __a, __m128 __b)
{
  __a[0] = __b[0];
  return __a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttpd_epi32(__m128d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(__a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttsd_si32(__m128d __a)
{
  return __a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttpd_pi32(__m128d __a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(__a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtpi32_pd(__m64 __a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)__a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_f64(__m128d __a)
{
  return __a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load_pd(double const *__dp)
{
  return *(__m128d*)__dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load1_pd(double const *__dp)
{
  struct __mm_load1_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load1_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __u };
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadr_pd(double const *__dp)
{
  __m128d __u = *(__m128d*)__dp;
  return __builtin_shufflevector(__u, __u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadu_pd(double const *__dp)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_pd*)__dp)->__v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load_sd(double const *__dp)
{
  struct __mm_load_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_load_sd_struct*)__dp)->__u;
  return (__m128d){ __u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadh_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadh_pd_struct*)__dp)->__u;
  return (__m128d){ __a[0], __u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadl_pd(__m128d __a, double const *__dp)
{
  struct __mm_loadl_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  double __u = ((struct __mm_loadl_pd_struct*)__dp)->__u;
  return (__m128d){ __u, __a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_undefined_pd()
{
  return (__m128d)__builtin_ia32_undef128();
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_sd(double __w)
{
  return (__m128d){ __w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_pd(double __w)
{
  return (__m128d){ __w, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_pd(double __w, double __x)
{
  return (__m128d){ __x, __w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_pd(double __w, double __x)
{
  return (__m128d){ __w, __x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_move_sd(__m128d __a, __m128d __b)
{
  return (__m128d){ __b[0], __a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_sd(double *__dp, __m128d __a)
{
  struct __mm_store_sd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)__dp)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store1_pd(double *__dp, __m128d __a)
{
  struct __mm_store1_pd_struct {
    double __u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)__dp)->__u[0] = __a[0];
  ((struct __mm_store1_pd_struct*)__dp)->__u[1] = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_pd(double *__dp, __m128d __a)
{
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storeu_pd(double *__dp, __m128d __a)
{
  __builtin_ia32_storeupd(__dp, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storer_pd(double *__dp, __m128d __a)
{
  __a = __builtin_shufflevector(__a, __a, 1, 0);
  *(__m128d *)__dp = __a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storeh_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storel_pd(double *__dp, __m128d __a)
{
  struct __mm_storeh_pd_struct {
    double __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)__dp)->__u = __a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a + (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a + (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a + (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_paddq(__a, __b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_add_epi64(__m128i __a, __m128i __b)
{
  return __a + __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_adds_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_avg_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_avg_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_madd_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_max_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_min_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mulhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mulhi_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mullo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a * (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_su32(__m64 __a, __m64 __b)
{
  return __builtin_ia32_pmuludq((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mul_epu32(__m128i __a, __m128i __b)
{
  return __builtin_ia32_pmuludq128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sad_epu8(__m128i __a, __m128i __b)
{
  return __builtin_ia32_psadbw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a - (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a - (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a - (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_si64(__m64 __a, __m64 __b)
{
  return (__m64)__builtin_ia32_psubq(__a, __b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sub_epi64(__m128i __a, __m128i __b)
{
  return __a - __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epu8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_subs_epu16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_and_si128(__m128i __a, __m128i __b)
{
  return __a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_andnot_si128(__m128i __a, __m128i __b)
{
  return ~__a & __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_or_si128(__m128i __a, __m128i __b)
{
  return __a | __b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_xor_si128(__m128i __a, __m128i __b)
{
  return __a ^ __b;
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_slli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sll_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_slli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sll_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_slli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psllqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sll_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psllq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srai_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sra_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srai_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_sra_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)__a, (__v4si)__count);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srli_epi16(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srl_epi16(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)__a, (__v8hi)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srli_epi32(__m128i __a, int __count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srl_epi32(__m128i __a, __m128i __count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)__a, (__v4si)__count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srli_epi64(__m128i __a, int __count)
{
  return __builtin_ia32_psrlqi128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_srl_epi64(__m128i __a, __m128i __count)
{
  return __builtin_ia32_psrlq128(__a, __count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)((__v16qi)__a == (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a == (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpeq_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a == (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_epi8(__m128i __a, __m128i __b)
{


  return (__m128i)((__v16qs)__a > (__v16qs)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)((__v8hi)__a > (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmpgt_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)((__v4si)__a > (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_epi8(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi8(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_epi16(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi16(__b, __a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cmplt_epi32(__m128i __a, __m128i __b)
{
  return _mm_cmpgt_epi32(__b, __a);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi64_sd(__m128d __a, long long __b)
{
  __a[0] = __b;
  return __a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsd_si64(__m128d __a)
{
  return __builtin_ia32_cvtsd2si64(__a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttsd_si64(__m128d __a)
{
  return __a[0];
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtepi32_ps(__m128i __a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvttps_epi32(__m128 __a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi32_si128(int __a)
{
  return (__m128i)(__v4si){ __a, 0, 0, 0 };
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi64_si128(long long __a)
{
  return (__m128i){ __a, 0 };
}


static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi128_si32(__m128i __a)
{
  __v4si __b = (__v4si)__a;
  return __b[0];
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_cvtsi128_si64(__m128i __a)
{
  return __a[0];
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_load_si128(__m128i const *__p)
{
  return *__p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadu_si128(__m128i const *__p)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_si128*)__p)->__v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_loadl_epi64(__m128i const *__p)
{
  struct __mm_loadl_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)__p)->__u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_undefined_si128()
{
  return (__m128i)__builtin_ia32_undef128();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi64x(long long __q1, long long __q0)
{
  return (__m128i){ __q0, __q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi64(__m64 __q1, __m64 __q0)
{
  return (__m128i){ (long long)__q0, (long long)__q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi32(int __i3, int __i2, int __i1, int __i0)
{
  return (__m128i)(__v4si){ __i0, __i1, __i2, __i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi16(short __w7, short __w6, short __w5, short __w4, short __w3, short __w2, short __w1, short __w0)
{
  return (__m128i)(__v8hi){ __w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set_epi8(char __b15, char __b14, char __b13, char __b12, char __b11, char __b10, char __b9, char __b8, char __b7, char __b6, char __b5, char __b4, char __b3, char __b2, char __b1, char __b0)
{
  return (__m128i)(__v16qi){ __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7, __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi64x(long long __q)
{
  return (__m128i){ __q, __q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi64(__m64 __q)
{
  return (__m128i){ (long long)__q, (long long)__q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi32(int __i)
{
  return (__m128i)(__v4si){ __i, __i, __i, __i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi16(short __w)
{
  return (__m128i)(__v8hi){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_set1_epi8(char __b)
{
  return (__m128i)(__v16qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi64(__m64 __q0, __m64 __q1)
{
  return (__m128i){ (long long)__q0, (long long)__q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi32(int __i0, int __i1, int __i2, int __i3)
{
  return (__m128i)(__v4si){ __i0, __i1, __i2, __i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi16(short __w0, short __w1, short __w2, short __w3, short __w4, short __w5, short __w6, short __w7)
{
  return (__m128i)(__v8hi){ __w0, __w1, __w2, __w3, __w4, __w5, __w6, __w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setr_epi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5, char __b6, char __b7, char __b8, char __b9, char __b10, char __b11, char __b12, char __b13, char __b14, char __b15)
{
  return (__m128i)(__v16qi){ __b0, __b1, __b2, __b3, __b4, __b5, __b6, __b7, __b8, __b9, __b10, __b11, __b12, __b13, __b14, __b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_store_si128(__m128i *__p, __m128i __b)
{
  *__p = __b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storeu_si128(__m128i *__p, __m128i __b)
{
  __builtin_ia32_storedqu((char *)__p, (__v16qi)__b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_maskmoveu_si128(__m128i __d, __m128i __n, char *__p)
{
  __builtin_ia32_maskmovdqu((__v16qi)__d, (__v16qi)__n, __p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_storel_epi64(__m128i *__p, __m128i __a)
{
  struct __mm_storel_epi64_struct {
    long long __u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storel_epi64_struct*)__p)->__u = __a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_pd(double *__p, __m128d __a)
{
  __builtin_ia32_movntpd(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si128(__m128i *__p, __m128i __a)
{
  __builtin_ia32_movntdq(__p, __a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si32(int *__p, int __a)
{
  __builtin_ia32_movnti(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_stream_si64(long long *__p, long long __a)
{
  __builtin_ia32_movnti64(__p, __a);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_clflush(void const *__p)
{
  __builtin_ia32_clflush(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_packs_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_packs_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_packus_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_extract_epi16(__m128i __a, int __imm)
{
  __v8hi __b = (__v8hi)__a;
  return (unsigned short)__b[__imm & 7];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_insert_epi16(__m128i __a, int __b, int __imm)
{
  __v8hi __c = (__v8hi)__a;
  __c[__imm & 7] = __b;
  return (__m128i)__c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movemask_epi8(__m128i __a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)__a);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi8(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__a, (__v16qi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi16(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi)__b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi32(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si)__b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_epi64(__m128i __a, __m128i __b)
{
  return (__m128i)__builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movepi64_pi64(__m128i __a)
{
  return (__m64)__a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movpi64_epi64(__m64 __a)
{
  return (__m128i){ (long long)__a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_move_epi64(__m128i __a)
{
  return __builtin_shufflevector(__a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpackhi_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_unpacklo_pd(__m128d __a, __m128d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_movemask_pd(__m128d __a)
{
  return __builtin_ia32_movmskpd(__a);
}





static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castpd_ps(__m128d __a)
{
  return (__m128)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castpd_si128(__m128d __a)
{
  return (__m128i)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castps_pd(__m128 __a)
{
  return (__m128d)__a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castps_si128(__m128 __a)
{
  return (__m128i)__a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castsi128_ps(__m128i __a)
{
  return (__m128)__a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_castsi128_pd(__m128i __a)
{
  return (__m128d)__a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse2")))
_mm_pause(void)
{
  __builtin_ia32_pause();
}



static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_lddqu_si128(__m128i const *__p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)__p);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_addsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_addsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hadd_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_haddps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hsub_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_hsubps(__a, __b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_movehdup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 1, 1, 3, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_moveldup_ps(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0, 2, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_addsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_addsubpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hadd_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_haddpd(__a, __b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_hsub_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_hsubpd(__a, __b);
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_movedup_pd(__m128d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0);
}
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_monitor(void const *__p, unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_monitor((void *)__p, __extensions, __hints);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse3")))
_mm_mwait(unsigned __extensions, unsigned __hints)
{
  __builtin_ia32_mwait(__extensions, __hints);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_pi8(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_epi8(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsb128((__v16qi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_pi16(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_epi16(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsw128((__v8hi)__a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_pi32(__m64 __a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)__a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_abs_epi32(__m128i __a)
{
    return (__m128i)__builtin_ia32_pabsd128((__v4si)__a);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadd_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadds_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hadds_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsub_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_hsubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_maddubs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_maddubs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_mulhrs_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_mulhrs_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_shuffle_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_shuffle_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_epi8(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)__a, (__v16qi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_epi16(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)__a, (__v8hi)__b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_epi32(__m128i __a, __m128i __b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)__a, (__v4si)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_pi8(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)__a, (__v8qi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_pi16(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)__a, (__v4hi)__b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("ssse3")))
_mm_sign_pi32(__m64 __a, __m64 __b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)__a, (__v2si)__b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_blendv_pd (__m128d __V1, __m128d __V2, __m128d __M)
{
  return (__m128d) __builtin_ia32_blendvpd ((__v2df)__V1, (__v2df)__V2,
                                            (__v2df)__M);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_blendv_ps (__m128 __V1, __m128 __V2, __m128 __M)
{
  return (__m128) __builtin_ia32_blendvps ((__v4sf)__V1, (__v4sf)__V2,
                                           (__v4sf)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_blendv_epi8 (__m128i __V1, __m128i __V2, __m128i __M)
{
  return (__m128i) __builtin_ia32_pblendvb128 ((__v16qi)__V1, (__v16qi)__V2,
                                               (__v16qi)__M);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_mullo_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) ((__v4si)__V1 * (__v4si)__V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_mul_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmuldq128 ((__v4si)__V1, (__v4si)__V2);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_stream_load_si128 (__m128i const *__V)
{
  return (__m128i) __builtin_ia32_movntdqa ((const __v2di *) __V);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epi8 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminsb128 ((__v16qi) __V1, (__v16qi) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epi8 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxsb128 ((__v16qi) __V1, (__v16qi) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epu16 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminuw128 ((__v8hi) __V1, (__v8hi) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epu16 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxuw128 ((__v8hi) __V1, (__v8hi) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminsd128 ((__v4si) __V1, (__v4si) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxsd128 ((__v4si) __V1, (__v4si) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_min_epu32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminud128((__v4si) __V1, (__v4si) __V2);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_max_epu32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxud128((__v4si) __V1, (__v4si) __V2);
}
static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_testz_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestz128((__v2di)__M, (__v2di)__V);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_testc_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestc128((__v2di)__M, (__v2di)__V);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_testnzc_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestnzc128((__v2di)__M, (__v2di)__V);
}






static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cmpeq_epi64(__m128i __V1, __m128i __V2)
{
  return (__m128i)((__v2di)__V1 == (__v2di)__V2);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi8_epi16(__m128i __V)
{


  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3, 4, 5, 6, 7), __v8hi);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi8_epi32(__m128i __V)
{


  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1, 2, 3), __v4si);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi8_epi64(__m128i __V)
{


  typedef signed char __v16qs __attribute__((__vector_size__(16)));
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v16qs)__V, (__v16qs)__V, 0, 1), __v2di);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi16_epi32(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1, 2, 3), __v4si);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi16_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v8hi)__V, (__v8hi)__V, 0, 1), __v2di);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepi32_epi64(__m128i __V)
{
  return (__m128i)__builtin_convertvector(__builtin_shufflevector((__v4si)__V, (__v4si)__V, 0, 1), __v2di);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu8_epi16(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxbw128((__v16qi) __V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu8_epi32(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxbd128((__v16qi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu8_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxbq128((__v16qi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu16_epi32(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxwd128((__v8hi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu16_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxwq128((__v8hi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_cvtepu32_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxdq128((__v4si)__V);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_packus_epi32(__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_packusdw128((__v4si)__V1, (__v4si)__V2);
}






static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.1")))
_mm_minpos_epu16(__m128i __V)
{
  return (__m128i) __builtin_ia32_phminposuw128((__v8hi)__V);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_cmpgt_epi64(__m128i __V1, __m128i __V2)
{
  return (__m128i)((__v2di)__V1 > (__v2di)__V2);
}


static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u8(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u16(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u32(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("sse4.2")))
_mm_crc32_u64(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesenc_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenc128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesenclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenclast128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesdec_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdec128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesdeclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdeclast128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("aes")))
_mm_aesimc_si128(__m128i __V)
{
  return (__m128i)__builtin_ia32_aesimc128(__V);
}


typedef double __v4df __attribute__ ((__vector_size__ (32)));
typedef float __v8sf __attribute__ ((__vector_size__ (32)));
typedef long long __v4di __attribute__ ((__vector_size__ (32)));
typedef int __v8si __attribute__ ((__vector_size__ (32)));
typedef short __v16hi __attribute__ ((__vector_size__ (32)));
typedef char __v32qi __attribute__ ((__vector_size__ (32)));



typedef signed char __v32qs __attribute__((__vector_size__(32)));

typedef float __m256 __attribute__ ((__vector_size__ (32)));
typedef double __m256d __attribute__((__vector_size__(32)));
typedef long long __m256i __attribute__((__vector_size__(32)));





static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_add_pd(__m256d __a, __m256d __b)
{
  return __a+__b;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_add_ps(__m256 __a, __m256 __b)
{
  return __a+__b;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sub_pd(__m256d __a, __m256d __b)
{
  return __a-__b;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sub_ps(__m256 __a, __m256 __b)
{
  return __a-__b;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_addsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_addsubpd256((__v4df)__a, (__v4df)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_addsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_addsubps256((__v8sf)__a, (__v8sf)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_div_pd(__m256d __a, __m256d __b)
{
  return __a / __b;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_div_ps(__m256 __a, __m256 __b)
{
  return __a / __b;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_max_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_maxpd256((__v4df)__a, (__v4df)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_max_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_maxps256((__v8sf)__a, (__v8sf)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_min_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_minpd256((__v4df)__a, (__v4df)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_min_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_minps256((__v8sf)__a, (__v8sf)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_mul_pd(__m256d __a, __m256d __b)
{
  return __a * __b;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_mul_ps(__m256 __a, __m256 __b)
{
  return __a * __b;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sqrt_pd(__m256d __a)
{
  return (__m256d)__builtin_ia32_sqrtpd256((__v4df)__a);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_sqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_sqrtps256((__v8sf)__a);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_rsqrt_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rsqrtps256((__v8sf)__a);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_rcp_ps(__m256 __a)
{
  return (__m256)__builtin_ia32_rcpps256((__v8sf)__a);
}
static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_and_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4di)__a & (__v4di)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_and_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8si)__a & (__v8si)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_andnot_pd(__m256d __a, __m256d __b)
{
  return (__m256d)(~(__v4di)__a & (__v4di)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_andnot_ps(__m256 __a, __m256 __b)
{
  return (__m256)(~(__v8si)__a & (__v8si)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_or_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4di)__a | (__v4di)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_or_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8si)__a | (__v8si)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_xor_pd(__m256d __a, __m256d __b)
{
  return (__m256d)((__v4di)__a ^ (__v4di)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_xor_ps(__m256 __a, __m256 __b)
{
  return (__m256)((__v8si)__a ^ (__v8si)__b);
}


static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hadd_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_haddpd256((__v4df)__a, (__v4df)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hadd_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_haddps256((__v8sf)__a, (__v8sf)__b);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hsub_pd(__m256d __a, __m256d __b)
{
  return (__m256d)__builtin_ia32_hsubpd256((__v4df)__a, (__v4df)__b);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_hsub_ps(__m256 __a, __m256 __b)
{
  return (__m256)__builtin_ia32_hsubps256((__v8sf)__a, (__v8sf)__b);
}


static __inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_permutevar_pd(__m128d __a, __m128i __c)
{
  return (__m128d)__builtin_ia32_vpermilvarpd((__v2df)__a, (__v2di)__c);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_permutevar_pd(__m256d __a, __m256i __c)
{
  return (__m256d)__builtin_ia32_vpermilvarpd256((__v4df)__a, (__v4di)__c);
}

static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_permutevar_ps(__m128 __a, __m128i __c)
{
  return (__m128)__builtin_ia32_vpermilvarps((__v4sf)__a, (__v4si)__c);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_permutevar_ps(__m256 __a, __m256i __c)
{
  return (__m256)__builtin_ia32_vpermilvarps256((__v8sf)__a, (__v8si)__c);
}
static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_blendv_pd(__m256d __a, __m256d __b, __m256d __c)
{
  return (__m256d)__builtin_ia32_blendvpd256(
    (__v4df)__a, (__v4df)__b, (__v4df)__c);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_blendv_ps(__m256 __a, __m256 __b, __m256 __c)
{
  return (__m256)__builtin_ia32_blendvps256(
    (__v8sf)__a, (__v8sf)__b, (__v8sf)__c);
}
static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi32(__m256i __a, const int __imm)
{
  __v8si __b = (__v8si)__a;
  return __b[__imm & 7];
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi16(__m256i __a, const int __imm)
{
  __v16hi __b = (__v16hi)__a;
  return __b[__imm & 15];
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi8(__m256i __a, const int __imm)
{
  __v32qi __b = (__v32qi)__a;
  return __b[__imm & 31];
}


static __inline long long __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_extract_epi64(__m256i __a, const int __imm)
{
  __v4di __b = (__v4di)__a;
  return __b[__imm & 3];
}


static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi32(__m256i __a, int __b, int const __imm)
{
  __v8si __c = (__v8si)__a;
  __c[__imm & 7] = __b;
  return (__m256i)__c;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi16(__m256i __a, int __b, int const __imm)
{
  __v16hi __c = (__v16hi)__a;
  __c[__imm & 15] = __b;
  return (__m256i)__c;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi8(__m256i __a, int __b, int const __imm)
{
  __v32qi __c = (__v32qi)__a;
  __c[__imm & 31] = __b;
  return (__m256i)__c;
}


static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_insert_epi64(__m256i __a, long long __b, int const __imm)
{
  __v4di __c = (__v4di)__a;
  __c[__imm & 3] = __b;
  return (__m256i)__c;
}



static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtepi32_pd(__m128i __a)
{
  return (__m256d)__builtin_ia32_cvtdq2pd256((__v4si) __a);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtepi32_ps(__m256i __a)
{
  return (__m256)__builtin_ia32_cvtdq2ps256((__v8si) __a);
}

static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtpd_ps(__m256d __a)
{
  return (__m128)__builtin_ia32_cvtpd2ps256((__v4df) __a);
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvtps2dq256((__v8sf) __a);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtps_pd(__m128 __a)
{
  return (__m256d)__builtin_ia32_cvtps2pd256((__v4sf) __a);
}

static __inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvttpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq256((__v4df) __a);
}

static __inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvtpd_epi32(__m256d __a)
{
  return (__m128i)__builtin_ia32_cvtpd2dq256((__v4df) __a);
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_cvttps_epi32(__m256 __a)
{
  return (__m256i)__builtin_ia32_cvttps2dq256((__v8sf) __a);
}


static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movehdup_ps(__m256 __a)
{
  return __builtin_shufflevector(__a, __a, 1, 1, 3, 3, 5, 5, 7, 7);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_moveldup_ps(__m256 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0, 2, 2, 4, 4, 6, 6);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movedup_pd(__m256d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0, 2, 2);
}


static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpackhi_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 5, 1+2, 5+2);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpacklo_pd(__m256d __a, __m256d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 4, 0+2, 4+2);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpackhi_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector(__a, __b, 2, 10, 2+1, 10+1, 6, 14, 6+1, 14+1);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_unpacklo_ps(__m256 __a, __m256 __b)
{
  return __builtin_shufflevector(__a, __b, 0, 8, 0+1, 8+1, 4, 12, 4+1, 12+1);
}


static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testz_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestzpd((__v2df)__a, (__v2df)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestcpd((__v2df)__a, (__v2df)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testnzc_pd(__m128d __a, __m128d __b)
{
  return __builtin_ia32_vtestnzcpd((__v2df)__a, (__v2df)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testz_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestzps((__v4sf)__a, (__v4sf)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestcps((__v4sf)__a, (__v4sf)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_testnzc_ps(__m128 __a, __m128 __b)
{
  return __builtin_ia32_vtestnzcps((__v4sf)__a, (__v4sf)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testz_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestzpd256((__v4df)__a, (__v4df)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestcpd256((__v4df)__a, (__v4df)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testnzc_pd(__m256d __a, __m256d __b)
{
  return __builtin_ia32_vtestnzcpd256((__v4df)__a, (__v4df)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testz_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestzps256((__v8sf)__a, (__v8sf)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestcps256((__v8sf)__a, (__v8sf)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testnzc_ps(__m256 __a, __m256 __b)
{
  return __builtin_ia32_vtestnzcps256((__v8sf)__a, (__v8sf)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testz_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestz256((__v4di)__a, (__v4di)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestc256((__v4di)__a, (__v4di)__b);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_testnzc_si256(__m256i __a, __m256i __b)
{
  return __builtin_ia32_ptestnzc256((__v4di)__a, (__v4di)__b);
}


static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movemask_pd(__m256d __a)
{
  return __builtin_ia32_movmskpd256((__v4df)__a);
}

static __inline int __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_movemask_ps(__m256 __a)
{
  return __builtin_ia32_movmskps256((__v8sf)__a);
}


static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroall(void)
{
  __builtin_ia32_vzeroall();
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_zeroupper(void)
{
  __builtin_ia32_vzeroupper();
}


static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return (__m128)(__v4sf){ __f, __f, __f, __f };
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_sd(double const *__a)
{
  double __d = *__a;
  return (__m256d)(__v4df){ __d, __d, __d, __d };
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_ss(float const *__a)
{
  float __f = *__a;
  return (__m256)(__v8sf){ __f, __f, __f, __f, __f, __f, __f, __f };
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_pd(__m128d const *__a)
{
  return (__m256d)__builtin_ia32_vbroadcastf128_pd256(__a);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_broadcast_ps(__m128 const *__a)
{
  return (__m256)__builtin_ia32_vbroadcastf128_ps256(__a);
}


static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_load_pd(double const *__p)
{
  return *(__m256d *)__p;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_load_ps(float const *__p)
{
  return *(__m256 *)__p;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu_pd(double const *__p)
{
  struct __loadu_pd {
    __m256d __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_pd*)__p)->__v;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu_ps(float const *__p)
{
  struct __loadu_ps {
    __m256 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_load_si256(__m256i const *__p)
{
  return *__p;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu_si256(__m256i const *__p)
{
  struct __loadu_si256 {
    __m256i __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_si256*)__p)->__v;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_lddqu_si256(__m256i const *__p)
{
  return (__m256i)__builtin_ia32_lddqu256((char const *)__p);
}


static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_store_pd(double *__p, __m256d __a)
{
  *(__m256d *)__p = __a;
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_store_ps(float *__p, __m256 __a)
{
  *(__m256 *)__p = __a;
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu_pd(double *__p, __m256d __a)
{
  __builtin_ia32_storeupd256(__p, (__v4df)__a);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu_ps(float *__p, __m256 __a)
{
  __builtin_ia32_storeups256(__p, (__v8sf)__a);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_store_si256(__m256i *__p, __m256i __a)
{
  *__p = __a;
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu_si256(__m256i *__p, __m256i __a)
{
  __builtin_ia32_storedqu256((char *)__p, (__v32qi)__a);
}


static __inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskload_pd(double const *__p, __m128i __m)
{
  return (__m128d)__builtin_ia32_maskloadpd((const __v2df *)__p, (__v2di)__m);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskload_pd(double const *__p, __m256i __m)
{
  return (__m256d)__builtin_ia32_maskloadpd256((const __v4df *)__p,
                                               (__v4di)__m);
}

static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskload_ps(float const *__p, __m128i __m)
{
  return (__m128)__builtin_ia32_maskloadps((const __v4sf *)__p, (__v4si)__m);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskload_ps(float const *__p, __m256i __m)
{
  return (__m256)__builtin_ia32_maskloadps256((const __v8sf *)__p, (__v8si)__m);
}


static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskstore_ps(float *__p, __m256i __m, __m256 __a)
{
  __builtin_ia32_maskstoreps256((__v8sf *)__p, (__v8si)__m, (__v8sf)__a);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskstore_pd(double *__p, __m128i __m, __m128d __a)
{
  __builtin_ia32_maskstorepd((__v2df *)__p, (__v2di)__m, (__v2df)__a);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_maskstore_pd(double *__p, __m256i __m, __m256d __a)
{
  __builtin_ia32_maskstorepd256((__v4df *)__p, (__v4di)__m, (__v4df)__a);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm_maskstore_ps(float *__p, __m128i __m, __m128 __a)
{
  __builtin_ia32_maskstoreps((__v4sf *)__p, (__v4si)__m, (__v4sf)__a);
}


static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_stream_si256(__m256i *__a, __m256i __b)
{
  __builtin_ia32_movntdq256((__v4di *)__a, (__v4di)__b);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_stream_pd(double *__a, __m256d __b)
{
  __builtin_ia32_movntpd256(__a, (__v4df)__b);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_stream_ps(float *__p, __m256 __a)
{
  __builtin_ia32_movntps256(__p, (__v8sf)__a);
}


static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_undefined_pd()
{
  return (__m256d)__builtin_ia32_undef256();
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_undefined_ps()
{
  return (__m256)__builtin_ia32_undef256();
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_undefined_si256()
{
  return (__m256i)__builtin_ia32_undef256();
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_pd(double __a, double __b, double __c, double __d)
{
  return (__m256d){ __d, __c, __b, __a };
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_ps(float __a, float __b, float __c, float __d,
              float __e, float __f, float __g, float __h)
{
  return (__m256){ __h, __g, __f, __e, __d, __c, __b, __a };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi32(int __i0, int __i1, int __i2, int __i3,
                 int __i4, int __i5, int __i6, int __i7)
{
  return (__m256i)(__v8si){ __i7, __i6, __i5, __i4, __i3, __i2, __i1, __i0 };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi16(short __w15, short __w14, short __w13, short __w12,
                 short __w11, short __w10, short __w09, short __w08,
                 short __w07, short __w06, short __w05, short __w04,
                 short __w03, short __w02, short __w01, short __w00)
{
  return (__m256i)(__v16hi){ __w00, __w01, __w02, __w03, __w04, __w05, __w06,
    __w07, __w08, __w09, __w10, __w11, __w12, __w13, __w14, __w15 };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi8(char __b31, char __b30, char __b29, char __b28,
                char __b27, char __b26, char __b25, char __b24,
                char __b23, char __b22, char __b21, char __b20,
                char __b19, char __b18, char __b17, char __b16,
                char __b15, char __b14, char __b13, char __b12,
                char __b11, char __b10, char __b09, char __b08,
                char __b07, char __b06, char __b05, char __b04,
                char __b03, char __b02, char __b01, char __b00)
{
  return (__m256i)(__v32qi){
    __b00, __b01, __b02, __b03, __b04, __b05, __b06, __b07,
    __b08, __b09, __b10, __b11, __b12, __b13, __b14, __b15,
    __b16, __b17, __b18, __b19, __b20, __b21, __b22, __b23,
    __b24, __b25, __b26, __b27, __b28, __b29, __b30, __b31
  };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return (__m256i)(__v4di){ __d, __c, __b, __a };
}


static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_pd(double __a, double __b, double __c, double __d)
{
  return (__m256d){ __a, __b, __c, __d };
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_ps(float __a, float __b, float __c, float __d,
               float __e, float __f, float __g, float __h)
{
  return (__m256){ __a, __b, __c, __d, __e, __f, __g, __h };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi32(int __i0, int __i1, int __i2, int __i3,
                  int __i4, int __i5, int __i6, int __i7)
{
  return (__m256i)(__v8si){ __i0, __i1, __i2, __i3, __i4, __i5, __i6, __i7 };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi16(short __w15, short __w14, short __w13, short __w12,
       short __w11, short __w10, short __w09, short __w08,
       short __w07, short __w06, short __w05, short __w04,
       short __w03, short __w02, short __w01, short __w00)
{
  return (__m256i)(__v16hi){ __w15, __w14, __w13, __w12, __w11, __w10, __w09,
    __w08, __w07, __w06, __w05, __w04, __w03, __w02, __w01, __w00 };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi8(char __b31, char __b30, char __b29, char __b28,
                 char __b27, char __b26, char __b25, char __b24,
                 char __b23, char __b22, char __b21, char __b20,
                 char __b19, char __b18, char __b17, char __b16,
                 char __b15, char __b14, char __b13, char __b12,
                 char __b11, char __b10, char __b09, char __b08,
                 char __b07, char __b06, char __b05, char __b04,
                 char __b03, char __b02, char __b01, char __b00)
{
  return (__m256i)(__v32qi){
    __b31, __b30, __b29, __b28, __b27, __b26, __b25, __b24,
    __b23, __b22, __b21, __b20, __b19, __b18, __b17, __b16,
    __b15, __b14, __b13, __b12, __b11, __b10, __b09, __b08,
    __b07, __b06, __b05, __b04, __b03, __b02, __b01, __b00 };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_epi64x(long long __a, long long __b, long long __c, long long __d)
{
  return (__m256i)(__v4di){ __a, __b, __c, __d };
}


static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_pd(double __w)
{
  return (__m256d){ __w, __w, __w, __w };
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_ps(float __w)
{
  return (__m256){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi32(int __i)
{
  return (__m256i)(__v8si){ __i, __i, __i, __i, __i, __i, __i, __i };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi16(short __w)
{
  return (__m256i)(__v16hi){ __w, __w, __w, __w, __w, __w, __w, __w, __w, __w,
    __w, __w, __w, __w, __w, __w };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi8(char __b)
{
  return (__m256i)(__v32qi){ __b, __b, __b, __b, __b, __b, __b, __b, __b, __b,
    __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b,
    __b, __b, __b, __b, __b, __b, __b };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set1_epi64x(long long __q)
{
  return (__m256i)(__v4di){ __q, __q, __q, __q };
}


static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setzero_pd(void)
{
  return (__m256d){ 0, 0, 0, 0 };
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setzero_ps(void)
{
  return (__m256){ 0, 0, 0, 0, 0, 0, 0, 0 };
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setzero_si256(void)
{
  return (__m256i){ 0LL, 0LL, 0LL, 0LL };
}


static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd_ps(__m256d __a)
{
  return (__m256)__a;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd_si256(__m256d __a)
{
  return (__m256i)__a;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps_pd(__m256 __a)
{
  return (__m256d)__a;
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps_si256(__m256 __a)
{
  return (__m256i)__a;
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi256_ps(__m256i __a)
{
  return (__m256)__a;
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi256_pd(__m256i __a)
{
  return (__m256d)__a;
}

static __inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd256_pd128(__m256d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1);
}

static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps256_ps128(__m256 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3);
}

static __inline __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi256_si128(__m256i __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castpd128_pd256(__m128d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, -1, -1);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castps128_ps256(__m128 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3, -1, -1, -1, -1);
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_castsi128_si256(__m128i __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, -1, -1);
}
static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu2_m128(float const *__addr_hi, float const *__addr_lo)
{
  struct __loadu_ps {
    __m128 __v;
  } __attribute__((__packed__, __may_alias__));

  __m256 __v256 = _mm256_castps128_ps256(((struct __loadu_ps*)__addr_lo)->__v);
  return __extension__ ({ (__m256)__builtin_shufflevector( (__v8sf)(__m256)(__v256), (__v8sf)_mm256_castps128_ps256((__m128)(((struct __loadu_ps*)__addr_hi)->__v)), (((1) & 1) ? 0 : 8), (((1) & 1) ? 1 : 9), (((1) & 1) ? 2 : 10), (((1) & 1) ? 3 : 11), (((1) & 1) ? 8 : 4), (((1) & 1) ? 9 : 5), (((1) & 1) ? 10 : 6), (((1) & 1) ? 11 : 7) );});
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu2_m128d(double const *__addr_hi, double const *__addr_lo)
{
  struct __loadu_pd {
    __m128d __v;
  } __attribute__((__packed__, __may_alias__));

  __m256d __v256 = _mm256_castpd128_pd256(((struct __loadu_pd*)__addr_lo)->__v);
  return __extension__ ({ (__m256d)__builtin_shufflevector( (__v4df)(__m256d)(__v256), (__v4df)_mm256_castpd128_pd256((__m128d)(((struct __loadu_pd*)__addr_hi)->__v)), (((1) & 1) ? 0 : 4), (((1) & 1) ? 1 : 5), (((1) & 1) ? 4 : 2), (((1) & 1) ? 5 : 3) );});
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_loadu2_m128i(__m128i const *__addr_hi, __m128i const *__addr_lo)
{
  struct __loadu_si128 {
    __m128i __v;
  } __attribute__((__packed__, __may_alias__));
  __m256i __v256 = _mm256_castsi128_si256(
    ((struct __loadu_si128*)__addr_lo)->__v);
  return __extension__ ({ (__m256i)__builtin_shufflevector( (__v4di)(__m256i)(__v256), (__v4di)_mm256_castsi128_si256((__m128i)(((struct __loadu_si128*)__addr_hi)->__v)), (((1) & 1) ? 0 : 4), (((1) & 1) ? 1 : 5), (((1) & 1) ? 4 : 2), (((1) & 1) ? 5 : 3) );});

}


static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu2_m128(float *__addr_hi, float *__addr_lo, __m256 __a)
{
  __m128 __v128;

  __v128 = _mm256_castps256_ps128(__a);
  __builtin_ia32_storeups(__addr_lo, __v128);
  __v128 = __extension__ ({ (__m128)__builtin_shufflevector( (__v8sf)(__m256)(__a), (__v8sf)(_mm256_setzero_ps()), (((1) & 1) ? 4 : 0), (((1) & 1) ? 5 : 1), (((1) & 1) ? 6 : 2), (((1) & 1) ? 7 : 3) );});
  __builtin_ia32_storeups(__addr_hi, __v128);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu2_m128d(double *__addr_hi, double *__addr_lo, __m256d __a)
{
  __m128d __v128;

  __v128 = _mm256_castpd256_pd128(__a);
  __builtin_ia32_storeupd(__addr_lo, __v128);
  __v128 = __extension__ ({ (__m128d)__builtin_shufflevector( (__v4df)(__m256d)(__a), (__v4df)(_mm256_setzero_pd()), (((1) & 1) ? 2 : 0), (((1) & 1) ? 3 : 1) );});
  __builtin_ia32_storeupd(__addr_hi, __v128);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_storeu2_m128i(__m128i *__addr_hi, __m128i *__addr_lo, __m256i __a)
{
  __m128i __v128;

  __v128 = _mm256_castsi256_si128(__a);
  __builtin_ia32_storedqu((char *)__addr_lo, (__v16qi)__v128);
  __v128 = __extension__ ({ (__m128i)__builtin_shufflevector( (__v4di)(__m256i)(__a), (__v4di)(_mm256_setzero_si256()), (((1) & 1) ? 2 : 0), (((1) & 1) ? 3 : 1) );});
  __builtin_ia32_storedqu((char *)__addr_hi, (__v16qi)__v128);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_m128 (__m128 __hi, __m128 __lo) {
  return (__m256) __builtin_shufflevector(__lo, __hi, 0, 1, 2, 3, 4, 5, 6, 7);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_m128d (__m128d __hi, __m128d __lo) {
  return (__m256d)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_set_m128i (__m128i __hi, __m128i __lo) {
  return (__m256i)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}

static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_m128 (__m128 __lo, __m128 __hi) {
  return _mm256_set_m128(__hi, __lo);
}

static __inline __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_m128d (__m128d __lo, __m128d __hi) {
  return (__m256d)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx")))
_mm256_setr_m128i (__m128i __lo, __m128i __hi) {
  return (__m256i)_mm256_set_m128((__m128)__hi, (__m128)__lo);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_abs_epi8(__m256i __a)
{
    return (__m256i)__builtin_ia32_pabsb256((__v32qi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_abs_epi16(__m256i __a)
{
    return (__m256i)__builtin_ia32_pabsw256((__v16hi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_abs_epi32(__m256i __a)
{
    return (__m256i)__builtin_ia32_pabsd256((__v8si)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packsswb256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packs_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packssdw256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packus_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_packuswb256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_packus_epi32(__m256i __V1, __m256i __V2)
{
  return (__m256i) __builtin_ia32_packusdw256((__v8si)__V1, (__v8si)__V2);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qi)__a + (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a + (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a + (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_add_epi64(__m256i __a, __m256i __b)
{
  return __a + __b;
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddusb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_adds_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_paddusw256((__v16hi)__a, (__v16hi)__b);
}





static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_and_si256(__m256i __a, __m256i __b)
{
  return __a & __b;
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_andnot_si256(__m256i __a, __m256i __b)
{
  return ~__a & __b;
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_avg_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pavgb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_avg_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pavgw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_blendv_epi8(__m256i __V1, __m256i __V2, __m256i __M)
{
  return (__m256i)__builtin_ia32_pblendvb256((__v32qi)__V1, (__v32qi)__V2,
                                              (__v32qi)__M);
}
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qi)__a == (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a == (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a == (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpeq_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)(__a == __b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi8(__m256i __a, __m256i __b)
{


  return (__m256i)((__v32qs)__a > (__v32qs)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a > (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a > (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cmpgt_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)(__a > __b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hadd_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hadd_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hadds_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phaddsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hsub_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hsub_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_hsubs_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_phsubsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maddubs_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_pmaddubsw256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_madd_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaddwd256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxsd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxub256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxuw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_max_epu32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmaxud256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminsd256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminub256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminuw256 ((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_min_epu32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pminud256((__v8si)__a, (__v8si)__b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_movemask_epi8(__m256i __a)
{
  return __builtin_ia32_pmovmskb256((__v32qi)__a);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi8_epi16(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovsxbw256((__v16qi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi8_epi32(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovsxbd256((__v16qi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi8_epi64(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovsxbq256((__v16qi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi16_epi32(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovsxwd256((__v8hi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi16_epi64(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovsxwq256((__v8hi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepi32_epi64(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovsxdq256((__v4si)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu8_epi16(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovzxbw256((__v16qi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu8_epi32(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovzxbd256((__v16qi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu8_epi64(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovzxbq256((__v16qi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu16_epi32(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovzxwd256((__v8hi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu16_epi64(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovzxwq256((__v8hi)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_cvtepu32_epi64(__m128i __V)
{
  return (__m256i)__builtin_ia32_pmovzxdq256((__v4si)__V);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mul_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmuldq256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mulhrs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhrsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mulhi_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhuw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mulhi_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pmulhw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mullo_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a * (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mullo_epi32 (__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a * (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_mul_epu32(__m256i __a, __m256i __b)
{
  return __builtin_ia32_pmuludq256((__v8si)__a, (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_or_si256(__m256i __a, __m256i __b)
{
  return __a | __b;
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sad_epu8(__m256i __a, __m256i __b)
{
  return __builtin_ia32_psadbw256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_shuffle_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_pshufb256((__v32qi)__a, (__v32qi)__b);
}
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sign_epi8(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sign_epi16(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sign_epi32(__m256i __a, __m256i __b)
{
    return (__m256i)__builtin_ia32_psignd256((__v8si)__a, (__v8si)__b);
}






static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_slli_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psllwi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sll_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psllw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_slli_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_pslldi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sll_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_pslld256((__v8si)__a, (__v4si)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_slli_epi64(__m256i __a, int __count)
{
  return __builtin_ia32_psllqi256(__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sll_epi64(__m256i __a, __m128i __count)
{
  return __builtin_ia32_psllq256(__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srai_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrawi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sra_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psraw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srai_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psradi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sra_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrad256((__v8si)__a, (__v4si)__count);
}






static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srli_epi16(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrlwi256((__v16hi)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srl_epi16(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrlw256((__v16hi)__a, (__v8hi)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srli_epi32(__m256i __a, int __count)
{
  return (__m256i)__builtin_ia32_psrldi256((__v8si)__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srl_epi32(__m256i __a, __m128i __count)
{
  return (__m256i)__builtin_ia32_psrld256((__v8si)__a, (__v4si)__count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srli_epi64(__m256i __a, int __count)
{
  return __builtin_ia32_psrlqi256(__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srl_epi64(__m256i __a, __m128i __count)
{
  return __builtin_ia32_psrlq256(__a, __count);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)((__v32qi)__a - (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)((__v16hi)__a - (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)((__v8si)__a - (__v8si)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sub_epi64(__m256i __a, __m256i __b)
{
  return __a - __b;
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubsb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubsw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epu8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubusb256((__v32qi)__a, (__v32qi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_subs_epu16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_psubusw256((__v16hi)__a, (__v16hi)__b);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v32qi)__a, (__v32qi)__b, 8, 32+8, 9, 32+9, 10, 32+10, 11, 32+11, 12, 32+12, 13, 32+13, 14, 32+14, 15, 32+15, 24, 32+24, 25, 32+25, 26, 32+26, 27, 32+27, 28, 32+28, 29, 32+29, 30, 32+30, 31, 32+31);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v16hi)__a, (__v16hi)__b, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v8si)__a, (__v8si)__b, 2, 8+2, 3, 8+3, 6, 8+6, 7, 8+7);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpackhi_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector(__a, __b, 1, 4+1, 3, 4+3);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi8(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v32qi)__a, (__v32qi)__b, 0, 32+0, 1, 32+1, 2, 32+2, 3, 32+3, 4, 32+4, 5, 32+5, 6, 32+6, 7, 32+7, 16, 32+16, 17, 32+17, 18, 32+18, 19, 32+19, 20, 32+20, 21, 32+21, 22, 32+22, 23, 32+23);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi16(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v16hi)__a, (__v16hi)__b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector((__v8si)__a, (__v8si)__b, 0, 8+0, 1, 8+1, 4, 8+4, 5, 8+5);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_unpacklo_epi64(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_shufflevector(__a, __b, 0, 4+0, 2, 4+2);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_xor_si256(__m256i __a, __m256i __b)
{
  return __a ^ __b;
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_stream_load_si256(__m256i const *__V)
{
  return (__m256i)__builtin_ia32_movntdqa256((const __v4di *)__V);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastss_ps(__m128 __X)
{
  return (__m128)__builtin_shufflevector((__v4sf)__X, (__v4sf)__X, 0, 0, 0, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastsd_pd(__m128d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 0);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastss_ps(__m128 __X)
{
  return (__m256)__builtin_shufflevector((__v4sf)__X, (__v4sf)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastsd_pd(__m128d __X)
{
  return (__m256d)__builtin_shufflevector((__v2df)__X, (__v2df)__X, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastsi128_si256(__m128i __X)
{
  return (__m256i)__builtin_shufflevector(__X, __X, 0, 1, 0, 1);
}
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastb_epi8(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v16qi)__X, (__v16qi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastw_epi16(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v8hi)__X, (__v8hi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastd_epi32(__m128i __X)
{
  return (__m256i)__builtin_shufflevector((__v4si)__X, (__v4si)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_broadcastq_epi64(__m128i __X)
{
  return (__m256i)__builtin_shufflevector(__X, __X, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastb_epi8(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v16qi)__X, (__v16qi)__X, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastw_epi16(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v8hi)__X, (__v8hi)__X, 0, 0, 0, 0, 0, 0, 0, 0);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastd_epi32(__m128i __X)
{
  return (__m128i)__builtin_shufflevector((__v4si)__X, (__v4si)__X, 0, 0, 0, 0);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_broadcastq_epi64(__m128i __X)
{
  return (__m128i)__builtin_shufflevector(__X, __X, 0, 0);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_permutevar8x32_epi32(__m256i __a, __m256i __b)
{
  return (__m256i)__builtin_ia32_permvarsi256((__v8si)__a, (__v8si)__b);
}







static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_permutevar8x32_ps(__m256 __a, __m256i __b)
{
  return (__m256)__builtin_ia32_permvarsf256((__v8sf)__a, (__v8si)__b);
}
static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskload_epi32(int const *__X, __m256i __M)
{
  return (__m256i)__builtin_ia32_maskloadd256((const __v8si *)__X, (__v8si)__M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskload_epi64(long long const *__X, __m256i __M)
{
  return (__m256i)__builtin_ia32_maskloadq256((const __v4di *)__X, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskload_epi32(int const *__X, __m128i __M)
{
  return (__m128i)__builtin_ia32_maskloadd((const __v4si *)__X, (__v4si)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskload_epi64(long long const *__X, __m128i __M)
{
  return (__m128i)__builtin_ia32_maskloadq((const __v2di *)__X, (__v2di)__M);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskstore_epi32(int *__X, __m256i __M, __m256i __Y)
{
  __builtin_ia32_maskstored256((__v8si *)__X, (__v8si)__M, (__v8si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_maskstore_epi64(long long *__X, __m256i __M, __m256i __Y)
{
  __builtin_ia32_maskstoreq256((__v4di *)__X, __M, __Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskstore_epi32(int *__X, __m128i __M, __m128i __Y)
{
  __builtin_ia32_maskstored((__v4si *)__X, (__v4si)__M, (__v4si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_maskstore_epi64(long long *__X, __m128i __M, __m128i __Y)
{
  __builtin_ia32_maskstoreq(( __v2di *)__X, __M, __Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sllv_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psllv8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_sllv_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psllv4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_sllv_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psllv4di(__X, __Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_sllv_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psllv2di(__X, __Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srav_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrav8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_srav_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrav4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srlv_epi32(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrlv8si((__v8si)__X, (__v8si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_srlv_epi32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrlv4si((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm256_srlv_epi64(__m256i __X, __m256i __Y)
{
  return (__m256i)__builtin_ia32_psrlv4di(__X, __Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx2")))
_mm_srlv_epi64(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_psrlv2di(__X, __Y);
}








static __inline __m256 __attribute__((__always_inline__, __nodebug__, __target__("f16c")))
_mm256_cvtph_ps(__m128i __a)
{
  return (__m256)__builtin_ia32_vcvtph2ps256((__v8hi)__a);
}


static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__))
__tzcnt_u16(unsigned short __X)
{
  return __X ? __builtin_ctzs(__X) : 16;
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u32(unsigned int __X, unsigned int __Y)
{
  return ~__X & __Y;
}


static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bextr_u32(__X, __Y);
}


static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u32(unsigned int __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u32 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u32(unsigned int __X)
{
  return __X & -__X;
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u32(unsigned int __X)
{
  return __X ^ (__X - 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u32(unsigned int __X)
{
  return __X & (__X - 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__tzcnt_u32(unsigned int __X)
{
  return __X ? __builtin_ctz(__X) : 32;
}
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__andn_u64 (unsigned long long __X, unsigned long long __Y)
{
  return ~__X & __Y;
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__bextr_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bextr_u64(__X, __Y);
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
_bextr_u64(unsigned long long __X, unsigned int __Y, unsigned int __Z)
{
  return __builtin_ia32_bextr_u64 (__X, ((__Y & 0xff) | ((__Z & 0xff) << 8)));
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsi_u64(unsigned long long __X)
{
  return __X & -__X;
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsmsk_u64(unsigned long long __X)
{
  return __X ^ (__X - 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi")))
__blsr_u64(unsigned long long __X)
{
  return __X & (__X - 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
__tzcnt_u64(unsigned long long __X)
{
  return __X ? __builtin_ctzll(__X) : 64;
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_bzhi_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_bzhi_si(__X, __Y);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pdep_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pdep_si(__X, __Y);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pext_u32(unsigned int __X, unsigned int __Y)
{
  return __builtin_ia32_pext_si(__X, __Y);
}



static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_bzhi_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_bzhi_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pdep_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pdep_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_pext_u64(unsigned long long __X, unsigned long long __Y)
{
  return __builtin_ia32_pext_di(__X, __Y);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("bmi2")))
_mulx_u64 (unsigned long long __X, unsigned long long __Y,
    unsigned long long *__P)
{
  unsigned __int128 __res = (unsigned __int128) __X * __Y;
  *__P = (unsigned long long) (__res >> 64);
  return (unsigned long long) __res;
}

static __inline__ unsigned short __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt16(unsigned short __X)
{
  return __X ? __builtin_clzs(__X) : 16;
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt32(unsigned int __X)
{
  return __X ? __builtin_clz(__X) : 32;
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u32(unsigned int __X)
{
  return __X ? __builtin_clz(__X) : 32;
}


static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
__lzcnt64(unsigned long long __X)
{
  return __X ? __builtin_clzll(__X) : 64;
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("lzcnt")))
_lzcnt_u64(unsigned long long __X)
{
  return __X ? __builtin_clzll(__X) : 64;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmadd_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmadd_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fnmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmaddsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmaddsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsubadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubaddps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm_fmsubadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubaddpd(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmaddps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmaddpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmsubps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fnmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmsubpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmaddsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmaddsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsubadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubaddps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma")))
_mm256_fmsubadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubaddpd256(__A, __B, __C);
}

typedef double __v8df __attribute__((__vector_size__(64)));
typedef float __v16sf __attribute__((__vector_size__(64)));
typedef long long __v8di __attribute__((__vector_size__(64)));
typedef int __v16si __attribute__((__vector_size__(64)));

typedef float __m512 __attribute__((__vector_size__(64)));
typedef double __m512d __attribute__((__vector_size__(64)));
typedef long long __m512i __attribute__((__vector_size__(64)));

typedef unsigned char __mmask8;
typedef unsigned short __mmask16;
static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_setzero_si512(void)
{
  return (__m512i)(__v8di){ 0, 0, 0, 0, 0, 0, 0, 0 };
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined_pd()
{
  return (__m512d)__builtin_ia32_undef512();
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined()
{
  return (__m512)__builtin_ia32_undef512();
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined_ps()
{
  return (__m512)__builtin_ia32_undef512();
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_undefined_epi32()
{
  return (__m512i)__builtin_ia32_undef512();
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_set1_epi32(__mmask16 __M, int __A)
{
  return (__m512i) __builtin_ia32_pbroadcastd512_gpr_mask (__A,
                 (__v16si)
                 _mm512_setzero_si512 (),
                 __M);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_set1_epi64(__mmask8 __M, long long __A)
{

  return (__m512i) __builtin_ia32_pbroadcastq512_gpr_mask (__A,
                 (__v8di)
                 _mm512_setzero_si512 (),
                 __M);






}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_setzero_ps(void)
{
  return (__m512){ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
}
static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_setzero_pd(void)
{
  return (__m512d){ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_ps(float __w)
{
  return (__m512){ __w, __w, __w, __w, __w, __w, __w, __w,
                   __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_pd(double __w)
{
  return (__m512d){ __w, __w, __w, __w, __w, __w, __w, __w };
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_epi32(int __s)
{
  return (__m512i)(__v16si){ __s, __s, __s, __s, __s, __s, __s, __s,
                             __s, __s, __s, __s, __s, __s, __s, __s };
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_set1_epi64(long long __d)
{
  return (__m512i)(__v8di){ __d, __d, __d, __d, __d, __d, __d, __d };
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcastss_ps(__m128 __X)
{
  float __f = __X[0];
  return (__v16sf){ __f, __f, __f, __f,
                    __f, __f, __f, __f,
                    __f, __f, __f, __f,
                    __f, __f, __f, __f };
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_broadcastsd_pd(__m128d __X)
{
  double __d = __X[0];
  return (__v8df){ __d, __d, __d, __d,
                   __d, __d, __d, __d };
}



static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd256_pd512(__m256d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3, -1, -1, -1, -1);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps256_ps512(__m256 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3, 4, 5, 6, 7,
                                          -1, -1, -1, -1, -1, -1, -1, -1);
}

static __inline __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castpd512_pd128(__m512d __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1);
}

static __inline __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_castps512_ps128(__m512 __a)
{
  return __builtin_shufflevector(__a, __a, 0, 1, 2, 3);
}


static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_and_epi32(__m512i __a, __m512i __b)
{
  return __a & __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_and_epi32(__m512i __src, __mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pandd512_mask((__v16si) __a,
              (__v16si) __b,
              (__v16si) __src,
              (__mmask16) __k);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_and_epi32(__mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pandd512_mask((__v16si) __a,
              (__v16si) __b,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __k);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_and_epi64(__m512i __a, __m512i __b)
{
  return __a & __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_and_epi64(__m512i __src, __mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pandq512_mask ((__v8di) __a,
              (__v8di) __b,
              (__v8di) __src,
              (__mmask8) __k);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_and_epi64(__mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pandq512_mask ((__v8di) __a,
              (__v8di) __b,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __k);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_andnot_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_andnot_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si) __W,
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_andnot_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_andnot_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_andnot_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di) __W, __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_andnot_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pandnq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_pd (),
              __U);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_or_epi32(__m512i __a, __m512i __b)
{
  return __a | __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_or_epi32(__m512i __src, __mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pord512_mask((__v16si) __a,
              (__v16si) __b,
              (__v16si) __src,
              (__mmask16) __k);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_or_epi32(__mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pord512_mask((__v16si) __a,
              (__v16si) __b,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __k);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_or_epi64(__m512i __a, __m512i __b)
{
  return __a | __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_or_epi64(__m512i __src, __mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_porq512_mask ((__v8di) __a,
              (__v8di) __b,
              (__v8di) __src,
              (__mmask8) __k);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_or_epi64(__mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_porq512_mask ((__v8di) __a,
              (__v8di) __b,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __k);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_xor_epi32(__m512i __a, __m512i __b)
{
  return __a ^ __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_xor_epi32(__m512i __src, __mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pxord512_mask((__v16si) __a,
              (__v16si) __b,
              (__v16si) __src,
              (__mmask16) __k);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_xor_epi32(__mmask16 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pxord512_mask((__v16si) __a,
              (__v16si) __b,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) __k);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_xor_epi64(__m512i __a, __m512i __b)
{
  return __a ^ __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_xor_epi64(__m512i __src, __mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pxorq512_mask ((__v8di) __a,
              (__v8di) __b,
              (__v8di) __src,
              (__mmask8) __k);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_xor_epi64(__mmask8 __k, __m512i __a, __m512i __b)
{
  return (__m512i) __builtin_ia32_pxorq512_mask ((__v8di) __a,
              (__v8di) __b,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __k);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_and_si512(__m512i __a, __m512i __b)
{
  return __a & __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_or_si512(__m512i __a, __m512i __b)
{
  return __a | __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_xor_si512(__m512i __a, __m512i __b)
{
  return __a ^ __b;
}


static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_pd(__m512d __a, __m512d __b)
{
  return __a + __b;
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_ps(__m512 __a, __m512 __b)
{
  return __a + __b;
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_pd(__m512d __a, __m512d __b)
{
  return __a * __b;
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_ps(__m512 __a, __m512 __b)
{
  return __a * __b;
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_pd(__m512d __a, __m512d __b)
{
  return __a - __b;
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_ps(__m512 __a, __m512 __b)
{
  return __a - __b;
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8di) __A + (__v8di) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddq512_mask ((__v8di) __A,
             (__v8di) __B,
             (__v8di) __W,
             (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddq512_mask ((__v8di) __A,
             (__v8di) __B,
             (__v8di)
             _mm512_setzero_si512 (),
             (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_epi64 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v8di) __A - (__v8di) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubq512_mask ((__v8di) __A,
             (__v8di) __B,
             (__v8di) __W,
             (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_epi64 (__mmask8 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubq512_mask ((__v8di) __A,
             (__v8di) __B,
             (__v8di)
             _mm512_setzero_si512 (),
             (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_add_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16si) __A + (__v16si) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddd512_mask ((__v16si) __A,
             (__v16si) __B,
             (__v16si) __W,
             (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddd512_mask ((__v16si) __A,
             (__v16si) __B,
             (__v16si)
             _mm512_setzero_si512 (),
             (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sub_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16si) __A - (__v16si) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_epi32 (__m512i __W, __mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubd512_mask ((__v16si) __A,
             (__v16si) __B,
             (__v16si) __W,
             (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_epi32 (__mmask16 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubd512_mask ((__v16si) __A,
             (__v16si) __B,
             (__v16si)
             _mm512_setzero_si512 (),
             (__mmask16) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_pd(__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_maxpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) -1,
             0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_ps(__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_maxps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) -1,
            0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_max_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_maxss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_max_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_maxss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_max_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_maxsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_max_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_maxsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
static __inline __m512i
__attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epi32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epu32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxud512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epi64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_max_epu64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_pd(__m512d __A, __m512d __B)
{
  return (__m512d) __builtin_ia32_minpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) -1,
             0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_ps(__m512 __A, __m512 __B)
{
  return (__m512) __builtin_ia32_minps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) -1,
            0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_min_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_minss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_min_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_minss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_min_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_minsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_min_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_minsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
static __inline __m512i
__attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epi32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsd512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epu32(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminud512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              (__mmask16) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epi64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_min_epu64(__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_epi32(__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuldq512_mask ((__v16si) __X,
              (__v16si) __Y,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_epi32 (__m512i __W, __mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuldq512_mask ((__v16si) __X,
              (__v16si) __Y,
              (__v8di) __W, __M);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_epi32 (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuldq512_mask ((__v16si) __X,
              (__v16si) __Y,
              (__v8di)
              _mm512_setzero_si512 (),
              __M);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mul_epu32(__m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuludq512_mask ((__v16si) __X,
               (__v16si) __Y,
               (__v8di)
               _mm512_setzero_si512 (),
               (__mmask8) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_epu32 (__m512i __W, __mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuludq512_mask ((__v16si) __X,
               (__v16si) __Y,
               (__v8di) __W, __M);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_epu32 (__mmask8 __M, __m512i __X, __m512i __Y)
{
  return (__m512i) __builtin_ia32_pmuludq512_mask ((__v16si) __X,
               (__v16si) __Y,
               (__v8di)
               _mm512_setzero_si512 (),
               __M);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mullo_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) ((__v16si) __A * (__v16si) __B);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mullo_epi32 (__mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulld512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si)
              _mm512_setzero_si512 (),
              __M);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mullo_epi32 (__m512i __W, __mmask16 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulld512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v16si) __W, __M);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sqrt_pd(__m512d __a)
{
  return (__m512d)__builtin_ia32_sqrtpd512_mask((__v8df)__a,
                                                (__v8df) _mm512_setzero_pd (),
                                                (__mmask8) -1,
                                                0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_sqrt_ps(__m512 __a)
{
  return (__m512)__builtin_ia32_sqrtps512_mask((__v16sf)__a,
                                               (__v16sf) _mm512_setzero_ps (),
                                               (__mmask16) -1,
                                               0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rsqrt14_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rsqrt14pd512_mask ((__v8df) __A,
                 (__v8df)
                 _mm512_setzero_pd (),
                 (__mmask8) -1);}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rsqrt14_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rsqrt14ps512_mask ((__v16sf) __A,
                (__v16sf)
                _mm512_setzero_ps (),
                (__mmask16) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rsqrt14_ss(__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rsqrt14ss ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf)
             _mm_setzero_ps (),
             (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rsqrt14_sd(__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rsqrt14sd ((__v2df) __A,
              (__v2df) __B,
              (__v2df)
              _mm_setzero_pd (),
              (__mmask8) -1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rcp14_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rcp14pd512_mask ((__v8df) __A,
               (__v8df)
               _mm512_setzero_pd (),
               (__mmask8) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_rcp14_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rcp14ps512_mask ((__v16sf) __A,
              (__v16sf)
              _mm512_setzero_ps (),
              (__mmask16) -1);
}
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rcp14_ss(__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_rcp14ss ((__v4sf) __A,
                 (__v4sf) __B,
                 (__v4sf)
                 _mm_setzero_ps (),
                 (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_rcp14_sd(__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_rcp14sd ((__v2df) __A,
            (__v2df) __B,
            (__v2df)
            _mm_setzero_pd (),
            (__mmask8) -1);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_floor_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
                                                  (0x00 | 0x01),
                                                  (__v16sf) __A, -1,
                                                  0x04);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_floor_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
                                                   (0x00 | 0x01),
                                                   (__v8df) __A, -1,
                                                   0x04);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_ceil_ps(__m512 __A)
{
  return (__m512) __builtin_ia32_rndscaleps_mask ((__v16sf) __A,
                                                  (0x00 | 0x02),
                                                  (__v16sf) __A, -1,
                                                  0x04);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_ceil_pd(__m512d __A)
{
  return (__m512d) __builtin_ia32_rndscalepd_mask ((__v8df) __A,
                                                   (0x00 | 0x02),
                                                   (__v8df) __A, -1,
                                                   0x04);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_abs_epi64(__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsq512_mask ((__v8di) __A,
             (__v8di)
             _mm512_setzero_si512 (),
             (__mmask8) -1);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_abs_epi32(__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsd512_mask ((__v16si) __A,
             (__v16si)
             _mm512_setzero_si512 (),
             (__mmask16) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_add_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_addss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_add_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_addss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_add_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_addsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_add_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_addsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_addpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __W,
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_addpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) _mm512_setzero_pd (),
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_add_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_addps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U,
            0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_add_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_addps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) _mm512_setzero_ps (),
            (__mmask16) __U,
            0x04);
}
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_sub_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_subss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_sub_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_subss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_sub_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_subsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_sub_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_subsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_subpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __W,
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_subpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_sub_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_subps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U,
            0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_sub_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_subps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) __U,
            0x04);
}
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_mul_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_mulss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_mul_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_mulss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_mul_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_mulsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_mul_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_mulsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_mulpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __W,
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_mulpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_mul_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_mulps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U,
            0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_mul_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_mulps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) __U,
            0x04);
}
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_div_ss(__m128 __W, __mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_divss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_div_ss(__mmask8 __U,__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_divss_round ((__v4sf) __A,
                (__v4sf) __B,
                (__v4sf) _mm_setzero_ps (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_mask_div_sd(__m128d __W, __mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_divsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm_maskz_div_sd(__mmask8 __U,__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_divsd_round ((__v2df) __A,
                (__v2df) __B,
                (__v2df) _mm_setzero_pd (),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_div_pd(__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_divpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __W,
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_div_pd(__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_divpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) __U,
             0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_div_ps(__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_divps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U,
            0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_div_ps(__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_divps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) __U,
            0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmadd_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    (__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmadd_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    (__v8df) __C,
                                                    (__mmask8) __U,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmadd_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask3 ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmadd_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsub_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    -(__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsub_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask ((__v8df) __A,
                                                    (__v8df) __B,
                                                    -(__v8df) __C,
                                                    (__mmask8) __U,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsub_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz ((__v8df) __A,
                                                     (__v8df) __B,
                                                     -(__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmadd_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask (-(__v8df) __A,
                                                    (__v8df) __B,
                                                    (__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmadd_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask3 (-(__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmadd_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz (-(__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmsub_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_mask (-(__v8df) __A,
                                                    (__v8df) __B,
                                                    -(__v8df) __C,
                                                    (__mmask8) -1,
                                                    0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmsub_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddpd512_maskz (-(__v8df) __A,
                                                     (__v8df) __B,
                                                     -(__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmadd_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   (__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmadd_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   (__v16sf) __C,
                                                   (__mmask16) __U,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmadd_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask3 ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmadd_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsub_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   -(__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsub_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask ((__v16sf) __A,
                                                   (__v16sf) __B,
                                                   -(__v16sf) __C,
                                                   (__mmask16) __U,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsub_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    -(__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmadd_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask (-(__v16sf) __A,
                                                   (__v16sf) __B,
                                                   (__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmadd_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask3 (-(__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmadd_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz (-(__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fnmsub_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_mask (-(__v16sf) __A,
                                                   (__v16sf) __B,
                                                   -(__v16sf) __C,
                                                   (__mmask16) -1,
                                                   0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fnmsub_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddps512_maskz (-(__v16sf) __A,
                                                    (__v16sf) __B,
                                                    -(__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmaddsub_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       (__v8df) __C,
                                                       (__mmask8) -1,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmaddsub_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       (__v8df) __C,
                                                       (__mmask8) __U,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmaddsub_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask3 ((__v8df) __A,
                                                        (__v8df) __B,
                                                        (__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmaddsub_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_maskz ((__v8df) __A,
                                                        (__v8df) __B,
                                                        (__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsubadd_pd(__m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       -(__v8df) __C,
                                                       (__mmask8) -1,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsubadd_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_mask ((__v8df) __A,
                                                       (__v8df) __B,
                                                       -(__v8df) __C,
                                                       (__mmask8) __U,
                                                       0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsubadd_pd(__mmask8 __U, __m512d __A, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfmaddsubpd512_maskz ((__v8df) __A,
                                                        (__v8df) __B,
                                                        -(__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmaddsub_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      (__v16sf) __C,
                                                      (__mmask16) -1,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmaddsub_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      (__v16sf) __C,
                                                      (__mmask16) __U,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmaddsub_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask3 ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmaddsub_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_maskz ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_fmsubadd_ps(__m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      -(__v16sf) __C,
                                                      (__mmask16) -1,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fmsubadd_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_mask ((__v16sf) __A,
                                                      (__v16sf) __B,
                                                      -(__v16sf) __C,
                                                      (__mmask16) __U,
                                                      0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_fmsubadd_ps(__mmask16 __U, __m512 __A, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfmaddsubps512_maskz ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       -(__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}







static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsub_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmsubpd512_mask3 ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}







static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsub_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmsubps512_mask3 ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}







static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsubadd_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfmsubaddpd512_mask3 ((__v8df) __A,
                                                        (__v8df) __B,
                                                        (__v8df) __C,
                                                        (__mmask8) __U,
                                                        0x04);
}







static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fmsubadd_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfmsubaddps512_mask3 ((__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__v16sf) __C,
                                                       (__mmask16) __U,
                                                       0x04);
}







static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmadd_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmaddpd512_mask ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}







static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmadd_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmaddps512_mask ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmsub_pd(__m512d __A, __mmask8 __U, __m512d __B, __m512d __C)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask ((__v8df) __A,
                                                     (__v8df) __B,
                                                     (__v8df) __C,
                                                     (__mmask8) __U,
                                                     0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmsub_pd(__m512d __A, __m512d __B, __m512d __C, __mmask8 __U)
{
  return (__m512d) __builtin_ia32_vfnmsubpd512_mask3 ((__v8df) __A,
                                                      (__v8df) __B,
                                                      (__v8df) __C,
                                                      (__mmask8) __U,
                                                      0x04);
}
static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_fnmsub_ps(__m512 __A, __mmask16 __U, __m512 __B, __m512 __C)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask ((__v16sf) __A,
                                                    (__v16sf) __B,
                                                    (__v16sf) __C,
                                                    (__mmask16) __U,
                                                    0x04);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask3_fnmsub_ps(__m512 __A, __m512 __B, __m512 __C, __mmask16 __U)
{
  return (__m512) __builtin_ia32_vfnmsubps512_mask3 ((__v16sf) __A,
                                                     (__v16sf) __B,
                                                     (__v16sf) __C,
                                                     (__mmask16) __U,
                                                     0x04);
}





static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_epi32(__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2vard512_mask ((__v16si) __I
                                                                 ,
                                                       (__v16si) __A,
                                                       (__v16si) __B,
                                                       (__mmask16) -1);
}
static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_epi64(__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varq512_mask ((__v8di) __I
                                                                 ,
                                                       (__v8di) __A,
                                                       (__v8di) __B,
                                                       (__mmask8) -1);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_pd(__m512d __A, __m512i __I, __m512d __B)
{
  return (__m512d) __builtin_ia32_vpermt2varpd512_mask ((__v8di) __I
                                                                  ,
                                                        (__v8df) __A,
                                                        (__v8df) __B,
                                                        (__mmask8) -1);
}
static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_permutex2var_ps(__m512 __A, __m512i __I, __m512 __B)
{
  return (__m512) __builtin_ia32_vpermt2varps512_mask ((__v16si) __I
                                                                 ,
                                                       (__v16sf) __A,
                                                       (__v16sf) __B,
                                                       (__mmask16) -1);
}
static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_pd(__mmask8 __U, __m512d __A, __m512d __W)
{
  return (__m512d) __builtin_ia32_blendmpd_512_mask ((__v8df) __A,
                 (__v8df) __W,
                 (__mmask8) __U);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_ps(__mmask16 __U, __m512 __A, __m512 __W)
{
  return (__m512) __builtin_ia32_blendmps_512_mask ((__v16sf) __A,
                (__v16sf) __W,
                (__mmask16) __U);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_epi64(__mmask8 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_blendmq_512_mask ((__v8di) __A,
                (__v8di) __W,
                (__mmask8) __U);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_blend_epi32(__mmask16 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_blendmd_512_mask ((__v16si) __A,
                (__v16si) __W,
                (__mmask16) __U);
}
static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttps_epu32(__m512 __A)
{
  return (__m512i) __builtin_ia32_cvttps2udq512_mask ((__v16sf) __A,
                  (__v16si)
                  _mm512_setzero_si512 (),
                  (__mmask16) -1,
                  0x04);
}
static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepi32_pd(__m256i __A)
{
  return (__m512d) __builtin_ia32_cvtdq2pd512_mask ((__v8si) __A,
                (__v8df)
                _mm512_setzero_pd (),
                (__mmask8) -1);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtepu32_pd(__m256i __A)
{
  return (__m512d) __builtin_ia32_cvtudq2pd512_mask ((__v8si) __A,
                (__v8df)
                _mm512_setzero_pd (),
                (__mmask8) -1);
}
static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvtph_ps(__m256i __A)
{
  return (__m512) __builtin_ia32_vcvtph2ps512_mask ((__v16hi) __A,
                (__v16sf)
                _mm512_setzero_ps (),
                (__mmask16) -1,
                0x04);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttps_epi32(__m512 __a)
{
  return (__m512i)
    __builtin_ia32_cvttps2dq512_mask((__v16sf) __a,
                                     (__v16si) _mm512_setzero_si512 (),
                                     (__mmask16) -1, 0x04);
}

static __inline __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cvttpd_epi32(__m512d __a)
{
  return (__m256i)__builtin_ia32_cvttpd2dq512_mask((__v8df) __a,
                                                   (__v8si)_mm256_setzero_si256(),
                                                   (__mmask8) -1,
                                                    0x04);
}
static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpackhi_pd(__m512d __a, __m512d __b)
{
  return __builtin_shufflevector(__a, __b, 1, 9, 1+2, 9+2, 1+4, 9+4, 1+6, 9+6);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpacklo_pd(__m512d __a, __m512d __b)
{
  return __builtin_shufflevector(__a, __b, 0, 8, 0+2, 8+2, 0+4, 8+4, 0+6, 8+6);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpackhi_ps(__m512 __a, __m512 __b)
{
  return __builtin_shufflevector(__a, __b,
                                 2, 18, 3, 19,
                                 2+4, 18+4, 3+4, 19+4,
                                 2+8, 18+8, 3+8, 19+8,
                                 2+12, 18+12, 3+12, 19+12);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_unpacklo_ps(__m512 __a, __m512 __b)
{
  return __builtin_shufflevector(__a, __b,
                                 0, 16, 1, 17,
                                 0+4, 16+4, 1+4, 17+4,
                                 0+8, 16+8, 1+8, 17+8,
                                 0+12, 16+12, 1+12, 17+12);
}



static __inline __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_test_epi32_mask(__m512i __A, __m512i __B)
{
  return (__mmask16) __builtin_ia32_ptestmd512 ((__v16si) __A,
            (__v16si) __B,
            (__mmask16) -1);
}

static __inline __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_test_epi64_mask(__m512i __A, __m512i __B)
{
  return (__mmask8) __builtin_ia32_ptestmq512 ((__v8di) __A,
                 (__v8di) __B,
                 (__mmask8) -1);
}



static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_epi32(__mmask16 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqusi512_mask ((const __v16si *)__P,
                                                     (__v16si)
                                                     _mm512_setzero_si512 (),
                                                     (__mmask16) __U);
}

static __inline __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_epi64(__mmask8 __U, void const *__P)
{
  return (__m512i) __builtin_ia32_loaddqudi512_mask ((const __v8di *)__P,
                                                     (__v8di)
                                                     _mm512_setzero_si512 (),
                                                     (__mmask8) __U);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_ps(__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadups512_mask ((const __v16sf *)__P,
                                                  (__v16sf)
                                                  _mm512_setzero_ps (),
                                                  (__mmask16) __U);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_loadu_pd(__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadupd512_mask ((const __v8df *)__P,
                                                   (__v8df)
                                                   _mm512_setzero_pd (),
                                                   (__mmask8) __U);
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_load_ps(__mmask16 __U, void const *__P)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *)__P,
                                                  (__v16sf)
                                                  _mm512_setzero_ps (),
                                                  (__mmask16) __U);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_maskz_load_pd(__mmask8 __U, void const *__P)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *)__P,
                                                   (__v8df)
                                                   _mm512_setzero_pd (),
                                                   (__mmask8) __U);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_loadu_pd(double const *__p)
{
  struct __loadu_pd {
    __m512d __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_pd*)__p)->__v;
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_loadu_ps(float const *__p)
{
  struct __loadu_ps {
    __m512 __v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)__p)->__v;
}

static __inline __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_ps(double const *__p)
{
  return (__m512) __builtin_ia32_loadaps512_mask ((const __v16sf *)__p,
                                                  (__v16sf)
                                                  _mm512_setzero_ps (),
                                                  (__mmask16) -1);
}

static __inline __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_load_pd(float const *__p)
{
  return (__m512d) __builtin_ia32_loadapd512_mask ((const __v8df *)__p,
                                                   (__v8df)
                                                   _mm512_setzero_pd (),
                                                   (__mmask8) -1);
}



static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_epi64(void *__P, __mmask8 __U, __m512i __A)
{
  __builtin_ia32_storedqudi512_mask ((__v8di *)__P, (__v8di) __A,
                                     (__mmask8) __U);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_epi32(void *__P, __mmask16 __U, __m512i __A)
{
  __builtin_ia32_storedqusi512_mask ((__v16si *)__P, (__v16si) __A,
                                     (__mmask16) __U);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_pd(void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_storeupd512_mask ((__v8df *)__P, (__v8df) __A, (__mmask8) __U);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_storeu_pd(void *__P, __m512d __A)
{
  __builtin_ia32_storeupd512_mask((__v8df *)__P, (__v8df)__A, (__mmask8)-1);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_storeu_ps(void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_storeups512_mask ((__v16sf *)__P, (__v16sf) __A,
                                   (__mmask16) __U);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_storeu_ps(void *__P, __m512 __A)
{
  __builtin_ia32_storeups512_mask((__v16sf *)__P, (__v16sf)__A, (__mmask16)-1);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_store_pd(void *__P, __mmask8 __U, __m512d __A)
{
  __builtin_ia32_storeapd512_mask ((__v8df *)__P, (__v8df) __A, (__mmask8) __U);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_pd(void *__P, __m512d __A)
{
  *(__m512d*)__P = __A;
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_store_ps(void *__P, __mmask16 __U, __m512 __A)
{
  __builtin_ia32_storeaps512_mask ((__v16sf *)__P, (__v16sf) __A,
                                   (__mmask16) __U);
}

static __inline void __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_store_ps(void *__P, __m512 __A)
{
  *(__m512*)__P = __A;
}



static __inline __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_knot(__mmask16 __M)
{
  return __builtin_ia32_knothi(__M);
}



static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqd512_mask((__v16si)__a, (__v16si)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqd512_mask((__v16si)__a, (__v16si)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 0,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 0,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq512_mask((__v8di)__a, (__v8di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq512_mask((__v8di)__a, (__v8di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpeq_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpeq_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 0,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 5,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpge_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpge_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtd512_mask((__v16si)__a, (__v16si)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtd512_mask((__v16si)__a, (__v16si)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 6,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 6,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq512_mask((__v8di)__a, (__v8di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq512_mask((__v8di)__a, (__v8di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpgt_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpgt_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 6,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 2,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmple_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmple_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 1,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmplt_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmplt_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epi32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epi32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_cmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epu32_mask(__m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epu32_mask(__mmask16 __u, __m512i __a, __m512i __b) {
  return (__mmask16)__builtin_ia32_ucmpd512_mask((__v16si)__a, (__v16si)__b, 4,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epi64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epi64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_cmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_cmpneq_epu64_mask(__m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512f")))
_mm512_mask_cmpneq_epu64_mask(__mmask8 __u, __m512i __a, __m512i __b) {
  return (__mmask8)__builtin_ia32_ucmpq512_mask((__v8di)__a, (__v8di)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_cmpeq_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd128_mask((__v4si)__a, (__v4si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_mask_cmpeq_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd128_mask((__v4si)__a, (__v4si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpeq_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpeq_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 0,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_cmpeq_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd256_mask((__v8si)__a, (__v8si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_mask_cmpeq_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqd256_mask((__v8si)__a, (__v8si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpeq_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpeq_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 0,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_cmpeq_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq128_mask((__v2di)__a, (__v2di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_mask_cmpeq_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq128_mask((__v2di)__a, (__v2di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpeq_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpeq_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 0,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_cmpeq_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq256_mask((__v4di)__a, (__v4di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_mask_cmpeq_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqq256_mask((__v4di)__a, (__v4di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpeq_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpeq_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 0,
                                                __u);
}


static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpge_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpge_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpge_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpge_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 5,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_cmpgt_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd128_mask((__v4si)__a, (__v4si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_mask_cmpgt_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd128_mask((__v4si)__a, (__v4si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpgt_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpgt_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_cmpgt_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd256_mask((__v8si)__a, (__v8si)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_mask_cmpgt_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtd256_mask((__v8si)__a, (__v8si)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpgt_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpgt_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_cmpgt_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq128_mask((__v2di)__a, (__v2di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm_mask_cmpgt_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq128_mask((__v2di)__a, (__v2di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpgt_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpgt_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_cmpgt_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq256_mask((__v4di)__a, (__v4di)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl, avx512bw")))
_mm256_mask_cmpgt_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtq256_mask((__v4di)__a, (__v4di)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpgt_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpgt_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 6,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmple_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmple_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmple_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmple_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 2,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmplt_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmplt_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmplt_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmplt_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 1,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epi32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epi32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epu32_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epu32_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpd128_mask((__v4si)__a, (__v4si)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epi32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epi32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epu32_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epu32_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpd256_mask((__v8si)__a, (__v8si)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epi64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epi64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cmpneq_epu64_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cmpneq_epu64_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpq128_mask((__v2di)__a, (__v2di)__b, 4,
                                                __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epi64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epi64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_cmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cmpneq_epu64_mask(__m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cmpneq_epu64_mask(__mmask8 __u, __m256i __a, __m256i __b) {
  return (__mmask8)__builtin_ia32_ucmpq256_mask((__v4di)__a, (__v4di)__b, 4,
                                                __u);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_paddd256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddd256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_paddq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_psubd256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubd256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_psubq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_paddd128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddd128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_paddq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_psubd128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubd128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_psubq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
           __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuldq256_mask ((__v8si) __X,
              (__v8si) __Y,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_epi32 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuldq256_mask ((__v8si) __X,
              (__v8si) __Y,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_epi32 (__m128i __W, __mmask8 __M, __m128i __X,
        __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuldq128_mask ((__v4si) __X,
              (__v4si) __Y,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_epi32 (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuldq128_mask ((__v4si) __X,
              (__v4si) __Y,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_epu32 (__m256i __W, __mmask8 __M, __m256i __X,
           __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuludq256_mask ((__v8si) __X,
               (__v8si) __Y,
               (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_epu32 (__mmask8 __M, __m256i __X, __m256i __Y)
{
  return (__m256i) __builtin_ia32_pmuludq256_mask ((__v8si) __X,
               (__v8si) __Y,
               (__v4di)
               _mm256_setzero_si256 (),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_epu32 (__m128i __W, __mmask8 __M, __m128i __X,
        __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuludq128_mask ((__v4si) __X,
               (__v4si) __Y,
               (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_epu32 (__mmask8 __M, __m128i __X, __m128i __Y)
{
  return (__m128i) __builtin_ia32_pmuludq128_mask ((__v4si) __X,
               (__v4si) __Y,
               (__v2di)
               _mm_setzero_si128 (),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mullo_epi32 (__mmask8 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulld256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mullo_epi32 (__m256i __W, __mmask8 __M, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_pmulld256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mullo_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulld128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mullo_epi32 (__m128i __W, __mmask16 __M, __m128i __A,
          __m128i __B)
{
  return (__m128i) __builtin_ia32_pmulld128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_and_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pandd256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_and_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandd256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_and_epi32 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandd128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_and_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandd128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_andnot_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W,
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_andnot_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_andnot_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_andnot_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_or_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_pord256_mask ((__v8si) __A,
            (__v8si) __B,
            (__v8si) __W,
            (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_or_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pord256_mask ((__v8si) __A,
            (__v8si) __B,
            (__v8si)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_or_epi32 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pord128_mask ((__v4si) __A,
            (__v4si) __B,
            (__v4si) __W,
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_or_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pord128_mask ((__v4si) __A,
            (__v4si) __B,
            (__v4si)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_xor_epi32 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pxord256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_xor_epi32 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pxord256_mask ((__v8si) __A,
             (__v8si) __B,
             (__v8si)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_xor_epi32 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pxord128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_xor_epi32 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pxord128_mask ((__v4si) __A,
             (__v4si) __B,
             (__v4si)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_and_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pandq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di) __W, __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_and_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di)
             _mm256_setzero_pd (),
             __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_and_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pandq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di) __W, __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_and_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di)
             _mm_setzero_pd (),
             __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_andnot_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_andnot_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pandnq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_pd (),
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_andnot_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_andnot_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pandnq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_pd (),
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_or_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_porq256_mask ((__v4di) __A,
            (__v4di) __B,
            (__v4di) __W,
            (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_or_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_porq256_mask ((__v4di) __A,
            (__v4di) __B,
            (__v4di)
            _mm256_setzero_si256 (),
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_or_epi64 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_porq128_mask ((__v2di) __A,
            (__v2di) __B,
            (__v2di) __W,
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_or_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_porq128_mask ((__v2di) __A,
            (__v2di) __B,
            (__v2di)
            _mm_setzero_si128 (),
            (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_xor_epi64 (__m256i __W, __mmask8 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pxorq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_xor_epi64 (__mmask8 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pxorq256_mask ((__v4di) __A,
             (__v4di) __B,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_xor_epi64 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pxorq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_xor_epi64 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pxorq128_mask ((__v2di) __A,
             (__v2di) __B,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmadd_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask ((__v2df) __A,
                                                    (__v2df) __B,
                                                    (__v2df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmadd_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask3 ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmadd_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsub_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask ((__v2df) __A,
                                                    (__v2df) __B,
                                                    -(__v2df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsub_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz ((__v2df) __A,
                                                     (__v2df) __B,
                                                     -(__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmadd_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_mask3 (-(__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmadd_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz (-(__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmsub_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddpd128_maskz (-(__v2df) __A,
                                                     (__v2df) __B,
                                                     -(__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmadd_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask ((__v4df) __A,
                                                    (__v4df) __B,
                                                    (__v4df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmadd_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask3 ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmadd_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsub_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask ((__v4df) __A,
                                                    (__v4df) __B,
                                                    -(__v4df) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsub_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz ((__v4df) __A,
                                                     (__v4df) __B,
                                                     -(__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmadd_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_mask3 (-(__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmadd_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz (-(__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmsub_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddpd256_maskz (-(__v4df) __A,
                                                     (__v4df) __B,
                                                     -(__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmadd_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask ((__v4sf) __A,
                                                   (__v4sf) __B,
                                                   (__v4sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmadd_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask3 ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmadd_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsub_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask ((__v4sf) __A,
                                                   (__v4sf) __B,
                                                   -(__v4sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsub_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    -(__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmadd_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddps128_mask3 (-(__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmadd_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz (-(__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fnmsub_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddps128_maskz (-(__v4sf) __A,
                                                    (__v4sf) __B,
                                                    -(__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmadd_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask ((__v8sf) __A,
                                                   (__v8sf) __B,
                                                   (__v8sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmadd_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask3 ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmadd_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsub_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask ((__v8sf) __A,
                                                   (__v8sf) __B,
                                                   -(__v8sf) __C,
                                                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsub_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    -(__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmadd_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddps256_mask3 (-(__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmadd_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz (-(__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fnmsub_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddps256_maskz (-(__v8sf) __A,
                                                    (__v8sf) __B,
                                                    -(__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmaddsub_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask ((__v2df) __A,
                                                       (__v2df) __B,
                                                       (__v2df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmaddsub_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask3 ((__v2df) __A,
                                                        (__v2df) __B,
                                                        (__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmaddsub_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_maskz ((__v2df) __A,
                                                        (__v2df) __B,
                                                        (__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsubadd_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_mask ((__v2df) __A,
                                                       (__v2df) __B,
                                                       -(__v2df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsubadd_pd(__mmask8 __U, __m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfmaddsubpd128_maskz ((__v2df) __A,
                                                        (__v2df) __B,
                                                        -(__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmaddsub_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask ((__v4df) __A,
                                                       (__v4df) __B,
                                                       (__v4df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmaddsub_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask3 ((__v4df) __A,
                                                        (__v4df) __B,
                                                        (__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmaddsub_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_maskz ((__v4df) __A,
                                                        (__v4df) __B,
                                                        (__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsubadd_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_mask ((__v4df) __A,
                                                       (__v4df) __B,
                                                       -(__v4df) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsubadd_pd(__mmask8 __U, __m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfmaddsubpd256_maskz ((__v4df) __A,
                                                        (__v4df) __B,
                                                        -(__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmaddsub_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask ((__v4sf) __A,
                                                      (__v4sf) __B,
                                                      (__v4sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmaddsub_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask3 ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       (__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmaddsub_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_maskz ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       (__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fmsubadd_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_mask ((__v4sf) __A,
                                                      (__v4sf) __B,
                                                      -(__v4sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_fmsubadd_ps(__mmask8 __U, __m128 __A, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfmaddsubps128_maskz ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       -(__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmaddsub_ps(__m256 __A, __mmask8 __U, __m256 __B,
                         __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask ((__v8sf) __A,
                                                      (__v8sf) __B,
                                                      (__v8sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmaddsub_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask3 ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       (__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmaddsub_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_maskz ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       (__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fmsubadd_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_mask ((__v8sf) __A,
                                                      (__v8sf) __B,
                                                      -(__v8sf) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_fmsubadd_ps(__mmask8 __U, __m256 __A, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfmaddsubps256_maskz ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       -(__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsub_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubpd128_mask3 ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsub_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmsubpd256_mask3 ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsub_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubps128_mask3 ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsub_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmsubps256_mask3 ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsubadd_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfmsubaddpd128_mask3 ((__v2df) __A,
                                                        (__v2df) __B,
                                                        (__v2df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsubadd_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfmsubaddpd256_mask3 ((__v4df) __A,
                                                        (__v4df) __B,
                                                        (__v4df) __C,
                                                        (__mmask8)
                                                        __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fmsubadd_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfmsubaddps128_mask3 ((__v4sf) __A,
                                                       (__v4sf) __B,
                                                       (__v4sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fmsubadd_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfmsubaddps256_mask3 ((__v8sf) __A,
                                                       (__v8sf) __B,
                                                       (__v8sf) __C,
                                                       (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmadd_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmaddpd128_mask ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmadd_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmaddpd256_mask ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmadd_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmaddps128_mask ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmadd_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmaddps256_mask ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmsub_pd(__m128d __A, __mmask8 __U, __m128d __B, __m128d __C)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_mask ((__v2df) __A,
                                                     (__v2df) __B,
                                                     (__v2df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmsub_pd(__m128d __A, __m128d __B, __m128d __C, __mmask8 __U)
{
  return (__m128d) __builtin_ia32_vfnmsubpd128_mask3 ((__v2df) __A,
                                                      (__v2df) __B,
                                                      (__v2df) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmsub_pd(__m256d __A, __mmask8 __U, __m256d __B, __m256d __C)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_mask ((__v4df) __A,
                                                     (__v4df) __B,
                                                     (__v4df) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmsub_pd(__m256d __A, __m256d __B, __m256d __C, __mmask8 __U)
{
  return (__m256d) __builtin_ia32_vfnmsubpd256_mask3 ((__v4df) __A,
                                                      (__v4df) __B,
                                                      (__v4df) __C,
                                                      (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_fnmsub_ps(__m128 __A, __mmask8 __U, __m128 __B, __m128 __C)
{
  return (__m128) __builtin_ia32_vfnmsubps128_mask ((__v4sf) __A,
                                                    (__v4sf) __B,
                                                    (__v4sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask3_fnmsub_ps(__m128 __A, __m128 __B, __m128 __C, __mmask8 __U)
{
  return (__m128) __builtin_ia32_vfnmsubps128_mask3 ((__v4sf) __A,
                                                     (__v4sf) __B,
                                                     (__v4sf) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_fnmsub_ps(__m256 __A, __mmask8 __U, __m256 __B, __m256 __C)
{
  return (__m256) __builtin_ia32_vfnmsubps256_mask ((__v8sf) __A,
                                                    (__v8sf) __B,
                                                    (__v8sf) __C,
                                                    (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask3_fnmsub_ps(__m256 __A, __m256 __B, __m256 __C, __mmask8 __U)
{
  return (__m256) __builtin_ia32_vfnmsubps256_mask3 ((__v8sf) __A,
                                                     (__v8sf) __B,
                                                     (__v8sf) __C,
                                                     (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_addpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df) __W,
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_addpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df)
             _mm_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_pd (__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_addpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_addpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_add_ps (__m128 __W, __mmask16 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_addps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf) __W,
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_add_ps (__mmask16 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_addps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_add_ps (__m256 __W, __mmask16 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_addps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_add_ps (__mmask16 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_addps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_epi32 (__mmask8 __U, __m128i __A, __m128i __W) {
  return (__m128i) __builtin_ia32_blendmd_128_mask ((__v4si) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_epi32 (__mmask8 __U, __m256i __A, __m256i __W) {
  return (__m256i) __builtin_ia32_blendmd_256_mask ((__v8si) __A,
                (__v8si) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_pd (__mmask8 __U, __m128d __A, __m128d __W) {
  return (__m128d) __builtin_ia32_blendmpd_128_mask ((__v2df) __A,
                 (__v2df) __W,
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_pd (__mmask8 __U, __m256d __A, __m256d __W) {
  return (__m256d) __builtin_ia32_blendmpd_256_mask ((__v4df) __A,
                 (__v4df) __W,
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_ps (__mmask8 __U, __m128 __A, __m128 __W) {
  return (__m128) __builtin_ia32_blendmps_128_mask ((__v4sf) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_ps (__mmask8 __U, __m256 __A, __m256 __W) {
  return (__m256) __builtin_ia32_blendmps_256_mask ((__v8sf) __A,
                (__v8sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_blend_epi64 (__mmask8 __U, __m128i __A, __m128i __W) {
  return (__m128i) __builtin_ia32_blendmq_128_mask ((__v2di) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_blend_epi64 (__mmask8 __U, __m256i __A, __m256i __W) {
  return (__m256i) __builtin_ia32_blendmq_256_mask ((__v4di) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_compressdf128_mask ((__v2df) __A,
                  (__v2df) __W,
                  (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_compressdf128_mask ((__v2df) __A,
                  (__v2df)
                  _mm_setzero_pd (),
                  (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_compressdf256_mask ((__v4df) __A,
                  (__v4df) __W,
                  (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_compressdf256_mask ((__v4df) __A,
                  (__v4df)
                  _mm256_setzero_pd (),
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_epi64 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compressdi128_mask ((__v2di) __A,
                  (__v2di) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_epi64 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compressdi128_mask ((__v2di) __A,
                  (__v2di)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_epi64 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compressdi256_mask ((__v4di) __A,
                  (__v4di) __W,
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_epi64 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compressdi256_mask ((__v4di) __A,
                  (__v4di)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_compresssf128_mask ((__v4sf) __A,
                 (__v4sf) __W,
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_compresssf128_mask ((__v4sf) __A,
                 (__v4sf)
                 _mm_setzero_ps (),
                 (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_compresssf256_mask ((__v8sf) __A,
                 (__v8sf) __W,
                 (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_compresssf256_mask ((__v8sf) __A,
                 (__v8sf)
                 _mm256_setzero_ps (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compress_epi32 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compresssi128_mask ((__v4si) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_compress_epi32 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_compresssi128_mask ((__v4si) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compress_epi32 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compresssi256_mask ((__v8si) __A,
                  (__v8si) __W,
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_compress_epi32 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_compresssi256_mask ((__v8si) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m128d __A) {
  __builtin_ia32_compressstoredf128_mask ((__v2df *) __P,
            (__v2df) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_pd (void *__P, __mmask8 __U, __m256d __A) {
  __builtin_ia32_compressstoredf256_mask ((__v4df *) __P,
            (__v4df) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m128i __A) {
  __builtin_ia32_compressstoredi128_mask ((__v2di *) __P,
            (__v2di) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_epi64 (void *__P, __mmask8 __U, __m256i __A) {
  __builtin_ia32_compressstoredi256_mask ((__v4di *) __P,
            (__v4di) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_ps (void *__P, __mmask8 __U, __m128 __A) {
  __builtin_ia32_compressstoresf128_mask ((__v4sf *) __P,
            (__v4sf) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_ps (void *__P, __mmask8 __U, __m256 __A) {
  __builtin_ia32_compressstoresf256_mask ((__v8sf *) __P,
            (__v8sf) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_compressstoreu_epi32 (void *__P, __mmask8 __U, __m128i __A) {
  __builtin_ia32_compressstoresi128_mask ((__v4si *) __P,
            (__v4si) __A,
            (__mmask8) __U);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_compressstoreu_epi32 (void *__P, __mmask8 __U, __m256i __A) {
  __builtin_ia32_compressstoresi256_mask ((__v8si *) __P,
            (__v8si) __A,
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtdq2pd128_mask ((__v4si) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_pd (__mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtdq2pd128_mask ((__v4si) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_pd (__m256d __W, __mmask8 __U, __m128i __A) {
  return (__m256d) __builtin_ia32_cvtdq2pd256_mask ((__v4si) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_pd (__mmask8 __U, __m128i __A) {
  return (__m256d) __builtin_ia32_cvtdq2pd256_mask ((__v4si) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepi32_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtdq2ps128_mask ((__v4si) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepi32_ps (__mmask16 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtdq2ps128_mask ((__v4si) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepi32_ps (__m256 __W, __mmask8 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtdq2ps256_mask ((__v8si) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepi32_ps (__mmask16 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtdq2ps256_mask ((__v8si) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtpd_epi32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq128_mask ((__v2df) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtpd_epi32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq128_mask ((__v2df) __A,
                (__v4si)
                _mm_setzero_si128 (),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtpd_epi32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq256_mask ((__v4df) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtpd_epi32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2dq256_mask ((__v4df) __A,
                (__v4si)
                _mm_setzero_si128 (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtpd_ps (__m128 __W, __mmask8 __U, __m128d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps_mask ((__v2df) __A,
            (__v4sf) __W,
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtpd_ps (__mmask8 __U, __m128d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps_mask ((__v2df) __A,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtpd_ps (__m128 __W, __mmask8 __U, __m256d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps256_mask ((__v4df) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtpd_ps (__mmask8 __U, __m256d __A) {
  return (__m128) __builtin_ia32_cvtpd2ps256_mask ((__v4df) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtpd_epu32 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtpd_epu32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtpd_epu32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq128_mask ((__v2df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtpd_epu32 (__m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtpd_epu32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtpd_epu32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvtpd2udq256_mask ((__v4df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_epi32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2dq128_mask ((__v4sf) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_epi32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2dq128_mask ((__v4sf) __A,
                (__v4si)
                _mm_setzero_si128 (),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_epi32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2dq256_mask ((__v8sf) __A,
                (__v8si) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_epi32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2dq256_mask ((__v8sf) __A,
                (__v8si)
                _mm256_setzero_si256 (),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_pd (__m128d __W, __mmask8 __U, __m128 __A) {
  return (__m128d) __builtin_ia32_cvtps2pd128_mask ((__v4sf) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_pd (__mmask8 __U, __m128 __A) {
  return (__m128d) __builtin_ia32_cvtps2pd128_mask ((__v4sf) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_pd (__m256d __W, __mmask8 __U, __m128 __A) {
  return (__m256d) __builtin_ia32_cvtps2pd256_mask ((__v4sf) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_pd (__mmask8 __U, __m128 __A) {
  return (__m256d) __builtin_ia32_cvtps2pd256_mask ((__v4sf) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtps_epu32 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtps_epu32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtps_epu32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2udq128_mask ((__v4sf) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtps_epu32 (__m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtps_epu32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
                 (__v8si) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtps_epu32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvtps2udq256_mask ((__v8sf) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttpd_epi32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq128_mask ((__v2df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttpd_epi32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq128_mask ((__v2df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttpd_epi32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq256_mask ((__v4df) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttpd_epi32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2dq256_mask ((__v4df) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvttpd_epu32 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttpd_epu32 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttpd_epu32 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq128_mask ((__v2df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvttpd_epu32 (__m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttpd_epu32 (__m128i __W, __mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttpd_epu32 (__mmask8 __U, __m256d __A) {
  return (__m128i) __builtin_ia32_cvttpd2udq256_mask ((__v4df) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttps_epi32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2dq128_mask ((__v4sf) __A,
                 (__v4si) __W,
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttps_epi32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2dq128_mask ((__v4sf) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttps_epi32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2dq256_mask ((__v8sf) __A,
                 (__v8si) __W,
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttps_epi32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2dq256_mask ((__v8sf) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvttps_epu32 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvttps_epu32 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
                  (__v4si) __W,
                  (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvttps_epu32 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2udq128_mask ((__v4sf) __A,
                  (__v4si)
                  _mm_setzero_si128 (),
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvttps_epu32 (__m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvttps_epu32 (__m256i __W, __mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
                  (__v8si) __W,
                  (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvttps_epu32 (__mmask8 __U, __m256 __A) {
  return (__m256i) __builtin_ia32_cvttps2udq256_mask ((__v8sf) __A,
                  (__v8si)
                  _mm256_setzero_si256 (),
                  (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepu32_pd (__m128i __A) {
  return (__m128d) __builtin_ia32_cvtudq2pd128_mask ((__v4si) __A,
                 (__v2df)
                 _mm_setzero_pd (),
                 (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu32_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtudq2pd128_mask ((__v4si) __A,
                 (__v2df) __W,
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu32_pd (__mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtudq2pd128_mask ((__v4si) __A,
                 (__v2df)
                 _mm_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepu32_pd (__m128i __A) {
  return (__m256d) __builtin_ia32_cvtudq2pd256_mask ((__v4si) __A,
                 (__v4df)
                 _mm256_setzero_pd (),
                 (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu32_pd (__m256d __W, __mmask8 __U, __m128i __A) {
  return (__m256d) __builtin_ia32_cvtudq2pd256_mask ((__v4si) __A,
                 (__v4df) __W,
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu32_pd (__mmask8 __U, __m128i __A) {
  return (__m256d) __builtin_ia32_cvtudq2pd256_mask ((__v4si) __A,
                 (__v4df)
                 _mm256_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_cvtepu32_ps (__m128i __A) {
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_cvtepu32_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_cvtepu32_ps (__mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtudq2ps128_mask ((__v4si) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_cvtepu32_ps (__m256i __A) {
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_cvtepu32_ps (__m256 __W, __mmask8 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
                (__v8sf) __W,
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_cvtepu32_ps (__mmask8 __U, __m256i __A) {
  return (__m256) __builtin_ia32_cvtudq2ps256_mask ((__v8si) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_div_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_divpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_div_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_divpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_div_pd (__m256d __W, __mmask8 __U, __m256d __A,
        __m256d __B) {
  return (__m256d) __builtin_ia32_divpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_div_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_divpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_div_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_divps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_div_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_divps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_div_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_divps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_div_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_divps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_expanddf128_mask ((__v2df) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_expanddf128_mask ((__v2df) __A,
                 (__v2df)
                 _mm_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_expanddf256_mask ((__v4df) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_expanddf256_mask ((__v4df) __A,
                 (__v4df)
                 _mm256_setzero_pd (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_epi64 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expanddi128_mask ((__v2di) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_epi64 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expanddi128_mask ((__v2di) __A,
                 (__v2di)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_epi64 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expanddi256_mask ((__v4di) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_epi64 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expanddi256_mask ((__v4di) __A,
                 (__v4di)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_pd (__m128d __W, __mmask8 __U, void const *__P) {
  return (__m128d) __builtin_ia32_expandloaddf128_mask ((__v2df *) __P,
              (__v2df) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_pd (__mmask8 __U, void const *__P) {
  return (__m128d) __builtin_ia32_expandloaddf128_mask ((__v2df *) __P,
               (__v2df)
               _mm_setzero_pd (),
               (__mmask8)
               __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_pd (__m256d __W, __mmask8 __U, void const *__P) {
  return (__m256d) __builtin_ia32_expandloaddf256_mask ((__v4df *) __P,
              (__v4df) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_pd (__mmask8 __U, void const *__P) {
  return (__m256d) __builtin_ia32_expandloaddf256_mask ((__v4df *) __P,
               (__v4df)
               _mm256_setzero_pd (),
               (__mmask8)
               __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_epi64 (__m128i __W, __mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloaddi128_mask ((__v2di *) __P,
              (__v2di) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloaddi128_mask ((__v2di *) __P,
               (__v2di)
               _mm_setzero_si128 (),
               (__mmask8)
               __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_epi64 (__m256i __W, __mmask8 __U,
             void const *__P) {
  return (__m256i) __builtin_ia32_expandloaddi256_mask ((__v4di *) __P,
              (__v4di) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_epi64 (__mmask8 __U, void const *__P) {
  return (__m256i) __builtin_ia32_expandloaddi256_mask ((__v4di *) __P,
               (__v4di)
               _mm256_setzero_si256 (),
               (__mmask8)
               __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_ps (__m128 __W, __mmask8 __U, void const *__P) {
  return (__m128) __builtin_ia32_expandloadsf128_mask ((__v4sf *) __P,
                   (__v4sf) __W,
                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_ps (__mmask8 __U, void const *__P) {
  return (__m128) __builtin_ia32_expandloadsf128_mask ((__v4sf *) __P,
              (__v4sf)
              _mm_setzero_ps (),
              (__mmask8)
              __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_ps (__m256 __W, __mmask8 __U, void const *__P) {
  return (__m256) __builtin_ia32_expandloadsf256_mask ((__v8sf *) __P,
                   (__v8sf) __W,
                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_ps (__mmask8 __U, void const *__P) {
  return (__m256) __builtin_ia32_expandloadsf256_mask ((__v8sf *) __P,
              (__v8sf)
              _mm256_setzero_ps (),
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expandloadu_epi32 (__m128i __W, __mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloadsi128_mask ((__v4si *) __P,
              (__v4si) __W,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expandloadu_epi32 (__mmask8 __U, void const *__P) {
  return (__m128i) __builtin_ia32_expandloadsi128_mask ((__v4si *) __P,
               (__v4si)
               _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expandloadu_epi32 (__m256i __W, __mmask8 __U,
             void const *__P) {
  return (__m256i) __builtin_ia32_expandloadsi256_mask ((__v8si *) __P,
              (__v8si) __W,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expandloadu_epi32 (__mmask8 __U, void const *__P) {
  return (__m256i) __builtin_ia32_expandloadsi256_mask ((__v8si *) __P,
               (__v8si)
               _mm256_setzero_si256 (),
               (__mmask8)
               __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_expandsf128_mask ((__v4sf) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_expandsf128_mask ((__v4sf) __A,
                (__v4sf)
                _mm_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_expandsf256_mask ((__v8sf) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_expandsf256_mask ((__v8sf) __A,
                (__v8sf)
                _mm256_setzero_ps (),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_expand_epi32 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expandsi128_mask ((__v4si) __A,
                (__v4si) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_expand_epi32 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_expandsi128_mask ((__v4si) __A,
                 (__v4si)
                 _mm_setzero_si128 (),
                 (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_expand_epi32 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expandsi256_mask ((__v8si) __A,
                (__v8si) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_expand_epi32 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_expandsi256_mask ((__v8si) __A,
                 (__v8si)
                 _mm256_setzero_si256 (),
                 (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_getexp_pd (__m128d __A) {
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_getexp_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_getexp_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_getexppd128_mask ((__v2df) __A,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_getexp_pd (__m256d __A) {
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_getexp_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_getexp_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_getexppd256_mask ((__v4df) __A,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_getexp_ps (__m128 __A) {
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_getexp_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_getexp_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_getexpps128_mask ((__v4sf) __A,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_getexp_ps (__m256 __A) {
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_getexp_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_getexp_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_getexpps256_mask ((__v8sf) __A,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_maxpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_maxpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_pd (__m256d __W, __mmask8 __U, __m256d __A,
        __m256d __B) {
  return (__m256d) __builtin_ia32_maxpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_maxpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_maxps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_maxps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_maxps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_maxps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_minpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_minpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_pd (__m256d __W, __mmask8 __U, __m256d __A,
        __m256d __B) {
  return (__m256d) __builtin_ia32_minpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_minpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_minps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_minps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_minps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_minps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_mulpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_mulpd_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_pd (__m256d __W, __mmask8 __U, __m256d __A,
        __m256d __B) {
  return (__m256d) __builtin_ia32_mulpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_mulpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_mul_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_mulps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_mul_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_mulps_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_mul_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_mulps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_mul_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_mulps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_abs_epi32 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_pabsd128_mask ((__v4si) __A,
             (__v4si) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_abs_epi32 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_pabsd128_mask ((__v4si) __A,
             (__v4si)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_abs_epi32 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_pabsd256_mask ((__v8si) __A,
             (__v8si) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_abs_epi32 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_pabsd256_mask ((__v8si) __A,
             (__v8si)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_abs_epi64 (__m128i __A) {
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_abs_epi64 (__m128i __W, __mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
             (__v2di) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_abs_epi64 (__mmask8 __U, __m128i __A) {
  return (__m128i) __builtin_ia32_pabsq128_mask ((__v2di) __A,
             (__v2di)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_abs_epi64 (__m256i __A) {
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_abs_epi64 (__m256i __W, __mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
             (__v4di) __W,
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_abs_epi64 (__mmask8 __U, __m256i __A) {
  return (__m256i) __builtin_ia32_pabsq256_mask ((__v4di) __A,
             (__v4di)
             _mm256_setzero_si256 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epi32 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epi32 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epi32 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epi64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epi64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_max_epi64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epi64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epi64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_max_epi64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epu32 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxud128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epu32 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxud128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epu32 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxud256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epu32 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxud256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_max_epu64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_max_epu64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_max_epu64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pmaxuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_max_epu64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_max_epu64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_max_epu64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pmaxuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epi32 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminsd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epi32 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pminsd128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epi32 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminsd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epi32 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pminsd256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_min_epi64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epi64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epi64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminsq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_min_epi64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epi64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epi64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminsq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epu32 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminud128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epu32 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pminud128_mask ((__v4si) __A,
              (__v4si) __B,
              (__v4si) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epu32 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminud256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si)
              _mm256_setzero_si256 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epu32 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pminud256_mask ((__v8si) __A,
              (__v8si) __B,
              (__v8si) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_min_epu64 (__m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_min_epu64 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B) {
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_min_epu64 (__mmask8 __M, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pminuq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_min_epu64 (__m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_min_epu64 (__m256i __W, __mmask8 __M, __m256i __A,
           __m256i __B) {
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_min_epu64 (__mmask8 __M, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pminuq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              __M);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_scalef_pd (__m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_scalef_pd (__m128d __W, __mmask8 __U, __m128d __A,
        __m128d __B) {
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_scalef_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_scalefpd128_mask ((__v2df) __A,
                (__v2df) __B,
                (__v2df)
                _mm_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_scalef_pd (__m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
                (__v4df) __B,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_scalef_pd (__m256d __W, __mmask8 __U, __m256d __A,
           __m256d __B) {
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
                (__v4df) __B,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_scalef_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_scalefpd256_mask ((__v4df) __A,
                (__v4df) __B,
                (__v4df)
                _mm256_setzero_pd (),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_scalef_ps (__m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_scalef_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf) __W,
               (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_scalef_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_scalefps128_mask ((__v4sf) __A,
               (__v4sf) __B,
               (__v4sf)
               _mm_setzero_ps (),
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_scalef_ps (__m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
               (__v8sf) __B,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_scalef_ps (__m256 __W, __mmask8 __U, __m256 __A,
           __m256 __B) {
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
               (__v8sf) __B,
               (__v8sf) __W,
               (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_scalef_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_scalefps256_mask ((__v8sf) __A,
               (__v8sf) __B,
               (__v8sf)
               _mm256_setzero_ps (),
               (__mmask8) __U);
}
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sqrt_pd (__m128d __W, __mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_sqrtpd128_mask ((__v2df) __A,
              (__v2df) __W,
              (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sqrt_pd (__mmask8 __U, __m128d __A) {
  return (__m128d) __builtin_ia32_sqrtpd128_mask ((__v2df) __A,
              (__v2df)
              _mm_setzero_pd (),
              (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sqrt_pd (__m256d __W, __mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_sqrtpd256_mask ((__v4df) __A,
              (__v4df) __W,
              (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sqrt_pd (__mmask8 __U, __m256d __A) {
  return (__m256d) __builtin_ia32_sqrtpd256_mask ((__v4df) __A,
              (__v4df)
              _mm256_setzero_pd (),
              (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sqrt_ps (__m128 __W, __mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_sqrtps128_mask ((__v4sf) __A,
             (__v4sf) __W,
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sqrt_ps (__mmask8 __U, __m128 __A) {
  return (__m128) __builtin_ia32_sqrtps128_mask ((__v4sf) __A,
             (__v4sf)
             _mm_setzero_ps (),
             (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sqrt_ps (__m256 __W, __mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_sqrtps256_mask ((__v8sf) __A,
             (__v8sf) __W,
             (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sqrt_ps (__mmask8 __U, __m256 __A) {
  return (__m256) __builtin_ia32_sqrtps256_mask ((__v8sf) __A,
             (__v8sf)
             _mm256_setzero_ps (),
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_subpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df) __W,
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_subpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df)
             _mm_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_pd (__m256d __W, __mmask8 __U, __m256d __A,
        __m256d __B) {
  return (__m256d) __builtin_ia32_subpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_subpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_sub_ps (__m128 __W, __mmask16 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_subps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf) __W,
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_sub_ps (__mmask16 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_subps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_sub_ps (__m256 __W, __mmask16 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_subps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_sub_ps (__mmask16 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_subps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_epi32 (__m128i __A, __m128i __I, __mmask8 __U,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermi2vard128_mask ((__v4si) __A,
                   (__v4si) __I
                             ,
                   (__v4si) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_epi32 (__m256i __A, __m256i __I,
         __mmask8 __U, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermi2vard256_mask ((__v8si) __A,
                   (__v8si) __I
                             ,
                   (__v8si) __B,
                   (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_pd (__m128d __A, __m128i __I, __mmask8 __U,
         __m128d __B) {
  return (__m128d) __builtin_ia32_vpermi2varpd128_mask ((__v2df) __A,
              (__v2di) __I
                        ,
              (__v2df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_pd (__m256d __A, __m256i __I, __mmask8 __U,
            __m256d __B) {
  return (__m256d) __builtin_ia32_vpermi2varpd256_mask ((__v4df) __A,
              (__v4di) __I
                        ,
              (__v4df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_ps (__m128 __A, __m128i __I, __mmask8 __U,
         __m128 __B) {
  return (__m128) __builtin_ia32_vpermi2varps128_mask ((__v4sf) __A,
                   (__v4si) __I
                             ,
                   (__v4sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_ps (__m256 __A, __m256i __I, __mmask8 __U,
            __m256 __B) {
  return (__m256) __builtin_ia32_vpermi2varps256_mask ((__v8sf) __A,
                   (__v8si) __I
                             ,
                   (__v8sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask2_permutex2var_epi64 (__m128i __A, __m128i __I, __mmask8 __U,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermi2varq128_mask ((__v2di) __A,
                   (__v2di) __I
                             ,
                   (__v2di) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask2_permutex2var_epi64 (__m256i __A, __m256i __I,
         __mmask8 __U, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermi2varq256_mask ((__v4di) __A,
                   (__v4di) __I
                             ,
                   (__v4di) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_epi32 (__m128i __A, __m128i __I, __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2vard128_mask ((__v4si) __I
                             ,
                   (__v4si) __A,
                   (__v4si) __B,
                   (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_epi32 (__m128i __A, __mmask8 __U, __m128i __I,
           __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2vard128_mask ((__v4si) __I
                             ,
                   (__v4si) __A,
                   (__v4si) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_epi32 (__mmask8 __U, __m128i __A, __m128i __I,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2vard128_maskz ((__v4si) __I
                        ,
              (__v4si) __A,
              (__v4si) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_epi32 (__m256i __A, __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2vard256_mask ((__v8si) __I
                             ,
                   (__v8si) __A,
                   (__v8si) __B,
                   (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_epi32 (__m256i __A, __mmask8 __U, __m256i __I,
        __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2vard256_mask ((__v8si) __I
                             ,
                   (__v8si) __A,
                   (__v8si) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_epi32 (__mmask8 __U, __m256i __A,
         __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2vard256_maskz ((__v8si) __I
                        ,
              (__v8si) __A,
              (__v8si) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_pd (__m128d __A, __m128i __I, __m128d __B) {
  return (__m128d) __builtin_ia32_vpermt2varpd128_mask ((__v2di) __I
                        ,
              (__v2df) __A,
              (__v2df) __B,
              (__mmask8) -
              1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_pd (__m128d __A, __mmask8 __U, __m128i __I,
        __m128d __B) {
  return (__m128d) __builtin_ia32_vpermt2varpd128_mask ((__v2di) __I
                        ,
              (__v2df) __A,
              (__v2df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_pd (__mmask8 __U, __m128d __A, __m128i __I,
         __m128d __B) {
  return (__m128d) __builtin_ia32_vpermt2varpd128_maskz ((__v2di) __I
                         ,
               (__v2df) __A,
               (__v2df) __B,
               (__mmask8)
               __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_pd (__m256d __A, __m256i __I, __m256d __B) {
  return (__m256d) __builtin_ia32_vpermt2varpd256_mask ((__v4di) __I
                        ,
              (__v4df) __A,
              (__v4df) __B,
              (__mmask8) -
              1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_pd (__m256d __A, __mmask8 __U, __m256i __I,
           __m256d __B) {
  return (__m256d) __builtin_ia32_vpermt2varpd256_mask ((__v4di) __I
                        ,
              (__v4df) __A,
              (__v4df) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_pd (__mmask8 __U, __m256d __A, __m256i __I,
            __m256d __B) {
  return (__m256d) __builtin_ia32_vpermt2varpd256_maskz ((__v4di) __I
                         ,
               (__v4df) __A,
               (__v4df) __B,
               (__mmask8)
               __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_ps (__m128 __A, __m128i __I, __m128 __B) {
  return (__m128) __builtin_ia32_vpermt2varps128_mask ((__v4si) __I
                             ,
                   (__v4sf) __A,
                   (__v4sf) __B,
                   (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_ps (__m128 __A, __mmask8 __U, __m128i __I,
        __m128 __B) {
  return (__m128) __builtin_ia32_vpermt2varps128_mask ((__v4si) __I
                             ,
                   (__v4sf) __A,
                   (__v4sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_ps (__mmask8 __U, __m128 __A, __m128i __I,
         __m128 __B) {
  return (__m128) __builtin_ia32_vpermt2varps128_maskz ((__v4si) __I
                        ,
              (__v4sf) __A,
              (__v4sf) __B,
              (__mmask8)
              __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_ps (__m256 __A, __m256i __I, __m256 __B) {
  return (__m256) __builtin_ia32_vpermt2varps256_mask ((__v8si) __I
                             ,
                   (__v8sf) __A,
                   (__v8sf) __B,
                   (__mmask8) -1);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_ps (__m256 __A, __mmask8 __U, __m256i __I,
           __m256 __B) {
  return (__m256) __builtin_ia32_vpermt2varps256_mask ((__v8si) __I
                             ,
                   (__v8sf) __A,
                   (__v8sf) __B,
                   (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_ps (__mmask8 __U, __m256 __A, __m256i __I,
            __m256 __B) {
  return (__m256) __builtin_ia32_vpermt2varps256_maskz ((__v8si) __I
                        ,
              (__v8sf) __A,
              (__v8sf) __B,
              (__mmask8)
              __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_permutex2var_epi64 (__m128i __A, __m128i __I, __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2varq128_mask ((__v2di) __I
                             ,
                   (__v2di) __A,
                   (__v2di) __B,
                   (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_mask_permutex2var_epi64 (__m128i __A, __mmask8 __U, __m128i __I,
           __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2varq128_mask ((__v2di) __I
                             ,
                   (__v2di) __A,
                   (__v2di) __B,
                   (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm_maskz_permutex2var_epi64 (__mmask8 __U, __m128i __A, __m128i __I,
            __m128i __B) {
  return (__m128i) __builtin_ia32_vpermt2varq128_maskz ((__v2di) __I
                        ,
              (__v2di) __A,
              (__v2di) __B,
              (__mmask8)
              __U);
}


static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_permutex2var_epi64 (__m256i __A, __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2varq256_mask ((__v4di) __I
                             ,
                   (__v4di) __A,
                   (__v4di) __B,
                   (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_mask_permutex2var_epi64 (__m256i __A, __mmask8 __U, __m256i __I,
        __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2varq256_mask ((__v4di) __I
                             ,
                   (__v4di) __A,
                   (__v4di) __B,
                   (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl")))
_mm256_maskz_permutex2var_epi64 (__mmask8 __U, __m256i __A,
         __m256i __I, __m256i __B) {
  return (__m256i) __builtin_ia32_vpermt2varq256_maskz ((__v4di) __I
                        ,
              (__v4di) __A,
              (__v4di) __B,
              (__mmask8)
              __U);
}

typedef unsigned int __mmask32;
typedef unsigned long long __mmask64;
typedef char __v64qi __attribute__ ((__vector_size__ (64)));
typedef short __v32hi __attribute__ ((__vector_size__ (64)));




static __inline __v64qi __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_setzero_qi(void) {
  return (__v64qi){ 0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0 };
}

static __inline __v32hi __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_setzero_hi(void) {
  return (__v32hi){ 0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0,
                       0, 0, 0, 0, 0, 0, 0, 0 };
}



static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpeqb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpeqb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 0,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 0,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpeq_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 0,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpeq_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 0,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 5,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpge_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpge_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 5,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpgtb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_pcmpgtb512_mask((__v64qi)__a, (__v64qi)__b,
                                                   __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 6,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 6,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtw512_mask((__v32hi)__a, (__v32hi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpgt_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 6,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpgt_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 6,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 2,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmple_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmple_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 2,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 1,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmplt_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmplt_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 1,
                                                 __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epi8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epi8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_cmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                __u);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epu8_mask(__m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                 (__mmask64)-1);
}

static __inline__ __mmask64 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epu8_mask(__mmask64 __u, __m512i __a, __m512i __b) {
  return (__mmask64)__builtin_ia32_ucmpb512_mask((__v64qi)__a, (__v64qi)__b, 4,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epi16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epi16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_cmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cmpneq_epu16_mask(__m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cmpneq_epu16_mask(__mmask32 __u, __m512i __a, __m512i __b) {
  return (__mmask32)__builtin_ia32_ucmpw512_mask((__v32hi)__a, (__v32hi)__b, 4,
                                                 __u);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_add_epi8 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v64qi) __A + (__v64qi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_add_epi8 (__m512i __W, __mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_paddb512_mask ((__v64qi) __A,
             (__v64qi) __B,
             (__v64qi) __W,
             (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_add_epi8 (__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_paddb512_mask ((__v64qi) __A,
             (__v64qi) __B,
             (__v64qi) _mm512_setzero_qi(),
             (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sub_epi8 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v64qi) __A - (__v64qi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sub_epi8 (__m512i __W, __mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_psubb512_mask ((__v64qi) __A,
             (__v64qi) __B,
             (__v64qi) __W,
             (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sub_epi8 (__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_psubb512_mask ((__v64qi) __A,
             (__v64qi) __B,
             (__v64qi) _mm512_setzero_qi(),
             (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_add_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v32hi) __A + (__v32hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_add_epi16 (__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_paddw512_mask ((__v32hi) __A,
             (__v32hi) __B,
             (__v32hi) __W,
             (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_add_epi16 (__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_paddw512_mask ((__v32hi) __A,
             (__v32hi) __B,
             (__v32hi) _mm512_setzero_hi(),
             (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_sub_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v32hi) __A - (__v32hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_sub_epi16 (__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_psubw512_mask ((__v32hi) __A,
             (__v32hi) __B,
             (__v32hi) __W,
             (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_sub_epi16 (__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_psubw512_mask ((__v32hi) __A,
             (__v32hi) __B,
             (__v32hi) _mm512_setzero_hi(),
             (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mullo_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v32hi) __A * (__v32hi) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mullo_epi16 (__m512i __W, __mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmullw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mullo_epi16 (__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmullw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_blend_epi8 (__mmask64 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_blendmb_512_mask ((__v64qi) __A,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_blend_epi16 (__mmask32 __U, __m512i __A, __m512i __W)
{
  return (__m512i) __builtin_ia32_blendmw_512_mask ((__v32hi) __A,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_abs_epi8 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_abs_epi8 (__m512i __W, __mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_abs_epi8 (__mmask64 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsb512_mask ((__v64qi) __A,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_abs_epi16 (__m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_abs_epi16 (__m512i __W, __mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_abs_epi16 (__mmask32 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_pabsw512_mask ((__v32hi) __A,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packs_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packssdw512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packs_epi32 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packssdw512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v32hi) _mm512_setzero_hi(),
              __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packs_epi32 (__m512i __W, __mmask32 __M, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_packssdw512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v32hi) __W,
              __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packsswb512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packs_epi16 (__m512i __W, __mmask64 __M, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_packsswb512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packs_epi16 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packsswb512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v64qi) _mm512_setzero_qi(),
              __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packus_epi32 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packusdw512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packus_epi32 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packusdw512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v32hi) _mm512_setzero_hi(),
              __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packus_epi32 (__m512i __W, __mmask32 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_packusdw512_mask ((__v16si) __A,
              (__v16si) __B,
              (__v32hi) __W,
              __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_packus_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packuswb512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_packus_epi16 (__m512i __W, __mmask64 __M, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_packuswb512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_packus_epi16 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_packuswb512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_adds_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_adds_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_adds_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_paddusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_avg_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_avg_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_avg_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_avg_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_avg_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_avg_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pavgw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epi8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epi16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epu8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epu8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_max_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_max_epu16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_max_epu16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pmaxuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epi8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epi8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epi16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epi16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pminsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epu8 (__mmask64 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epu8 (__m512i __W, __mmask64 __M, __m512i __A,
          __m512i __B)
{
  return (__m512i) __builtin_ia32_pminub512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_min_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_min_epu16 (__mmask32 __M, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_min_epu16 (__m512i __W, __mmask32 __M, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_pminuw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_shuffle_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pshufb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_shuffle_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pshufb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_shuffle_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pshufb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epi8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epi8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubsw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epu8 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epu8 (__m512i __W, __mmask64 __U, __m512i __A,
           __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) __W,
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epu8 (__mmask64 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusb512_mask ((__v64qi) __A,
              (__v64qi) __B,
              (__v64qi) _mm512_setzero_qi(),
              (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_subs_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_subs_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
      __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_subs_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_psubusw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask2_permutex2var_epi16 (__m512i __A, __m512i __I,
         __mmask32 __U, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermi2varhi512_mask ((__v32hi) __A,
              (__v32hi) __I ,
              (__v32hi) __B,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_permutex2var_epi16 (__m512i __A, __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_mask ((__v32hi) __I ,
              (__v32hi) __A,
              (__v32hi) __B,
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_permutex2var_epi16 (__m512i __A, __mmask32 __U,
        __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_mask ((__v32hi) __I ,
              (__v32hi) __A,
              (__v32hi) __B,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_permutex2var_epi16 (__mmask32 __U, __m512i __A,
         __m512i __I, __m512i __B)
{
  return (__m512i) __builtin_ia32_vpermt2varhi512_maskz ((__v32hi) __I
                        ,
              (__v32hi) __A,
              (__v32hi) __B,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mulhrs_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
                (__v32hi) __B,
                (__v32hi) _mm512_setzero_hi(),
                (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mulhrs_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
        __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
                (__v32hi) __B,
                (__v32hi) __W,
                (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mulhrs_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhrsw512_mask ((__v32hi) __A,
                (__v32hi) __B,
                (__v32hi) _mm512_setzero_hi(),
                (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mulhi_epi16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mulhi_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) __W,
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mulhi_epi16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhw512_mask ((__v32hi) __A,
              (__v32hi) __B,
              (__v32hi) _mm512_setzero_hi(),
              (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mulhi_epu16 (__m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v32hi) _mm512_setzero_hi(),
               (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_mulhi_epu16 (__m512i __W, __mmask32 __U, __m512i __A,
       __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v32hi) __W,
               (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_mulhi_epu16 (__mmask32 __U, __m512i __A, __m512i __B)
{
  return (__m512i) __builtin_ia32_pmulhuw512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v32hi) _mm512_setzero_hi(),
               (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maddubs_epi16 (__m512i __X, __m512i __Y) {
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
                 (__v64qi) __Y,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_maddubs_epi16 (__m512i __W, __mmask32 __U, __m512i __X,
         __m512i __Y) {
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
                 (__v64qi) __Y,
                 (__v32hi) __W,
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_maddubs_epi16 (__mmask32 __U, __m512i __X, __m512i __Y) {
  return (__m512i) __builtin_ia32_pmaddubsw512_mask ((__v64qi) __X,
                 (__v64qi) __Y,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_madd_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v16si) _mm512_setzero_si512(),
               (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_madd_epi16 (__m512i __W, __mmask16 __U, __m512i __A,
      __m512i __B) {
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v16si) __W,
               (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_madd_epi16 (__mmask16 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmaddwd512_mask ((__v32hi) __A,
               (__v32hi) __B,
               (__v16si) _mm512_setzero_si512(),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtsepi16_epi8 (__m512i __A) {
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
               (__v32qi)_mm256_setzero_si256(),
               (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtsepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
               (__v32qi)__O,
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtsepi16_epi8 (__mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovswb512_mask ((__v32hi) __A,
               (__v32qi) _mm256_setzero_si256(),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtusepi16_epi8 (__m512i __A) {
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
                (__v32qi) _mm256_setzero_si256(),
                (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtusepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
                (__v32qi) __O,
                __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtusepi16_epi8 (__mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovuswb512_mask ((__v32hi) __A,
                (__v32qi) _mm256_setzero_si256(),
                __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_cvtepi16_epi8 (__m512i __A) {
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
              (__v32qi) _mm256_setzero_si256(),
              (__mmask32) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_cvtepi16_epi8 (__m256i __O, __mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
              (__v32qi) __O,
              __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_cvtepi16_epi8 (__mmask32 __M, __m512i __A) {
  return (__m256i) __builtin_ia32_pmovwb512_mask ((__v32hi) __A,
              (__v32qi) _mm256_setzero_si256(),
              __M);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpackhi_epi8 (__m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpckhbw512_mask ((__v64qi) __A,
                 (__v64qi) __B,
                 (__v64qi) _mm512_setzero_qi(),
                 (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpackhi_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
         __m512i __B) {
  return (__m512i) __builtin_ia32_punpckhbw512_mask ((__v64qi) __A,
                 (__v64qi) __B,
                 (__v64qi) __W,
                 (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpackhi_epi8 (__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpckhbw512_mask ((__v64qi) __A,
                 (__v64qi) __B,
                 (__v64qi) _mm512_setzero_qi(),
                 (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpackhi_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpckhwd512_mask ((__v32hi) __A,
                 (__v32hi) __B,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpackhi_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
          __m512i __B) {
  return (__m512i) __builtin_ia32_punpckhwd512_mask ((__v32hi) __A,
                 (__v32hi) __B,
                 (__v32hi) __W,
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpackhi_epi16 (__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpckhwd512_mask ((__v32hi) __A,
                 (__v32hi) __B,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpacklo_epi8 (__m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpcklbw512_mask ((__v64qi) __A,
                 (__v64qi) __B,
                 (__v64qi) _mm512_setzero_qi(),
                 (__mmask64) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpacklo_epi8 (__m512i __W, __mmask64 __U, __m512i __A,
         __m512i __B) {
  return (__m512i) __builtin_ia32_punpcklbw512_mask ((__v64qi) __A,
                 (__v64qi) __B,
                 (__v64qi) __W,
                 (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpacklo_epi8 (__mmask64 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpcklbw512_mask ((__v64qi) __A,
                 (__v64qi) __B,
                 (__v64qi) _mm512_setzero_qi(),
                 (__mmask64) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_unpacklo_epi16 (__m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpcklwd512_mask ((__v32hi) __A,
                 (__v32hi) __B,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_mask_unpacklo_epi16 (__m512i __W, __mmask32 __U, __m512i __A,
          __m512i __B) {
  return (__m512i) __builtin_ia32_punpcklwd512_mask ((__v32hi) __A,
                 (__v32hi) __B,
                 (__v32hi) __W,
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512bw")))
_mm512_maskz_unpacklo_epi16 (__mmask32 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_punpcklwd512_mask ((__v32hi) __A,
                 (__v32hi) __B,
                 (__v32hi) _mm512_setzero_hi(),
                 (__mmask32) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_conflict_epi64 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
                 (__v8di) _mm512_setzero_si512 (),
                 (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_conflict_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
               (__v8di) __W,
               (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_conflict_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictdi_512_mask ((__v8di) __A,
                 (__v8di) _mm512_setzero_si512 (),
                 (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_conflict_epi32 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
                 (__v16si) _mm512_setzero_si512 (),
                 (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_conflict_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
               (__v16si) __W,
               (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_conflict_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vpconflictsi_512_mask ((__v16si) __A,
                 (__v16si) _mm512_setzero_si512 (),
                 (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_lzcnt_epi32 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
             (__v16si) _mm512_setzero_si512 (),
             (__mmask16) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_lzcnt_epi32 (__m512i __W, __mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
                 (__v16si) __W,
                 (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_lzcnt_epi32 (__mmask16 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntd_512_mask ((__v16si) __A,
             (__v16si) _mm512_setzero_si512 (),
             (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_lzcnt_epi64 (__m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
             (__v8di) _mm512_setzero_si512 (),
             (__mmask8) -1);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_mask_lzcnt_epi64 (__m512i __W, __mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
                 (__v8di) __W,
                 (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512cd")))
_mm512_maskz_lzcnt_epi64 (__mmask8 __U, __m512i __A)
{
  return (__m512i) __builtin_ia32_vplzcntq_512_mask ((__v8di) __A,
             (__v8di) _mm512_setzero_si512 (),
             (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mullo_epi64 (__m512i __A, __m512i __B) {
  return (__m512i) ((__v8di) __A * (__v8di) __B);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_mullo_epi64 (__m512i __W, __mmask8 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmullq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di) __W,
              (__mmask8) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_mullo_epi64 (__mmask8 __U, __m512i __A, __m512i __B) {
  return (__m512i) __builtin_ia32_pmullq512_mask ((__v8di) __A,
              (__v8di) __B,
              (__v8di)
              _mm512_setzero_si512 (),
              (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_xor_pd (__m512d __A, __m512d __B) {
  return (__m512d) ((__v8di) __A ^ (__v8di) __B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_xor_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_xorpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __W,
             (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_xor_pd (__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_xorpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_xor_ps (__m512 __A, __m512 __B) {
  return (__m512) ((__v16si) __A ^ (__v16si) __B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_xor_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_xorps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_xor_ps (__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_xorps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_or_pd (__m512d __A, __m512d __B) {
  return (__m512d) ((__v8di) __A | (__v8di) __B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_or_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_orpd512_mask ((__v8df) __A,
            (__v8df) __B,
            (__v8df) __W,
            (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_or_pd (__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_orpd512_mask ((__v8df) __A,
            (__v8df) __B,
            (__v8df)
            _mm512_setzero_pd (),
            (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_or_ps (__m512 __A, __m512 __B) {
  return (__m512) ((__v16si) __A | (__v16si) __B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_or_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_orps512_mask ((__v16sf) __A,
                 (__v16sf) __B,
                 (__v16sf) __W,
                 (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_or_ps (__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_orps512_mask ((__v16sf) __A,
                 (__v16sf) __B,
                 (__v16sf)
                 _mm512_setzero_ps (),
                 (__mmask16) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_and_pd (__m512d __A, __m512d __B) {
  return (__m512d) ((__v8di) __A & (__v8di) __B);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_and_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_andpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df) __W,
             (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_and_pd (__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_andpd512_mask ((__v8df) __A,
             (__v8df) __B,
             (__v8df)
             _mm512_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_and_ps (__m512 __A, __m512 __B) {
  return (__m512) ((__v16si) __A & (__v16si) __B);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_and_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_andps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf) __W,
            (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_and_ps (__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_andps512_mask ((__v16sf) __A,
            (__v16sf) __B,
            (__v16sf)
            _mm512_setzero_ps (),
            (__mmask16) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_andnot_pd (__m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_andnpd512_mask ((__v8df) __A,
              (__v8df) __B,
              (__v8df)
              _mm512_setzero_pd (),
              (__mmask8) -1);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_andnot_pd (__m512d __W, __mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_andnpd512_mask ((__v8df) __A,
              (__v8df) __B,
              (__v8df) __W,
              (__mmask8) __U);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_andnot_pd (__mmask8 __U, __m512d __A, __m512d __B) {
  return (__m512d) __builtin_ia32_andnpd512_mask ((__v8df) __A,
              (__v8df) __B,
              (__v8df)
              _mm512_setzero_pd (),
              (__mmask8) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_andnot_ps (__m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_andnps512_mask ((__v16sf) __A,
             (__v16sf) __B,
             (__v16sf)
             _mm512_setzero_ps (),
             (__mmask16) -1);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_andnot_ps (__m512 __W, __mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_andnps512_mask ((__v16sf) __A,
             (__v16sf) __B,
             (__v16sf) __W,
             (__mmask16) __U);
}

static __inline__ __m512 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_andnot_ps (__mmask16 __U, __m512 __A, __m512 __B) {
  return (__m512) __builtin_ia32_andnps512_mask ((__v16sf) __A,
             (__v16sf) __B,
             (__v16sf)
             _mm512_setzero_ps (),
             (__mmask16) __U);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtpd_epi64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtpd_epi64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
                (__v8di) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtpd_epi64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2qq512_mask ((__v8df) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtpd_epu64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtpd_epu64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtpd_epu64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvtpd2uqq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtps_epi64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtps_epi64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
                (__v8di) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtps_epi64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2qq512_mask ((__v8sf) __A,
                (__v8di) _mm512_setzero_si512(),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtps_epu64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtps_epu64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtps_epu64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvtps2uqq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepi64_pd (__m512i __A) {
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
                (__v8df) _mm512_setzero_pd(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepi64_pd (__m512d __W, __mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
                (__v8df) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepi64_pd (__mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtqq2pd512_mask ((__v8di) __A,
                (__v8df) _mm512_setzero_pd(),
                (__mmask8) __U,
                0x04);
}
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepi64_ps (__m512i __A) {
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
               (__v8sf) _mm256_setzero_ps(),
               (__mmask8) -1,
               0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepi64_ps (__m256 __W, __mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
               (__v8sf) __W,
               (__mmask8) __U,
               0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepi64_ps (__mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtqq2ps512_mask ((__v8di) __A,
               (__v8sf) _mm256_setzero_ps(),
               (__mmask8) __U,
               0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttpd_epi64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttpd_epi64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttpd_epi64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2qq512_mask ((__v8df) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttpd_epu64 (__m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) -1,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttpd_epu64 (__m512i __W, __mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
                  (__v8di) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttpd_epu64 (__mmask8 __U, __m512d __A) {
  return (__m512i) __builtin_ia32_cvttpd2uqq512_mask ((__v8df) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) __U,
                  0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttps_epi64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttps_epi64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
                 (__v8di) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttps_epi64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2qq512_mask ((__v8sf) __A,
                 (__v8di) _mm512_setzero_si512(),
                 (__mmask8) __U,
                 0x04);
}
static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvttps_epu64 (__m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) -1,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvttps_epu64 (__m512i __W, __mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
                  (__v8di) __W,
                  (__mmask8) __U,
                  0x04);
}

static __inline__ __m512i __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvttps_epu64 (__mmask8 __U, __m256 __A) {
  return (__m512i) __builtin_ia32_cvttps2uqq512_mask ((__v8sf) __A,
                  (__v8di) _mm512_setzero_si512(),
                  (__mmask8) __U,
                  0x04);
}
static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepu64_pd (__m512i __A) {
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
                 (__v8df) _mm512_setzero_pd(),
                 (__mmask8) -1,
                 0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepu64_pd (__m512d __W, __mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
                 (__v8df) __W,
                 (__mmask8) __U,
                 0x04);
}

static __inline__ __m512d __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepu64_pd (__mmask8 __U, __m512i __A) {
  return (__m512d) __builtin_ia32_cvtuqq2pd512_mask ((__v8di) __A,
                 (__v8df) _mm512_setzero_pd(),
                 (__mmask8) __U,
                 0x04);
}
static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_cvtepu64_ps (__m512i __A) {
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
                (__v8sf) _mm256_setzero_ps(),
                (__mmask8) -1,
                0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_mask_cvtepu64_ps (__m256 __W, __mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
                (__v8sf) __W,
                (__mmask8) __U,
                0x04);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512dq")))
_mm512_maskz_cvtepu64_ps (__mmask8 __U, __m512i __A) {
  return (__m256) __builtin_ia32_cvtuqq2ps512_mask ((__v8di) __A,
                (__v8sf) _mm256_setzero_ps(),
                (__mmask8) __U,
                0x04);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 0,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 0,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpeqb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 0,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 0,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpeqw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpeq_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 0,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpeq_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 0,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpeqw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpeq_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 0,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpeq_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 0,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 5,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 5,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpge_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpge_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpge_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpge_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 5,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtb128_mask((__v16qi)__a, (__v16qi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 6,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 6,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_pcmpgtb256_mask((__v32qi)__a, (__v32qi)__b,
                                                   __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 6,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 6,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_pcmpgtw128_mask((__v8hi)__a, (__v8hi)__b,
                                                  __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpgt_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 6,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpgt_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 6,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_pcmpgtw256_mask((__v16hi)__a, (__v16hi)__b,
                                                   __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpgt_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 6,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpgt_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 6,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 2,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 2,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmple_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmple_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmple_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmple_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 2,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 1,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 1,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmplt_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmplt_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmplt_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmplt_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 1,
                                                 __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epi8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epi8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_cmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epu8_mask(__m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epu8_mask(__mmask16 __u, __m128i __a, __m128i __b) {
  return (__mmask16)__builtin_ia32_ucmpb128_mask((__v16qi)__a, (__v16qi)__b, 4,
                                                 __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epi8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epi8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_cmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                __u);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epu8_mask(__m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                 (__mmask32)-1);
}

static __inline__ __mmask32 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epu8_mask(__mmask32 __u, __m256i __a, __m256i __b) {
  return (__mmask32)__builtin_ia32_ucmpb256_mask((__v32qi)__a, (__v32qi)__b, 4,
                                                 __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epi16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                               (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epi16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_cmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                               __u);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cmpneq_epu16_mask(__m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                                (__mmask8)-1);
}

static __inline__ __mmask8 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cmpneq_epu16_mask(__mmask8 __u, __m128i __a, __m128i __b) {
  return (__mmask8)__builtin_ia32_ucmpw128_mask((__v8hi)__a, (__v8hi)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epi16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epi16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_cmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                __u);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cmpneq_epu16_mask(__m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                 (__mmask16)-1);
}

static __inline__ __mmask16 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cmpneq_epu16_mask(__mmask16 __u, __m256i __a, __m256i __b) {
  return (__mmask16)__builtin_ia32_ucmpw256_mask((__v16hi)__a, (__v16hi)__b, 4,
                                                 __u);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_add_epi8 (__m256i __W, __mmask32 __U, __m256i __A, __m256i __B){
  return (__m256i) __builtin_ia32_paddb256_mask ((__v32qi) __A,
             (__v32qi) __B,
             (__v32qi) __W,
             (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_add_epi8 (__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_paddb256_mask ((__v32qi) __A,
             (__v32qi) __B,
             (__v32qi)
             _mm256_setzero_si256 (),
             (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_add_epi16 (__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_paddw256_mask ((__v16hi) __A,
             (__v16hi) __B,
             (__v16hi) __W,
             (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_add_epi16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_paddw256_mask ((__v16hi) __A,
             (__v16hi) __B,
             (__v16hi)
             _mm256_setzero_si256 (),
             (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sub_epi8 (__m256i __W, __mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_psubb256_mask ((__v32qi) __A,
             (__v32qi) __B,
             (__v32qi) __W,
             (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sub_epi8 (__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_psubb256_mask ((__v32qi) __A,
             (__v32qi) __B,
             (__v32qi)
             _mm256_setzero_si256 (),
             (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_sub_epi16 (__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_psubw256_mask ((__v16hi) __A,
             (__v16hi) __B,
             (__v16hi) __W,
             (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_sub_epi16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_psubw256_mask ((__v16hi) __A,
             (__v16hi) __B,
             (__v16hi)
             _mm256_setzero_si256 (),
             (__mmask16) __U);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_add_epi8 (__m128i __W, __mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_paddb128_mask ((__v16qi) __A,
             (__v16qi) __B,
             (__v16qi) __W,
             (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_add_epi8 (__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_paddb128_mask ((__v16qi) __A,
             (__v16qi) __B,
             (__v16qi)
             _mm_setzero_si128 (),
             (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_add_epi16 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_paddw128_mask ((__v8hi) __A,
             (__v8hi) __B,
             (__v8hi) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_add_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_paddw128_mask ((__v8hi) __A,
             (__v8hi) __B,
             (__v8hi)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sub_epi8 (__m128i __W, __mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_psubb128_mask ((__v16qi) __A,
             (__v16qi) __B,
             (__v16qi) __W,
             (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sub_epi8 (__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_psubb128_mask ((__v16qi) __A,
             (__v16qi) __B,
             (__v16qi)
             _mm_setzero_si128 (),
             (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_sub_epi16 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_psubw128_mask ((__v8hi) __A,
             (__v8hi) __B,
             (__v8hi) __W,
             (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_sub_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_psubw128_mask ((__v8hi) __A,
             (__v8hi) __B,
             (__v8hi)
             _mm_setzero_si128 (),
             (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mullo_epi16 (__m256i __W, __mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmullw256_mask ((__v16hi) __A,
              (__v16hi) __B,
              (__v16hi) __W,
              (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mullo_epi16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmullw256_mask ((__v16hi) __A,
              (__v16hi) __B,
              (__v16hi)
              _mm256_setzero_si256 (),
              (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mullo_epi16 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmullw128_mask ((__v8hi) __A,
              (__v8hi) __B,
              (__v8hi) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mullo_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmullw128_mask ((__v8hi) __A,
              (__v8hi) __B,
              (__v8hi)
              _mm_setzero_si128 (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_blend_epi8 (__mmask16 __U, __m128i __A, __m128i __W)
{
  return (__m128i) __builtin_ia32_blendmb_128_mask ((__v16qi) __A,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_blend_epi8 (__mmask32 __U, __m256i __A, __m256i __W)
{
  return (__m256i) __builtin_ia32_blendmb_256_mask ((__v32qi) __A,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_blend_epi16 (__mmask8 __U, __m128i __A, __m128i __W)
{
  return (__m128i) __builtin_ia32_blendmw_128_mask ((__v8hi) __A,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_blend_epi16 (__mmask16 __U, __m256i __A, __m256i __W)
{
  return (__m256i) __builtin_ia32_blendmw_256_mask ((__v16hi) __A,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_abs_epi8 (__m128i __W, __mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsb128_mask ((__v16qi) __A,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_abs_epi8 (__mmask16 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsb128_mask ((__v16qi) __A,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_abs_epi8 (__m256i __W, __mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsb256_mask ((__v32qi) __A,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_abs_epi8 (__mmask32 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsb256_mask ((__v32qi) __A,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_abs_epi16 (__m128i __W, __mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsw128_mask ((__v8hi) __A,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_abs_epi16 (__mmask8 __U, __m128i __A)
{
  return (__m128i) __builtin_ia32_pabsw128_mask ((__v8hi) __A,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_abs_epi16 (__m256i __W, __mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsw256_mask ((__v16hi) __A,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_abs_epi16 (__mmask16 __U, __m256i __A)
{
  return (__m256i) __builtin_ia32_pabsw256_mask ((__v16hi) __A,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packs_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packssdw128_mask ((__v4si) __A,
               (__v4si) __B,
               (__v8hi) _mm_setzero_si128 (), __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packs_epi32 (__m128i __W, __mmask16 __M, __m128i __A,
          __m128i __B)
{
  return (__m128i) __builtin_ia32_packssdw128_mask ((__v4si) __A,
               (__v4si) __B,
               (__v8hi) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packs_epi32 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packssdw256_mask ((__v8si) __A,
               (__v8si) __B,
               (__v16hi) _mm256_setzero_si256 (),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packs_epi32 (__m256i __W, __mmask16 __M, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_packssdw256_mask ((__v8si) __A,
               (__v8si) __B,
               (__v16hi) __W, __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packs_epi16 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packsswb128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packs_epi16 (__m128i __W, __mmask16 __M, __m128i __A,
          __m128i __B)
{
  return (__m128i) __builtin_ia32_packsswb128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v16qi) __W,
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packs_epi16 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packsswb256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packs_epi16 (__m256i __W, __mmask32 __M, __m256i __A,
       __m256i __B)
{
  return (__m256i) __builtin_ia32_packsswb256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v32qi) __W,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packus_epi32 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packusdw128_mask ((__v4si) __A,
               (__v4si) __B,
               (__v8hi) _mm_setzero_si128 (),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packus_epi32 (__m128i __W, __mmask16 __M, __m128i __A,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_packusdw128_mask ((__v4si) __A,
               (__v4si) __B,
               (__v8hi) __W, __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packus_epi32 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packusdw256_mask ((__v8si) __A,
               (__v8si) __B,
               (__v16hi) _mm256_setzero_si256 (),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packus_epi32 (__m256i __W, __mmask16 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_packusdw256_mask ((__v8si) __A,
               (__v8si) __B,
               (__v16hi) __W,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_packus_epi16 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_packuswb128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v16qi) _mm_setzero_si128 (),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_packus_epi16 (__m128i __W, __mmask16 __M, __m128i __A,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_packuswb128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v16qi) __W,
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_packus_epi16 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_packuswb256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_packus_epi16 (__m256i __W, __mmask32 __M, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_packuswb256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v32qi) __W,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epu8 (__m128i __W, __mmask16 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epu8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epu8 (__m256i __W, __mmask32 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epu8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_adds_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_adds_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_paddusw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_adds_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_adds_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_paddusw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_avg_epu8 (__m128i __W, __mmask16 __U, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_avg_epu8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_avg_epu8 (__m256i __W, __mmask32 __U, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_avg_epu8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_avg_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_avg_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pavgw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_avg_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_avg_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pavgw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epi8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epi8 (__m128i __W, __mmask16 __M, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epi8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epi8 (__m256i __W, __mmask32 __M, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epi16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epi16 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epi16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epi16 (__m256i __W, __mmask16 __M, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epu8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxub128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epu8 (__m128i __W, __mmask16 __M, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxub128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epu8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxub256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epu8 (__m256i __W, __mmask32 __M, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxub256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_max_epu16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_max_epu16 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pmaxuw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_max_epu16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_max_epu16 (__m256i __W, __mmask16 __M, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pmaxuw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epi8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epi8 (__m128i __W, __mmask16 __M, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epi8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epi8 (__m256i __W, __mmask32 __M, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epi16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epi16 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pminsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epi16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epi16 (__m256i __W, __mmask16 __M, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pminsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epu8 (__mmask16 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminub128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epu8 (__m128i __W, __mmask16 __M, __m128i __A,
       __m128i __B)
{
  return (__m128i) __builtin_ia32_pminub128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epu8 (__mmask32 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminub256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epu8 (__m256i __W, __mmask32 __M, __m256i __A,
          __m256i __B)
{
  return (__m256i) __builtin_ia32_pminub256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_min_epu16 (__mmask8 __M, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_min_epu16 (__m128i __W, __mmask8 __M, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_pminuw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_min_epu16 (__mmask16 __M, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __M);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_min_epu16 (__m256i __W, __mmask16 __M, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_pminuw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_shuffle_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_pshufb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_shuffle_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_pshufb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_shuffle_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
        __m256i __B)
{
  return (__m256i) __builtin_ia32_pshufb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_shuffle_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_pshufb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epi8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epi8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epi16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubsw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epi16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubsw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epu8 (__m128i __W, __mmask16 __U, __m128i __A,
        __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epu8 (__mmask16 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusb128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128 (),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epu8 (__m256i __W, __mmask32 __U, __m256i __A,
           __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epu8 (__mmask32 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusb256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256 (),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_subs_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_subs_epu16 (__mmask8 __U, __m128i __A, __m128i __B)
{
  return (__m128i) __builtin_ia32_psubusw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128 (),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_subs_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
      __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_subs_epu16 (__mmask16 __U, __m256i __A, __m256i __B)
{
  return (__m256i) __builtin_ia32_psubusw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256 (),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask2_permutex2var_epi16 (__m128i __A, __m128i __I, __mmask8 __U,
            __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermi2varhi128_mask ((__v8hi) __A,
               (__v8hi) __I ,
               (__v8hi) __B,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask2_permutex2var_epi16 (__m256i __A, __m256i __I,
         __mmask16 __U, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermi2varhi256_mask ((__v16hi) __A,
               (__v16hi) __I ,
               (__v16hi) __B,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_permutex2var_epi16 (__m128i __A, __m128i __I, __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_mask ((__v8hi) __I ,
               (__v8hi) __A,
               (__v8hi) __B,
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_permutex2var_epi16 (__m128i __A, __mmask8 __U, __m128i __I,
           __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_mask ((__v8hi) __I ,
               (__v8hi) __A,
               (__v8hi) __B,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_permutex2var_epi16 (__mmask8 __U, __m128i __A, __m128i __I,
            __m128i __B)
{
  return (__m128i) __builtin_ia32_vpermt2varhi128_maskz ((__v8hi) __I ,
               (__v8hi) __A,
               (__v8hi) __B,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_permutex2var_epi16 (__m256i __A, __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_mask ((__v16hi) __I ,
               (__v16hi) __A,
               (__v16hi) __B,
               (__mmask16) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_permutex2var_epi16 (__m256i __A, __mmask16 __U,
        __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_mask ((__v16hi) __I ,
               (__v16hi) __A,
               (__v16hi) __B,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_permutex2var_epi16 (__mmask16 __U, __m256i __A,
         __m256i __I, __m256i __B)
{
  return (__m256i) __builtin_ia32_vpermt2varhi256_maskz ((__v16hi) __I ,
               (__v16hi) __A,
               (__v16hi) __B,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_maddubs_epi16 (__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i) __builtin_ia32_pmaddubsw128_mask ((__v16qi) __X,
               (__v16qi) __Y,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_maddubs_epi16 (__mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i) __builtin_ia32_pmaddubsw128_mask ((__v16qi) __X,
               (__v16qi) __Y,
              (__v8hi) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_maddubs_epi16 (__m256i __W, __mmask16 __U, __m256i __X,
         __m256i __Y) {
  return (__m256i) __builtin_ia32_pmaddubsw256_mask ((__v32qi) __X,
               (__v32qi) __Y,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_maddubs_epi16 (__mmask16 __U, __m256i __X, __m256i __Y) {
  return (__m256i) __builtin_ia32_pmaddubsw256_mask ((__v32qi) __X,
               (__v32qi) __Y,
               (__v16hi) _mm256_setzero_si256(),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_madd_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
         __m128i __B) {
  return (__m128i) __builtin_ia32_pmaddwd128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v4si) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_madd_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmaddwd128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v4si) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_madd_epi16 (__m256i __W, __mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaddwd256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v8si) __W,
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_madd_epi16 (__mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmaddwd256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v8si) _mm256_setzero_si256(),
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cvtsepi16_epi8 (__m128i __A) {
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtsepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
               (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtsepi16_epi8 (__mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovswb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cvtsepi16_epi8 (__m256i __A) {
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtsepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
               (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtsepi16_epi8 (__mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovswb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cvtusepi16_epi8 (__m128i __A) {
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
                (__v16qi) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtusepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtusepi16_epi8 (__mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovuswb128_mask ((__v8hi) __A,
                (__v16qi) _mm_setzero_si128(),
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cvtusepi16_epi8 (__m256i __A) {
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
                (__v16qi) _mm_setzero_si128(),
                (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtusepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
                (__v16qi) __O,
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtusepi16_epi8 (__mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovuswb256_mask ((__v16hi) __A,
                (__v16qi) _mm_setzero_si128(),
                __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_cvtepi16_epi8 (__m128i __A) {

  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_cvtepi16_epi8 (__m128i __O, __mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
               (__v16qi) __O,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_cvtepi16_epi8 (__mmask8 __M, __m128i __A) {
  return (__m128i) __builtin_ia32_pmovwb128_mask ((__v8hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_cvtepi16_epi8 (__m256i __A) {
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               (__mmask16) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_cvtepi16_epi8 (__m128i __O, __mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
               (__v16qi) __O,
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_cvtepi16_epi8 (__mmask16 __M, __m256i __A) {
  return (__m128i) __builtin_ia32_pmovwb256_mask ((__v16hi) __A,
               (__v16qi) _mm_setzero_si128(),
               __M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mulhrs_epi16 (__m128i __W, __mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i) __builtin_ia32_pmulhrsw128_mask ((__v8hi) __X,
               (__v8hi) __Y,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mulhrs_epi16 (__mmask8 __U, __m128i __X, __m128i __Y) {
  return (__m128i) __builtin_ia32_pmulhrsw128_mask ((__v8hi) __X,
               (__v8hi) __Y,
              (__v8hi) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mulhrs_epi16 (__m256i __W, __mmask16 __U, __m256i __X, __m256i __Y) {
  return (__m256i) __builtin_ia32_pmulhrsw256_mask ((__v16hi) __X,
               (__v16hi) __Y,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mulhrs_epi16 (__mmask16 __U, __m256i __X, __m256i __Y) {
  return (__m256i) __builtin_ia32_pmulhrsw256_mask ((__v16hi) __X,
               (__v16hi) __Y,
               (__v16hi) _mm256_setzero_si256(),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mulhi_epu16 (__m128i __W, __mmask8 __U, __m128i __A,
          __m128i __B) {
  return (__m128i) __builtin_ia32_pmulhuw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mulhi_epu16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmulhuw128_mask ((__v8hi) __A,
               (__v8hi) __B,
              (__v8hi) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mulhi_epu16 (__m256i __W, __mmask16 __U, __m256i __A,
       __m256i __B) {
  return (__m256i) __builtin_ia32_pmulhuw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mulhi_epu16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmulhuw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256(),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_mulhi_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
          __m128i __B) {
  return (__m128i) __builtin_ia32_pmulhw128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_mulhi_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmulhw128_mask ((__v8hi) __A,
               (__v8hi) __B,
              (__v8hi) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_mulhi_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
       __m256i __B) {
  return (__m256i) __builtin_ia32_pmulhw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_mulhi_epi16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmulhw256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256(),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpackhi_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
      __m128i __B) {
  return (__m128i) __builtin_ia32_punpckhbw128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpackhi_epi8 (__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_punpckhbw128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128(),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpackhi_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
         __m256i __B) {
  return (__m256i) __builtin_ia32_punpckhbw256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpackhi_epi8 (__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_punpckhbw256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256(),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpackhi_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B) {
  return (__m128i) __builtin_ia32_punpckhwd128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpackhi_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_punpckhwd128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpackhi_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
          __m256i __B) {
  return (__m256i) __builtin_ia32_punpckhwd256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpackhi_epi16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_punpckhwd256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256(),
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpacklo_epi8 (__m128i __W, __mmask16 __U, __m128i __A,
      __m128i __B) {
  return (__m128i) __builtin_ia32_punpcklbw128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) __W,
               (__mmask16) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpacklo_epi8 (__mmask16 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_punpcklbw128_mask ((__v16qi) __A,
               (__v16qi) __B,
               (__v16qi) _mm_setzero_si128(),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpacklo_epi8 (__m256i __W, __mmask32 __U, __m256i __A,
         __m256i __B) {
  return (__m256i) __builtin_ia32_punpcklbw256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) __W,
               (__mmask32) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpacklo_epi8 (__mmask32 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_punpcklbw256_mask ((__v32qi) __A,
               (__v32qi) __B,
               (__v32qi) _mm256_setzero_si256(),
               (__mmask32) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_mask_unpacklo_epi16 (__m128i __W, __mmask8 __U, __m128i __A,
       __m128i __B) {
  return (__m128i) __builtin_ia32_punpcklwd128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) __W,
               (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm_maskz_unpacklo_epi16 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_punpcklwd128_mask ((__v8hi) __A,
               (__v8hi) __B,
               (__v8hi) _mm_setzero_si128(),
               (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_mask_unpacklo_epi16 (__m256i __W, __mmask16 __U, __m256i __A,
          __m256i __B) {
  return (__m256i) __builtin_ia32_punpcklwd256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) __W,
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512bw")))
_mm256_maskz_unpacklo_epi16 (__mmask16 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_punpcklwd256_mask ((__v16hi) __A,
               (__v16hi) __B,
               (__v16hi) _mm256_setzero_si256(),
               (__mmask16) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mullo_epi64 (__m256i __A, __m256i __B) {
  return (__m256i) ((__v4di) __A * (__v4di) __B);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_mullo_epi64 (__m256i __W, __mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmullq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di) __W,
              (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_mullo_epi64 (__mmask8 __U, __m256i __A, __m256i __B) {
  return (__m256i) __builtin_ia32_pmullq256_mask ((__v4di) __A,
              (__v4di) __B,
              (__v4di)
              _mm256_setzero_si256 (),
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mullo_epi64 (__m128i __A, __m128i __B) {
  return (__m128i) ((__v2di) __A * (__v2di) __B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_mullo_epi64 (__m128i __W, __mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmullq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di) __W,
              (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_mullo_epi64 (__mmask8 __U, __m128i __A, __m128i __B) {
  return (__m128i) __builtin_ia32_pmullq128_mask ((__v2di) __A,
              (__v2di) __B,
              (__v2di)
              _mm_setzero_si128 (),
              (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_andnot_pd (__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_andnpd256_mask ((__v4df) __A,
              (__v4df) __B,
              (__v4df) __W,
              (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_andnot_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_andnpd256_mask ((__v4df) __A,
              (__v4df) __B,
              (__v4df)
              _mm256_setzero_pd (),
              (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_andnot_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_andnpd128_mask ((__v2df) __A,
              (__v2df) __B,
              (__v2df) __W,
              (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_andnot_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_andnpd128_mask ((__v2df) __A,
              (__v2df) __B,
              (__v2df)
              _mm_setzero_pd (),
              (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_andnot_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_andnps256_mask ((__v8sf) __A,
             (__v8sf) __B,
             (__v8sf) __W,
             (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_andnot_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_andnps256_mask ((__v8sf) __A,
             (__v8sf) __B,
             (__v8sf)
             _mm256_setzero_ps (),
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_andnot_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_andnps128_mask ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf) __W,
             (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_andnot_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_andnps128_mask ((__v4sf) __A,
             (__v4sf) __B,
             (__v4sf)
             _mm_setzero_ps (),
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_and_pd (__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_andpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_and_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_andpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_and_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_andpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df) __W,
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_and_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_andpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df)
             _mm_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_and_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_andps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_and_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_andps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_and_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_andps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf) __W,
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_and_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_andps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_xor_pd (__m256d __W, __mmask8 __U, __m256d __A,
        __m256d __B) {
  return (__m256d) __builtin_ia32_xorpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df) __W,
             (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_xor_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_xorpd256_mask ((__v4df) __A,
             (__v4df) __B,
             (__v4df)
             _mm256_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_xor_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_xorpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df) __W,
             (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_xor_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_xorpd128_mask ((__v2df) __A,
             (__v2df) __B,
             (__v2df)
             _mm_setzero_pd (),
             (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_xor_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_xorps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf) __W,
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_xor_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_xorps256_mask ((__v8sf) __A,
            (__v8sf) __B,
            (__v8sf)
            _mm256_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_xor_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_xorps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf) __W,
            (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_xor_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_xorps128_mask ((__v4sf) __A,
            (__v4sf) __B,
            (__v4sf)
            _mm_setzero_ps (),
            (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_or_pd (__m256d __W, __mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_orpd256_mask ((__v4df) __A,
            (__v4df) __B,
            (__v4df) __W,
            (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_or_pd (__mmask8 __U, __m256d __A, __m256d __B) {
  return (__m256d) __builtin_ia32_orpd256_mask ((__v4df) __A,
            (__v4df) __B,
            (__v4df)
            _mm256_setzero_pd (),
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_or_pd (__m128d __W, __mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_orpd128_mask ((__v2df) __A,
            (__v2df) __B,
            (__v2df) __W,
            (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_or_pd (__mmask8 __U, __m128d __A, __m128d __B) {
  return (__m128d) __builtin_ia32_orpd128_mask ((__v2df) __A,
            (__v2df) __B,
            (__v2df)
            _mm_setzero_pd (),
            (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_or_ps (__m256 __W, __mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_orps256_mask ((__v8sf) __A,
                 (__v8sf) __B,
                 (__v8sf) __W,
                 (__mmask8) __U);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_or_ps (__mmask8 __U, __m256 __A, __m256 __B) {
  return (__m256) __builtin_ia32_orps256_mask ((__v8sf) __A,
                 (__v8sf) __B,
                 (__v8sf)
                 _mm256_setzero_ps (),
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_or_ps (__m128 __W, __mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_orps128_mask ((__v4sf) __A,
                 (__v4sf) __B,
                 (__v4sf) __W,
                 (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_or_ps (__mmask8 __U, __m128 __A, __m128 __B) {
  return (__m128) __builtin_ia32_orps128_mask ((__v4sf) __A,
                 (__v4sf) __B,
                 (__v4sf)
                 _mm_setzero_ps (),
                 (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtpd_epi64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtpd_epi64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtpd_epi64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtpd_epi64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtpd_epi64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtpd_epi64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtpd_epu64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtpd_epu64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtpd_epu64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvtpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtpd_epu64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtpd_epu64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtpd_epu64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvtpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtps_epi64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtps_epi64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtps_epi64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtps_epi64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtps_epu64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtps_epu64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvtps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtps_epu64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtps_epu64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvtps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepi64_pd (__m128i __A) {
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepi64_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepi64_pd (__mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepi64_pd (__m256i __A) {
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepi64_pd (__m256d __W, __mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepi64_pd (__mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepi64_ps (__m128i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepi64_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepi64_ps (__mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepi64_ps (__m256i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepi64_ps (__m128 __W, __mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepi64_ps (__mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttpd_epi64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttpd_epi64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttpd_epi64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2qq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttpd_epi64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttpd_epi64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttpd_epi64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2qq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttpd_epu64 (__m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttpd_epu64 (__m128i __W, __mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttpd_epu64 (__mmask8 __U, __m128d __A) {
  return (__m128i) __builtin_ia32_cvttpd2uqq128_mask ((__v2df) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttpd_epu64 (__m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttpd_epu64 (__m256i __W, __mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttpd_epu64 (__mmask8 __U, __m256d __A) {
  return (__m256i) __builtin_ia32_cvttpd2uqq256_mask ((__v4df) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttps_epi64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttps_epi64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2qq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttps_epi64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttps_epi64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttps_epi64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2qq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvttps_epu64 (__m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) -1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvttps_epu64 (__m128i __W, __mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
                (__v2di) __W,
                (__mmask8) __U);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvttps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m128i) __builtin_ia32_cvttps2uqq128_mask ((__v4sf) __A,
                (__v2di) _mm_setzero_si128(),
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvttps_epu64 (__m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) -1);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvttps_epu64 (__m256i __W, __mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
                (__v4di) __W,
                (__mmask8) __U);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvttps_epu64 (__mmask8 __U, __m128 __A) {
  return (__m256i) __builtin_ia32_cvttps2uqq256_mask ((__v4sf) __A,
                (__v4di) _mm256_setzero_si256(),
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepu64_pd (__m128i __A) {
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepu64_pd (__m128d __W, __mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
                (__v2df) __W,
                (__mmask8) __U);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepu64_pd (__mmask8 __U, __m128i __A) {
  return (__m128d) __builtin_ia32_cvtuqq2pd128_mask ((__v2di) __A,
                (__v2df) _mm_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepu64_pd (__m256i __A) {
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) -1);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepu64_pd (__m256d __W, __mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
                (__v4df) __W,
                (__mmask8) __U);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepu64_pd (__mmask8 __U, __m256i __A) {
  return (__m256d) __builtin_ia32_cvtuqq2pd256_mask ((__v4di) __A,
                (__v4df) _mm256_setzero_pd(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_cvtepu64_ps (__m128i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_mask_cvtepu64_ps (__m128 __W, __mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm_maskz_cvtepu64_ps (__mmask8 __U, __m128i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps128_mask ((__v2di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_cvtepu64_ps (__m256i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) -1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_mask_cvtepu64_ps (__m128 __W, __mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
                (__v4sf) __W,
                (__mmask8) __U);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("avx512vl,avx512dq")))
_mm256_maskz_cvtepu64_ps (__mmask8 __U, __m256i __A) {
  return (__m128) __builtin_ia32_cvtuqq2ps256_mask ((__v4di) __A,
                (__v4sf) _mm_setzero_ps(),
                (__mmask8) __U);
}


static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("pku")))
_rdpkru_u32(void)
{
  return __builtin_ia32_rdpkru();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("pku")))
_wrpkru(unsigned int val)
{
  return __builtin_ia32_wrpkru(val);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand16_step(unsigned short *__p)
{
  return __builtin_ia32_rdrand16_step(__p);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand32_step(unsigned int *__p)
{
  return __builtin_ia32_rdrand32_step(__p);
}


static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdrnd")))
_rdrand64_step(unsigned long long *__p)
{
  return __builtin_ia32_rdrand64_step(__p);
}



static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readfsbase_u32(void)
{
  return __builtin_ia32_rdfsbase32();
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readfsbase_u64(void)
{
  return __builtin_ia32_rdfsbase64();
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readgsbase_u32(void)
{
  return __builtin_ia32_rdgsbase32();
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_readgsbase_u64(void)
{
  return __builtin_ia32_rdgsbase64();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writefsbase_u32(unsigned int __V)
{
  return __builtin_ia32_wrfsbase32(__V);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writefsbase_u64(unsigned long long __V)
{
  return __builtin_ia32_wrfsbase64(__V);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writegsbase_u32(unsigned int __V)
{
  return __builtin_ia32_wrgsbase32(__V);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fsgsbase")))
_writegsbase_u64(unsigned long long __V)
{
  return __builtin_ia32_wrgsbase64(__V);
}



static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("rtm")))
_xbegin(void)
{
  return __builtin_ia32_xbegin();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("rtm")))
_xend(void)
{
  __builtin_ia32_xend();
}

static __inline__ int
    __attribute__((__always_inline__, __nodebug__, __target__("rtm")))
    _xtest(void) {
  return __builtin_ia32_xtest();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha1nexte_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1nexte((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha1msg1_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1msg1((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha1msg2_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha1msg2((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha256rnds2_epu32(__m128i __X, __m128i __Y, __m128i __Z)
{
  return (__m128i)__builtin_ia32_sha256rnds2((__v4si)__X, (__v4si)__Y, (__v4si)__Z);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha256msg1_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha256msg1((__v4si)__X, (__v4si)__Y);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sha")))
_mm_sha256msg2_epu32(__m128i __X, __m128i __Y)
{
  return (__m128i)__builtin_ia32_sha256msg2((__v4si)__X, (__v4si)__Y);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave(void *__p) {
  return __builtin_ia32_fxsave(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxsave64(void *__p) {
  return __builtin_ia32_fxsave64(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor(void *__p) {
  return __builtin_ia32_fxrstor(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("fxsr")))
_fxrstor64(void *__p) {
  return __builtin_ia32_fxrstor64(__p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsave(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor(void *__p, unsigned long long __m) {
  return __builtin_ia32_xrstor(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xsave64(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsave64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsave")))
_xrstor64(void *__p, unsigned long long __m) {
  return __builtin_ia32_xrstor64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsaveopt(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaveopt")))
_xsaveopt64(void *__p, unsigned long long __m) {
  return __builtin_ia32_xsaveopt64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsavec")))
_xsavec(void *__p, unsigned long long __m) {
  __builtin_ia32_xsavec(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsavec")))
_xsavec64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsavec64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xsaves(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaves(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xrstors(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstors(__p, __m);
}


static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xrstors64(void *__p, unsigned long long __m) {
  __builtin_ia32_xrstors64(__p, __m);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("xsaves")))
_xsaves64(void *__p, unsigned long long __m) {
  __builtin_ia32_xsaves64(__p, __m);
}



static __inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
               unsigned int *__p)
{
  return __builtin_ia32_addcarryx_u32(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__, __target__("adx")))
_addcarryx_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarryx_u64(__cf, __x, __y, __p);
}



static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_addcarry_u32(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_addcarry_u64(unsigned char __cf, unsigned long long __x,
              unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_addcarry_u64(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u32(unsigned char __cf, unsigned int __x, unsigned int __y,
              unsigned int *__p)
{
  return __builtin_ia32_subborrow_u32(__cf, __x, __y, __p);
}


static __inline unsigned char __attribute__((__always_inline__, __nodebug__))
_subborrow_u64(unsigned char __cf, unsigned long long __x,
               unsigned long long __y, unsigned long long *__p)
{
  return __builtin_ia32_subborrow_u64(__cf, __x, __y, __p);
}


typedef float __v2sf __attribute__((__vector_size__(8)));




static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_femms() {
  __builtin_ia32_femms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pavgusb(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pavgusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pf2id(__m64 __m) {
  return (__m64)__builtin_ia32_pf2id((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfacc(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfacc((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfadd(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfadd((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfcmpeq(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfcmpeq((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfcmpge(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfcmpge((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfcmpgt(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfcmpgt((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfmax(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfmax((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfmin(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfmin((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfmul(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfmul((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfrcp(__m64 __m) {
  return (__m64)__builtin_ia32_pfrcp((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfrcpit1(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfrcpit1((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfrcpit2(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfrcpit2((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfrsqrt(__m64 __m) {
  return (__m64)__builtin_ia32_pfrsqrt((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfrsqrtit1(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfrsqit1((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfsub(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfsub((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pfsubr(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfsubr((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pi2fd(__m64 __m) {
  return (__m64)__builtin_ia32_pi2fd((__v2si)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnow")))
_m_pmulhrw(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pmulhrw((__v4hi)__m1, (__v4hi)__m2);
}





static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnowa")))
_m_pf2iw(__m64 __m) {
  return (__m64)__builtin_ia32_pf2iw((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnowa")))
_m_pfnacc(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfnacc((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnowa")))
_m_pfpnacc(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfpnacc((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnowa")))
_m_pi2fw(__m64 __m) {
  return (__m64)__builtin_ia32_pi2fw((__v2si)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnowa")))
_m_pswapdsf(__m64 __m) {
  return (__m64)__builtin_ia32_pswapdsf((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__, __target__("3dnowa")))
_m_pswapdsi(__m64 __m) {
  return (__m64)__builtin_ia32_pswapdsi((__v2si)__m);
}




static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("popcnt")))
_mm_popcnt_u32(unsigned int __A)
{
  return __builtin_popcount(__A);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("popcnt")))
_popcnt32(int __A)
{
  return __builtin_popcount(__A);
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("popcnt")))
_mm_popcnt_u64(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__, __target__("popcnt")))
_popcnt64(long long __A)
{
  return __builtin_popcountll(__A);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdseed")))
_rdseed16_step(unsigned short *__p)
{
  return __builtin_ia32_rdseed16_step(__p);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdseed")))
_rdseed32_step(unsigned int *__p)
{
  return __builtin_ia32_rdseed32_step(__p);
}


static __inline__ int __attribute__((__always_inline__, __nodebug__, __target__("rdseed")))
_rdseed64_step(unsigned long long *__p)
{
  return __builtin_ia32_rdseed64_step(__p);
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4a")))
_mm_extract_si64(__m128i __x, __m128i __y)
{
  return (__m128i)__builtin_ia32_extrq((__v2di)__x, (__v16qi)__y);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("sse4a")))
_mm_insert_si64(__m128i __x, __m128i __y)
{
  return (__m128i)__builtin_ia32_insertq((__v2di)__x, (__v2di)__y);
}
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse4a")))
_mm_stream_sd(double *__p, __m128d __a)
{
  __builtin_ia32_movntsd(__p, (__v2df)__a);
}
static __inline__ void __attribute__((__always_inline__, __nodebug__, __target__("sse4a")))
_mm_stream_ss(float *__p, __m128 __a)
{
  __builtin_ia32_movntss(__p, (__v4sf)__a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_macc_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_macc_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_macc_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_macc_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_msub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_msub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_msub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_msub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmacc_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmacc_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmacc_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmaddss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmacc_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmaddsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmsub_ss(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfnmsubss(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_nmsub_sd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfnmsubsd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_maddsub_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmaddsubps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_maddsub_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmaddsubpd(__A, __B, __C);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_msubadd_ps(__m128 __A, __m128 __B, __m128 __C)
{
  return (__m128)__builtin_ia32_vfmsubaddps(__A, __B, __C);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm_msubadd_pd(__m128d __A, __m128d __B, __m128d __C)
{
  return (__m128d)__builtin_ia32_vfmsubaddpd(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_macc_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_macc_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_msub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_msub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_nmacc_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmaddps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_nmacc_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmaddpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_nmsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfnmsubps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_nmsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfnmsubpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_maddsub_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmaddsubps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_maddsub_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmaddsubpd256(__A, __B, __C);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_msubadd_ps(__m256 __A, __m256 __B, __m256 __C)
{
  return (__m256)__builtin_ia32_vfmsubaddps256(__A, __B, __C);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("fma4")))
_mm256_msubadd_pd(__m256d __A, __m256d __B, __m256d __C)
{
  return (__m256d)__builtin_ia32_vfmsubaddpd256(__A, __B, __C);
}





static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maccs_epi16(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacssww((__v8hi)__A, (__v8hi)__B, (__v8hi)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_macc_epi16(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacsww((__v8hi)__A, (__v8hi)__B, (__v8hi)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maccsd_epi16(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacsswd((__v8hi)__A, (__v8hi)__B, (__v4si)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maccd_epi16(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacswd((__v8hi)__A, (__v8hi)__B, (__v4si)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maccs_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacssdd((__v4si)__A, (__v4si)__B, (__v4si)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_macc_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacsdd((__v4si)__A, (__v4si)__B, (__v4si)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maccslo_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacssdql((__v4si)__A, (__v4si)__B, (__v2di)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_macclo_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacsdql((__v4si)__A, (__v4si)__B, (__v2di)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maccshi_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacssdqh((__v4si)__A, (__v4si)__B, (__v2di)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_macchi_epi32(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmacsdqh((__v4si)__A, (__v4si)__B, (__v2di)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maddsd_epi16(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmadcsswd((__v8hi)__A, (__v8hi)__B, (__v4si)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_maddd_epi16(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpmadcswd((__v8hi)__A, (__v8hi)__B, (__v4si)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddw_epi8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddbw((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddd_epi8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddbd((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddq_epi8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddbq((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddd_epi16(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddwd((__v8hi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddq_epi16(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddwq((__v8hi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddq_epi32(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphadddq((__v4si)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddw_epu8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddubw((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddd_epu8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddubd((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddq_epu8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddubq((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddd_epu16(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphadduwd((__v8hi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddq_epu16(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphadduwq((__v8hi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_haddq_epu32(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphaddudq((__v4si)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_hsubw_epi8(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphsubbw((__v16qi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_hsubd_epi16(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphsubwd((__v8hi)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_hsubq_epi32(__m128i __A)
{
  return (__m128i)__builtin_ia32_vphsubdq((__v4si)__A);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_cmov_si128(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpcmov(__A, __B, __C);
}

static __inline__ __m256i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm256_cmov_si256(__m256i __A, __m256i __B, __m256i __C)
{
  return (__m256i)__builtin_ia32_vpcmov_256(__A, __B, __C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_perm_epi8(__m128i __A, __m128i __B, __m128i __C)
{
  return (__m128i)__builtin_ia32_vpperm((__v16qi)__A, (__v16qi)__B, (__v16qi)__C);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_rot_epi8(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vprotb((__v16qi)__A, (__v16qi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_rot_epi16(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vprotw((__v8hi)__A, (__v8hi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_rot_epi32(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vprotd((__v4si)__A, (__v4si)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_rot_epi64(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vprotq((__v2di)__A, (__v2di)__B);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_shl_epi8(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshlb((__v16qi)__A, (__v16qi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_shl_epi16(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshlw((__v8hi)__A, (__v8hi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_shl_epi32(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshld((__v4si)__A, (__v4si)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_shl_epi64(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshlq((__v2di)__A, (__v2di)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_sha_epi8(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshab((__v16qi)__A, (__v16qi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_sha_epi16(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshaw((__v8hi)__A, (__v8hi)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_sha_epi32(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshad((__v4si)__A, (__v4si)__B);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_sha_epi64(__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_vpshaq((__v2di)__A, (__v2di)__B);
}
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epu8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomub((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epu16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epu32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomud((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epu64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomuq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epi8(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomb((__v16qi)(__m128i)(__A), (__v16qi)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epi16(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomw((__v8hi)(__m128i)(__A), (__v8hi)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epi32(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomd((__v4si)(__m128i)(__A), (__v4si)(__m128i)(__B), (7)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comlt_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (0)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comle_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (1)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comgt_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (2)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comge_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (3)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comeq_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (4)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comneq_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (5)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comfalse_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (6)); });
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_comtrue_epi64(__m128i __A, __m128i __B)
{
  return __extension__ ({ (__m128i)__builtin_ia32_vpcomq((__v2di)(__m128i)(__A), (__v2di)(__m128i)(__B), (7)); });
}
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_frcz_ss(__m128 __A)
{
  return (__m128)__builtin_ia32_vfrczss((__v4sf)__A);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_frcz_sd(__m128d __A)
{
  return (__m128d)__builtin_ia32_vfrczsd((__v2df)__A);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_frcz_ps(__m128 __A)
{
  return (__m128)__builtin_ia32_vfrczps((__v4sf)__A);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm_frcz_pd(__m128d __A)
{
  return (__m128d)__builtin_ia32_vfrczpd((__v2df)__A);
}

static __inline__ __m256 __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm256_frcz_ps(__m256 __A)
{
  return (__m256)__builtin_ia32_vfrczps256((__v8sf)__A);
}

static __inline__ __m256d __attribute__((__always_inline__, __nodebug__, __target__("xop")))
_mm256_frcz_pd(__m256d __A)
{
  return (__m256d)__builtin_ia32_vfrczpd256((__v4df)__A);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcfill_u32(unsigned int a)
{
  return a & (a + 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blci_u32(unsigned int a)
{
  return a | ~(a + 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcic_u32(unsigned int a)
{
  return ~a & (a + 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcmsk_u32(unsigned int a)
{
  return a ^ (a + 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcs_u32(unsigned int a)
{
  return a | (a + 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blsfill_u32(unsigned int a)
{
  return a | (a - 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blsic_u32(unsigned int a)
{
  return ~a | (a - 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__t1mskc_u32(unsigned int a)
{
  return ~a | (a + 1);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__tzmsk_u32(unsigned int a)
{
  return ~a & (a - 1);
}






static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcfill_u64(unsigned long long a)
{
  return a & (a + 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blci_u64(unsigned long long a)
{
  return a | ~(a + 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcic_u64(unsigned long long a)
{
  return ~a & (a + 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcmsk_u64(unsigned long long a)
{
  return a ^ (a + 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blcs_u64(unsigned long long a)
{
  return a | (a + 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blsfill_u64(unsigned long long a)
{
  return a | (a - 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__blsic_u64(unsigned long long a)
{
  return ~a | (a - 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__t1mskc_u64(unsigned long long a)
{
  return ~a | (a + 1);
}

static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__, __target__("tbm")))
__tzmsk_u64(unsigned long long a)
{
  return ~a & (a - 1);
}



namespace std __attribute__ ((__visibility__ ("default")))
{
}



namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _ForwardIterator, typename _Tp>
    void
    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
    {





                                                     ;

      for (; __first != __last; ++__first)
 {
   *__first = __value;
   ++__value;
 }
    }


}



namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {


                                                     ;

      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = std::move(__tmp);
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;





                                                     ;

      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = std::move(__tmp);
 }
      return ++__result;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{



  namespace __detail
  {
    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
      _Tp
      _Mod<_Tp, __m, __a, __c, false, true>::
      __calc(_Tp __x)
      {
 if (__a == 1)
   __x %= __m;
 else
   {
     static const _Tp __q = __m / __a;
     static const _Tp __r = __m % __a;

     _Tp __t1 = __a * (__x % __q);
     _Tp __t2 = __r * (__x / __q);
     if (__t1 >= __t2)
       __x = __t1 - __t2;
     else
       __x = __m - __t2 + __t1;
   }

 if (__c != 0)
   {
     const _Tp __d = __m - __x;
     if (__d > __c)
       __x += __c;
     else
       __x = __c - __d;
   }
 return __x;
      }

    template<typename _InputIterator, typename _OutputIterator,
      typename _Tp>
      _OutputIterator
      __normalize(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, const _Tp& __factor)
      {
 for (; __first != __last; ++__first, ++__result)
   *__result = *__first / __factor;
 return __result;
      }


  }



  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    constexpr _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;





  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    void
    linear_congruential_engine<_UIntType, __a, __c, __m>::
    seed(result_type __s)
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
   && (__detail::__mod<_UIntType, __m>(__s) == 0))
 _M_x = 1;
      else
 _M_x = __detail::__mod<_UIntType, __m>(__s);
    }




  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      linear_congruential_engine<_UIntType, __a, __c, __m>::
      seed(_Sseq& __q)
      {
 const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits
                                 : std::__lg(__m);
 const _UIntType __k = (__k0 + 31) / 32;
 uint_least32_t __arr[__k + 3];
 __q.generate(__arr + 0, __arr + __k + 3);
 _UIntType __factor = 1u;
 _UIntType __sum = 0u;
 for (size_t __j = 0; __j < __k; ++__j)
   {
     __sum += __arr[__j + 3] * __factor;
     __factor *= __detail::_Shift<_UIntType, 32>::__value;
   }
 seed(__sum);
      }

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const linear_congruential_engine<_UIntType,
      __a, __c, __m>& __lcr)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__os.widen(' '));

      __os << __lcr._M_x;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        linear_congruential_engine<_UIntType, __a, __c, __m>& __lcr)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec);

      __is >> __lcr._M_x;

      __is.flags(__flags);
      return __is;
    }


  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::word_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::state_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::shift_size;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::mask_bits;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::xor_mask;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_u;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_d;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_s;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_b;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_t;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_c;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_l;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
                                              initialization_multiplier;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    constexpr _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::default_seed;

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    seed(result_type __sd)
    {
      _M_x[0] = __detail::__mod<_UIntType,
 __detail::_Shift<_UIntType, __w>::__value>(__sd);

      for (size_t __i = 1; __i < state_size; ++__i)
 {
   _UIntType __x = _M_x[__i - 1];
   __x ^= __x >> (__w - 2);
   __x *= __f;
   __x += __detail::__mod<_UIntType, __n>(__i);
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__x);
 }
      _M_p = state_size;
    }

  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         __s, __b, __t, __c, __l, __f>::
      seed(_Sseq& __q)
      {
 const _UIntType __upper_mask = (~_UIntType()) << __r;
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__n * __k];
 __q.generate(__arr + 0, __arr + __n * __k);

 bool __zero = true;
 for (size_t __i = 0; __i < state_size; ++__i)
   {
     _UIntType __factor = 1u;
     _UIntType __sum = 0u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);

     if (__zero)
       {
  if (__i == 0)
    {
      if ((_M_x[0] & __upper_mask) != 0u)
        __zero = false;
    }
  else if (_M_x[__i] != 0u)
    __zero = false;
       }
   }
        if (__zero)
          _M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
 _M_p = state_size;
      }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    _M_gen_rand(void)
    {
      const _UIntType __upper_mask = (~_UIntType()) << __r;
      const _UIntType __lower_mask = ~__upper_mask;

      for (size_t __k = 0; __k < (__n - __m); ++__k)
        {
   _UIntType __y = ((_M_x[__k] & __upper_mask)
      | (_M_x[__k + 1] & __lower_mask));
   _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
         ^ ((__y & 0x01) ? __a : 0));
        }

      for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
 {
   _UIntType __y = ((_M_x[__k] & __upper_mask)
      | (_M_x[__k + 1] & __lower_mask));
   _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
         ^ ((__y & 0x01) ? __a : 0));
 }

      _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
         | (_M_x[0] & __lower_mask));
      _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
         ^ ((__y & 0x01) ? __a : 0));
      _M_p = 0;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    discard(unsigned long long __z)
    {
      while (__z > state_size - _M_p)
 {
   __z -= state_size - _M_p;
   _M_gen_rand();
 }
      _M_p += __z;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    typename
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    operator()()
    {

      if (_M_p >= state_size)
 _M_gen_rand();


      result_type __z = _M_x[_M_p++];
      __z ^= (__z >> __u) & __d;
      __z ^= (__z << __s) & __b;
      __z ^= (__z << __t) & __c;
      __z ^= (__z >> __l);

      return __z;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      for (size_t __i = 0; __i < __n; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_p;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      for (size_t __i = 0; __i < __n; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_p;

      __is.flags(__flags);
      return __is;
    }


  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    constexpr _UIntType
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    void
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    seed(result_type __value)
    {
      std::linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
 __lcg(__value == 0u ? default_seed : __value);

      const size_t __n = (__w + 31) / 32;

      for (size_t __i = 0; __i < long_lag; ++__i)
 {
   _UIntType __sum = 0u;
   _UIntType __factor = 1u;
   for (size_t __j = 0; __j < __n; ++__j)
     {
       __sum += __detail::__mod<uint_least32_t,
         __detail::_Shift<uint_least32_t, 32>::__value>
    (__lcg()) * __factor;
       __factor *= __detail::_Shift<_UIntType, 32>::__value;
     }
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__sum);
 }
      _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
      _M_p = 0;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      seed(_Sseq& __q)
      {
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__r * __k];
 __q.generate(__arr + 0, __arr + __r * __k);

 for (size_t __i = 0; __i < long_lag; ++__i)
   {
     _UIntType __sum = 0u;
     _UIntType __factor = 1u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);
   }
 _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
 _M_p = 0;
      }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      result_type
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    operator()()
    {

      long __ps = _M_p - short_lag;
      if (__ps < 0)
 __ps += long_lag;




      _UIntType __xi;
      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)
 {
   __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;
   _M_carry = 0;
 }
      else
 {
   __xi = (__detail::_Shift<_UIntType, __w>::__value
    - _M_x[_M_p] - _M_carry + _M_x[__ps]);
   _M_carry = 1;
 }
      _M_x[_M_p] = __xi;


      if (++_M_p >= long_lag)
 _M_p = 0;

      return __xi;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const subtract_with_carry_engine<_UIntType,
      __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      for (size_t __i = 0; __i < __r; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_carry << __space << __x._M_p;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        subtract_with_carry_engine<_UIntType, __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      for (size_t __i = 0; __i < __r; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_carry;
      __is >> __x._M_p;

      __is.flags(__flags);
      return __is;
    }


  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    constexpr size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;

  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    constexpr size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;

  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    typename discard_block_engine<_RandomNumberEngine,
      __p, __r>::result_type
    discard_block_engine<_RandomNumberEngine, __p, __r>::
    operator()()
    {
      if (_M_n >= used_block)
 {
   _M_b.discard(block_size - _M_n);
   _M_n = 0;
 }
      ++_M_n;
      return _M_b();
    }

  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discard_block_engine<_RandomNumberEngine,
        __p, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      __os << __x.base() << __space << __x._M_n;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discard_block_engine<_RandomNumberEngine, __p, __r>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      __is >> __x._M_b >> __x._M_n;

      __is.flags(__flags);
      return __is;
    }


  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    typename independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
      result_type
    independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
    operator()()
    {
      typedef typename _RandomNumberEngine::result_type _Eresult_type;
      const _Eresult_type __r
 = (_M_b.max() - _M_b.min() < std::numeric_limits<_Eresult_type>::max()
    ? _M_b.max() - _M_b.min() + 1 : 0);
      const unsigned __edig = std::numeric_limits<_Eresult_type>::digits;
      const unsigned __m = __r ? std::__lg(__r) : __edig;

      typedef typename std::common_type<_Eresult_type, result_type>::type
 __ctype;
      const unsigned __cdig = std::numeric_limits<__ctype>::digits;

      unsigned __n, __n0;
      __ctype __s0, __s1, __y0, __y1;

      for (size_t __i = 0; __i < 2; ++__i)
 {
   __n = (__w + __m - 1) / __m + __i;
   __n0 = __n - __w % __n;
   const unsigned __w0 = __w / __n;

   __s0 = 0;
   __s1 = 0;
   if (__w0 < __cdig)
     {
       __s0 = __ctype(1) << __w0;
       __s1 = __s0 << 1;
     }

   __y0 = 0;
   __y1 = 0;
   if (__r)
     {
       __y0 = __s0 * (__r / __s0);
       if (__s1)
  __y1 = __s1 * (__r / __s1);

       if (__r - __y0 <= __y0 / __n)
  break;
     }
   else
     break;
 }

      result_type __sum = 0;
      for (size_t __k = 0; __k < __n0; ++__k)
 {
   __ctype __u;
   do
     __u = _M_b() - _M_b.min();
   while (__y0 && __u >= __y0);
   __sum = __s0 * __sum + (__s0 ? __u % __s0 : __u);
 }
      for (size_t __k = __n0; __k < __n; ++__k)
 {
   __ctype __u;
   do
     __u = _M_b() - _M_b.min();
   while (__y1 && __u >= __y1);
   __sum = __s1 * __sum + (__s1 ? __u % __s1 : __u);
 }
      return __sum;
    }


  template<typename _RandomNumberEngine, size_t __k>
    constexpr size_t
    shuffle_order_engine<_RandomNumberEngine, __k>::table_size;

  template<typename _RandomNumberEngine, size_t __k>
    typename shuffle_order_engine<_RandomNumberEngine, __k>::result_type
    shuffle_order_engine<_RandomNumberEngine, __k>::
    operator()()
    {
      size_t __j = __k * ((_M_y - _M_b.min())
     / (_M_b.max() - _M_b.min() + 1.0L));
      _M_y = _M_v[__j];
      _M_v[__j] = _M_b();

      return _M_y;
    }

  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);

      __os << __x.base();
      for (size_t __i = 0; __i < __k; ++__i)
 __os << __space << __x._M_v[__i];
      __os << __space << __x._M_y;

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      __is >> __x._M_b;
      for (size_t __i = 0; __i < __k; ++__i)
 __is >> __x._M_v[__i];
      __is >> __x._M_y;

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_int_distribution<_IntType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_real_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 auto __range = __p.b() - __p.a();
 while (__f != __t)
   *__f++ = __aurng() * __range + __p.a();
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_real_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _ForwardIterator,
    typename _UniformRandomNumberGenerator>
    void
    std::bernoulli_distribution::
    __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
      _UniformRandomNumberGenerator& __urng,
      const param_type& __p)
    {

      __detail::_Adaptor<_UniformRandomNumberGenerator, double>
 __aurng(__urng);
      auto __limit = __p.p() * (__aurng.max() - __aurng.min());

      while (__f != __t)
 *__f++ = (__aurng() - __aurng.min()) < __limit;
    }

  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bernoulli_distribution& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.p();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename geometric_distribution<_IntType>::result_type
      geometric_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {


 const double __naf =
   (1 - std::numeric_limits<double>::epsilon()) / 2;

 const double __thr =
   std::numeric_limits<_IntType>::max() + __naf;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 double __cand;
 do
   __cand = std::floor(std::log(1.0 - __aurng()) / __param._M_log_1_p);
 while (__cand >= __thr);

 return result_type(__cand + __naf);
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      geometric_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {



 const double __naf =
   (1 - std::numeric_limits<double>::epsilon()) / 2;

 const double __thr =
   std::numeric_limits<_IntType>::max() + __naf;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 while (__f != __t)
   {
     double __cand;
     do
       __cand = std::floor(std::log(1.0 - __aurng())
      / __param._M_log_1_p);
     while (__cand >= __thr);

     *__f++ = __cand + __naf;
   }
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.p();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __p;
      __is >> __p;
      __x.param(typename geometric_distribution<_IntType>::param_type(__p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng)
      {
 const double __y = _M_gd(__urng);


 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 typedef typename std::gamma_distribution<double>::param_type
   param_type;

 const double __y =
   _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));

 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      negative_binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   {
     const double __y = _M_gd(__urng);


     std::poisson_distribution<result_type> __poisson(__y);
     *__f++ = __poisson(__urng);
   }
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      negative_binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 typename std::gamma_distribution<result_type>::param_type
   __p2(__p.k(), (1.0 - __p.p()) / __p.p());

 while (__f != __t)
   {
     const double __y = _M_gd(__urng, __p2);

     std::poisson_distribution<result_type> __poisson(__y);
     *__f++ = __poisson(__urng);
   }
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.k() << __space << __x.p()
    << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _IntType __k;
      double __p;
      __is >> __k >> __p >> __x._M_gd;
      __x.param(typename negative_binomial_distribution<_IntType>::
  param_type(__k, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    poisson_distribution<_IntType>::param_type::
    _M_initialize()
    {

      if (_M_mean >= 12)
 {
   const double __m = std::floor(_M_mean);
   _M_lm_thr = std::log(_M_mean);
   _M_lfm = std::lgamma(__m + 1);
   _M_sm = std::sqrt(__m);

   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __dx = std::sqrt(2 * __m * std::log(32 * __m
             / __pi_4));
   _M_d = std::round(std::max(6.0, std::min(__m, __dx)));
   const double __cx = 2 * __m + _M_d;
   _M_scx = std::sqrt(__cx / 2);
   _M_1cx = 1 / __cx;

   _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
   _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
  / _M_d;
 }
      else

 _M_lm_thr = std::exp(-_M_mean);
      }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename poisson_distribution<_IntType>::result_type
      poisson_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 if (__param.mean() >= 12)
   {
     double __x;


     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;

     const double __m = std::floor(__param.mean());

     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __c1 = __param._M_sm * __spi_2;
     const double __c2 = __param._M_c2b + __c1;
     const double __c3 = __c2 + 1;
     const double __c4 = __c3 + 1;

     const double __e178 = 1.0129030479320018583185514777512983L;
     const double __c5 = __c4 + __e178;
     const double __c = __param._M_cb + __c5;
     const double __2cx = 2 * (2 * __m + __param._M_d);

     bool __reject = true;
     do
       {
  const double __u = __c * __aurng();
  const double __e = -std::log(1.0 - __aurng());

  double __w = 0.0;

  if (__u <= __c1)
    {
      const double __n = _M_nd(__urng);
      const double __y = -std::abs(__n) * __param._M_sm - 1;
      __x = std::floor(__y);
      __w = -__n * __n / 2;
      if (__x < -__m)
        continue;
    }
  else if (__u <= __c2)
    {
      const double __n = _M_nd(__urng);
      const double __y = 1 + std::abs(__n) * __param._M_scx;
      __x = std::ceil(__y);
      __w = __y * (2 - __y) * __param._M_1cx;
      if (__x > __param._M_d)
        continue;
    }
  else if (__u <= __c3)


    __x = -1;
  else if (__u <= __c4)
    __x = 0;
  else if (__u <= __c5)
    __x = 1;
  else
    {
      const double __v = -std::log(1.0 - __aurng());
      const double __y = __param._M_d
         + __v * __2cx / __param._M_d;
      __x = std::ceil(__y);
      __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
    }

  __reject = (__w - __e - __x * __param._M_lm_thr
       > __param._M_lfm - std::lgamma(__x + __m + 1));

  __reject |= __x + __m >= __thr;

       } while (__reject);

     return result_type(__x + __m + __naf);
   }
 else

   {
     _IntType __x = 0;
     double __prod = 1.0;

     do
       {
  __prod *= __aurng();
  __x += 1;
       }
     while (__prod > __param._M_lm_thr);

     return __x - 1;
   }
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      poisson_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 while (__f != __t)
   *__f++ = this->operator()(__urng, __param);
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.mean() << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __mean;
      __is >> __mean >> __x._M_nd;
      __x.param(typename poisson_distribution<_IntType>::param_type(__mean));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    binomial_distribution<_IntType>::param_type::
    _M_initialize()
    {
      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;

      _M_easy = true;


      if (_M_t * __p12 >= 8)
 {
   _M_easy = false;
   const double __np = std::floor(_M_t * __p12);
   const double __pa = __np / _M_t;
   const double __1p = 1 - __pa;

   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __d1x =
     std::sqrt(__np * __1p * std::log(32 * __np
          / (81 * __pi_4 * __1p)));
   _M_d1 = std::round(std::max(1.0, __d1x));
   const double __d2x =
     std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
          / (__pi_4 * __pa)));
   _M_d2 = std::round(std::max(1.0, __d2x));


   const double __spi_2 = 1.2533141373155002512078826424055226L;
   _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
   _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * _M_t * __1p));
   _M_c = 2 * _M_d1 / __np;
   _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
   const double __a12 = _M_a1 + _M_s2 * __spi_2;
   const double __s1s = _M_s1 * _M_s1;
   _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
        * 2 * __s1s / _M_d1
        * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
   const double __s2s = _M_s2 * _M_s2;
   _M_s = (_M_a123 + 2 * __s2s / _M_d2
    * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
   _M_lf = (std::lgamma(__np + 1)
     + std::lgamma(_M_t - __np + 1));
   _M_lp1p = std::log(__pa / __1p);

   _M_q = -std::log(1 - (__p12 - __pa) / __1p);
 }
      else

 _M_q = -std::log(1 - __p12);
    }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      _M_waiting(_UniformRandomNumberGenerator& __urng,
   _IntType __t, double __q)
      {
 _IntType __x = 0;
 double __sum = 0.0;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 do
   {
     if (__t == __x)
       return __x;
     const double __e = -std::log(1.0 - __aurng());
     __sum += __e / (__t - __x);
     __x += 1;
   }
 while (__sum <= __q);

 return __x - 1;
      }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 const _IntType __t = __param.t();
 const double __p = __param.p();
 const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);


 if (!__param._M_easy)
   {
     double __x;


     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;

     const double __np = std::floor(__t * __p12);


     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __a1 = __param._M_a1;
     const double __a12 = __a1 + __param._M_s2 * __spi_2;
     const double __a123 = __param._M_a123;
     const double __s1s = __param._M_s1 * __param._M_s1;
     const double __s2s = __param._M_s2 * __param._M_s2;

     bool __reject;
     do
       {
  const double __u = __param._M_s * __aurng();

  double __v;

  if (__u <= __a1)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s1 * std::abs(__n);
      __reject = __y >= __param._M_d1;
      if (!__reject)
        {
   const double __e = -std::log(1.0 - __aurng());
   __x = std::floor(__y);
   __v = -__e - __n * __n / 2 + __param._M_c;
        }
    }
  else if (__u <= __a12)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s2 * std::abs(__n);
      __reject = __y >= __param._M_d2;
      if (!__reject)
        {
   const double __e = -std::log(1.0 - __aurng());
   __x = std::floor(-__y);
   __v = -__e - __n * __n / 2;
        }
    }
  else if (__u <= __a123)
    {
      const double __e1 = -std::log(1.0 - __aurng());
      const double __e2 = -std::log(1.0 - __aurng());

      const double __y = __param._M_d1
         + 2 * __s1s * __e1 / __param._M_d1;
      __x = std::floor(__y);
      __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
          -__y / (2 * __s1s)));
      __reject = false;
    }
  else
    {
      const double __e1 = -std::log(1.0 - __aurng());
      const double __e2 = -std::log(1.0 - __aurng());

      const double __y = __param._M_d2
         + 2 * __s2s * __e1 / __param._M_d2;
      __x = std::floor(-__y);
      __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
      __reject = false;
    }

  __reject = __reject || __x < -__np || __x > __t - __np;
  if (!__reject)
    {
      const double __lfx =
        std::lgamma(__np + __x + 1)
        + std::lgamma(__t - (__np + __x) + 1);
      __reject = __v > __param._M_lf - __lfx
        + __x * __param._M_lp1p;
    }

  __reject |= __x + __np >= __thr;
       }
     while (__reject);

     __x += __np + __naf;

     const _IntType __z = _M_waiting(__urng, __t - _IntType(__x),
         __param._M_q);
     __ret = _IntType(__x) + __z;
   }
 else

   __ret = _M_waiting(__urng, __t, __param._M_q);

 if (__p12 != __p)
   __ret = __t - __ret;
 return __ret;
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 while (__f != __t)
   *__f++ = this->operator()(__urng, __param);
      }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.t() << __space << __x.p()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __t;
      double __p;
      __is >> __t >> __p >> __x._M_nd;
      __x.param(typename binomial_distribution<_IntType>::
  param_type(__t, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::exponential_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 while (__f != __t)
   *__f++ = -std::log(result_type(1) - __aurng()) / __p.lambda();
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.lambda();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __lambda;
      __is >> __lambda;
      __x.param(typename exponential_distribution<_RealType>::
  param_type(__lambda));

      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename normal_distribution<_RealType>::result_type
      normal_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 if (_M_saved_available)
   {
     _M_saved_available = false;
     __ret = _M_saved;
   }
 else
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     _M_saved = __x * __mult;
     _M_saved_available = true;
     __ret = __y * __mult;
   }

 __ret = __ret * __param.stddev() + __param.mean();
 return __ret;
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      normal_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 if (__f == __t)
   return;

 if (_M_saved_available)
   {
     _M_saved_available = false;
     *__f++ = _M_saved * __param.stddev() + __param.mean();

     if (__f == __t)
       return;
   }

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 while (__f + 1 < __t)
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     *__f++ = __y * __mult * __param.stddev() + __param.mean();
     *__f++ = __x * __mult * __param.stddev() + __param.mean();
   }

 if (__f != __t)
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);

     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     _M_saved = __x * __mult;
     _M_saved_available = true;
     *__f = __y * __mult * __param.stddev() + __param.mean();
   }
      }

  template<typename _RealType>
    bool
    operator==(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    {
      if (__d1._M_param == __d2._M_param
   && __d1._M_saved_available == __d2._M_saved_available)
 {
   if (__d1._M_saved_available
       && __d1._M_saved == __d2._M_saved)
     return true;
   else if(!__d1._M_saved_available)
     return true;
   else
     return false;
 }
      else
 return false;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const normal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.mean() << __space << __x.stddev()
    << __space << __x._M_saved_available;
      if (__x._M_saved_available)
 __os << __space << __x._M_saved;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        normal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      double __mean, __stddev;
      __is >> __mean >> __stddev
    >> __x._M_saved_available;
      if (__x._M_saved_available)
 __is >> __x._M_saved;
      __x.param(typename normal_distribution<_RealType>::
  param_type(__mean, __stddev));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      lognormal_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

   while (__f != __t)
     *__f++ = std::exp(__p.s() * _M_nd(__urng) + __p.m());
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.s()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __s;
      __is >> __m >> __s >> __x._M_nd;
      __x.param(typename lognormal_distribution<_RealType>::
  param_type(__m, __s));

      __is.flags(__flags);
      return __is;
    }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::chi_squared_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   *__f++ = 2 * _M_gd(__urng);
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::chi_squared_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const typename
        std::gamma_distribution<result_type>::param_type& __p)
      {

 while (__f != __t)
   *__f++ = 2 * _M_gd(__urng, __p);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __n;
      __is >> __n >> __x._M_gd;
      __x.param(typename chi_squared_distribution<_RealType>::
  param_type(__n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename cauchy_distribution<_RealType>::result_type
      cauchy_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 _RealType __u;
 do
   __u = __aurng();
 while (__u == 0.5);

 const _RealType __pi = 3.1415926535897932384626433832795029L;
 return __p.a() + __p.b() * std::tan(__pi * __u);
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      cauchy_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 const _RealType __pi = 3.1415926535897932384626433832795029L;
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 while (__f != __t)
   {
     _RealType __u;
     do
       __u = __aurng();
     while (__u == 0.5);

     *__f++ = __p.a() + __p.b() * std::tan(__pi * __u);
   }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename cauchy_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::fisher_f_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   *__f++ = ((_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()));
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::fisher_f_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 typedef typename std::gamma_distribution<result_type>::param_type
   param_type;
 param_type __p1(__p.m() / 2);
 param_type __p2(__p.n() / 2);
 while (__f != __t)
   *__f++ = ((_M_gd_x(__urng, __p1) * n())
      / (_M_gd_y(__urng, __p2) * m()));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.n()
    << __space << __x._M_gd_x << __space << __x._M_gd_y;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __n;
      __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
      __x.param(typename fisher_f_distribution<_RealType>::
  param_type(__m, __n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::student_t_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng)
      {

 while (__f != __t)
   *__f++ = _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng));
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      std::student_t_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 typename std::gamma_distribution<result_type>::param_type
   __p2(__p.n() / 2, 2);
 while (__f != __t)
   *__f++ = _M_nd(__urng) * std::sqrt(__p.n() / _M_gd(__urng, __p2));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __n;
      __is >> __n >> __x._M_nd >> __x._M_gd;
      __x.param(typename student_t_distribution<_RealType>::param_type(__n));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    gamma_distribution<_RealType>::param_type::
    _M_initialize()
    {
      _M_malpha = _M_alpha < 1.0 ? _M_alpha + _RealType(1.0) : _M_alpha;

      const _RealType __a1 = _M_malpha - _RealType(1.0) / _RealType(3.0);
      _M_a2 = _RealType(1.0) / std::sqrt(_RealType(9.0) * __a1);
    }






  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename gamma_distribution<_RealType>::result_type
      gamma_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 result_type __u, __v, __n;
 const result_type __a1 = (__param._M_malpha
      - _RealType(1.0) / _RealType(3.0));

 do
   {
     do
       {
  __n = _M_nd(__urng);
  __v = result_type(1.0) + __param._M_a2 * __n;
       }
     while (__v <= 0.0);

     __v = __v * __v * __v;
     __u = __aurng();
   }
 while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
        && (std::log(__u) > (0.5 * __n * __n + __a1
        * (1.0 - __v + std::log(__v)))));

 if (__param.alpha() == __param._M_malpha)
   return __a1 * __v * __param.beta();
 else
   {
     do
       __u = __aurng();
     while (__u == 0.0);

     return (std::pow(__u, result_type(1.0) / __param.alpha())
      * __a1 * __v * __param.beta());
   }
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      gamma_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 result_type __u, __v, __n;
 const result_type __a1 = (__param._M_malpha
      - _RealType(1.0) / _RealType(3.0));

 if (__param.alpha() == __param._M_malpha)
   while (__f != __t)
     {
       do
  {
    do
      {
        __n = _M_nd(__urng);
        __v = result_type(1.0) + __param._M_a2 * __n;
      }
    while (__v <= 0.0);

    __v = __v * __v * __v;
    __u = __aurng();
  }
       while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
       && (std::log(__u) > (0.5 * __n * __n + __a1
       * (1.0 - __v + std::log(__v)))));

       *__f++ = __a1 * __v * __param.beta();
     }
 else
   while (__f != __t)
     {
       do
  {
    do
      {
        __n = _M_nd(__urng);
        __v = result_type(1.0) + __param._M_a2 * __n;
      }
    while (__v <= 0.0);

    __v = __v * __v * __v;
    __u = __aurng();
  }
       while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
       && (std::log(__u) > (0.5 * __n * __n + __a1
       * (1.0 - __v + std::log(__v)))));

       do
  __u = __aurng();
       while (__u == 0.0);

       *__f++ = (std::pow(__u, result_type(1.0) / __param.alpha())
   * __a1 * __v * __param.beta());
     }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.alpha() << __space << __x.beta()
    << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __alpha_val, __beta_val;
      __is >> __alpha_val >> __beta_val >> __x._M_nd;
      __x.param(typename gamma_distribution<_RealType>::
  param_type(__alpha_val, __beta_val));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename weibull_distribution<_RealType>::result_type
      weibull_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
      result_type(1) / __p.a());
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      weibull_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 auto __inv_a = result_type(1) / __p.a();

 while (__f != __t)
   *__f++ = __p.b() * std::pow(-std::log(result_type(1) - __aurng()),
          __inv_a);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename weibull_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename extreme_value_distribution<_RealType>::result_type
      extreme_value_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.a() - __p.b() * std::log(-std::log(result_type(1)
            - __aurng()));
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      extreme_value_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __p)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);

 while (__f != __t)
   *__f++ = __p.a() - __p.b() * std::log(-std::log(result_type(1)
         - __aurng()));
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.a() << __space << __x.b();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename extreme_value_distribution<_RealType>::
  param_type(__a, __b));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    discrete_distribution<_IntType>::param_type::
    _M_initialize()
    {
      if (_M_prob.size() < 2)
 {
   _M_prob.clear();
   return;
 }

      const double __sum = std::accumulate(_M_prob.begin(),
        _M_prob.end(), 0.0);

      __detail::__normalize(_M_prob.begin(), _M_prob.end(), _M_prob.begin(),
       __sum);

      _M_cp.reserve(_M_prob.size());
      std::partial_sum(_M_prob.begin(), _M_prob.end(),
         std::back_inserter(_M_cp));

      _M_cp[_M_cp.size() - 1] = 1.0;
    }

  template<typename _IntType>
    template<typename _Func>
      discrete_distribution<_IntType>::param_type::
      param_type(size_t __nw, double __xmin, double __xmax, _Func __fw)
      : _M_prob(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const double __delta = (__xmax - __xmin) / __n;

 _M_prob.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_prob.push_back(__fw(__xmin + __k * __delta + 0.5 * __delta));

 _M_initialize();
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename discrete_distribution<_IntType>::result_type
      discrete_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 if (__param._M_cp.empty())
   return result_type(0);

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);

 return __pos - __param._M_cp.begin();
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      discrete_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 if (__param._M_cp.empty())
   {
     while (__f != __t)
       *__f++ = result_type(0);
     return;
   }

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 while (__f != __t)
   {
     const double __p = __aurng();
     auto __pos = std::lower_bound(__param._M_cp.begin(),
       __param._M_cp.end(), __p);

     *__f++ = __pos - __param._M_cp.begin();
   }
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      std::vector<double> __prob = __x.probabilities();
      __os << __prob.size();
      for (auto __dit = __prob.begin(); __dit != __prob.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<double> __prob_vec;
      __prob_vec.reserve(__n);
      for (; __n != 0; --__n)
 {
   double __prob;
   __is >> __prob;
   __prob_vec.push_back(__prob);
 }

      __x.param(typename discrete_distribution<_IntType>::
  param_type(__prob_vec.begin(), __prob_vec.end()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    piecewise_constant_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2
   || (_M_int.size() == 2
       && _M_int[0] == _RealType(0)
       && _M_int[1] == _RealType(1)))
 {
   _M_int.clear();
   _M_den.clear();
   return;
 }

      const double __sum = std::accumulate(_M_den.begin(),
        _M_den.end(), 0.0);

      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
       __sum);

      _M_cp.reserve(_M_den.size());
      std::partial_sum(_M_den.begin(), _M_den.end(),
         std::back_inserter(_M_cp));


      _M_cp[_M_cp.size() - 1] = 1.0;

      for (size_t __k = 0; __k < _M_den.size(); ++__k)
 _M_den[__k] /= _M_int[__k + 1] - _M_int[__k];
    }

  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp()
      {
 if (__bbegin != __bend)
   {
     for (;;)
       {
  _M_int.push_back(*__bbegin);
  ++__bbegin;
  if (__bbegin == __bend)
    break;

  _M_den.push_back(*__wbegin);
  ++__wbegin;
       }
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 _M_int.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   _M_int.push_back(*__biter);

 _M_den.reserve(_M_int.size() - 1);
 for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
   _M_den.push_back(__fw(0.5 * (_M_int[__k + 1] + _M_int[__k])));

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;

 _M_int.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   _M_int.push_back(__xmin + __k * __delta);

 _M_den.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_den.push_back(__fw(_M_int[__k] + 0.5 * __delta));

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_constant_distribution<_RealType>::result_type
      piecewise_constant_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 if (__param._M_cp.empty())
   return __p;

 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();

 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

 return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      piecewise_constant_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 if (__param._M_cp.empty())
   {
     while (__f != __t)
       *__f++ = __aurng();
     return;
   }

 while (__f != __t)
   {
     const double __p = __aurng();

     auto __pos = std::lower_bound(__param._M_cp.begin(),
       __param._M_cp.end(), __p);
     const size_t __i = __pos - __param._M_cp.begin();

     const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

     *__f++ = (__param._M_int[__i]
        + (__p - __pref) / __param._M_den[__i]);
   }
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;

      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;

      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }

      std::vector<double> __den_vec;
      __den_vec.reserve(__n);
      for (size_t __i = 0; __i < __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }

      __x.param(typename piecewise_constant_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    void
    piecewise_linear_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2
   || (_M_int.size() == 2
       && _M_int[0] == _RealType(0)
       && _M_int[1] == _RealType(1)
       && _M_den[0] == _M_den[1]))
 {
   _M_int.clear();
   _M_den.clear();
   return;
 }

      double __sum = 0.0;
      _M_cp.reserve(_M_int.size() - 1);
      _M_m.reserve(_M_int.size() - 1);
      for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
 {
   const _RealType __delta = _M_int[__k + 1] - _M_int[__k];
   __sum += 0.5 * (_M_den[__k + 1] + _M_den[__k]) * __delta;
   _M_cp.push_back(__sum);
   _M_m.push_back((_M_den[__k + 1] - _M_den[__k]) / __delta);
 }


      __detail::__normalize(_M_den.begin(), _M_den.end(), _M_den.begin(),
       __sum);

      __detail::__normalize(_M_cp.begin(), _M_cp.end(), _M_cp.begin(), __sum);

      __detail::__normalize(_M_m.begin(), _M_m.end(), _M_m.begin(), __sum);


      _M_cp[_M_cp.size() - 1] = 1.0;
     }

  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 for (; __bbegin != __bend; ++__bbegin, ++__wbegin)
   {
     _M_int.push_back(*__bbegin);
     _M_den.push_back(*__wbegin);
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 _M_int.reserve(__bl.size());
 _M_den.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   {
     _M_int.push_back(*__biter);
     _M_den.push_back(__fw(*__biter));
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;

 _M_int.reserve(__n + 1);
 _M_den.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   {
     _M_int.push_back(__xmin + __k * __delta);
     _M_den.push_back(__fw(_M_int[__k] + __delta));
   }

 _M_initialize();
      }

  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_linear_distribution<_RealType>::result_type
      piecewise_linear_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);

 const double __p = __aurng();
 if (__param._M_cp.empty())
   return __p;

 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();

 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;

 const double __a = 0.5 * __param._M_m[__i];
 const double __b = __param._M_den[__i];
 const double __cm = __p - __pref;

 _RealType __x = __param._M_int[__i];
 if (__a == 0)
   __x += __cm / __b;
 else
   {
     const double __d = __b * __b + 4.0 * __a * __cm;
     __x += 0.5 * (std::sqrt(__d) - __b) / __a;
          }

        return __x;
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      piecewise_linear_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {


 while (__f != __t)
   *__f++ = this->operator()(__urng, __param);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;

      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;

      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      size_t __n;
      __is >> __n;

      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }

      std::vector<double> __den_vec;
      __den_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }

      __x.param(typename piecewise_linear_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    seed_seq::seed_seq(std::initializer_list<_IntType> __il)
    {
      for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }

  template<typename _InputIterator>
    seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
    {
      for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }

  template<typename _RandomAccessIterator>
    void
    seed_seq::generate(_RandomAccessIterator __begin,
         _RandomAccessIterator __end)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
        _Type;

      if (__begin == __end)
 return;

      std::fill(__begin, __end, _Type(0x8b8b8b8bu));

      const size_t __n = __end - __begin;
      const size_t __s = _M_v.size();
      const size_t __t = (__n >= 623) ? 11
         : (__n >= 68) ? 7
         : (__n >= 39) ? 5
         : (__n >= 7) ? 3
         : (__n - 1) / 2;
      const size_t __p = (__n - __t) / 2;
      const size_t __q = __p + __t;
      const size_t __m = std::max(size_t(__s + 1), __n);

      for (size_t __k = 0; __k < __m; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    ^ __begin[(__k + __p) % __n]
    ^ __begin[(__k - 1) % __n]);
   _Type __r1 = __arg ^ (__arg >> 27);
   __r1 = __detail::__mod<_Type,
      __detail::_Shift<_Type, 32>::__value>(1664525u * __r1);
   _Type __r2 = __r1;
   if (__k == 0)
     __r2 += __s;
   else if (__k <= __s)
     __r2 += __k % __n + _M_v[__k - 1];
   else
     __r2 += __k % __n;
   __r2 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r2);
   __begin[(__k + __p) % __n] += __r1;
   __begin[(__k + __q) % __n] += __r2;
   __begin[__k % __n] = __r2;
 }

      for (size_t __k = __m; __k < __m + __n; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    + __begin[(__k + __p) % __n]
    + __begin[(__k - 1) % __n]);
   _Type __r3 = __arg ^ (__arg >> 27);
   __r3 = __detail::__mod<_Type,
     __detail::_Shift<_Type, 32>::__value>(1566083941u * __r3);
   _Type __r4 = __r3 - __k % __n;
   __r4 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r4);
   __begin[(__k + __p) % __n] ^= __r3;
   __begin[(__k + __q) % __n] ^= __r4;
   __begin[__k % __n] = __r4;
 }
    }

  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __urng)
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");

      const size_t __b
 = std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                   __bits);
      const long double __r = static_cast<long double>(__urng.max())
       - static_cast<long double>(__urng.min()) + 1.0L;
      const size_t __log2r = std::log(__r) / std::log(2.0L);
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
 {
   __sum += _RealType(__urng() - __urng.min()) * __tmp;
   __tmp *= __r;
 }
      return __sum / __tmp;
    }


}




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
         return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
           typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {




                                                     ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {






                                                     ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {





      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {
                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
        if (!__pred(__first))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {




      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
                                                     ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
                                                     ;
                                                                   ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                                  ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





                                                                  ;
                                                                  ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
                    ;

                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                                  ;
                                                                  ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {





                                                  ;
                                                 ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {






                                                               ;
                                                              ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result));


    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
                                                                ;
                                                                ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
                                                                             ;
                                                                             ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, ++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {





                                                     ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {



      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                : pair<const _Tp&, const _Tp&>(__a, __b);
    }
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                       : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {





                                                     ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {






                                                       ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, ++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
                                                       ;
                                                       ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
                                                       ;
                                                       ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {



                                                     ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {





                                                       ;
                                                      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {






                                                       ;
                                                      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
                                                                ;
                                                                ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
                                                                             ;
                                                                             ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






                                                     ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
                                                                ;
                                                                ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
                                                                             ;
                                                                             ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
                                                                ;
                                                                ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
                                                                             ;
                                                                             ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
                                                                ;
                                                                ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
                                                                             ;
                                                                             ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
                                                                ;
                                                                ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
                                                                             ;
                                                                             ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


}
namespace Urho3D
{


template <class T> class Vector : public VectorBase
{
    struct CopyTag {};
    struct MoveTag {};

public:
    using ValueType = T;
    using Iterator = RandomAccessIterator<T>;
    using ConstIterator = RandomAccessConstIterator<T>;


    Vector() noexcept = default;


    explicit Vector(unsigned size)
    {
        Resize(size);
    }


    Vector(unsigned size, const T& value)
    {
        Resize(size);
        for (unsigned i = 0; i < size; ++i)
            At(i) = value;
    }


    Vector(const T* data, unsigned size)
    {
        DoInsertElements(0, data, data + size, CopyTag{});
    }


    Vector(const Vector<T>& vector)
    {
        DoInsertElements(0, vector.Begin(), vector.End(), CopyTag{});
    }


    Vector(Vector<T> && vector)
    {
        Swap(vector);
    }


    Vector(const std::initializer_list<T>& list) : Vector()
    {
        for (auto it = list.begin(); it != list.end(); it++)
        {
            Push(*it);
        }
    }


    ~Vector()
    {
        DestructElements(Buffer(), size_);
        delete[] buffer_;
    }


    Vector<T>& operator =(const Vector<T>& rhs)
    {

        if (&rhs != this)
        {
            Vector<T> copy(rhs);
            Swap(copy);
        }
        return *this;
    }


    Vector<T>& operator =(Vector<T> && rhs)
    {
        ((&rhs != this) ? static_cast<void> (0) : __assert_fail ("&rhs != this", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 119, __PRETTY_FUNCTION__));
        Swap(rhs);
        return *this;
    }


    Vector<T>& operator +=(const T& rhs)
    {
        Push(rhs);
        return *this;
    }


    Vector<T>& operator +=(const Vector<T>& rhs)
    {
        Push(rhs);
        return *this;
    }


    Vector<T> operator +(const T& rhs) const
    {
        Vector<T> ret(*this);
        ret.Push(rhs);
        return ret;
    }


    Vector<T> operator +(const Vector<T>& rhs) const
    {
        Vector<T> ret(*this);
        ret.Push(rhs);
        return ret;
    }


    bool operator ==(const Vector<T>& rhs) const
    {
        if (rhs.size_ != size_)
            return false;

        T* buffer = Buffer();
        T* rhsBuffer = rhs.Buffer();
        for (unsigned i = 0; i < size_; ++i)
        {
            if (buffer[i] != rhsBuffer[i])
                return false;
        }

        return true;
    }


    bool operator !=(const Vector<T>& rhs) const
    {
        if (rhs.size_ != size_)
            return true;

        T* buffer = Buffer();
        T* rhsBuffer = rhs.Buffer();
        for (unsigned i = 0; i < size_; ++i)
        {
            if (buffer[i] != rhsBuffer[i])
                return true;
        }

        return false;
    }


    T& operator [](unsigned index)
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 191, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    const T& operator [](unsigned index) const
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 198, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    T& At(unsigned index)
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 205, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    const T& At(unsigned index) const
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 212, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    template <class... Args> T& EmplaceBack(Args&&... args)
    {
        if (size_ < capacity_)
        {

            ++size_;
            new (&Back()) T(std::forward<Args>(args)...);
        }
        else
        {
            T value(std::forward<Args>(args)...);
            Push(std::move(value));
        }
        return Back();
    }



    void Push(const T& value)
    {
        if (size_ < capacity_)
        {

            ++size_;
            new (&Back()) T(value);
        }
        else
            DoInsertElements(size_, &value, &value + 1, CopyTag{});
    }


    void Push(T && value)
    {
        if (size_ < capacity_)
        {

            ++size_;
            new (&Back()) T(std::move(value));
        }
        else
            DoInsertElements(size_, &value, &value + 1, MoveTag{});
    }
    void Push(const Vector<T>& vector) { DoInsertElements(size_, vector.Begin(), vector.End(), CopyTag{}); }


    void Pop()
    {
        if (size_)
            Resize(size_ - 1);
    }


    void Insert(unsigned pos, const T& value)
    {
        DoInsertElements(pos, &value, &value + 1, CopyTag{});
    }


    void Insert(unsigned pos, T && value)
    {
        DoInsertElements(pos, &value, &value + 1, MoveTag{});
    }


    void Insert(unsigned pos, const Vector<T>& vector)
    {
        DoInsertElements(pos, vector.Begin(), vector.End(), CopyTag{});
    }


    Iterator Insert(const Iterator& dest, const T& value)
    {
        auto pos = (unsigned)(dest - Begin());
        return DoInsertElements(pos, &value, &value + 1, CopyTag{});
    }


    Iterator Insert(const Iterator& dest, T && value)
    {
        auto pos = (unsigned)(dest - Begin());
        return DoInsertElements(pos, &value, &value + 1, MoveTag{});
    }


    Iterator Insert(const Iterator& dest, const Vector<T>& vector)
    {
        auto pos = (unsigned)(dest - Begin());
        return DoInsertElements(pos, vector.Begin(), vector.End(), CopyTag{});
    }


    Iterator Insert(const Iterator& dest, const ConstIterator& start, const ConstIterator& end)
    {
        auto pos = (unsigned)(dest - Begin());
        return DoInsertElements(pos, start, end, CopyTag{});
    }


    Iterator Insert(const Iterator& dest, const T* start, const T* end)
    {
        auto pos = (unsigned)(dest - Begin());
        return DoInsertElements(pos, start, end, CopyTag{});
    }


    void Erase(unsigned pos, unsigned length = 1)
    {

        if (pos + length > size_ || !length)
            return;

        DoEraseElements(pos, length);
    }


    void EraseSwap(unsigned pos, unsigned length = 1)
    {
        unsigned shiftStartIndex = pos + length;

        if (shiftStartIndex > size_ || !length)
            return;

        unsigned newSize = size_ - length;
        unsigned trailingCount = size_ - shiftStartIndex;
        if (trailingCount <= length)
        {

            DoEraseElements(pos, length);
        }
        else
        {

            T* buffer = Buffer();
            std::move(buffer + newSize, buffer + size_, buffer + pos);
            Resize(newSize);
        }
    }


    Iterator Erase(const Iterator& it)
    {
        auto pos = (unsigned)(it - Begin());
        if (pos >= size_)
            return End();
        Erase(pos);

        return Begin() + pos;
    }


    Iterator Erase(const Iterator& start, const Iterator& end)
    {
        auto pos = (unsigned)(start - Begin());
        if (pos >= size_)
            return End();
        auto length = (unsigned)(end - start);
        Erase(pos, length);

        return Begin() + pos;
    }


    bool Remove(const T& value)
    {
        Iterator i = Find(value);
        if (i != End())
        {
            Erase(i);
            return true;
        }
        else
            return false;
    }


    bool RemoveSwap(const T& value)
    {
        Iterator i = Find(value);
        if (i != End())
        {
            EraseSwap(i - Begin());
            return true;
        }
        else
            return false;
    }


    void Clear() { Resize(0); }


    void Resize(unsigned newSize) { DoResize(newSize); }


    void Resize(unsigned newSize, const T& value)
    {
        unsigned oldSize = Size();
        DoResize(newSize);
        for (unsigned i = oldSize; i < newSize; ++i)
            At(i) = value;
    }


    void Reserve(unsigned newCapacity)
    {
        if (newCapacity < size_)
            newCapacity = size_;

        if (newCapacity != capacity_)
        {
            T* newBuffer = nullptr;
            capacity_ = newCapacity;

            if (capacity_)
            {
                newBuffer = reinterpret_cast<T*>(AllocateBuffer((unsigned)(capacity_ * sizeof(T))));

                ConstructElements(newBuffer, Begin(), End(), MoveTag{});
            }


            DestructElements(Buffer(), size_);
            delete[] buffer_;
            buffer_ = reinterpret_cast<unsigned char*>(newBuffer);
        }
    }


    void Compact() { Reserve(size_); }


    Iterator Find(const T& value)
    {
        Iterator it = Begin();
        while (it != End() && *it != value)
            ++it;
        return it;
    }


    ConstIterator Find(const T& value) const
    {
        ConstIterator it = Begin();
        while (it != End() && *it != value)
            ++it;
        return it;
    }


    Iterator FindLast(const T& value)
    {
        if (!Size())
            return End();
        for (Iterator it = --End(); it != Begin(); ++it)
            if (*it == value)
                return it;
        if (Front() == value)
            return Begin();
        return End();
    }


    ConstIterator FindLast(const T& value) const
    {
        if (!Size())
            return End();
        for (ConstIterator it = --End(); it != Begin(); ++it)
            if (*it == value)
                return it;
        if (Front() == value)
            return Begin();
        return End();
    }


    unsigned IndexOf(const T& value) const
    {
        return Find(value) - Begin();
    }


    bool Contains(const T& value) const { return Find(value) != End(); }


    Iterator Begin() { return Iterator(Buffer()); }


    ConstIterator Begin() const { return ConstIterator(Buffer()); }


    Iterator End() { return Iterator(Buffer() + size_); }


    ConstIterator End() const { return ConstIterator(Buffer() + size_); }


    T& Front()
    {
        ((size_) ? static_cast<void> (0) : __assert_fail ("size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 526, __PRETTY_FUNCTION__));
        return Buffer()[0];
    }


    const T& Front() const
    {
        ((size_) ? static_cast<void> (0) : __assert_fail ("size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 533, __PRETTY_FUNCTION__));
        return Buffer()[0];
    }


    T& Back()
    {
        ((size_) ? static_cast<void> (0) : __assert_fail ("size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 540, __PRETTY_FUNCTION__));
        return Buffer()[size_ - 1];
    }


    const T& Back() const
    {
        ((size_) ? static_cast<void> (0) : __assert_fail ("size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 547, __PRETTY_FUNCTION__));
        return Buffer()[size_ - 1];
    }


    unsigned Size() const { return size_; }


    unsigned Capacity() const { return capacity_; }


    bool Empty() const { return size_ == 0; }


    T* Buffer() const { return reinterpret_cast<T*>(buffer_); }

private:

    static void ConstructElements(T* dest, unsigned count)
    {
        for (unsigned i = 0; i < count; ++i)
            new(dest + i) T();
    }


    template <class RandomIteratorT>
    static void ConstructElements(T* dest, RandomIteratorT start, RandomIteratorT end, CopyTag)
    {
        const unsigned count = end - start;
        for (unsigned i = 0; i < count; ++i)
            new(dest + i) T(*(start + i));
    }


    template <class RandomIteratorT>
    static void ConstructElements(T* dest, RandomIteratorT start, RandomIteratorT end, MoveTag)
    {
        const unsigned count = end - start;
        for (unsigned i = 0; i < count; ++i)
            new(dest + i) T(std::move(*(start + i)));
    }


    static unsigned CalculateCapacity(unsigned size, unsigned capacity)
    {
        if (!capacity)
            return size;
        else
        {
            while (capacity < size)
                capacity += (capacity + 1) >> 1;
            return capacity;
        }
    }


    void DoResize(unsigned newSize)
    {

        if (newSize < size_)
            DestructElements(Buffer() + newSize, size_ - newSize);
        else
        {

            if (newSize > capacity_)
            {
                T* src = Buffer();


                Vector<T> newVector;
                newVector.Reserve(CalculateCapacity(newSize, capacity_));
                newVector.size_ = size_;
                T* dest = newVector.Buffer();


                ConstructElements(dest, src, src + size_, MoveTag{});

                Swap(newVector);
            }


            ConstructElements(Buffer() + size_, newSize - size_);
        }

        size_ = newSize;
    }


    template <class Tag, class RandomIteratorT>
    Iterator DoInsertElements(unsigned pos, RandomIteratorT start, RandomIteratorT end, Tag)
    {
        if (pos > size_)
            pos = size_;

        const unsigned numElements = end - start;
        if (size_ + numElements > capacity_)
        {
            T* src = Buffer();


            Vector<T> newVector;
            newVector.Reserve(CalculateCapacity(size_ + numElements, capacity_));
            newVector.size_ = size_ + numElements;
            T* dest = newVector.Buffer();


            ConstructElements(dest + pos, start, end, Tag{});


            if (pos > 0)
                ConstructElements(dest, src, src + pos, MoveTag{});
            if (pos < size_)
                ConstructElements(dest + pos + numElements, src + pos, src + size_, MoveTag{});

            Swap(newVector);
        }
        else if (numElements > 0)
        {
            T* buffer = Buffer();


            ConstructElements(buffer + size_, start, end, Tag{});


            if (pos < size_)
            {
                std::rotate(buffer + pos, buffer + size_, buffer + size_ + numElements);
            }


            size_ += numElements;
        }

        return Begin() + pos;
    }


    Iterator DoEraseElements(unsigned pos, unsigned count)
    {
        ((count > 0) ? static_cast<void> (0) : __assert_fail ("count > 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 686, __PRETTY_FUNCTION__));
        ((pos + count <= size_) ? static_cast<void> (0) : __assert_fail ("pos + count <= size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 687, __PRETTY_FUNCTION__));
        T* buffer = Buffer();
        std::move(buffer + pos + count, buffer + size_, buffer + pos);
        Resize(size_ - count);
        return Begin() + pos;
    }


    static void DestructElements(T* dest, unsigned count)
    {
        while (count--)
        {
            dest->~T();
            ++dest;
        }
    }
};


template <class T> class PODVector : public VectorBase
{
public:
    using ValueType = T;
    using Iterator = RandomAccessIterator<T>;
    using ConstIterator = RandomAccessConstIterator<T>;


    PODVector() noexcept = default;


    explicit PODVector(unsigned size)
    {
        Resize(size);
    }


    PODVector(unsigned size, const T& value)
    {
        Resize(size);
        for (unsigned i = 0; i < size; ++i)
            At(i) = value;
    }


    PODVector(const T* data, unsigned size)
    {
        Resize(size);
        CopyElements(Buffer(), data, size);
    }


    PODVector(const PODVector<T>& vector)
    {
        *this = vector;
    }

    PODVector(const std::initializer_list<T>& list) : PODVector()
    {
        for (auto it = list.begin(); it != list.end(); it++)
        {
            Push(*it);
        }
    }

    ~PODVector()
    {
        delete[] buffer_;
    }


    PODVector<T>& operator =(const PODVector<T>& rhs)
    {

        if (&rhs != this)
        {
            Resize(rhs.size_);
            CopyElements(Buffer(), rhs.Buffer(), rhs.size_);
        }
        return *this;
    }


    PODVector<T>& operator +=(const T& rhs)
    {
        Push(rhs);
        return *this;
    }


    PODVector<T>& operator +=(const PODVector<T>& rhs)
    {
        Push(rhs);
        return *this;
    }


    PODVector<T> operator +(const T& rhs) const
    {
        PODVector<T> ret(*this);
        ret.Push(rhs);
        return ret;
    }


    PODVector<T> operator +(const PODVector<T>& rhs) const
    {
        PODVector<T> ret(*this);
        ret.Push(rhs);
        return ret;
    }


    bool operator ==(const PODVector<T>& rhs) const
    {
        if (rhs.size_ != size_)
            return false;

        T* buffer = Buffer();
        T* rhsBuffer = rhs.Buffer();
        for (unsigned i = 0; i < size_; ++i)
        {
            if (buffer[i] != rhsBuffer[i])
                return false;
        }

        return true;
    }


    bool operator !=(const PODVector<T>& rhs) const
    {
        if (rhs.size_ != size_)
            return true;

        T* buffer = Buffer();
        T* rhsBuffer = rhs.Buffer();
        for (unsigned i = 0; i < size_; ++i)
        {
            if (buffer[i] != rhsBuffer[i])
                return true;
        }

        return false;
    }


    T& operator [](unsigned index)
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 835, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    const T& operator [](unsigned index) const
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 842, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    T& At(unsigned index)
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 849, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    const T& At(unsigned index) const
    {
        ((index < size_) ? static_cast<void> (0) : __assert_fail ("index < size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 856, __PRETTY_FUNCTION__));
        return Buffer()[index];
    }


    void Push(const T& value)
    {
        if (size_ < capacity_)
            ++size_;
        else
            Resize(size_ + 1);
        Back() = value;
    }


    void Push(const PODVector<T>& vector)
    {
        unsigned oldSize = size_;
        Resize(size_ + vector.size_);
        CopyElements(Buffer() + oldSize, vector.Buffer(), vector.size_);
    }


    void Pop()
    {
        if (size_)
            Resize(size_ - 1);
    }


    void Insert(unsigned pos, const T& value)
    {
        if (pos > size_)
            pos = size_;

        unsigned oldSize = size_;
        Resize(size_ + 1);
        MoveRange(pos + 1, pos, oldSize - pos);
        Buffer()[pos] = value;
    }


    void Insert(unsigned pos, const PODVector<T>& vector)
    {
        if (pos > size_)
            pos = size_;

        unsigned oldSize = size_;
        Resize(size_ + vector.size_);
        MoveRange(pos + vector.size_, pos, oldSize - pos);
        CopyElements(Buffer() + pos, vector.Buffer(), vector.size_);
    }


    Iterator Insert(const Iterator& dest, const T& value)
    {
        auto pos = (unsigned)(dest - Begin());
        if (pos > size_)
            pos = size_;
        Insert(pos, value);

        return Begin() + pos;
    }


    Iterator Insert(const Iterator& dest, const PODVector<T>& vector)
    {
        auto pos = (unsigned)(dest - Begin());
        if (pos > size_)
            pos = size_;
        Insert(pos, vector);

        return Begin() + pos;
    }


    Iterator Insert(const Iterator& dest, const ConstIterator& start, const ConstIterator& end)
    {
        auto pos = (unsigned)(dest - Begin());
        if (pos > size_)
            pos = size_;
        auto length = (unsigned)(end - start);
        Resize(size_ + length);
        MoveRange(pos + length, pos, size_ - pos - length);
        CopyElements(Buffer() + pos, &(*start), length);

        return Begin() + pos;
    }


    Iterator Insert(const Iterator& dest, const T* start, const T* end)
    {
        auto pos = (unsigned)(dest - Begin());
        if (pos > size_)
            pos = size_;
        auto length = (unsigned)(end - start);
        Resize(size_ + length);
        MoveRange(pos + length, pos, size_ - pos - length);

        T* destPtr = Buffer() + pos;
        for (const T* i = start; i != end; ++i)
            *destPtr++ = *i;

        return Begin() + pos;
    }


    void Erase(unsigned pos, unsigned length = 1)
    {

        if (!length || pos + length > size_)
            return;

        MoveRange(pos, pos + length, size_ - pos - length);
        Resize(size_ - length);
    }


    Iterator Erase(const Iterator& it)
    {
        auto pos = (unsigned)(it - Begin());
        if (pos >= size_)
            return End();
        Erase(pos);

        return Begin() + pos;
    }


    Iterator Erase(const Iterator& start, const Iterator& end)
    {
        auto pos = (unsigned)(start - Begin());
        if (pos >= size_)
            return End();
        auto length = (unsigned)(end - start);
        Erase(pos, length);

        return Begin() + pos;
    }


    void EraseSwap(unsigned pos, unsigned length = 1)
    {
        unsigned shiftStartIndex = pos + length;

        if (shiftStartIndex > size_ || !length)
            return;

        unsigned newSize = size_ - length;
        unsigned trailingCount = size_ - shiftStartIndex;
        if (trailingCount <= length)
        {

            MoveRange(pos, shiftStartIndex, trailingCount);
        }
        else
        {

            CopyElements(Buffer() + pos, Buffer() + newSize, length);
        }
        Resize(newSize);
    }


    bool Remove(const T& value)
    {
        Iterator i = Find(value);
        if (i != End())
        {
            Erase(i);
            return true;
        }
        else
            return false;
    }


    bool RemoveSwap(const T& value)
    {
        Iterator i = Find(value);
        if (i != End())
        {
            EraseSwap(i - Begin());
            return true;
        }
        else
            return false;
    }


    void Clear() { Resize(0); }


    void Resize(unsigned newSize)
    {
        if (newSize > capacity_)
        {
            if (!capacity_)
                capacity_ = newSize;
            else
            {
                while (capacity_ < newSize)
                    capacity_ += (capacity_ + 1) >> 1;
            }

            unsigned char* newBuffer = AllocateBuffer((unsigned)(capacity_ * sizeof(T)));

            if (buffer_)
            {
                CopyElements(reinterpret_cast<T*>(newBuffer), Buffer(), size_);
                delete[] buffer_;
            }
            buffer_ = newBuffer;
        }

        size_ = newSize;
    }


    void Reserve(unsigned newCapacity)
    {
        if (newCapacity < size_)
            newCapacity = size_;

        if (newCapacity != capacity_)
        {
            unsigned char* newBuffer = nullptr;
            capacity_ = newCapacity;

            if (capacity_)
            {
                newBuffer = AllocateBuffer((unsigned)(capacity_ * sizeof(T)));

                CopyElements(reinterpret_cast<T*>(newBuffer), Buffer(), size_);
            }


            delete[] buffer_;
            buffer_ = newBuffer;
        }
    }


    void Compact() { Reserve(size_); }


    Iterator Find(const T& value)
    {
        Iterator it = Begin();
        while (it != End() && *it != value)
            ++it;
        return it;
    }


    ConstIterator Find(const T& value) const
    {
        ConstIterator it = Begin();
        while (it != End() && *it != value)
            ++it;
        return it;
    }


    Iterator FindLast(const T& value)
    {
        if (!Size())
            return End();
        for (Iterator it = --End(); it != Begin(); ++it)
            if (*it == value)
                return it;
        if (Front() == value)
            return Begin();
        return End();
    }


    ConstIterator FindLast(const T& value) const
    {
        if (!Size())
            return End();
        for (ConstIterator it = --End(); it != Begin(); ++it)
            if (*it == value)
                return it;
        if (Front() == value)
            return Begin();
        return End();
    }


    unsigned IndexOf(const T& value) const
    {
        return Find(value) - Begin();
    }


    bool Contains(const T& value) const { return Find(value) != End(); }


    Iterator Begin() { return Iterator(Buffer()); }


    ConstIterator Begin() const { return ConstIterator(Buffer()); }


    Iterator End() { return Iterator(Buffer() + size_); }


    ConstIterator End() const { return ConstIterator(Buffer() + size_); }


    T& Front() { return Buffer()[0]; }


    const T& Front() const { return Buffer()[0]; }


    T& Back()
    {
        ((size_) ? static_cast<void> (0) : __assert_fail ("size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 1175, __PRETTY_FUNCTION__));
        return Buffer()[size_ - 1];
    }


    const T& Back() const
    {
        ((size_) ? static_cast<void> (0) : __assert_fail ("size_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/../Container/Vector.h", 1182, __PRETTY_FUNCTION__));
        return Buffer()[size_ - 1];
    }


    unsigned Size() const { return size_; }


    unsigned Capacity() const { return capacity_; }


    bool Empty() const { return size_ == 0; }


    T* Buffer() const { return reinterpret_cast<T*>(buffer_); }

private:

    void MoveRange(unsigned dest, unsigned src, unsigned count)
    {
        if (count)
            memmove(Buffer() + dest, Buffer() + src, count * sizeof(T));
    }


    static void CopyElements(T* dest, const T* src, unsigned count)
    {
        if (count)
            memcpy(dest, src, count * sizeof(T));
    }
};

template <class T> typename Urho3D::Vector<T>::ConstIterator begin(const Urho3D::Vector<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::Vector<T>::ConstIterator end(const Urho3D::Vector<T>& v) { return v.End(); }

template <class T> typename Urho3D::Vector<T>::Iterator begin(Urho3D::Vector<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::Vector<T>::Iterator end(Urho3D::Vector<T>& v) { return v.End(); }

template <class T> typename Urho3D::PODVector<T>::ConstIterator begin(const Urho3D::PODVector<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::PODVector<T>::ConstIterator end(const Urho3D::PODVector<T>& v) { return v.End(); }

template <class T> typename Urho3D::PODVector<T>::Iterator begin(Urho3D::PODVector<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::PODVector<T>::Iterator end(Urho3D::PODVector<T>& v) { return v.End(); }

}






namespace Urho3D
{


template <class T, class U> class HashMap : public HashBase
{
public:
    using KeyType = T;
    using ValueType = U;


    class KeyValue
    {
    public:

        KeyValue() :
            first_(T())
        {
        }


        KeyValue(const T& first, const U& second) :
            first_(first),
            second_(second)
        {
        }


        KeyValue(const KeyValue& value) :
            first_(value.first_),
            second_(value.second_)
        {
        }


        KeyValue& operator =(const KeyValue& rhs) = delete;


        bool operator ==(const KeyValue& rhs) const { return first_ == rhs.first_ && second_ == rhs.second_; }

        bool operator !=(const KeyValue& rhs) const { return first_ != rhs.first_ || second_ != rhs.second_; }


        const T first_;

        U second_;
    };


    struct Node : public HashNodeBase
    {

        Node() = default;


        Node(const T& key, const U& value) :
            pair_(key, value)
        {
        }


        KeyValue pair_;


        Node* Next() const { return static_cast<Node*>(next_); }


        Node* Prev() const { return static_cast<Node*>(prev_); }


        Node* Down() const { return static_cast<Node*>(down_); }
    };


    struct Iterator : public HashIteratorBase
    {

        Iterator() = default;


        explicit Iterator(Node* ptr) :
            HashIteratorBase(ptr)
        {
        }


        Iterator& operator ++()
        {
            GotoNext();
            return *this;
        }


        Iterator operator ++(int)
        {
            Iterator it = *this;
            GotoNext();
            return it;
        }


        Iterator& operator --()
        {
            GotoPrev();
            return *this;
        }


        Iterator operator --(int)
        {
            Iterator it = *this;
            GotoPrev();
            return it;
        }


        KeyValue* operator ->() const { return &(static_cast<Node*>(ptr_))->pair_; }


        KeyValue& operator *() const { return (static_cast<Node*>(ptr_))->pair_; }
    };


    struct ConstIterator : public HashIteratorBase
    {

        ConstIterator() = default;


        explicit ConstIterator(Node* ptr) :
            HashIteratorBase(ptr)
        {
        }


        ConstIterator(const Iterator& rhs) :
            HashIteratorBase(rhs.ptr_)
        {
        }


        ConstIterator& operator =(const Iterator& rhs)
        {
            ptr_ = rhs.ptr_;
            return *this;
        }


        ConstIterator& operator ++()
        {
            GotoNext();
            return *this;
        }


        ConstIterator operator ++(int)
        {
            ConstIterator it = *this;
            GotoNext();
            return it;
        }


        ConstIterator& operator --()
        {
            GotoPrev();
            return *this;
        }


        ConstIterator operator --(int)
        {
            ConstIterator it = *this;
            GotoPrev();
            return it;
        }


        const KeyValue* operator ->() const { return &(static_cast<Node*>(ptr_))->pair_; }


        const KeyValue& operator *() const { return (static_cast<Node*>(ptr_))->pair_; }
    };


    HashMap()
    {

        allocator_ = AllocatorInitialize((unsigned)sizeof(Node));
        head_ = tail_ = ReserveNode();
    }


    HashMap(const HashMap<T, U>& map)
    {

        allocator_ = AllocatorInitialize((unsigned)sizeof(Node), map.Size() + 1);
        head_ = tail_ = ReserveNode();
        *this = map;
    }


    HashMap(HashMap<T, U> && map) noexcept
    {
        Swap(map);
    }


    HashMap(const std::initializer_list<Pair<T, U>>& list) : HashMap()
    {
        for (auto it = list.begin(); it != list.end(); it++)
        {
            Insert(*it);
        }
    }


    ~HashMap()
    {
        if (allocator_)
        {
            Clear();
            FreeNode(Tail());
            AllocatorUninitialize(allocator_);
            delete[] ptrs_;
        }
    }


    HashMap& operator =(const HashMap<T, U>& rhs)
    {

        if (&rhs != this)
        {
            Clear();
            Insert(rhs);
        }
        return *this;
    }


    HashMap& operator =(HashMap<T, U> && rhs) noexcept
    {
        ((&rhs != this) ? static_cast<void> (0) : __assert_fail ("&rhs != this", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/HashMap.h", 276, __PRETTY_FUNCTION__));
        Swap(rhs);
        return *this;
    }


    HashMap& operator +=(const Pair<T, U>& rhs)
    {
        Insert(rhs);
        return *this;
    }


    HashMap& operator +=(const HashMap<T, U>& rhs)
    {
        Insert(rhs);
        return *this;
    }


    bool operator ==(const HashMap<T, U>& rhs) const
    {
        if (rhs.Size() != Size())
            return false;

        ConstIterator i = Begin();
        while (i != End())
        {
            ConstIterator j = rhs.Find(i->first_);
            if (j == rhs.End() || j->second_ != i->second_)
                return false;
            ++i;
        }

        return true;
    }


    bool operator !=(const HashMap<T, U>& rhs) const
    {
        if (rhs.Size() != Size())
            return true;

        ConstIterator i = Begin();
        while (i != End())
        {
            ConstIterator j = rhs.Find(i->first_);
            if (j == rhs.End() || j->second_ != i->second_)
                return true;
            ++i;
        }

        return false;
    }


    U& operator [](const T& key)
    {
        if (!ptrs_)
            return InsertNode(key, U(), false)->pair_.second_;

        unsigned hashKey = Hash(key);

        Node* node = FindNode(key, hashKey);
        return node ? node->pair_.second_ : InsertNode(key, U(), false)->pair_.second_;
    }


    U* operator [](const T& key) const
    {
        if (!ptrs_)
            return 0;

        unsigned hashKey = Hash(key);

        Node* node = FindNode(key, hashKey);
        return node ? &node->pair_.second_ : 0;
    }


    HashMap& Populate(const T& key, const U& value)
    {
        this->operator [](key) = value;
        return *this;
    }


    template <typename... Args> HashMap& Populate(const T& key, const U& value, const Args&... args)
    {
        this->operator [](key) = value;
        return Populate(args...);
    }


    Iterator Insert(const Pair<T, U>& pair)
    {
        return Iterator(InsertNode(pair.first_, pair.second_));
    }


    Iterator Insert(const Pair<T, U>& pair, bool& exists)
    {
        unsigned oldSize = Size();
        Iterator ret(InsertNode(pair.first_, pair.second_));
        exists = (Size() == oldSize);
        return ret;
    }


    void Insert(const HashMap<T, U>& map)
    {
        ConstIterator it = map.Begin();
        ConstIterator end = map.End();
        while (it != end)
        {
            InsertNode(it->first_, it->second_);
            ++it;
        }
    }


    Iterator Insert(const ConstIterator& it) { return Iterator(InsertNode(it->first_, it->second_)); }


    void Insert(const ConstIterator& start, const ConstIterator& end)
    {
        ConstIterator it = start;
        while (it != end)
            InsertNode(*it++);
    }


    bool Erase(const T& key)
    {
        if (!ptrs_)
            return false;

        unsigned hashKey = Hash(key);

        Node* previous;
        Node* node = FindNode(key, hashKey, previous);
        if (!node)
            return false;

        if (previous)
            previous->down_ = node->down_;
        else
            Ptrs()[hashKey] = node->down_;

        EraseNode(node);
        return true;
    }


    Iterator Erase(const Iterator& it)
    {
        if (!ptrs_ || !it.ptr_)
            return End();

        auto* node = static_cast<Node*>(it.ptr_);
        Node* next = node->Next();

        unsigned hashKey = Hash(node->pair_.first_);

        Node* previous = 0;
        auto* current = static_cast<Node*>(Ptrs()[hashKey]);
        while (current && current != node)
        {
            previous = current;
            current = current->Down();
        }

        ((current == node) ? static_cast<void> (0) : __assert_fail ("current == node", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/HashMap.h", 448, __PRETTY_FUNCTION__));

        if (previous)
            previous->down_ = node->down_;
        else
            Ptrs()[hashKey] = node->down_;

        EraseNode(node);
        return Iterator(next);
    }


    void Clear()
    {

        ResetPtrs();

        if (Size())
        {
            for (Iterator i = Begin(); i != End();)
            {
                FreeNode(static_cast<Node*>(i++.ptr_));
                i.ptr_->prev_ = 0;
            }

            head_ = tail_;
            SetSize(0);
        }
    }


    void Sort()
    {
        unsigned numKeys = Size();
        if (!numKeys)
            return;

        auto** ptrs = new Node* [numKeys];
        Node* ptr = Head();

        for (unsigned i = 0; i < numKeys; ++i)
        {
            ptrs[i] = ptr;
            ptr = ptr->Next();
        }

        Urho3D::Sort(RandomAccessIterator<Node*>(ptrs), RandomAccessIterator<Node*>(ptrs + numKeys), CompareNodes);

        head_ = ptrs[0];
        ptrs[0]->prev_ = 0;
        for (unsigned i = 1; i < numKeys; ++i)
        {
            ptrs[i - 1]->next_ = ptrs[i];
            ptrs[i]->prev_ = ptrs[i - 1];
        }
        ptrs[numKeys - 1]->next_ = tail_;
        tail_->prev_ = ptrs[numKeys - 1];

        delete[] ptrs;
    }


    bool Rehash(unsigned numBuckets)
    {
        if (numBuckets == NumBuckets())
            return true;
        if (!numBuckets || numBuckets < Size() / MAX_LOAD_FACTOR)
            return false;


        unsigned check = numBuckets;
        while (!(check & 1u))
            check >>= 1;
        if (check != 1)
            return false;

        AllocateBuckets(Size(), numBuckets);
        Rehash();
        return true;
    }


    Iterator Find(const T& key)
    {
        if (!ptrs_)
            return End();

        unsigned hashKey = Hash(key);
        Node* node = FindNode(key, hashKey);
        if (node)
            return Iterator(node);
        else
            return End();
    }


    ConstIterator Find(const T& key) const
    {
        if (!ptrs_)
            return End();

        unsigned hashKey = Hash(key);
        Node* node = FindNode(key, hashKey);
        if (node)
            return ConstIterator(node);
        else
            return End();
    }


    bool Contains(const T& key) const
    {
        if (!ptrs_)
            return false;

        unsigned hashKey = Hash(key);
        return FindNode(key, hashKey) != 0;
    }


    bool TryGetValue(const T& key, U& out) const
    {
        if (!ptrs_)
            return false;
        unsigned hashKey = Hash(key);
        Node* node = FindNode(key, hashKey);
        if (node)
        {
            out = node->pair_.second_;
            return true;
        }
        else
            return false;
    }


    Vector<T> Keys() const
    {
        Vector<T> result;
        result.Reserve(Size());
        for (ConstIterator i = Begin(); i != End(); ++i)
            result.Push(i->first_);
        return result;
    }


    Vector<U> Values() const
    {
        Vector<U> result;
        result.Reserve(Size());
        for (ConstIterator i = Begin(); i != End(); ++i)
            result.Push(i->second_);
        return result;
    }


    Iterator Begin() { return Iterator(Head()); }


    ConstIterator Begin() const { return ConstIterator(Head()); }


    Iterator End() { return Iterator(Tail()); }


    ConstIterator End() const { return ConstIterator(Tail()); }


    const KeyValue& Front() const { return *Begin(); }


    const KeyValue& Back() const { return *(--End()); }

private:

    Node* Head() const { return static_cast<Node*>(head_); }


    Node* Tail() const { return static_cast<Node*>(tail_); }


    Node* FindNode(const T& key, unsigned hashKey) const
    {
        auto* node = static_cast<Node*>(Ptrs()[hashKey]);
        while (node)
        {
            if (node->pair_.first_ == key)
                return node;
            node = node->Down();
        }

        return 0;
    }


    Node* FindNode(const T& key, unsigned hashKey, Node*& previous) const
    {
        previous = 0;

        auto* node = static_cast<Node*>(Ptrs()[hashKey]);
        while (node)
        {
            if (node->pair_.first_ == key)
                return node;
            previous = node;
            node = node->Down();
        }

        return 0;
    }


    Node* InsertNode(const T& key, const U& value, bool findExisting = true)
    {

        if (!ptrs_)
        {
            AllocateBuckets(Size(), MIN_BUCKETS);
            Rehash();
        }

        unsigned hashKey = Hash(key);

        if (findExisting)
        {

            Node* existing = FindNode(key, hashKey);
            if (existing)
            {
                existing->pair_.second_ = value;
                return existing;
            }
        }

        Node* newNode = InsertNode(Tail(), key, value);
        newNode->down_ = Ptrs()[hashKey];
        Ptrs()[hashKey] = newNode;


        if (Size() > NumBuckets() * MAX_LOAD_FACTOR)
        {
            AllocateBuckets(Size(), NumBuckets() << 1);
            Rehash();
        }

        return newNode;
    }


    Node* InsertNode(Node* dest, const T& key, const U& value)
    {
        if (!dest)
            return 0;

        Node* newNode = ReserveNode(key, value);
        Node* prev = dest->Prev();
        newNode->next_ = dest;
        newNode->prev_ = prev;
        if (prev)
            prev->next_ = newNode;
        dest->prev_ = newNode;


        if (dest == Head())
            head_ = newNode;

        SetSize(Size() + 1);

        return newNode;
    }


    Node* EraseNode(Node* node)
    {

        if (!node || node == tail_)
            return Tail();

        Node* prev = node->Prev();
        Node* next = node->Next();
        if (prev)
            prev->next_ = next;
        next->prev_ = prev;


        if (node == Head())
            head_ = next;

        FreeNode(node);
        SetSize(Size() - 1);

        return next;
    }


    Node* ReserveNode()
    {
        auto* newNode = static_cast<Node*>(AllocatorReserve(allocator_));
        new(newNode) Node();
        return newNode;
    }


    Node* ReserveNode(const T& key, const U& value)
    {
        auto* newNode = static_cast<Node*>(AllocatorReserve(allocator_));
        new(newNode) Node(key, value);
        return newNode;
    }


    void FreeNode(Node* node)
    {
        (node)->~Node();
        AllocatorFree(allocator_, node);
    }


    void Rehash()
    {
        for (Iterator i = Begin(); i != End(); ++i)
        {
            auto* node = static_cast<Node*>(i.ptr_);
            unsigned hashKey = Hash(i->first_);
            node->down_ = Ptrs()[hashKey];
            Ptrs()[hashKey] = node;
        }
    }


    static bool CompareNodes(Node*& lhs, Node*& rhs) { return lhs->pair_.first_ < rhs->pair_.first_; }


    unsigned Hash(const T& key) const { return MakeHash(key) & (NumBuckets() - 1); }
};

template <class T, class U> typename Urho3D::HashMap<T, U>::ConstIterator begin(const Urho3D::HashMap<T, U>& v) { return v.Begin(); }

template <class T, class U> typename Urho3D::HashMap<T, U>::ConstIterator end(const Urho3D::HashMap<T, U>& v) { return v.End(); }

template <class T, class U> typename Urho3D::HashMap<T, U>::Iterator begin(Urho3D::HashMap<T, U>& v) { return v.Begin(); }

template <class T, class U> typename Urho3D::HashMap<T, U>::Iterator end(Urho3D::HashMap<T, U>& v) { return v.End(); }

}

namespace std
{
  using ::va_list;
}




namespace Urho3D
{

static const int CONVERSION_BUFFER_LENGTH = 128;
static const int MATRIX_CONVERSION_BUFFER_LENGTH = 256;

class WString;

class StringHash;
template <class T, class U> class HashMap;


using StringMap = HashMap<StringHash, String>;


class __attribute__((visibility("default"))) String
{
public:
    using Iterator = RandomAccessIterator<char>;
    using ConstIterator = RandomAccessConstIterator<char>;


    String() noexcept :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
    }


    String(const String& str) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        *this = str;
    }


    String(String && str) noexcept :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        Swap(str);
    }


    String(const char* str) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        *this = str;
    }


    String(char* str) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        *this = (const char*)str;
    }


    String(const char* str, unsigned length) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        Resize(length);
        CopyChars(buffer_, str, length);
    }


    explicit String(const wchar_t* str) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        SetUTF8FromWChar(str);
    }


    explicit String(wchar_t* str) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        SetUTF8FromWChar(str);
    }


    explicit String(const WString& str);


    explicit String(int value);

    explicit String(short value);

    explicit String(long value);

    explicit String(long long value);

    explicit String(unsigned value);

    explicit String(unsigned short value);

    explicit String(unsigned long value);

    explicit String(unsigned long long value);

    explicit String(float value);

    explicit String(double value);

    explicit String(bool value);

    explicit String(char value);

    explicit String(char value, unsigned length);


    template <class T> explicit String(const T& value) :
        length_(0),
        capacity_(0),
        buffer_(&endZero)
    {
        *this = value.ToString();
    }


    ~String()
    {
        if (capacity_)
            delete[] buffer_;
    }


    String& operator =(const String& rhs)
    {
        if (&rhs != this)
        {
            Resize(rhs.length_);
            CopyChars(buffer_, rhs.buffer_, rhs.length_);
        }

        return *this;
    }


    String& operator =(String && rhs) noexcept
    {
        ((&rhs != this) ? static_cast<void> (0) : __assert_fail ("&rhs != this", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 185, __PRETTY_FUNCTION__));
        Swap(rhs);
        return *this;
    }


    String& operator =(const char* rhs)
    {
        unsigned rhsLength = CStringLength(rhs);
        Resize(rhsLength);
        CopyChars(buffer_, rhs, rhsLength);

        return *this;
    }


    String& operator +=(const String& rhs)
    {
        unsigned oldLength = length_;
        Resize(length_ + rhs.length_);
        CopyChars(buffer_ + oldLength, rhs.buffer_, rhs.length_);

        return *this;
    }


    String& operator +=(const char* rhs)
    {
        unsigned rhsLength = CStringLength(rhs);
        unsigned oldLength = length_;
        Resize(length_ + rhsLength);
        CopyChars(buffer_ + oldLength, rhs, rhsLength);

        return *this;
    }


    String& operator +=(char rhs)
    {
        unsigned oldLength = length_;
        Resize(length_ + 1);
        buffer_[oldLength] = rhs;

        return *this;
    }


    String& operator +=(int rhs);

    String& operator +=(short rhs);

    String& operator +=(long rhs);

    String& operator +=(long long rhs);

    String& operator +=(unsigned rhs);

    String& operator +=(unsigned short rhs);

    String& operator +=(unsigned long rhs);

    String& operator +=(unsigned long long rhs);

    String& operator +=(float rhs);

    String& operator +=(bool rhs);


    template <class T> String& operator +=(const T& rhs) { return *this += rhs.ToString(); }


    String operator +(const String& rhs) const
    {
        String ret;
        ret.Resize(length_ + rhs.length_);
        CopyChars(ret.buffer_, buffer_, length_);
        CopyChars(ret.buffer_ + length_, rhs.buffer_, rhs.length_);

        return ret;
    }


    String operator +(const char* rhs) const
    {
        unsigned rhsLength = CStringLength(rhs);
        String ret;
        ret.Resize(length_ + rhsLength);
        CopyChars(ret.buffer_, buffer_, length_);
        CopyChars(ret.buffer_ + length_, rhs, rhsLength);

        return ret;
    }


    bool operator ==(const String& rhs) const { return strcmp(CString(), rhs.CString()) == 0; }


    bool operator !=(const String& rhs) const { return strcmp(CString(), rhs.CString()) != 0; }


    bool operator <(const String& rhs) const { return strcmp(CString(), rhs.CString()) < 0; }


    bool operator >(const String& rhs) const { return strcmp(CString(), rhs.CString()) > 0; }


    bool operator ==(const char* rhs) const { return strcmp(CString(), rhs) == 0; }


    bool operator !=(const char* rhs) const { return strcmp(CString(), rhs) != 0; }


    bool operator <(const char* rhs) const { return strcmp(CString(), rhs) < 0; }


    bool operator >(const char* rhs) const { return strcmp(CString(), rhs) > 0; }


    char& operator [](unsigned index)
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 305, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    const char& operator [](unsigned index) const
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 312, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    char& At(unsigned index)
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 319, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    const char& At(unsigned index) const
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 326, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    void Replace(char replaceThis, char replaceWith, bool caseSensitive = true);

    void Replace(const String& replaceThis, const String& replaceWith, bool caseSensitive = true);

    void Replace(unsigned pos, unsigned length, const String& replaceWith);

    void Replace(unsigned pos, unsigned length, const char* replaceWith);

    Iterator Replace(const Iterator& start, const Iterator& end, const String& replaceWith);

    String Replaced(char replaceThis, char replaceWith, bool caseSensitive = true) const;

    String Replaced(const String& replaceThis, const String& replaceWith, bool caseSensitive = true) const;

    String& Append(const String& str);

    String& Append(const char* str);

    String& Append(char c);

    String& Append(const char* str, unsigned length);

    void Insert(unsigned pos, const String& str);

    void Insert(unsigned pos, char c);

    Iterator Insert(const Iterator& dest, const String& str);

    Iterator Insert(const Iterator& dest, const Iterator& start, const Iterator& end);

    Iterator Insert(const Iterator& dest, char c);

    void Erase(unsigned pos, unsigned length = 1);

    Iterator Erase(const Iterator& it);

    Iterator Erase(const Iterator& start, const Iterator& end);

    void Resize(unsigned newLength);

    void Reserve(unsigned newCapacity);

    void Compact();

    void Clear();

    void Swap(String& str);


    Iterator Begin() { return Iterator(buffer_); }


    ConstIterator Begin() const { return ConstIterator(buffer_); }


    Iterator End() { return Iterator(buffer_ + length_); }


    ConstIterator End() const { return ConstIterator(buffer_ + length_); }


    char Front() const { return buffer_[0]; }


    char Back() const { return length_ ? buffer_[length_ - 1] : buffer_[0]; }


    String Substring(unsigned pos) const;

    String Substring(unsigned pos, unsigned length) const;

    String Trimmed() const;

    String ToUpper() const;

    String ToLower() const;

    Vector<String> Split(char separator, bool keepEmptyStrings = false) const;

    void Join(const Vector<String>& subStrings, const String& glue);

    unsigned Find(const String& str, unsigned startPos = 0, bool caseSensitive = true) const;

    unsigned Find(char c, unsigned startPos = 0, bool caseSensitive = true) const;

    unsigned FindLast(const String& str, unsigned startPos = NPOS, bool caseSensitive = true) const;

    unsigned FindLast(char c, unsigned startPos = NPOS, bool caseSensitive = true) const;

    bool StartsWith(const String& str, bool caseSensitive = true) const;

    bool EndsWith(const String& str, bool caseSensitive = true) const;


    const char* CString() const { return buffer_; }


    unsigned Length() const { return length_; }


    unsigned Capacity() const { return capacity_; }


    bool Empty() const { return length_ == 0; }


    int Compare(const String& str, bool caseSensitive = true) const;

    int Compare(const char* str, bool caseSensitive = true) const;


    bool Contains(const String& str, bool caseSensitive = true) const { return Find(str, 0, caseSensitive) != NPOS; }


    bool Contains(char c, bool caseSensitive = true) const { return Find(c, 0, caseSensitive) != NPOS; }


    void SetUTF8FromLatin1(const char* str);

    void SetUTF8FromWChar(const wchar_t* str);

    unsigned LengthUTF8() const;

    unsigned ByteOffsetUTF8(unsigned index) const;

    unsigned NextUTF8Char(unsigned& byteOffset) const;

    unsigned AtUTF8(unsigned index) const;

    void ReplaceUTF8(unsigned index, unsigned unicodeChar);

    String& AppendUTF8(unsigned unicodeChar);

    String SubstringUTF8(unsigned pos) const;

    String SubstringUTF8(unsigned pos, unsigned length) const;


    unsigned ToHash() const
    {
        unsigned hash = 0;
        const char* ptr = buffer_;
        while (*ptr)
        {
            hash = *ptr + (hash << 6u) + (hash << 16u) - hash;
            ++ptr;
        }

        return hash;
    }


    static Vector<String> Split(const char* str, char separator, bool keepEmptyStrings = false);

    static String Joined(const Vector<String>& subStrings, const String& glue);

    static void EncodeUTF8(char*& dest, unsigned unicodeChar);

    static unsigned DecodeUTF8(const char*& src);
    static unsigned CStringLength(const char* str) { return str ? (unsigned)strlen(str) : 0; }


    String& AppendWithFormat(const char* formatString, ...);

    String& AppendWithFormatArgs(const char* formatString, va_list args);


    static int Compare(const char* lhs, const char* rhs, bool caseSensitive);


    static const unsigned NPOS = 0xffffffff;

    static const unsigned MIN_CAPACITY = 8;

    static const String EMPTY;

private:

    void MoveRange(unsigned dest, unsigned src, unsigned count)
    {
        if (count)
            memmove(buffer_ + dest, buffer_ + src, count);
    }


    static void CopyChars(char* dest, const char* src, unsigned count)
    {




        char* end = dest + count;
        while (dest != end)
        {
            *dest = *src;
            ++dest;
            ++src;
        }

    }


    void Replace(unsigned pos, unsigned length, const char* srcStart, unsigned srcLength);


    unsigned length_;

    unsigned capacity_;

    char* buffer_;


    static char endZero;
};


inline String operator +(const char* lhs, const String& rhs)
{
    String ret(lhs);
    ret += rhs;
    return ret;
}


inline String operator +(const wchar_t* lhs, const String& rhs)
{
    String ret(lhs);
    ret += rhs;
    return ret;
}


class __attribute__((visibility("default"))) WString
{
public:

    WString();

    explicit WString(const String& str);

    ~WString();


    wchar_t& operator [](unsigned index)
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 584, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    const wchar_t& operator [](unsigned index) const
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 591, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    wchar_t& At(unsigned index)
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 598, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    const wchar_t& At(unsigned index) const
    {
        ((index < length_) ? static_cast<void> (0) : __assert_fail ("index < length_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Container/Str.h", 605, __PRETTY_FUNCTION__));
        return buffer_[index];
    }


    void Resize(unsigned newLength);


    bool Empty() const { return length_ == 0; }


    unsigned Length() const { return length_; }


    const wchar_t* CString() const { return buffer_; }

private:

    unsigned length_;

    wchar_t* buffer_;
};

}

namespace Urho3D
{

class StringHashRegister;


class __attribute__((visibility("default"))) StringHash
{
public:

    StringHash() noexcept :
        value_(0)
    {
    }


    StringHash(const StringHash& rhs) noexcept = default;


    explicit StringHash(unsigned value) noexcept :
        value_(value)
    {
    }


    StringHash(const char* str) noexcept;

    StringHash(const String& str) noexcept;


    StringHash& operator =(const StringHash& rhs) noexcept = default;


    StringHash operator +(const StringHash& rhs) const
    {
        StringHash ret;
        ret.value_ = value_ + rhs.value_;
        return ret;
    }


    StringHash& operator +=(const StringHash& rhs)
    {
        value_ += rhs.value_;
        return *this;
    }


    bool operator ==(const StringHash& rhs) const { return value_ == rhs.value_; }


    bool operator !=(const StringHash& rhs) const { return value_ != rhs.value_; }


    bool operator <(const StringHash& rhs) const { return value_ < rhs.value_; }


    bool operator >(const StringHash& rhs) const { return value_ > rhs.value_; }


    explicit operator bool() const { return value_ != 0; }


    unsigned Value() const { return value_; }


    String ToString() const;


    String Reverse() const;


    unsigned ToHash() const { return value_; }


    static unsigned Calculate(const char* str, unsigned hash = 0);


    static StringHashRegister* GetGlobalStringHashRegister();


    static const StringHash ZERO;

private:

    unsigned value_;
};

}



class asIScriptEngine;
class asIScriptModule;
class asIScriptContext;
class asIScriptGeneric;
class asIScriptObject;
class asITypeInfo;
class asIScriptFunction;
class asIBinaryStream;
class asIJITCompiler;
class asIThreadManager;
class asILockableSharedBool;
class asIStringFactory;




enum asERetCodes
{
 asSUCCESS = 0,
 asERROR = -1,
 asCONTEXT_ACTIVE = -2,
 asCONTEXT_NOT_FINISHED = -3,
 asCONTEXT_NOT_PREPARED = -4,
 asINVALID_ARG = -5,
 asNO_FUNCTION = -6,
 asNOT_SUPPORTED = -7,
 asINVALID_NAME = -8,
 asNAME_TAKEN = -9,
 asINVALID_DECLARATION = -10,
 asINVALID_OBJECT = -11,
 asINVALID_TYPE = -12,
 asALREADY_REGISTERED = -13,
 asMULTIPLE_FUNCTIONS = -14,
 asNO_MODULE = -15,
 asNO_GLOBAL_VAR = -16,
 asINVALID_CONFIGURATION = -17,
 asINVALID_INTERFACE = -18,
 asCANT_BIND_ALL_FUNCTIONS = -19,
 asLOWER_ARRAY_DIMENSION_NOT_REGISTERED = -20,
 asWRONG_CONFIG_GROUP = -21,
 asCONFIG_GROUP_IS_IN_USE = -22,
 asILLEGAL_BEHAVIOUR_FOR_TYPE = -23,
 asWRONG_CALLING_CONV = -24,
 asBUILD_IN_PROGRESS = -25,
 asINIT_GLOBAL_VARS_FAILED = -26,
 asOUT_OF_MEMORY = -27,
 asMODULE_IS_IN_USE = -28
};


enum asEEngineProp
{
 asEP_ALLOW_UNSAFE_REFERENCES = 1,
 asEP_OPTIMIZE_BYTECODE = 2,
 asEP_COPY_SCRIPT_SECTIONS = 3,
 asEP_MAX_STACK_SIZE = 4,
 asEP_USE_CHARACTER_LITERALS = 5,
 asEP_ALLOW_MULTILINE_STRINGS = 6,
 asEP_ALLOW_IMPLICIT_HANDLE_TYPES = 7,
 asEP_BUILD_WITHOUT_LINE_CUES = 8,
 asEP_INIT_GLOBAL_VARS_AFTER_BUILD = 9,
 asEP_REQUIRE_ENUM_SCOPE = 10,
 asEP_SCRIPT_SCANNER = 11,
 asEP_INCLUDE_JIT_INSTRUCTIONS = 12,
 asEP_STRING_ENCODING = 13,
 asEP_PROPERTY_ACCESSOR_MODE = 14,
 asEP_EXPAND_DEF_ARRAY_TO_TMPL = 15,
 asEP_AUTO_GARBAGE_COLLECT = 16,
 asEP_DISALLOW_GLOBAL_VARS = 17,
 asEP_ALWAYS_IMPL_DEFAULT_CONSTRUCT = 18,
 asEP_COMPILER_WARNINGS = 19,
 asEP_DISALLOW_VALUE_ASSIGN_FOR_REF_TYPE = 20,
 asEP_ALTER_SYNTAX_NAMED_ARGS = 21,
 asEP_DISABLE_INTEGER_DIVISION = 22,
 asEP_DISALLOW_EMPTY_LIST_ELEMENTS = 23,
 asEP_PRIVATE_PROP_AS_PROTECTED = 24,
 asEP_ALLOW_UNICODE_IDENTIFIERS = 25,
 asEP_HEREDOC_TRIM_MODE = 26,
 asEP_MAX_NESTED_CALLS = 27,
 asEP_GENERIC_CALL_MODE = 28,
 asEP_INIT_STACK_SIZE = 29,
 asEP_INIT_CALL_STACK_SIZE = 30,
 asEP_MAX_CALL_STACK_SIZE = 31,

 asEP_LAST_PROPERTY
};


enum asECallConvTypes
{
 asCALL_CDECL = 0,
 asCALL_STDCALL = 1,
 asCALL_THISCALL_ASGLOBAL = 2,
 asCALL_THISCALL = 3,
 asCALL_CDECL_OBJLAST = 4,
 asCALL_CDECL_OBJFIRST = 5,
 asCALL_GENERIC = 6,
 asCALL_THISCALL_OBJLAST = 7,
 asCALL_THISCALL_OBJFIRST = 8
};


enum asEObjTypeFlags
{
 asOBJ_REF = (1<<0),
 asOBJ_VALUE = (1<<1),
 asOBJ_GC = (1<<2),
 asOBJ_POD = (1<<3),
 asOBJ_NOHANDLE = (1<<4),
 asOBJ_SCOPED = (1<<5),
 asOBJ_TEMPLATE = (1<<6),
 asOBJ_ASHANDLE = (1<<7),
 asOBJ_APP_CLASS = (1<<8),
 asOBJ_APP_CLASS_CONSTRUCTOR = (1<<9),
 asOBJ_APP_CLASS_DESTRUCTOR = (1<<10),
 asOBJ_APP_CLASS_ASSIGNMENT = (1<<11),
 asOBJ_APP_CLASS_COPY_CONSTRUCTOR = (1<<12),
 asOBJ_APP_CLASS_C = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR),
 asOBJ_APP_CLASS_CD = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_DESTRUCTOR),
 asOBJ_APP_CLASS_CA = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_ASSIGNMENT),
 asOBJ_APP_CLASS_CK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_CDA = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_DESTRUCTOR + asOBJ_APP_CLASS_ASSIGNMENT),
 asOBJ_APP_CLASS_CDK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_DESTRUCTOR + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_CAK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_ASSIGNMENT + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_CDAK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_CONSTRUCTOR + asOBJ_APP_CLASS_DESTRUCTOR + asOBJ_APP_CLASS_ASSIGNMENT + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_D = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_DESTRUCTOR),
 asOBJ_APP_CLASS_DA = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_DESTRUCTOR + asOBJ_APP_CLASS_ASSIGNMENT),
 asOBJ_APP_CLASS_DK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_DESTRUCTOR + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_DAK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_DESTRUCTOR + asOBJ_APP_CLASS_ASSIGNMENT + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_A = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_ASSIGNMENT),
 asOBJ_APP_CLASS_AK = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_ASSIGNMENT + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_CLASS_K = (asOBJ_APP_CLASS + asOBJ_APP_CLASS_COPY_CONSTRUCTOR),
 asOBJ_APP_PRIMITIVE = (1<<13),
 asOBJ_APP_FLOAT = (1<<14),
 asOBJ_APP_ARRAY = (1<<15),
 asOBJ_APP_CLASS_ALLINTS = (1<<16),
 asOBJ_APP_CLASS_ALLFLOATS = (1<<17),
 asOBJ_NOCOUNT = (1<<18),
 asOBJ_APP_CLASS_ALIGN8 = (1<<19),
 asOBJ_IMPLICIT_HANDLE = (1<<20),
 asOBJ_MASK_VALID_FLAGS = 0x1FFFFF,

 asOBJ_SCRIPT_OBJECT = (1<<21),
 asOBJ_SHARED = (1<<22),
 asOBJ_NOINHERIT = (1<<23),
 asOBJ_FUNCDEF = (1<<24),
 asOBJ_LIST_PATTERN = (1<<25),
 asOBJ_ENUM = (1<<26),
 asOBJ_TEMPLATE_SUBTYPE = (1<<27),
 asOBJ_TYPEDEF = (1<<28),
 asOBJ_ABSTRACT = (1<<29),
 asOBJ_APP_ALIGN16 = (1<<30)
};


enum asEBehaviours
{

 asBEHAVE_CONSTRUCT,
 asBEHAVE_LIST_CONSTRUCT,
 asBEHAVE_DESTRUCT,


 asBEHAVE_FACTORY,
 asBEHAVE_LIST_FACTORY,
 asBEHAVE_ADDREF,
 asBEHAVE_RELEASE,
 asBEHAVE_GET_WEAKREF_FLAG,


 asBEHAVE_TEMPLATE_CALLBACK,


 asBEHAVE_FIRST_GC,
  asBEHAVE_GETREFCOUNT = asBEHAVE_FIRST_GC,
  asBEHAVE_SETGCFLAG,
  asBEHAVE_GETGCFLAG,
  asBEHAVE_ENUMREFS,
  asBEHAVE_RELEASEREFS,
 asBEHAVE_LAST_GC = asBEHAVE_RELEASEREFS,

 asBEHAVE_MAX
};


enum asEContextState
{
 asEXECUTION_FINISHED = 0,
 asEXECUTION_SUSPENDED = 1,
 asEXECUTION_ABORTED = 2,
 asEXECUTION_EXCEPTION = 3,
 asEXECUTION_PREPARED = 4,
 asEXECUTION_UNINITIALIZED = 5,
 asEXECUTION_ACTIVE = 6,
 asEXECUTION_ERROR = 7
};


enum asEMsgType
{
 asMSGTYPE_ERROR = 0,
 asMSGTYPE_WARNING = 1,
 asMSGTYPE_INFORMATION = 2
};


enum asEGCFlags
{
 asGC_FULL_CYCLE = 1,
 asGC_ONE_STEP = 2,
 asGC_DESTROY_GARBAGE = 4,
 asGC_DETECT_GARBAGE = 8
};


enum asETokenClass
{
 asTC_UNKNOWN = 0,
 asTC_KEYWORD = 1,
 asTC_VALUE = 2,
 asTC_IDENTIFIER = 3,
 asTC_COMMENT = 4,
 asTC_WHITESPACE = 5
};


enum asETypeIdFlags
{
 asTYPEID_VOID = 0,
 asTYPEID_BOOL = 1,
 asTYPEID_INT8 = 2,
 asTYPEID_INT16 = 3,
 asTYPEID_INT32 = 4,
 asTYPEID_INT64 = 5,
 asTYPEID_UINT8 = 6,
 asTYPEID_UINT16 = 7,
 asTYPEID_UINT32 = 8,
 asTYPEID_UINT64 = 9,
 asTYPEID_FLOAT = 10,
 asTYPEID_DOUBLE = 11,
 asTYPEID_OBJHANDLE = 0x40000000,
 asTYPEID_HANDLETOCONST = 0x20000000,
 asTYPEID_MASK_OBJECT = 0x1C000000,
 asTYPEID_APPOBJECT = 0x04000000,
 asTYPEID_SCRIPTOBJECT = 0x08000000,
 asTYPEID_TEMPLATE = 0x10000000,
 asTYPEID_MASK_SEQNBR = 0x03FFFFFF
};


enum asETypeModifiers
{
 asTM_NONE = 0,
 asTM_INREF = 1,
 asTM_OUTREF = 2,
 asTM_INOUTREF = 3,
 asTM_CONST = 4
};


enum asEGMFlags
{
 asGM_ONLY_IF_EXISTS = 0,
 asGM_CREATE_IF_NOT_EXISTS = 1,
 asGM_ALWAYS_CREATE = 2
};


enum asECompileFlags
{
 asCOMP_ADD_TO_MODULE = 1
};


enum asEFuncType
{
 asFUNC_DUMMY =-1,
 asFUNC_SYSTEM = 0,
 asFUNC_SCRIPT = 1,
 asFUNC_INTERFACE = 2,
 asFUNC_VIRTUAL = 3,
 asFUNC_FUNCDEF = 4,
 asFUNC_IMPORTED = 5,
 asFUNC_DELEGATE = 6
};
typedef signed char asINT8;
typedef signed short asINT16;
typedef unsigned char asBYTE;
typedef unsigned short asWORD;
typedef unsigned int asUINT;






 typedef uintptr_t asPWORD;


 typedef unsigned int asDWORD;
 typedef unsigned long asQWORD;
 typedef long asINT64;
typedef void (*asFUNCTION_t)();
typedef void (*asGENFUNC_t)(asIScriptGeneric *);
typedef void *(*asALLOCFUNC_t)(size_t);
typedef void (*asFREEFUNC_t)(void *);
typedef void (*asCLEANENGINEFUNC_t)(asIScriptEngine *);
typedef void (*asCLEANMODULEFUNC_t)(asIScriptModule *);
typedef void (*asCLEANCONTEXTFUNC_t)(asIScriptContext *);
typedef void (*asCLEANFUNCTIONFUNC_t)(asIScriptFunction *);
typedef void (*asCLEANTYPEINFOFUNC_t)(asITypeInfo *);
typedef void (*asCLEANSCRIPTOBJECTFUNC_t)(asIScriptObject *);
typedef asIScriptContext *(*asREQUESTCONTEXTFUNC_t)(asIScriptEngine *, void *);
typedef void (*asRETURNCONTEXTFUNC_t)(asIScriptEngine *, asIScriptContext *, void *);
typedef void (*asCIRCULARREFFUNC_t)(asITypeInfo *, const void *, void *);
class asCUnknownClass;
typedef void (asCUnknownClass::*asMETHOD_t)();

struct asSFuncPtr
{
 asSFuncPtr(asBYTE f = 0)
 {
  for( size_t n = 0; n < sizeof(ptr.dummy); n++ )
   ptr.dummy[n] = 0;
  flag = f;
 }

 void CopyMethodPtr(const void *mthdPtr, size_t size)
 {
  for( size_t n = 0; n < size; n++ )
   ptr.dummy[n] = reinterpret_cast<const char *>(mthdPtr)[n];
 }

 union
 {



  char dummy[25];
  struct {asMETHOD_t mthd; char dummy[25-sizeof(asMETHOD_t)];} m;
  struct {asFUNCTION_t func; char dummy[25-sizeof(asFUNCTION_t)];} f;
 } ptr;
 asBYTE flag;
};
struct asSMessageInfo
{
 const char *section;
 int row;
 int col;
 asEMsgType type;
 const char *message;
};
extern "C"
{

        asIScriptEngine *asCreateScriptEngine(asDWORD version = 23300);
        const char *asGetLibraryVersion();
        const char *asGetLibraryOptions();


        asIScriptContext *asGetActiveContext();


        int asPrepareMultithread(asIThreadManager *externalMgr = 0);
        void asUnprepareMultithread();
        asIThreadManager *asGetThreadManager();
        void asAcquireExclusiveLock();
        void asReleaseExclusiveLock();
        void asAcquireSharedLock();
        void asReleaseSharedLock();
        int asAtomicInc(int &value);
        int asAtomicDec(int &value);
        int asThreadCleanup();


        int asSetGlobalMemoryFunctions(asALLOCFUNC_t allocFunc, asFREEFUNC_t freeFunc);
        int asResetGlobalMemoryFunctions();
        void *asAllocMem(size_t size);
        void asFreeMem(void *mem);


        asILockableSharedBool *asCreateLockableSharedBool();
}
template<typename T>
asUINT asGetTypeTraits()
{




 bool hasConstructor = std::is_default_constructible<T>::value && !std::is_trivially_default_constructible<T>::value;
 bool hasDestructor = std::is_destructible<T>::value && !std::is_trivially_destructible<T>::value;
 bool hasAssignmentOperator = std::is_copy_assignable<T>::value && !std::is_trivially_copy_assignable<T>::value;
 bool hasCopyConstructor = std::is_copy_constructible<T>::value && !std::is_trivially_copy_constructible<T>::value;
 bool isFloat = std::is_floating_point<T>::value;
 bool isPrimitive = std::is_integral<T>::value || std::is_pointer<T>::value || std::is_enum<T>::value;
 bool isClass = std::is_class<T>::value;
 bool isArray = std::is_array<T>::value;

 if( isFloat )
  return asOBJ_APP_FLOAT;
 if( isPrimitive )
  return asOBJ_APP_PRIMITIVE;

 if( isClass )
 {
  asDWORD flags = asOBJ_APP_CLASS;
  if( hasConstructor )
   flags |= asOBJ_APP_CLASS_CONSTRUCTOR;
  if( hasDestructor )
   flags |= asOBJ_APP_CLASS_DESTRUCTOR;
  if( hasAssignmentOperator )
   flags |= asOBJ_APP_CLASS_ASSIGNMENT;
  if( hasCopyConstructor )
   flags |= asOBJ_APP_CLASS_COPY_CONSTRUCTOR;
  return flags;
 }

 if( isArray )
  return asOBJ_APP_ARRAY;


 return 0;
}





class asIScriptEngine
{
public:

 virtual int AddRef() const = 0;
 virtual int Release() const = 0;
 virtual int ShutDownAndRelease() = 0;


 virtual int SetEngineProperty(asEEngineProp property, asPWORD value) = 0;
 virtual asPWORD GetEngineProperty(asEEngineProp property) const = 0;


 virtual int SetMessageCallback(const asSFuncPtr &callback, void *obj, asDWORD callConv) = 0;
 virtual int ClearMessageCallback() = 0;
 virtual int WriteMessage(const char *section, int row, int col, asEMsgType type, const char *message) = 0;


 virtual int SetJITCompiler(asIJITCompiler *compiler) = 0;
 virtual asIJITCompiler *GetJITCompiler() const = 0;


 virtual int RegisterGlobalFunction(const char *declaration, const asSFuncPtr &funcPointer, asDWORD callConv, void *auxiliary = 0) = 0;
 virtual asUINT GetGlobalFunctionCount() const = 0;
 virtual asIScriptFunction *GetGlobalFunctionByIndex(asUINT index) const = 0;
 virtual asIScriptFunction *GetGlobalFunctionByDecl(const char *declaration) const = 0;


 virtual int RegisterGlobalProperty(const char *declaration, void *pointer) = 0;
 virtual asUINT GetGlobalPropertyCount() const = 0;
 virtual int GetGlobalPropertyByIndex(asUINT index, const char **name, const char **nameSpace = 0, int *typeId = 0, bool *isConst = 0, const char **configGroup = 0, void **pointer = 0, asDWORD *accessMask = 0) const = 0;
 virtual int GetGlobalPropertyIndexByName(const char *name) const = 0;
 virtual int GetGlobalPropertyIndexByDecl(const char *decl) const = 0;


 virtual int RegisterObjectType(const char *obj, int byteSize, asDWORD flags) = 0;
 virtual int RegisterObjectProperty(const char *obj, const char *declaration, int byteOffset, int compositeOffset = 0, bool isCompositeIndirect = false) = 0;
 virtual int RegisterObjectMethod(const char *obj, const char *declaration, const asSFuncPtr &funcPointer, asDWORD callConv, void *auxiliary = 0, int compositeOffset = 0, bool isCompositeIndirect = false) = 0;
 virtual int RegisterObjectBehaviour(const char *obj, asEBehaviours behaviour, const char *declaration, const asSFuncPtr &funcPointer, asDWORD callConv, void *auxiliary = 0, int compositeOffset = 0, bool isCompositeIndirect = false) = 0;
 virtual int RegisterInterface(const char *name) = 0;
 virtual int RegisterInterfaceMethod(const char *intf, const char *declaration) = 0;
 virtual asUINT GetObjectTypeCount() const = 0;
 virtual asITypeInfo *GetObjectTypeByIndex(asUINT index) const = 0;


 virtual int RegisterStringFactory(const char *datatype, asIStringFactory *factory) = 0;
 virtual int GetStringFactoryReturnTypeId(asDWORD *flags = 0) const = 0;


 virtual int RegisterDefaultArrayType(const char *type) = 0;
 virtual int GetDefaultArrayTypeId() const = 0;


 virtual int RegisterEnum(const char *type) = 0;
 virtual int RegisterEnumValue(const char *type, const char *name, int value) = 0;
 virtual asUINT GetEnumCount() const = 0;
 virtual asITypeInfo *GetEnumByIndex(asUINT index) const = 0;


 virtual int RegisterFuncdef(const char *decl) = 0;
 virtual asUINT GetFuncdefCount() const = 0;
 virtual asITypeInfo *GetFuncdefByIndex(asUINT index) const = 0;


 virtual int RegisterTypedef(const char *type, const char *decl) = 0;
 virtual asUINT GetTypedefCount() const = 0;
 virtual asITypeInfo *GetTypedefByIndex(asUINT index) const = 0;


 virtual int BeginConfigGroup(const char *groupName) = 0;
 virtual int EndConfigGroup() = 0;
 virtual int RemoveConfigGroup(const char *groupName) = 0;
 virtual asDWORD SetDefaultAccessMask(asDWORD defaultMask) = 0;
 virtual int SetDefaultNamespace(const char *nameSpace) = 0;
 virtual const char *GetDefaultNamespace() const = 0;


 virtual asIScriptModule *GetModule(const char *module, asEGMFlags flag = asGM_ONLY_IF_EXISTS) = 0;
 virtual int DiscardModule(const char *module) = 0;
 virtual asUINT GetModuleCount() const = 0;
 virtual asIScriptModule *GetModuleByIndex(asUINT index) const = 0;


 virtual asIScriptFunction *GetFunctionById(int funcId) const = 0;


 virtual int GetTypeIdByDecl(const char *decl) const = 0;
 virtual const char *GetTypeDeclaration(int typeId, bool includeNamespace = false) const = 0;
 virtual int GetSizeOfPrimitiveType(int typeId) const = 0;
 virtual asITypeInfo *GetTypeInfoById(int typeId) const = 0;
 virtual asITypeInfo *GetTypeInfoByName(const char *name) const = 0;
 virtual asITypeInfo *GetTypeInfoByDecl(const char *decl) const = 0;


 virtual asIScriptContext *CreateContext() = 0;
 virtual void *CreateScriptObject(const asITypeInfo *type) = 0;
 virtual void *CreateScriptObjectCopy(void *obj, const asITypeInfo *type) = 0;
 virtual void *CreateUninitializedScriptObject(const asITypeInfo *type) = 0;
 virtual asIScriptFunction *CreateDelegate(asIScriptFunction *func, void *obj) = 0;
 virtual int AssignScriptObject(void *dstObj, void *srcObj, const asITypeInfo *type) = 0;
 virtual void ReleaseScriptObject(void *obj, const asITypeInfo *type) = 0;
 virtual void AddRefScriptObject(void *obj, const asITypeInfo *type) = 0;
 virtual int RefCastObject(void *obj, asITypeInfo *fromType, asITypeInfo *toType, void **newPtr, bool useOnlyImplicitCast = false) = 0;
 virtual asILockableSharedBool *GetWeakRefFlagOfScriptObject(void *obj, const asITypeInfo *type) const = 0;


 virtual asIScriptContext *RequestContext() = 0;
 virtual void ReturnContext(asIScriptContext *ctx) = 0;
 virtual int SetContextCallbacks(asREQUESTCONTEXTFUNC_t requestCtx, asRETURNCONTEXTFUNC_t returnCtx, void *param = 0) = 0;


 virtual asETokenClass ParseToken(const char *string, size_t stringLength = 0, asUINT *tokenLength = 0) const = 0;


 virtual int GarbageCollect(asDWORD flags = asGC_FULL_CYCLE, asUINT numIterations = 1) = 0;
 virtual void GetGCStatistics(asUINT *currentSize, asUINT *totalDestroyed = 0, asUINT *totalDetected = 0, asUINT *newObjects = 0, asUINT *totalNewDestroyed = 0) const = 0;
 virtual int NotifyGarbageCollectorOfNewObject(void *obj, asITypeInfo *type) = 0;
 virtual int GetObjectInGC(asUINT idx, asUINT *seqNbr = 0, void **obj = 0, asITypeInfo **type = 0) = 0;
 virtual void GCEnumCallback(void *reference) = 0;
 virtual void ForwardGCEnumReferences(void *ref, asITypeInfo *type) = 0;
 virtual void ForwardGCReleaseReferences(void *ref, asITypeInfo *type) = 0;
 virtual void SetCircularRefDetectedCallback(asCIRCULARREFFUNC_t callback, void *param = 0) = 0;


 virtual void *SetUserData(void *data, asPWORD type = 0) = 0;
 virtual void *GetUserData(asPWORD type = 0) const = 0;
 virtual void SetEngineUserDataCleanupCallback(asCLEANENGINEFUNC_t callback, asPWORD type = 0) = 0;
 virtual void SetModuleUserDataCleanupCallback(asCLEANMODULEFUNC_t callback, asPWORD type = 0) = 0;
 virtual void SetContextUserDataCleanupCallback(asCLEANCONTEXTFUNC_t callback, asPWORD type = 0) = 0;
 virtual void SetFunctionUserDataCleanupCallback(asCLEANFUNCTIONFUNC_t callback, asPWORD type = 0) = 0;
 virtual void SetTypeInfoUserDataCleanupCallback(asCLEANTYPEINFOFUNC_t callback, asPWORD type = 0) = 0;
 virtual void SetScriptObjectUserDataCleanupCallback(asCLEANSCRIPTOBJECTFUNC_t callback, asPWORD type = 0) = 0;


 virtual int SetTranslateAppExceptionCallback(asSFuncPtr callback, void *param, int callConv) = 0;

protected:
 virtual ~asIScriptEngine() {}
};

class asIStringFactory
{
public:
 virtual const void *GetStringConstant(const char *data, asUINT length) = 0;
 virtual int ReleaseStringConstant(const void *str) = 0;
 virtual int GetRawStringData(const void *str, char *data, asUINT *length) const = 0;

protected:
 virtual ~asIStringFactory() {}
};

class asIThreadManager
{
protected:
 virtual ~asIThreadManager() {}
};

class asIScriptModule
{
public:
 virtual asIScriptEngine *GetEngine() const = 0;
 virtual void SetName(const char *name) = 0;
 virtual const char *GetName() const = 0;
 virtual void Discard() = 0;


 virtual int AddScriptSection(const char *name, const char *code, size_t codeLength = 0, int lineOffset = 0) = 0;
 virtual int Build() = 0;
 virtual int CompileFunction(const char *sectionName, const char *code, int lineOffset, asDWORD compileFlags, asIScriptFunction **outFunc) = 0;
 virtual int CompileGlobalVar(const char *sectionName, const char *code, int lineOffset) = 0;
 virtual asDWORD SetAccessMask(asDWORD accessMask) = 0;
 virtual int SetDefaultNamespace(const char *nameSpace) = 0;
 virtual const char *GetDefaultNamespace() const = 0;


 virtual asUINT GetFunctionCount() const = 0;
 virtual asIScriptFunction *GetFunctionByIndex(asUINT index) const = 0;
 virtual asIScriptFunction *GetFunctionByDecl(const char *decl) const = 0;
 virtual asIScriptFunction *GetFunctionByName(const char *name) const = 0;
 virtual int RemoveFunction(asIScriptFunction *func) = 0;


 virtual int ResetGlobalVars(asIScriptContext *ctx = 0) = 0;
 virtual asUINT GetGlobalVarCount() const = 0;
 virtual int GetGlobalVarIndexByName(const char *name) const = 0;
 virtual int GetGlobalVarIndexByDecl(const char *decl) const = 0;
 virtual const char *GetGlobalVarDeclaration(asUINT index, bool includeNamespace = false) const = 0;
 virtual int GetGlobalVar(asUINT index, const char **name, const char **nameSpace = 0, int *typeId = 0, bool *isConst = 0) const = 0;
 virtual void *GetAddressOfGlobalVar(asUINT index) = 0;
 virtual int RemoveGlobalVar(asUINT index) = 0;


 virtual asUINT GetObjectTypeCount() const = 0;
 virtual asITypeInfo *GetObjectTypeByIndex(asUINT index) const = 0;
 virtual int GetTypeIdByDecl(const char *decl) const = 0;
 virtual asITypeInfo *GetTypeInfoByName(const char *name) const = 0;
 virtual asITypeInfo *GetTypeInfoByDecl(const char *decl) const = 0;


 virtual asUINT GetEnumCount() const = 0;
 virtual asITypeInfo *GetEnumByIndex(asUINT index) const = 0;


 virtual asUINT GetTypedefCount() const = 0;
 virtual asITypeInfo *GetTypedefByIndex(asUINT index) const = 0;


 virtual asUINT GetImportedFunctionCount() const = 0;
 virtual int GetImportedFunctionIndexByDecl(const char *decl) const = 0;
 virtual const char *GetImportedFunctionDeclaration(asUINT importIndex) const = 0;
 virtual const char *GetImportedFunctionSourceModule(asUINT importIndex) const = 0;
 virtual int BindImportedFunction(asUINT importIndex, asIScriptFunction *func) = 0;
 virtual int UnbindImportedFunction(asUINT importIndex) = 0;
 virtual int BindAllImportedFunctions() = 0;
 virtual int UnbindAllImportedFunctions() = 0;


 virtual int SaveByteCode(asIBinaryStream *out, bool stripDebugInfo = false) const = 0;
 virtual int LoadByteCode(asIBinaryStream *in, bool *wasDebugInfoStripped = 0) = 0;


 virtual void *SetUserData(void *data, asPWORD type = 0) = 0;
 virtual void *GetUserData(asPWORD type = 0) const = 0;

protected:
 virtual ~asIScriptModule() {}
};

class asIScriptContext
{
public:

 virtual int AddRef() const = 0;
 virtual int Release() const = 0;


 virtual asIScriptEngine *GetEngine() const = 0;


 virtual int Prepare(asIScriptFunction *func) = 0;
 virtual int Unprepare() = 0;
 virtual int Execute() = 0;
 virtual int Abort() = 0;
 virtual int Suspend() = 0;
 virtual asEContextState GetState() const = 0;
 virtual int PushState() = 0;
 virtual int PopState() = 0;
 virtual bool IsNested(asUINT *nestCount = 0) const = 0;


 virtual int SetObject(void *obj) = 0;


 virtual int SetArgByte(asUINT arg, asBYTE value) = 0;
 virtual int SetArgWord(asUINT arg, asWORD value) = 0;
 virtual int SetArgDWord(asUINT arg, asDWORD value) = 0;
 virtual int SetArgQWord(asUINT arg, asQWORD value) = 0;
 virtual int SetArgFloat(asUINT arg, float value) = 0;
 virtual int SetArgDouble(asUINT arg, double value) = 0;
 virtual int SetArgAddress(asUINT arg, void *addr) = 0;
 virtual int SetArgObject(asUINT arg, void *obj) = 0;
 virtual int SetArgVarType(asUINT arg, void *ptr, int typeId) = 0;
 virtual void *GetAddressOfArg(asUINT arg) = 0;


 virtual asBYTE GetReturnByte() = 0;
 virtual asWORD GetReturnWord() = 0;
 virtual asDWORD GetReturnDWord() = 0;
 virtual asQWORD GetReturnQWord() = 0;
 virtual float GetReturnFloat() = 0;
 virtual double GetReturnDouble() = 0;
 virtual void *GetReturnAddress() = 0;
 virtual void *GetReturnObject() = 0;
 virtual void *GetAddressOfReturnValue() = 0;


 virtual int SetException(const char *info, bool allowCatch = true) = 0;
 virtual int GetExceptionLineNumber(int *column = 0, const char **sectionName = 0) = 0;
 virtual asIScriptFunction *GetExceptionFunction() = 0;
 virtual const char * GetExceptionString() = 0;
 virtual bool WillExceptionBeCaught() = 0;
 virtual int SetExceptionCallback(asSFuncPtr callback, void *obj, int callConv) = 0;
 virtual void ClearExceptionCallback() = 0;


 virtual int SetLineCallback(asSFuncPtr callback, void *obj, int callConv) = 0;
 virtual void ClearLineCallback() = 0;
 virtual asUINT GetCallstackSize() const = 0;
 virtual asIScriptFunction *GetFunction(asUINT stackLevel = 0) = 0;
 virtual int GetLineNumber(asUINT stackLevel = 0, int *column = 0, const char **sectionName = 0) = 0;
 virtual int GetVarCount(asUINT stackLevel = 0) = 0;
 virtual const char *GetVarName(asUINT varIndex, asUINT stackLevel = 0) = 0;
 virtual const char *GetVarDeclaration(asUINT varIndex, asUINT stackLevel = 0, bool includeNamespace = false) = 0;
 virtual int GetVarTypeId(asUINT varIndex, asUINT stackLevel = 0) = 0;
 virtual void *GetAddressOfVar(asUINT varIndex, asUINT stackLevel = 0) = 0;
 virtual bool IsVarInScope(asUINT varIndex, asUINT stackLevel = 0) = 0;
 virtual int GetThisTypeId(asUINT stackLevel = 0) = 0;
 virtual void *GetThisPointer(asUINT stackLevel = 0) = 0;
 virtual asIScriptFunction *GetSystemFunction() = 0;


 virtual void *SetUserData(void *data, asPWORD type = 0) = 0;
 virtual void *GetUserData(asPWORD type = 0) const = 0;

protected:
 virtual ~asIScriptContext() {}
};

class asIScriptGeneric
{
public:

 virtual asIScriptEngine *GetEngine() const = 0;
 virtual asIScriptFunction *GetFunction() const = 0;
 virtual void *GetAuxiliary() const = 0;


 virtual void *GetObject() = 0;
 virtual int GetObjectTypeId() const = 0;


 virtual int GetArgCount() const = 0;
 virtual int GetArgTypeId(asUINT arg, asDWORD *flags = 0) const = 0;
 virtual asBYTE GetArgByte(asUINT arg) = 0;
 virtual asWORD GetArgWord(asUINT arg) = 0;
 virtual asDWORD GetArgDWord(asUINT arg) = 0;
 virtual asQWORD GetArgQWord(asUINT arg) = 0;
 virtual float GetArgFloat(asUINT arg) = 0;
 virtual double GetArgDouble(asUINT arg) = 0;
 virtual void *GetArgAddress(asUINT arg) = 0;
 virtual void *GetArgObject(asUINT arg) = 0;
 virtual void *GetAddressOfArg(asUINT arg) = 0;


 virtual int GetReturnTypeId(asDWORD *flags = 0) const = 0;
 virtual int SetReturnByte(asBYTE val) = 0;
 virtual int SetReturnWord(asWORD val) = 0;
 virtual int SetReturnDWord(asDWORD val) = 0;
 virtual int SetReturnQWord(asQWORD val) = 0;
 virtual int SetReturnFloat(float val) = 0;
 virtual int SetReturnDouble(double val) = 0;
 virtual int SetReturnAddress(void *addr) = 0;
 virtual int SetReturnObject(void *obj) = 0;
 virtual void *GetAddressOfReturnLocation() = 0;

protected:
 virtual ~asIScriptGeneric() {}
};

class asIScriptObject
{
public:

 virtual int AddRef() const = 0;
 virtual int Release() const = 0;
 virtual asILockableSharedBool *GetWeakRefFlag() const = 0;


 virtual int GetTypeId() const = 0;
 virtual asITypeInfo *GetObjectType() const = 0;


 virtual asUINT GetPropertyCount() const = 0;
 virtual int GetPropertyTypeId(asUINT prop) const = 0;
 virtual const char *GetPropertyName(asUINT prop) const = 0;
 virtual void *GetAddressOfProperty(asUINT prop) = 0;


 virtual asIScriptEngine *GetEngine() const = 0;
 virtual int CopyFrom(asIScriptObject *other) = 0;


 virtual void *SetUserData(void *data, asPWORD type = 0) = 0;
 virtual void *GetUserData(asPWORD type = 0) const = 0;

protected:
 virtual ~asIScriptObject() {}
};

class asITypeInfo
{
public:

 virtual asIScriptEngine *GetEngine() const = 0;
 virtual const char *GetConfigGroup() const = 0;
 virtual asDWORD GetAccessMask() const = 0;
 virtual asIScriptModule *GetModule() const = 0;


 virtual int AddRef() const = 0;
 virtual int Release() const = 0;


 virtual const char *GetName() const = 0;
 virtual const char *GetNamespace() const = 0;
 virtual asITypeInfo *GetBaseType() const = 0;
 virtual bool DerivesFrom(const asITypeInfo *objType) const = 0;
 virtual asDWORD GetFlags() const = 0;
 virtual asUINT GetSize() const = 0;
 virtual int GetTypeId() const = 0;
 virtual int GetSubTypeId(asUINT subTypeIndex = 0) const = 0;
 virtual asITypeInfo *GetSubType(asUINT subTypeIndex = 0) const = 0;
 virtual asUINT GetSubTypeCount() const = 0;


 virtual asUINT GetInterfaceCount() const = 0;
 virtual asITypeInfo *GetInterface(asUINT index) const = 0;
 virtual bool Implements(const asITypeInfo *objType) const = 0;


 virtual asUINT GetFactoryCount() const = 0;
 virtual asIScriptFunction *GetFactoryByIndex(asUINT index) const = 0;
 virtual asIScriptFunction *GetFactoryByDecl(const char *decl) const = 0;


 virtual asUINT GetMethodCount() const = 0;
 virtual asIScriptFunction *GetMethodByIndex(asUINT index, bool getVirtual = true) const = 0;
 virtual asIScriptFunction *GetMethodByName(const char *name, bool getVirtual = true) const = 0;
 virtual asIScriptFunction *GetMethodByDecl(const char *decl, bool getVirtual = true) const = 0;


 virtual asUINT GetPropertyCount() const = 0;
 virtual int GetProperty(asUINT index, const char **name, int *typeId = 0, bool *isPrivate = 0, bool *isProtected = 0, int *offset = 0, bool *isReference = 0, asDWORD *accessMask = 0, int *compositeOffset = 0, bool *isCompositeIndirect = 0) const = 0;
 virtual const char *GetPropertyDeclaration(asUINT index, bool includeNamespace = false) const = 0;


 virtual asUINT GetBehaviourCount() const = 0;
 virtual asIScriptFunction *GetBehaviourByIndex(asUINT index, asEBehaviours *outBehaviour) const = 0;


 virtual asUINT GetChildFuncdefCount() const = 0;
 virtual asITypeInfo *GetChildFuncdef(asUINT index) const = 0;
 virtual asITypeInfo *GetParentType() const = 0;


 virtual asUINT GetEnumValueCount() const = 0;
 virtual const char *GetEnumValueByIndex(asUINT index, int *outValue) const = 0;


 virtual int GetTypedefTypeId() const = 0;


 virtual asIScriptFunction *GetFuncdefSignature() const = 0;


 virtual void *SetUserData(void *data, asPWORD type = 0) = 0;
 virtual void *GetUserData(asPWORD type = 0) const = 0;

protected:
 virtual ~asITypeInfo() {}
};

class asIScriptFunction
{
public:
 virtual asIScriptEngine *GetEngine() const = 0;


 virtual int AddRef() const = 0;
 virtual int Release() const = 0;


 virtual int GetId() const = 0;
 virtual asEFuncType GetFuncType() const = 0;
 virtual const char *GetModuleName() const = 0;
 virtual asIScriptModule *GetModule() const = 0;
 virtual const char *GetScriptSectionName() const = 0;
 virtual const char *GetConfigGroup() const = 0;
 virtual asDWORD GetAccessMask() const = 0;
 virtual void *GetAuxiliary() const = 0;


 virtual asITypeInfo *GetObjectType() const = 0;
 virtual const char *GetObjectName() const = 0;
 virtual const char *GetName() const = 0;
 virtual const char *GetNamespace() const = 0;
 virtual const char *GetDeclaration(bool includeObjectName = true, bool includeNamespace = false, bool includeParamNames = false) const = 0;
 virtual bool IsReadOnly() const = 0;
 virtual bool IsPrivate() const = 0;
 virtual bool IsProtected() const = 0;
 virtual bool IsFinal() const = 0;
 virtual bool IsOverride() const = 0;
 virtual bool IsShared() const = 0;
 virtual bool IsExplicit() const = 0;
 virtual asUINT GetParamCount() const = 0;
 virtual int GetParam(asUINT index, int *typeId, asDWORD *flags = 0, const char **name = 0, const char **defaultArg = 0) const = 0;
 virtual int GetReturnTypeId(asDWORD *flags = 0) const = 0;


 virtual int GetTypeId() const = 0;
 virtual bool IsCompatibleWithTypeId(int typeId) const = 0;


 virtual void *GetDelegateObject() const = 0;
 virtual asITypeInfo *GetDelegateObjectType() const = 0;
 virtual asIScriptFunction *GetDelegateFunction() const = 0;


 virtual asUINT GetVarCount() const = 0;
 virtual int GetVar(asUINT index, const char **name, int *typeId = 0) const = 0;
 virtual const char *GetVarDecl(asUINT index, bool includeNamespace = false) const = 0;
 virtual int FindNextLineWithCode(int line) const = 0;


 virtual asDWORD *GetByteCode(asUINT *length = 0) = 0;


 virtual void *SetUserData(void *userData, asPWORD type = 0) = 0;
 virtual void *GetUserData(asPWORD type = 0) const = 0;

protected:
 virtual ~asIScriptFunction() {};
};

class asIBinaryStream
{
public:
 virtual int Read(void *ptr, asUINT size) = 0;
 virtual int Write(const void *ptr, asUINT size) = 0;

public:
 virtual ~asIBinaryStream() {}
};

class asILockableSharedBool
{
public:

 virtual int AddRef() const = 0;
 virtual int Release() const = 0;


 virtual bool Get() const = 0;
 virtual void Set(bool val) = 0;


 virtual void Lock() const = 0;
 virtual void Unlock() const = 0;

protected:
 virtual ~asILockableSharedBool() {}
};






template <class T>
inline asSFuncPtr asFunctionPtr(T func)
{

 asSFuncPtr p(2);




 p.ptr.f.func = reinterpret_cast<asFUNCTION_t>(size_t(func));






 return p;
}


template<>
inline asSFuncPtr asFunctionPtr<asGENFUNC_t>(asGENFUNC_t func)
{

 asSFuncPtr p(1);
 p.ptr.f.func = reinterpret_cast<asFUNCTION_t>(func);
 return p;
}






class asCSimpleDummy {};
typedef void (asCSimpleDummy::*asSIMPLEMETHOD_t)();
const int SINGLE_PTR_SIZE = sizeof(asSIMPLEMETHOD_t);


template <int N>
struct asSMethodPtr
{
 template<class M>
 static asSFuncPtr Convert(M Mthd)
 {



  int ERROR_UnsupportedMethodPtr[N-100];

  asSFuncPtr p(0);
  return p;
 }
};


template <>
struct asSMethodPtr<SINGLE_PTR_SIZE>
{
 template<class M>
 static asSFuncPtr Convert(M Mthd)
 {

  asSFuncPtr p(3);
  p.CopyMethodPtr(&Mthd, SINGLE_PTR_SIZE);
  return p;
 }
};
struct asSVMRegisters
{
 asDWORD *programPointer;
 asDWORD *stackFramePointer;
 asDWORD *stackPointer;
 asQWORD valueRegister;
 void *objectRegister;
 asITypeInfo *objectType;
 bool doProcessSuspend;
 asIScriptContext *ctx;
};

typedef void (*asJITFunction)(asSVMRegisters *registers, asPWORD jitArg);

class asIJITCompiler
{
public:
 virtual int CompileFunction(asIScriptFunction *function, asJITFunction *output) = 0;
 virtual void ReleaseJITFunction(asJITFunction func) = 0;
public:
 virtual ~asIJITCompiler() {}
};


enum asEBCInstr
{
 asBC_PopPtr = 0,
 asBC_PshGPtr = 1,
 asBC_PshC4 = 2,
 asBC_PshV4 = 3,
 asBC_PSF = 4,
 asBC_SwapPtr = 5,
 asBC_NOT = 6,
 asBC_PshG4 = 7,
 asBC_LdGRdR4 = 8,
 asBC_CALL = 9,
 asBC_RET = 10,
 asBC_JMP = 11,
 asBC_JZ = 12,
 asBC_JNZ = 13,
 asBC_JS = 14,
 asBC_JNS = 15,
 asBC_JP = 16,
 asBC_JNP = 17,
 asBC_TZ = 18,
 asBC_TNZ = 19,
 asBC_TS = 20,
 asBC_TNS = 21,
 asBC_TP = 22,
 asBC_TNP = 23,
 asBC_NEGi = 24,
 asBC_NEGf = 25,
 asBC_NEGd = 26,
 asBC_INCi16 = 27,
 asBC_INCi8 = 28,
 asBC_DECi16 = 29,
 asBC_DECi8 = 30,
 asBC_INCi = 31,
 asBC_DECi = 32,
 asBC_INCf = 33,
 asBC_DECf = 34,
 asBC_INCd = 35,
 asBC_DECd = 36,
 asBC_IncVi = 37,
 asBC_DecVi = 38,
 asBC_BNOT = 39,
 asBC_BAND = 40,
 asBC_BOR = 41,
 asBC_BXOR = 42,
 asBC_BSLL = 43,
 asBC_BSRL = 44,
 asBC_BSRA = 45,
 asBC_COPY = 46,
 asBC_PshC8 = 47,
 asBC_PshVPtr = 48,
 asBC_RDSPtr = 49,
 asBC_CMPd = 50,
 asBC_CMPu = 51,
 asBC_CMPf = 52,
 asBC_CMPi = 53,
 asBC_CMPIi = 54,
 asBC_CMPIf = 55,
 asBC_CMPIu = 56,
 asBC_JMPP = 57,
 asBC_PopRPtr = 58,
 asBC_PshRPtr = 59,
 asBC_STR = 60,
 asBC_CALLSYS = 61,
 asBC_CALLBND = 62,
 asBC_SUSPEND = 63,
 asBC_ALLOC = 64,
 asBC_FREE = 65,
 asBC_LOADOBJ = 66,
 asBC_STOREOBJ = 67,
 asBC_GETOBJ = 68,
 asBC_REFCPY = 69,
 asBC_CHKREF = 70,
 asBC_GETOBJREF = 71,
 asBC_GETREF = 72,
 asBC_PshNull = 73,
 asBC_ClrVPtr = 74,
 asBC_OBJTYPE = 75,
 asBC_TYPEID = 76,
 asBC_SetV4 = 77,
 asBC_SetV8 = 78,
 asBC_ADDSi = 79,
 asBC_CpyVtoV4 = 80,
 asBC_CpyVtoV8 = 81,
 asBC_CpyVtoR4 = 82,
 asBC_CpyVtoR8 = 83,
 asBC_CpyVtoG4 = 84,
 asBC_CpyRtoV4 = 85,
 asBC_CpyRtoV8 = 86,
 asBC_CpyGtoV4 = 87,
 asBC_WRTV1 = 88,
 asBC_WRTV2 = 89,
 asBC_WRTV4 = 90,
 asBC_WRTV8 = 91,
 asBC_RDR1 = 92,
 asBC_RDR2 = 93,
 asBC_RDR4 = 94,
 asBC_RDR8 = 95,
 asBC_LDG = 96,
 asBC_LDV = 97,
 asBC_PGA = 98,
 asBC_CmpPtr = 99,
 asBC_VAR = 100,
 asBC_iTOf = 101,
 asBC_fTOi = 102,
 asBC_uTOf = 103,
 asBC_fTOu = 104,
 asBC_sbTOi = 105,
 asBC_swTOi = 106,
 asBC_ubTOi = 107,
 asBC_uwTOi = 108,
 asBC_dTOi = 109,
 asBC_dTOu = 110,
 asBC_dTOf = 111,
 asBC_iTOd = 112,
 asBC_uTOd = 113,
 asBC_fTOd = 114,
 asBC_ADDi = 115,
 asBC_SUBi = 116,
 asBC_MULi = 117,
 asBC_DIVi = 118,
 asBC_MODi = 119,
 asBC_ADDf = 120,
 asBC_SUBf = 121,
 asBC_MULf = 122,
 asBC_DIVf = 123,
 asBC_MODf = 124,
 asBC_ADDd = 125,
 asBC_SUBd = 126,
 asBC_MULd = 127,
 asBC_DIVd = 128,
 asBC_MODd = 129,
 asBC_ADDIi = 130,
 asBC_SUBIi = 131,
 asBC_MULIi = 132,
 asBC_ADDIf = 133,
 asBC_SUBIf = 134,
 asBC_MULIf = 135,
 asBC_SetG4 = 136,
 asBC_ChkRefS = 137,
 asBC_ChkNullV = 138,
 asBC_CALLINTF = 139,
 asBC_iTOb = 140,
 asBC_iTOw = 141,
 asBC_SetV1 = 142,
 asBC_SetV2 = 143,
 asBC_Cast = 144,
 asBC_i64TOi = 145,
 asBC_uTOi64 = 146,
 asBC_iTOi64 = 147,
 asBC_fTOi64 = 148,
 asBC_dTOi64 = 149,
 asBC_fTOu64 = 150,
 asBC_dTOu64 = 151,
 asBC_i64TOf = 152,
 asBC_u64TOf = 153,
 asBC_i64TOd = 154,
 asBC_u64TOd = 155,
 asBC_NEGi64 = 156,
 asBC_INCi64 = 157,
 asBC_DECi64 = 158,
 asBC_BNOT64 = 159,
 asBC_ADDi64 = 160,
 asBC_SUBi64 = 161,
 asBC_MULi64 = 162,
 asBC_DIVi64 = 163,
 asBC_MODi64 = 164,
 asBC_BAND64 = 165,
 asBC_BOR64 = 166,
 asBC_BXOR64 = 167,
 asBC_BSLL64 = 168,
 asBC_BSRL64 = 169,
 asBC_BSRA64 = 170,
 asBC_CMPi64 = 171,
 asBC_CMPu64 = 172,
 asBC_ChkNullS = 173,
 asBC_ClrHi = 174,
 asBC_JitEntry = 175,
 asBC_CallPtr = 176,
 asBC_FuncPtr = 177,
 asBC_LoadThisR = 178,
 asBC_PshV8 = 179,
 asBC_DIVu = 180,
 asBC_MODu = 181,
 asBC_DIVu64 = 182,
 asBC_MODu64 = 183,
 asBC_LoadRObjR = 184,
 asBC_LoadVObjR = 185,
 asBC_RefCpyV = 186,
 asBC_JLowZ = 187,
 asBC_JLowNZ = 188,
 asBC_AllocMem = 189,
 asBC_SetListSize = 190,
 asBC_PshListElmnt = 191,
 asBC_SetListType = 192,
 asBC_POWi = 193,
 asBC_POWu = 194,
 asBC_POWf = 195,
 asBC_POWd = 196,
 asBC_POWdi = 197,
 asBC_POWi64 = 198,
 asBC_POWu64 = 199,
 asBC_Thiscall1 = 200,
 asBC_MAXBYTECODE = 201,


 asBC_TryBlock = 250,
 asBC_VarDecl = 251,
 asBC_Block = 252,
 asBC_ObjInfo = 253,
 asBC_LINE = 254,
 asBC_LABEL = 255
};


enum asEBCType
{
 asBCTYPE_INFO = 0,
 asBCTYPE_NO_ARG = 1,
 asBCTYPE_W_ARG = 2,
 asBCTYPE_wW_ARG = 3,
 asBCTYPE_DW_ARG = 4,
 asBCTYPE_rW_DW_ARG = 5,
 asBCTYPE_QW_ARG = 6,
 asBCTYPE_DW_DW_ARG = 7,
 asBCTYPE_wW_rW_rW_ARG = 8,
 asBCTYPE_wW_QW_ARG = 9,
 asBCTYPE_wW_rW_ARG = 10,
 asBCTYPE_rW_ARG = 11,
 asBCTYPE_wW_DW_ARG = 12,
 asBCTYPE_wW_rW_DW_ARG = 13,
 asBCTYPE_rW_rW_ARG = 14,
 asBCTYPE_wW_W_ARG = 15,
 asBCTYPE_QW_DW_ARG = 16,
 asBCTYPE_rW_QW_ARG = 17,
 asBCTYPE_W_DW_ARG = 18,
 asBCTYPE_rW_W_DW_ARG = 19,
 asBCTYPE_rW_DW_DW_ARG = 20
};


const int asBCTypeSize[21] =
{
 0,
 1,
 1,
 1,
 2,
 2,
 3,
 3,
 2,
 3,
 2,
 1,
 2,
 3,
 2,
 2,
 4,
 3,
 2,
 3,
 3
};


struct asSBCInfo
{
 asEBCInstr bc;
 asEBCType type;
 int stackInc;
 const char *name;
};
const asSBCInfo asBCInfo[256] =
{
 {asBC_PopPtr, asBCTYPE_NO_ARG, -2, "PopPtr"},
 {asBC_PshGPtr, asBCTYPE_QW_ARG, 2, "PshGPtr"},
 {asBC_PshC4, asBCTYPE_DW_ARG, 1, "PshC4"},
 {asBC_PshV4, asBCTYPE_rW_ARG, 1, "PshV4"},
 {asBC_PSF, asBCTYPE_rW_ARG, 2, "PSF"},
 {asBC_SwapPtr, asBCTYPE_NO_ARG, 0, "SwapPtr"},
 {asBC_NOT, asBCTYPE_rW_ARG, 0, "NOT"},
 {asBC_PshG4, asBCTYPE_QW_ARG, 1, "PshG4"},
 {asBC_LdGRdR4, asBCTYPE_wW_QW_ARG, 0, "LdGRdR4"},
 {asBC_CALL, asBCTYPE_DW_ARG, 0xFFFF, "CALL"},
 {asBC_RET, asBCTYPE_W_ARG, 0xFFFF, "RET"},
 {asBC_JMP, asBCTYPE_DW_ARG, 0, "JMP"},
 {asBC_JZ, asBCTYPE_DW_ARG, 0, "JZ"},
 {asBC_JNZ, asBCTYPE_DW_ARG, 0, "JNZ"},
 {asBC_JS, asBCTYPE_DW_ARG, 0, "JS"},
 {asBC_JNS, asBCTYPE_DW_ARG, 0, "JNS"},
 {asBC_JP, asBCTYPE_DW_ARG, 0, "JP"},
 {asBC_JNP, asBCTYPE_DW_ARG, 0, "JNP"},
 {asBC_TZ, asBCTYPE_NO_ARG, 0, "TZ"},
 {asBC_TNZ, asBCTYPE_NO_ARG, 0, "TNZ"},
 {asBC_TS, asBCTYPE_NO_ARG, 0, "TS"},
 {asBC_TNS, asBCTYPE_NO_ARG, 0, "TNS"},
 {asBC_TP, asBCTYPE_NO_ARG, 0, "TP"},
 {asBC_TNP, asBCTYPE_NO_ARG, 0, "TNP"},
 {asBC_NEGi, asBCTYPE_rW_ARG, 0, "NEGi"},
 {asBC_NEGf, asBCTYPE_rW_ARG, 0, "NEGf"},
 {asBC_NEGd, asBCTYPE_rW_ARG, 0, "NEGd"},
 {asBC_INCi16, asBCTYPE_NO_ARG, 0, "INCi16"},
 {asBC_INCi8, asBCTYPE_NO_ARG, 0, "INCi8"},
 {asBC_DECi16, asBCTYPE_NO_ARG, 0, "DECi16"},
 {asBC_DECi8, asBCTYPE_NO_ARG, 0, "DECi8"},
 {asBC_INCi, asBCTYPE_NO_ARG, 0, "INCi"},
 {asBC_DECi, asBCTYPE_NO_ARG, 0, "DECi"},
 {asBC_INCf, asBCTYPE_NO_ARG, 0, "INCf"},
 {asBC_DECf, asBCTYPE_NO_ARG, 0, "DECf"},
 {asBC_INCd, asBCTYPE_NO_ARG, 0, "INCd"},
 {asBC_DECd, asBCTYPE_NO_ARG, 0, "DECd"},
 {asBC_IncVi, asBCTYPE_rW_ARG, 0, "IncVi"},
 {asBC_DecVi, asBCTYPE_rW_ARG, 0, "DecVi"},
 {asBC_BNOT, asBCTYPE_rW_ARG, 0, "BNOT"},
 {asBC_BAND, asBCTYPE_wW_rW_rW_ARG, 0, "BAND"},
 {asBC_BOR, asBCTYPE_wW_rW_rW_ARG, 0, "BOR"},
 {asBC_BXOR, asBCTYPE_wW_rW_rW_ARG, 0, "BXOR"},
 {asBC_BSLL, asBCTYPE_wW_rW_rW_ARG, 0, "BSLL"},
 {asBC_BSRL, asBCTYPE_wW_rW_rW_ARG, 0, "BSRL"},
 {asBC_BSRA, asBCTYPE_wW_rW_rW_ARG, 0, "BSRA"},
 {asBC_COPY, asBCTYPE_W_DW_ARG, -2, "COPY"},
 {asBC_PshC8, asBCTYPE_QW_ARG, 2, "PshC8"},
 {asBC_PshVPtr, asBCTYPE_rW_ARG, 2, "PshVPtr"},
 {asBC_RDSPtr, asBCTYPE_NO_ARG, 0, "RDSPtr"},
 {asBC_CMPd, asBCTYPE_rW_rW_ARG, 0, "CMPd"},
 {asBC_CMPu, asBCTYPE_rW_rW_ARG, 0, "CMPu"},
 {asBC_CMPf, asBCTYPE_rW_rW_ARG, 0, "CMPf"},
 {asBC_CMPi, asBCTYPE_rW_rW_ARG, 0, "CMPi"},
 {asBC_CMPIi, asBCTYPE_rW_DW_ARG, 0, "CMPIi"},
 {asBC_CMPIf, asBCTYPE_rW_DW_ARG, 0, "CMPIf"},
 {asBC_CMPIu, asBCTYPE_rW_DW_ARG, 0, "CMPIu"},
 {asBC_JMPP, asBCTYPE_rW_ARG, 0, "JMPP"},
 {asBC_PopRPtr, asBCTYPE_NO_ARG, -2, "PopRPtr"},
 {asBC_PshRPtr, asBCTYPE_NO_ARG, 2, "PshRPtr"},
 {asBC_STR, asBCTYPE_W_ARG, 1+2, "STR"},
 {asBC_CALLSYS, asBCTYPE_DW_ARG, 0xFFFF, "CALLSYS"},
 {asBC_CALLBND, asBCTYPE_DW_ARG, 0xFFFF, "CALLBND"},
 {asBC_SUSPEND, asBCTYPE_NO_ARG, 0, "SUSPEND"},
 {asBC_ALLOC, asBCTYPE_QW_DW_ARG, 0xFFFF, "ALLOC"},
 {asBC_FREE, asBCTYPE_wW_QW_ARG, 0, "FREE"},
 {asBC_LOADOBJ, asBCTYPE_rW_ARG, 0, "LOADOBJ"},
 {asBC_STOREOBJ, asBCTYPE_wW_ARG, 0, "STOREOBJ"},
 {asBC_GETOBJ, asBCTYPE_W_ARG, 0, "GETOBJ"},
 {asBC_REFCPY, asBCTYPE_QW_ARG, -2, "REFCPY"},
 {asBC_CHKREF, asBCTYPE_NO_ARG, 0, "CHKREF"},
 {asBC_GETOBJREF, asBCTYPE_W_ARG, 0, "GETOBJREF"},
 {asBC_GETREF, asBCTYPE_W_ARG, 0, "GETREF"},
 {asBC_PshNull, asBCTYPE_NO_ARG, 2, "PshNull"},
 {asBC_ClrVPtr, asBCTYPE_wW_ARG, 0, "ClrVPtr"},
 {asBC_OBJTYPE, asBCTYPE_QW_ARG, 2, "OBJTYPE"},
 {asBC_TYPEID, asBCTYPE_DW_ARG, 1, "TYPEID"},
 {asBC_SetV4, asBCTYPE_wW_DW_ARG, 0, "SetV4"},
 {asBC_SetV8, asBCTYPE_wW_QW_ARG, 0, "SetV8"},
 {asBC_ADDSi, asBCTYPE_W_DW_ARG, 0, "ADDSi"},
 {asBC_CpyVtoV4, asBCTYPE_wW_rW_ARG, 0, "CpyVtoV4"},
 {asBC_CpyVtoV8, asBCTYPE_wW_rW_ARG, 0, "CpyVtoV8"},
 {asBC_CpyVtoR4, asBCTYPE_rW_ARG, 0, "CpyVtoR4"},
 {asBC_CpyVtoR8, asBCTYPE_rW_ARG, 0, "CpyVtoR8"},
 {asBC_CpyVtoG4, asBCTYPE_rW_QW_ARG, 0, "CpyVtoG4"},
 {asBC_CpyRtoV4, asBCTYPE_wW_ARG, 0, "CpyRtoV4"},
 {asBC_CpyRtoV8, asBCTYPE_wW_ARG, 0, "CpyRtoV8"},
 {asBC_CpyGtoV4, asBCTYPE_wW_QW_ARG, 0, "CpyGtoV4"},
 {asBC_WRTV1, asBCTYPE_rW_ARG, 0, "WRTV1"},
 {asBC_WRTV2, asBCTYPE_rW_ARG, 0, "WRTV2"},
 {asBC_WRTV4, asBCTYPE_rW_ARG, 0, "WRTV4"},
 {asBC_WRTV8, asBCTYPE_rW_ARG, 0, "WRTV8"},
 {asBC_RDR1, asBCTYPE_wW_ARG, 0, "RDR1"},
 {asBC_RDR2, asBCTYPE_wW_ARG, 0, "RDR2"},
 {asBC_RDR4, asBCTYPE_wW_ARG, 0, "RDR4"},
 {asBC_RDR8, asBCTYPE_wW_ARG, 0, "RDR8"},
 {asBC_LDG, asBCTYPE_QW_ARG, 0, "LDG"},
 {asBC_LDV, asBCTYPE_rW_ARG, 0, "LDV"},
 {asBC_PGA, asBCTYPE_QW_ARG, 2, "PGA"},
 {asBC_CmpPtr, asBCTYPE_rW_rW_ARG, 0, "CmpPtr"},
 {asBC_VAR, asBCTYPE_rW_ARG, 2, "VAR"},
 {asBC_iTOf, asBCTYPE_rW_ARG, 0, "iTOf"},
 {asBC_fTOi, asBCTYPE_rW_ARG, 0, "fTOi"},
 {asBC_uTOf, asBCTYPE_rW_ARG, 0, "uTOf"},
 {asBC_fTOu, asBCTYPE_rW_ARG, 0, "fTOu"},
 {asBC_sbTOi, asBCTYPE_rW_ARG, 0, "sbTOi"},
 {asBC_swTOi, asBCTYPE_rW_ARG, 0, "swTOi"},
 {asBC_ubTOi, asBCTYPE_rW_ARG, 0, "ubTOi"},
 {asBC_uwTOi, asBCTYPE_rW_ARG, 0, "uwTOi"},
 {asBC_dTOi, asBCTYPE_wW_rW_ARG, 0, "dTOi"},
 {asBC_dTOu, asBCTYPE_wW_rW_ARG, 0, "dTOu"},
 {asBC_dTOf, asBCTYPE_wW_rW_ARG, 0, "dTOf"},
 {asBC_iTOd, asBCTYPE_wW_rW_ARG, 0, "iTOd"},
 {asBC_uTOd, asBCTYPE_wW_rW_ARG, 0, "uTOd"},
 {asBC_fTOd, asBCTYPE_wW_rW_ARG, 0, "fTOd"},
 {asBC_ADDi, asBCTYPE_wW_rW_rW_ARG, 0, "ADDi"},
 {asBC_SUBi, asBCTYPE_wW_rW_rW_ARG, 0, "SUBi"},
 {asBC_MULi, asBCTYPE_wW_rW_rW_ARG, 0, "MULi"},
 {asBC_DIVi, asBCTYPE_wW_rW_rW_ARG, 0, "DIVi"},
 {asBC_MODi, asBCTYPE_wW_rW_rW_ARG, 0, "MODi"},
 {asBC_ADDf, asBCTYPE_wW_rW_rW_ARG, 0, "ADDf"},
 {asBC_SUBf, asBCTYPE_wW_rW_rW_ARG, 0, "SUBf"},
 {asBC_MULf, asBCTYPE_wW_rW_rW_ARG, 0, "MULf"},
 {asBC_DIVf, asBCTYPE_wW_rW_rW_ARG, 0, "DIVf"},
 {asBC_MODf, asBCTYPE_wW_rW_rW_ARG, 0, "MODf"},
 {asBC_ADDd, asBCTYPE_wW_rW_rW_ARG, 0, "ADDd"},
 {asBC_SUBd, asBCTYPE_wW_rW_rW_ARG, 0, "SUBd"},
 {asBC_MULd, asBCTYPE_wW_rW_rW_ARG, 0, "MULd"},
 {asBC_DIVd, asBCTYPE_wW_rW_rW_ARG, 0, "DIVd"},
 {asBC_MODd, asBCTYPE_wW_rW_rW_ARG, 0, "MODd"},
 {asBC_ADDIi, asBCTYPE_wW_rW_DW_ARG, 0, "ADDIi"},
 {asBC_SUBIi, asBCTYPE_wW_rW_DW_ARG, 0, "SUBIi"},
 {asBC_MULIi, asBCTYPE_wW_rW_DW_ARG, 0, "MULIi"},
 {asBC_ADDIf, asBCTYPE_wW_rW_DW_ARG, 0, "ADDIf"},
 {asBC_SUBIf, asBCTYPE_wW_rW_DW_ARG, 0, "SUBIf"},
 {asBC_MULIf, asBCTYPE_wW_rW_DW_ARG, 0, "MULIf"},
 {asBC_SetG4, asBCTYPE_QW_DW_ARG, 0, "SetG4"},
 {asBC_ChkRefS, asBCTYPE_NO_ARG, 0, "ChkRefS"},
 {asBC_ChkNullV, asBCTYPE_rW_ARG, 0, "ChkNullV"},
 {asBC_CALLINTF, asBCTYPE_DW_ARG, 0xFFFF, "CALLINTF"},
 {asBC_iTOb, asBCTYPE_rW_ARG, 0, "iTOb"},
 {asBC_iTOw, asBCTYPE_rW_ARG, 0, "iTOw"},
 {asBC_SetV1, asBCTYPE_wW_DW_ARG, 0, "SetV1"},
 {asBC_SetV2, asBCTYPE_wW_DW_ARG, 0, "SetV2"},
 {asBC_Cast, asBCTYPE_DW_ARG, -2, "Cast"},
 {asBC_i64TOi, asBCTYPE_wW_rW_ARG, 0, "i64TOi"},
 {asBC_uTOi64, asBCTYPE_wW_rW_ARG, 0, "uTOi64"},
 {asBC_iTOi64, asBCTYPE_wW_rW_ARG, 0, "iTOi64"},
 {asBC_fTOi64, asBCTYPE_wW_rW_ARG, 0, "fTOi64"},
 {asBC_dTOi64, asBCTYPE_rW_ARG, 0, "dTOi64"},
 {asBC_fTOu64, asBCTYPE_wW_rW_ARG, 0, "fTOu64"},
 {asBC_dTOu64, asBCTYPE_rW_ARG, 0, "dTOu64"},
 {asBC_i64TOf, asBCTYPE_wW_rW_ARG, 0, "i64TOf"},
 {asBC_u64TOf, asBCTYPE_wW_rW_ARG, 0, "u64TOf"},
 {asBC_i64TOd, asBCTYPE_rW_ARG, 0, "i64TOd"},
 {asBC_u64TOd, asBCTYPE_rW_ARG, 0, "u64TOd"},
 {asBC_NEGi64, asBCTYPE_rW_ARG, 0, "NEGi64"},
 {asBC_INCi64, asBCTYPE_NO_ARG, 0, "INCi64"},
 {asBC_DECi64, asBCTYPE_NO_ARG, 0, "DECi64"},
 {asBC_BNOT64, asBCTYPE_rW_ARG, 0, "BNOT64"},
 {asBC_ADDi64, asBCTYPE_wW_rW_rW_ARG, 0, "ADDi64"},
 {asBC_SUBi64, asBCTYPE_wW_rW_rW_ARG, 0, "SUBi64"},
 {asBC_MULi64, asBCTYPE_wW_rW_rW_ARG, 0, "MULi64"},
 {asBC_DIVi64, asBCTYPE_wW_rW_rW_ARG, 0, "DIVi64"},
 {asBC_MODi64, asBCTYPE_wW_rW_rW_ARG, 0, "MODi64"},
 {asBC_BAND64, asBCTYPE_wW_rW_rW_ARG, 0, "BAND64"},
 {asBC_BOR64, asBCTYPE_wW_rW_rW_ARG, 0, "BOR64"},
 {asBC_BXOR64, asBCTYPE_wW_rW_rW_ARG, 0, "BXOR64"},
 {asBC_BSLL64, asBCTYPE_wW_rW_rW_ARG, 0, "BSLL64"},
 {asBC_BSRL64, asBCTYPE_wW_rW_rW_ARG, 0, "BSRL64"},
 {asBC_BSRA64, asBCTYPE_wW_rW_rW_ARG, 0, "BSRA64"},
 {asBC_CMPi64, asBCTYPE_rW_rW_ARG, 0, "CMPi64"},
 {asBC_CMPu64, asBCTYPE_rW_rW_ARG, 0, "CMPu64"},
 {asBC_ChkNullS, asBCTYPE_W_ARG, 0, "ChkNullS"},
 {asBC_ClrHi, asBCTYPE_NO_ARG, 0, "ClrHi"},
 {asBC_JitEntry, asBCTYPE_QW_ARG, 0, "JitEntry"},
 {asBC_CallPtr, asBCTYPE_rW_ARG, 0xFFFF, "CallPtr"},
 {asBC_FuncPtr, asBCTYPE_QW_ARG, 2, "FuncPtr"},
 {asBC_LoadThisR, asBCTYPE_W_DW_ARG, 0, "LoadThisR"},
 {asBC_PshV8, asBCTYPE_rW_ARG, 2, "PshV8"},
 {asBC_DIVu, asBCTYPE_wW_rW_rW_ARG, 0, "DIVu"},
 {asBC_MODu, asBCTYPE_wW_rW_rW_ARG, 0, "MODu"},
 {asBC_DIVu64, asBCTYPE_wW_rW_rW_ARG, 0, "DIVu64"},
 {asBC_MODu64, asBCTYPE_wW_rW_rW_ARG, 0, "MODu64"},
 {asBC_LoadRObjR, asBCTYPE_rW_W_DW_ARG, 0, "LoadRObjR"},
 {asBC_LoadVObjR, asBCTYPE_rW_W_DW_ARG, 0, "LoadVObjR"},
 {asBC_RefCpyV, asBCTYPE_wW_QW_ARG, 0, "RefCpyV"},
 {asBC_JLowZ, asBCTYPE_DW_ARG, 0, "JLowZ"},
 {asBC_JLowNZ, asBCTYPE_DW_ARG, 0, "JLowNZ"},
 {asBC_AllocMem, asBCTYPE_wW_DW_ARG, 0, "AllocMem"},
 {asBC_SetListSize, asBCTYPE_rW_DW_DW_ARG, 0, "SetListSize"},
 {asBC_PshListElmnt, asBCTYPE_rW_DW_ARG, 2, "PshListElmnt"},
 {asBC_SetListType, asBCTYPE_rW_DW_DW_ARG, 0, "SetListType"},
 {asBC_POWi, asBCTYPE_wW_rW_rW_ARG, 0, "POWi"},
 {asBC_POWu, asBCTYPE_wW_rW_rW_ARG, 0, "POWu"},
 {asBC_POWf, asBCTYPE_wW_rW_rW_ARG, 0, "POWf"},
 {asBC_POWd, asBCTYPE_wW_rW_rW_ARG, 0, "POWd"},
 {asBC_POWdi, asBCTYPE_wW_rW_rW_ARG, 0, "POWdi"},
 {asBC_POWi64, asBCTYPE_wW_rW_rW_ARG, 0, "POWi64"},
 {asBC_POWu64, asBCTYPE_wW_rW_rW_ARG, 0, "POWu64"},
 {asBC_Thiscall1, asBCTYPE_DW_ARG, -2 -1, "Thiscall1"},

 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "201"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "202"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "203"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "204"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "205"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "206"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "207"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "208"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "209"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "210"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "211"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "212"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "213"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "214"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "215"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "216"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "217"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "218"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "219"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "220"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "221"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "222"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "223"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "224"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "225"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "226"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "227"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "228"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "229"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "230"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "231"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "232"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "233"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "234"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "235"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "236"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "237"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "238"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "239"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "240"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "241"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "242"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "243"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "244"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "245"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "246"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "247"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "248"},
 {asBC_MAXBYTECODE, asBCTYPE_INFO, 0, "BC_" "249"},

 {asBC_TryBlock, asBCTYPE_DW_ARG, 0, "TryBlock"},
 {asBC_VarDecl, asBCTYPE_W_ARG, 0, "VarDecl"},
 {asBC_Block, asBCTYPE_INFO, 0, "Block"},
 {asBC_ObjInfo, asBCTYPE_rW_DW_ARG, 0, "ObjInfo"},
 {asBC_LINE, asBCTYPE_INFO, 0, "LINE"},
 {asBC_LABEL, asBCTYPE_INFO, 0, "LABEL"}
};




namespace Urho3D
{

struct SArrayBuffer;
struct SArrayCache;


class __attribute__((visibility("default"))) CScriptArray
{
public:

    static void SetMemoryFunctions(asALLOCFUNC_t allocFunc, asFREEFUNC_t freeFunc);


    static CScriptArray *Create(asITypeInfo *ot);
    static CScriptArray *Create(asITypeInfo *ot, asUINT length);
    static CScriptArray *Create(asITypeInfo *ot, asUINT length, void *defVal);
    static CScriptArray *Create(asITypeInfo *ot, void *initList);


    void AddRef() const;
    void Release() const;


    asITypeInfo *GetArrayObjectType() const;
    int GetArrayTypeId() const;
    int GetElementTypeId() const;


    asUINT GetSize() const;


    bool IsEmpty() const;


    void Reserve(asUINT maxElements);


    void Resize(asUINT numElements);


    void *At(asUINT index);
    const void *At(asUINT index) const;





    void SetValue(asUINT index, void *value);


    CScriptArray &operator=(const CScriptArray&);


    bool operator==(const CScriptArray &) const;


    void InsertAt(asUINT index, void *value);
    void RemoveAt(asUINT index);
    void InsertLast(void *value);
    void RemoveLast();
    void SortAsc();
    void SortDesc();
    void SortAsc(asUINT startAt, asUINT count);
    void SortDesc(asUINT startAt, asUINT count);
    void Sort(asUINT startAt, asUINT count, bool asc);
    void Reverse();
    int Find(void *value) const;
    int Find(asUINT startAt, void *value) const;
    int FindByRef(void *ref) const;
    int FindByRef(asUINT startAt, void *ref) const;

    bool Swap(CScriptArray& other);


    int GetRefCount();
    void SetFlag();
    bool GetFlag();
    void EnumReferences(asIScriptEngine *engine);
    void ReleaseAllHandles(asIScriptEngine *engine);

protected:
    mutable int refCount;
    mutable bool gcFlag;
    asITypeInfo *objType;
    SArrayBuffer *buffer;
    size_t elementSize;
    int subTypeId{};


    CScriptArray(asITypeInfo *ot, void *buf);
    CScriptArray(asUINT length, asITypeInfo *ot);
    CScriptArray(asUINT length, void *defVal, asITypeInfo *ot);
    CScriptArray(const CScriptArray &other);
    virtual ~CScriptArray();

    bool Less(const void *a, const void *b, bool asc, asIScriptContext *ctx, SArrayCache *cache);
    void *GetArrayItemPointer(int index);
    void *GetDataPointer(void *buffer);
    void Copy(void *dst, void *src);
    void Precache();
    bool CheckMaxSize(asUINT numElements);
    void Resize(int delta, asUINT at);
    void CreateBuffer(SArrayBuffer **buf, asUINT numElements);
    void DeleteBuffer(SArrayBuffer *buf);
    void CopyBuffer(SArrayBuffer *dst, SArrayBuffer *src);
    void Construct(SArrayBuffer *buf, asUINT start, asUINT end);
    void Destruct(SArrayBuffer *buf, asUINT start, asUINT end);
    bool Equals(const void *a, const void *b, asIScriptContext *ctx, SArrayCache *cache) const;
};

class CScriptDictionary;


class __attribute__((visibility("default"))) CScriptDictValue
{
public:



    CScriptDictValue();
    CScriptDictValue(asIScriptEngine *engine, void *value, int typeId);


    ~CScriptDictValue();


    void Set(asIScriptEngine *engine, void *value, int typeId);
    void Set(asIScriptEngine *engine, const asINT64 &value);
    void Set(asIScriptEngine *engine, const double &value);


    bool Get(asIScriptEngine *engine, void *value, int typeId) const;
    bool Get(asIScriptEngine *engine, asINT64 &value) const;
    bool Get(asIScriptEngine *engine, double &value) const;


    int GetTypeId() const;


    void FreeValue(asIScriptEngine *engine);

protected:
    friend class CScriptDictionary;

    union
    {
        asINT64 m_valueInt;
        double m_valueFlt;
        void *m_valueObj;
    };
    int m_typeId;
};


class __attribute__((visibility("default"))) CScriptDictionary
{
public:

    static CScriptDictionary *Create(asIScriptEngine *engine);


    static CScriptDictionary *Create(asBYTE *buffer);


    void AddRef() const;
    void Release() const;


    CScriptDictionary &operator =(const CScriptDictionary &other);


    void Set(const String &key, void *value, int typeId);
    void Set(const String &key, const asINT64 &value);
    void Set(const String &key, const double &value);


    bool Get(const String &key, void *value, int typeId) const;
    bool Get(const String &key, asINT64 &value) const;
    bool Get(const String &key, double &value) const;



    CScriptDictValue *operator[](const String &key);
    const CScriptDictValue *operator[](const String &key) const;


    int GetTypeId(const String &key) const;


    bool Exists(const String &key) const;


    bool IsEmpty() const;


    asUINT GetSize() const;


    void Delete(const String &key);


    void DeleteAll();


    CScriptArray *GetKeys() const;

public:

    class CIterator
    {
    public:
        void operator++();
        void operator++(int);


        CIterator &operator*();

        bool operator==(const CIterator &other) const;
        bool operator!=(const CIterator &other) const;


        const String &GetKey() const;
        int GetTypeId() const;
        bool GetValue(asINT64 &value) const;
        bool GetValue(double &value) const;
        bool GetValue(void *value, int typeId) const;

    protected:
        friend class CScriptDictionary;

        CIterator();
        CIterator(const CScriptDictionary &dict,
                  HashMap<String, CScriptDictValue>::ConstIterator it);

        CIterator &operator=(const CIterator &) {return *this;}

        HashMap<String, CScriptDictValue>::ConstIterator m_it;
        const CScriptDictionary &m_dict;
    };

    CIterator begin() const;
    CIterator end() const;


    int GetRefCount();
    void SetGCFlag();
    bool GetGCFlag();
    void EnumReferences(asIScriptEngine *engine);
    void ReleaseAllReferences(asIScriptEngine *engine);

protected:



    explicit CScriptDictionary(asIScriptEngine *engine);
    explicit CScriptDictionary(asBYTE *buffer);


    virtual ~CScriptDictionary();


    asIScriptEngine *engine;
    mutable int refCount;
    mutable bool gcFlag;


    HashMap<String, CScriptDictValue> dict;
};


class __attribute__((visibility("default"))) StringFactory : public asIStringFactory
{
public:
    const void* GetStringConstant(const char* data, asUINT length) override;
    int ReleaseStringConstant(const void* str) override;
    int GetRawStringData(const void* str, char* data, asUINT* length) const override;

private:
    StringMap map_;
};


void RegisterArray(asIScriptEngine* engine);

void RegisterDictionary(asIScriptEngine* engine);

void RegisterString(asIScriptEngine* engine);

}

namespace Urho3D
{


class __attribute__((visibility("default"))) Mutex
{
public:

    Mutex();

    ~Mutex();


    void Acquire();

    bool TryAcquire();

    void Release();

private:

    void* handle_;
};


class __attribute__((visibility("default"))) MutexLock
{
public:

    explicit MutexLock(Mutex& mutex);

    ~MutexLock();


    MutexLock(const MutexLock& rhs) = delete;

    MutexLock& operator =(const MutexLock& rhs) = delete;

private:

    Mutex& mutex_;
};

}

namespace Urho3D
{


struct __attribute__((visibility("default"))) LinkedListNode
{

    LinkedListNode() :
        next_(nullptr)
    {
    }


    LinkedListNode* next_;
};


template <class T> class LinkedList
{
public:

    LinkedList() :
        head_(nullptr)
    {
    }


    LinkedList(const LinkedList<T>& list) = delete;


    LinkedList(const std::initializer_list<T>& list) : LinkedList()
    {
        for (auto it = list.begin(); it != list.end(); it++)
        {
            Insert(*it);
        }
    }


    LinkedList<T>& operator =(const LinkedList<T>& list) = delete;


    ~LinkedList()
    {
        Clear();
    }


    void Clear()
    {
        T* element = head_;
        while (element)
        {
            T* next = Next(element);
            delete element;
            element = next;
        }
        head_ = nullptr;
    }


    void InsertFront(T* element)
    {
        if (element)
        {
            element->next_ = head_;
            head_ = element;
        }
    }


    void Insert(T* element)
    {
        if (head_)
        {
            T* tail = Last();
            element->next_ = tail->next_;
            tail->next_ = element;
        }
        else
        {
            element->next_ = head_;
            head_ = element;
        }
    }


    bool Erase(T* element)
    {
        if (element && head_)
        {
            if (element == head_)
            {
                head_ = Next(element);
                delete element;
                return true;
            }
            else
            {
                T* tail = head_;
                while (tail && tail->next_ != element)
                    tail = Next(tail);
                if (tail)
                {
                    tail->next_ = element->next_;
                    delete element;
                    return true;
                }
            }
        }

        return false;
    }


    bool Erase(T* element, T* previous)
    {
        if (previous && previous->next_ == element)
        {
            previous->next_ = element->next_;
            delete element;
            return true;
        }
        else if (!previous)
        {
            if (head_ == element)
            {
                head_ = Next(element);
                delete element;
                return true;
            }
        }

        return false;
    }


    T* First() const { return head_; }


    T* Last() const
    {
        T* element = head_;
        if (element)
        {
            while (element->next_)
                element = Next(element);
        }
        return element;
    }


    T* Next(T* element) const { return element ? static_cast<T*>(element->next_) : nullptr; }


    bool Empty() const { return head_ == nullptr; }

private:

    T* head_;
};

}

namespace Urho3D
{


struct RefCount
{

    RefCount() :
        refs_(0),
        weakRefs_(0)
    {
    }


    ~RefCount()
    {

        refs_ = -1;
        weakRefs_ = -1;
    }


    int refs_;

    int weakRefs_;
};


class __attribute__((visibility("default"))) RefCounted
{
public:

    RefCounted();

    virtual ~RefCounted();


    RefCounted(const RefCounted& rhs) = delete;

    RefCounted& operator =(const RefCounted& rhs) = delete;


    void AddRef();

    void ReleaseRef();

    int Refs() const;

    int WeakRefs() const;


    RefCount* RefCountPtr() { return refCount_; }

private:

    RefCount* refCount_;
};

}








namespace Urho3D
{


template <class T> class SharedPtr
{
public:

    SharedPtr() noexcept :
        ptr_(nullptr)
    {
    }


    SharedPtr(std::nullptr_t) noexcept :
        ptr_(nullptr)
    {
    }


    SharedPtr(const SharedPtr<T>& rhs) noexcept :
        ptr_(rhs.ptr_)
    {
        AddRef();
    }


    template <class U> SharedPtr(const SharedPtr<U>& rhs) noexcept :
        ptr_(rhs.ptr_)
    {
        AddRef();
    }


    explicit SharedPtr(T* ptr) noexcept :
        ptr_(ptr)
    {
        AddRef();
    }


    ~SharedPtr() noexcept
    {
        ReleaseRef();
    }


    SharedPtr<T>& operator =(const SharedPtr<T>& rhs)
    {
        if (ptr_ == rhs.ptr_)
            return *this;

        SharedPtr<T> copy(rhs);
        Swap(copy);

        return *this;
    }


    template <class U> SharedPtr<T>& operator =(const SharedPtr<U>& rhs)
    {
        if (ptr_ == rhs.ptr_)
            return *this;

        SharedPtr<T> copy(rhs);
        Swap(copy);

        return *this;
    }


    SharedPtr<T>& operator =(T* ptr)
    {
        if (ptr_ == ptr)
            return *this;

        SharedPtr<T> copy(ptr);
        Swap(copy);

        return *this;
    }


    T* operator ->() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 117, __PRETTY_FUNCTION__));
        return ptr_;
    }


    T& operator *() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 124, __PRETTY_FUNCTION__));
        return *ptr_;
    }


    T& operator [](const int index)
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 131, __PRETTY_FUNCTION__));
        return ptr_[index];
    }


    template <class U> bool operator <(const SharedPtr<U>& rhs) const { return ptr_ < rhs.ptr_; }


    template <class U> bool operator ==(const SharedPtr<U>& rhs) const { return ptr_ == rhs.ptr_; }


    template <class U> bool operator !=(const SharedPtr<U>& rhs) const { return ptr_ != rhs.ptr_; }


    operator T*() const { return ptr_; }


    void Swap(SharedPtr& rhs) { Urho3D::Swap(ptr_, rhs.ptr_); }


    void Reset() { ReleaseRef(); }


    T* Detach()
    {
        T* ptr = ptr_;
        if (ptr_)
        {
            RefCount* refCount = RefCountPtr();
            ++refCount->refs_;
            Reset();
            --refCount->refs_;
        }
        return ptr;
    }


    template <class U> void StaticCast(const SharedPtr<U>& rhs)
    {
        SharedPtr<T> copy(static_cast<T*>(rhs.Get()));
        Swap(copy);
    }


    template <class U> void DynamicCast(const SharedPtr<U>& rhs)
    {
        SharedPtr<T> copy(dynamic_cast<T*>(rhs.Get()));
        Swap(copy);
    }


    bool Null() const { return ptr_ == 0; }


    bool NotNull() const { return ptr_ != nullptr; }


    T* Get() const { return ptr_; }


    int Refs() const { return ptr_ ? ptr_->Refs() : 0; }


    int WeakRefs() const { return ptr_ ? ptr_->WeakRefs() : 0; }


    RefCount* RefCountPtr() const { return ptr_ ? ptr_->RefCountPtr() : nullptr; }


    unsigned ToHash() const { return (unsigned)((size_t)ptr_ / sizeof(T)); }

private:
    template <class U> friend class SharedPtr;


    void AddRef()
    {
        if (ptr_)
            ptr_->AddRef();
    }


    void ReleaseRef()
    {
        if (ptr_)
        {
            ptr_->ReleaseRef();
            ptr_ = nullptr;
        }
    }


    T* ptr_;
};


template <class T, class U> SharedPtr<T> StaticCast(const SharedPtr<U>& ptr)
{
    SharedPtr<T> ret;
    ret.StaticCast(ptr);
    return ret;
}


template <class T, class U> SharedPtr<T> DynamicCast(const SharedPtr<U>& ptr)
{
    SharedPtr<T> ret;
    ret.DynamicCast(ptr);
    return ret;
}


template <class T> class ExternalPtr
{
public:

    ExternalPtr() noexcept {}


    ExternalPtr(std::nullptr_t) noexcept {}


    template <class U> ExternalPtr(const SharedPtr<U>& rhs) :
        ptr_(rhs.Get()),
        refCount_(rhs.RefCountPtr())
    {
        AddRef();
    }


    ExternalPtr(const ExternalPtr<T>& rhs) noexcept :
        ptr_(rhs.ptr_),
        refCount_(rhs.refCount_)
    {
        AddRef();
    }


    template <class U> explicit ExternalPtr(const ExternalPtr<U>& rhs) noexcept :
        ptr_(rhs.ptr_),
        refCount_(rhs.refCount_)
    {
        AddRef();
    }


    ExternalPtr(T* ptr, RefCount* refCount) noexcept :
        ptr_(ptr),
        refCount_(refCount)
    {
        AddRef();
    }


    ~ExternalPtr() noexcept
    {
        ReleaseRef();
    }


    ExternalPtr<T>& operator =(const ExternalPtr<T>& rhs)
    {
        if (ptr_ == rhs.ptr_)
            return *this;

        ExternalPtr<T> copy(rhs);
        Swap(copy);

        return *this;
    }


    template <class U> ExternalPtr<T>& operator =(const ExternalPtr<U>& rhs)
    {
        if (ptr_ == rhs.ptr_)
            return *this;

        ExternalPtr<T> copy(rhs);
        Swap(copy);

        return *this;
    }


    template <class U> ExternalPtr<T>& operator =(const SharedPtr<U>& rhs)
    {
        if (ptr_ == rhs.ptr_)
            return *this;

        ExternalPtr<T> copy(rhs);
        Swap(copy);

        return *this;
    }


    T* operator ->() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 329, __PRETTY_FUNCTION__));
        return ptr_;
    }


    T& operator *() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 336, __PRETTY_FUNCTION__));
        return *ptr_;
    }


    template <class U> bool operator <(const ExternalPtr<U>& rhs) const { return ptr_ < rhs.ptr_; }


    template <class U> bool operator ==(const ExternalPtr<U>& rhs) const { return ptr_ == rhs.ptr_; }


    template <class U> bool operator !=(const ExternalPtr<U>& rhs) const { return ptr_ != rhs.ptr_; }


    void Swap(ExternalPtr& rhs)
    {
        Urho3D::Swap(ptr_, rhs.ptr_);
        Urho3D::Swap(refCount_, rhs.refCount_);
    }


    void Reset() { ReleaseRef(); }


    bool Null() const { return ptr_ == 0; }


    bool NotNull() const { return ptr_ != 0; }


    T* Get() const { return ptr_; }


    int Refs() const { return refCount_ ? refCount_->refs_ : 0; }


    int WeakRefs() const { return refCount_ ? refCount_->weakRefs_ : 0; }


    RefCount* RefCountPtr() const { return refCount_; }


    unsigned ToHash() const { return (unsigned)((size_t)ptr_ / sizeof(T)); }

private:
    template <class U> friend class ExternalPtr;


    void AddRef()
    {
        if (ptr_)
        {

            ++refCount_->weakRefs_;


            ++refCount_->refs_;
        }
    }


    void ReleaseRef()
    {
        if (ptr_)
        {
            ((refCount_->refs_ > 0) ? static_cast<void> (0) : __assert_fail ("refCount_->refs_ > 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 401, __PRETTY_FUNCTION__));
            ((refCount_->weakRefs_ > 0) ? static_cast<void> (0) : __assert_fail ("refCount_->weakRefs_ > 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 402, __PRETTY_FUNCTION__));


            --refCount_->refs_;
            if (!refCount_->refs_)
            {
                delete ptr_;
                refCount_->refs_ = -1;
            }


            --refCount_->weakRefs_;
            if (!refCount_->weakRefs_)
                delete refCount_;

            ptr_ = nullptr;
            refCount_ = nullptr;
        }
    }


    T* ptr_ = nullptr;

    RefCount* refCount_ = nullptr;
};


template <class T> class WeakPtr
{
public:

    WeakPtr() noexcept :
        ptr_(nullptr),
        refCount_(nullptr)
    {
    }


    WeakPtr(std::nullptr_t) noexcept :
        ptr_(nullptr),
        refCount_(nullptr)
    {
    }


    WeakPtr(const WeakPtr<T>& rhs) noexcept :
        ptr_(rhs.ptr_),
        refCount_(rhs.refCount_)
    {
        AddRef();
    }


    template <class U> WeakPtr(const WeakPtr<U>& rhs) noexcept :
        ptr_(rhs.ptr_),
        refCount_(rhs.refCount_)
    {
        AddRef();
    }


    WeakPtr(const SharedPtr<T>& rhs) noexcept :
        ptr_(rhs.Get()),
        refCount_(rhs.RefCountPtr())
    {
        AddRef();
    }


    explicit WeakPtr(T* ptr) noexcept :
        ptr_(ptr),
        refCount_(ptr ? ptr->RefCountPtr() : nullptr)
    {
        AddRef();
    }


    ~WeakPtr() noexcept
    {
        ReleaseRef();
    }


    WeakPtr<T>& operator =(const SharedPtr<T>& rhs)
    {
        if (ptr_ == rhs.Get() && refCount_ == rhs.RefCountPtr())
            return *this;

        ReleaseRef();
        ptr_ = rhs.Get();
        refCount_ = rhs.RefCountPtr();
        AddRef();

        return *this;
    }


    WeakPtr<T>& operator =(const ExternalPtr<T>& rhs)
    {
        if (ptr_ == rhs.Get() && refCount_ == rhs.RefCountPtr())
            return *this;

        ReleaseRef();
        ptr_ = rhs.Get();
        refCount_ = rhs.RefCountPtr();
        AddRef();

        return *this;
    }


    WeakPtr<T>& operator =(const WeakPtr<T>& rhs)
    {
        if (ptr_ == rhs.ptr_ && refCount_ == rhs.refCount_)
            return *this;

        ReleaseRef();
        ptr_ = rhs.ptr_;
        refCount_ = rhs.refCount_;
        AddRef();

        return *this;
    }


    template <class U> WeakPtr<T>& operator =(const WeakPtr<U>& rhs)
    {
        if (ptr_ == rhs.ptr_ && refCount_ == rhs.refCount_)
            return *this;

        ReleaseRef();
        ptr_ = rhs.ptr_;
        refCount_ = rhs.refCount_;
        AddRef();

        return *this;
    }


    WeakPtr<T>& operator =(T* ptr)
    {
        RefCount* refCount = ptr ? ptr->RefCountPtr() : nullptr;

        if (ptr_ == ptr && refCount_ == refCount)
            return *this;

        ReleaseRef();
        ptr_ = ptr;
        refCount_ = refCount;
        AddRef();

        return *this;
    }


    SharedPtr<T> Lock() const
    {
        if (Expired())
            return SharedPtr<T>();
        else
            return SharedPtr<T>(ptr_);
    }


    T* Get() const
    {
        return Expired() ? nullptr : ptr_;
    }


    T* operator ->() const
    {
        T* rawPtr = Get();
        ((rawPtr) ? static_cast<void> (0) : __assert_fail ("rawPtr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 575, __PRETTY_FUNCTION__));
        return rawPtr;
    }


    T& operator *() const
    {
        T* rawPtr = Get();
        ((rawPtr) ? static_cast<void> (0) : __assert_fail ("rawPtr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 583, __PRETTY_FUNCTION__));
        return *rawPtr;
    }


    T& operator [](const int index)
    {
        T* rawPtr = Get();
        ((rawPtr) ? static_cast<void> (0) : __assert_fail ("rawPtr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 591, __PRETTY_FUNCTION__));
        return (*rawPtr)[index];
    }


    template <class U> bool operator ==(const WeakPtr<U>& rhs) const { return ptr_ == rhs.ptr_ && refCount_ == rhs.refCount_; }


    template <class U> bool operator !=(const WeakPtr<U>& rhs) const { return ptr_ != rhs.ptr_ || refCount_ != rhs.refCount_; }


    template <class U> bool operator <(const WeakPtr<U>& rhs) const { return ptr_ < rhs.ptr_; }


    operator T*() const { return Get(); }


    void Reset() { ReleaseRef(); }


    template <class U> void StaticCast(const WeakPtr<U>& rhs)
    {
        ReleaseRef();
        ptr_ = static_cast<T*>(rhs.Get());
        refCount_ = rhs.refCount_;
        AddRef();
    }


    template <class U> void DynamicCast(const WeakPtr<U>& rhs)
    {
        ReleaseRef();
        ptr_ = dynamic_cast<T*>(rhs.Get());

        if (ptr_)
        {
            refCount_ = rhs.refCount_;
            AddRef();
        }
        else
            refCount_ = 0;
    }


    bool Null() const { return refCount_ == nullptr; }


    bool NotNull() const { return refCount_ != nullptr; }


    int Refs() const { return (refCount_ && refCount_->refs_ >= 0) ? refCount_->refs_ : 0; }


    int WeakRefs() const
    {
        if (!Expired())
            return ptr_->WeakRefs();
        else
            return refCount_ ? refCount_->weakRefs_ : 0;
    }


    bool Expired() const { return refCount_ ? refCount_->refs_ < 0 : true; }


    RefCount* RefCountPtr() const { return refCount_; }


    unsigned ToHash() const { return (unsigned)((size_t)ptr_ / sizeof(T)); }

private:
    template <class U> friend class WeakPtr;


    void AddRef()
    {
        if (refCount_)
        {
            ((refCount_->weakRefs_ >= 0) ? static_cast<void> (0) : __assert_fail ("refCount_->weakRefs_ >= 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 669, __PRETTY_FUNCTION__));
            ++(refCount_->weakRefs_);
        }
    }


    void ReleaseRef()
    {
        if (refCount_)
        {
            ((refCount_->weakRefs_ > 0) ? static_cast<void> (0) : __assert_fail ("refCount_->weakRefs_ > 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 679, __PRETTY_FUNCTION__));
            --(refCount_->weakRefs_);

            if (Expired() && !refCount_->weakRefs_)
                delete refCount_;
        }

        ptr_ = nullptr;
        refCount_ = nullptr;
    }


    T* ptr_;

    RefCount* refCount_;
};


template <class T, class U> WeakPtr<T> StaticCast(const WeakPtr<U>& ptr)
{
    WeakPtr<T> ret;
    ret.StaticCast(ptr);
    return ret;
}


template <class T, class U> WeakPtr<T> DynamicCast(const WeakPtr<U>& ptr)
{
    WeakPtr<T> ret;
    ret.DynamicCast(ptr);
    return ret;
}


template<class T> inline void CheckedDelete(T* x)
{

    using type_must_be_complete = char[sizeof(T) ? 1 : -1];
    (void) sizeof(type_must_be_complete);
    delete x;
}


template <class T> class UniquePtr
{
public:

    UniquePtr() : ptr_(nullptr) { }


    explicit UniquePtr(T* ptr) : ptr_(ptr) { }


    UniquePtr(const UniquePtr&) = delete;

    UniquePtr& operator=(const UniquePtr&) = delete;


    UniquePtr& operator = (T* ptr)
    {
        Reset(ptr);
        return *this;
    }


    UniquePtr(std::nullptr_t) { }


    UniquePtr(UniquePtr&& up) noexcept :
        ptr_(up.Detach()) {}


    UniquePtr& operator =(UniquePtr&& up) noexcept
    {
        Reset(up.Detach());
        return *this;
    }


    T* operator ->() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 760, __PRETTY_FUNCTION__));
        return ptr_;
    }


    T& operator *() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/../Container/Ptr.h", 767, __PRETTY_FUNCTION__));
        return *ptr_;
    }


    template <class U>
    bool operator <(const UniquePtr<U>& rhs) const { return ptr_ < rhs.ptr_; }


    template <class U>
    bool operator ==(const UniquePtr<U>& rhs) const { return ptr_ == rhs.ptr_; }


    template <class U>
    bool operator !=(const UniquePtr<U>& rhs) const { return ptr_ != rhs.ptr_; }


    operator bool() const { return !!ptr_; }


    void Swap(UniquePtr& up) { Urho3D::Swap(ptr_, up.ptr_); }


    T* Detach()
    {
        T* ptr = ptr_;
        ptr_ = nullptr;
        return ptr;
    }


    bool Null() const { return ptr_ == 0; }


    bool NotNull() const { return ptr_ != 0; }


    T* Get() const { return ptr_; }


    void Reset(T* ptr = nullptr)
    {
        CheckedDelete(ptr_);
        ptr_ = ptr;
    }


    unsigned ToHash() const { return (unsigned)((size_t)ptr_ / sizeof(T)); }


    ~UniquePtr()
    {
        Reset();
    }

private:
    T* ptr_;

};


template <class T> void Swap(UniquePtr<T>& first, UniquePtr<T>& second)
{
    first.Swap(second);
}


template <class T, class ... Args> UniquePtr<T> MakeUnique(Args && ... args)
{
    return UniquePtr<T>(new T(std::forward<Args>(args)...));
}


template <class T, class ... Args> SharedPtr<T> MakeShared(Args && ... args)
{
    return SharedPtr<T>(new T(std::forward<Args>(args)...));
}

}


namespace Urho3D
{

class Mutex;


class __attribute__((visibility("default"))) StringHashRegister
{
public:

    StringHashRegister(bool threadSafe);

    ~StringHashRegister();


    StringHash RegisterString(const StringHash& hash, const char* string);

    StringHash RegisterString(const char* string);

    String GetStringCopy(const StringHash& hash) const;

    bool Contains(const StringHash& hash) const;


    const String& GetString(const StringHash& hash) const;

    const StringMap& GetInternalMap() const { return map_; }

private:

    StringMap map_;

    UniquePtr<Mutex> mutex_;
};

}

namespace Urho3D
{


__attribute__((visibility("default"))) void SetRandomSeed(unsigned seed);

__attribute__((visibility("default"))) unsigned GetRandomSeed();

__attribute__((visibility("default"))) int Rand();

__attribute__((visibility("default"))) float RandStandardNormal();

}






namespace Urho3D
{


static const float M_PI = 3.14159265358979323846264338327950288f;
static const float M_HALF_PI = M_PI * 0.5f;
static const int M_MIN_INT = 0x80000000;
static const int M_MAX_INT = 0x7fffffff;
static const unsigned M_MIN_UNSIGNED = 0x00000000;
static const unsigned M_MAX_UNSIGNED = 0xffffffff;

static const float M_EPSILON = 0.000001f;
static const float M_LARGE_EPSILON = 0.00005f;
static const float M_MIN_NEARCLIP = 0.01f;
static const float M_MAX_FOV = 160.0f;
static const float M_LARGE_VALUE = 100000000.0f;
static const float M_INFINITY = (float)(__builtin_huge_val());
static const float M_DEGTORAD = M_PI / 180.0f;
static const float M_DEGTORAD_2 = M_PI / 360.0f;
static const float M_RADTODEG = 1.0f / M_DEGTORAD;


enum Intersection
{
    OUTSIDE,
    INTERSECTS,
    INSIDE
};


template <class T>
inline bool Equals(T lhs, T rhs) { return lhs + std::numeric_limits<T>::epsilon() >= rhs && lhs - std::numeric_limits<T>::epsilon() <= rhs; }


template <class T, class U>
inline T Lerp(T lhs, T rhs, U t) { return lhs * (1.0 - t) + rhs * t; }


template <class T>
inline T InverseLerp(T lhs, T rhs, T x) { return (x - lhs) / (rhs - lhs); }


template <class T, class U>
inline T Min(T lhs, U rhs) { return lhs < rhs ? lhs : rhs; }


template <class T, class U>
inline T Max(T lhs, U rhs) { return lhs > rhs ? lhs : rhs; }


template <class T>
inline T Abs(T value) { return value >= 0.0 ? value : -value; }


template <class T>
inline T Sign(T value) { return value > 0.0 ? 1.0 : (value < 0.0 ? -1.0 : 0.0); }


inline unsigned FloatToRawIntBits(float value)
{
    unsigned u = *((unsigned*)&value);
    return u;
}


template <class T> inline bool IsNaN(T value) { return std::isnan(value); }


template <class T>
inline T Clamp(T value, T min, T max)
{
    if (value < min)
        return min;
    else if (value > max)
        return max;
    else
        return value;
}


template <class T>
inline T SmoothStep(T lhs, T rhs, T t)
{
    t = Clamp((t - lhs) / (rhs - lhs), T(0.0), T(1.0));
    return t * t * (3.0 - 2.0 * t);
}


template <class T> inline T Sin(T angle) { return sin(angle * M_DEGTORAD); }


template <class T> inline T Cos(T angle) { return cos(angle * M_DEGTORAD); }


template <class T> inline T Tan(T angle) { return tan(angle * M_DEGTORAD); }


template <class T> inline T Asin(T x) { return M_RADTODEG * asin(Clamp(x, T(-1.0), T(1.0))); }


template <class T> inline T Acos(T x) { return M_RADTODEG * acos(Clamp(x, T(-1.0), T(1.0))); }


template <class T> inline T Atan(T x) { return M_RADTODEG * atan(x); }


template <class T> inline T Atan2(T y, T x) { return M_RADTODEG * atan2(y, x); }


template <class T> inline T Pow(T x, T y) { return pow(x, y); }


template <class T> inline T Ln(T x) { return log(x); }


template <class T> inline T Sqrt(T x) { return sqrt(x); }


template <class T> inline T Mod(T x, T y) { return fmod(x, y); }


template <class T> inline T Fract(T value) { return value - floor(value); }


template <class T> inline T Floor(T x) { return floor(x); }


template <class T> inline int FloorToInt(T x) { return static_cast<int>(floor(x)); }


template <class T> inline T Round(T x) { return round(x); }


template <class T> inline int RoundToInt(T x) { return static_cast<int>(round(x)); }


template <class T> inline T RoundToNearestMultiple(T x, T multiple)
{
    T mag = Abs(x);
    multiple = Abs(multiple);
    T remainder = Mod(mag, multiple);
    if (remainder >= multiple / 2)
        return (FloorToInt<T>(mag / multiple) * multiple + multiple)*Sign(x);
    else
        return (FloorToInt<T>(mag / multiple) * multiple)*Sign(x);
}


template <class T> inline T Ceil(T x) { return ceil(x); }


template <class T> inline int CeilToInt(T x) { return static_cast<int>(ceil(x)); }


inline bool IsPowerOfTwo(unsigned value)
{
    return !(value & (value - 1));
}


inline unsigned NextPowerOfTwo(unsigned value)
{

    --value;
    value |= value >> 1u;
    value |= value >> 2u;
    value |= value >> 4u;
    value |= value >> 8u;
    value |= value >> 16u;
    return ++value;
}


inline unsigned LogBaseTwo(unsigned value)
{

    unsigned ret = 0;
    while (value >>= 1)
        ++ret;
    return ret;
}


inline unsigned CountSetBits(unsigned value)
{

    unsigned count = 0;
    for (count = 0; value; count++)
        value &= value - 1;
    return count;
}


inline unsigned SDBMHash(unsigned hash, unsigned char c) { return c + (hash << 6u) + (hash << 16u) - hash; }


inline float Random() { return Rand() / 32768.0f; }


inline float Random(float range) { return Rand() * range / 32767.0f; }


inline float Random(float min, float max) { return Rand() * (max - min) / 32767.0f + min; }


inline int Random(int range) { return (int)(Random() * range); }


inline int Random(int min, int max) { auto range = (float)(max - min); return (int)(Random() * range) + min; }


inline float RandomNormal(float meanValue, float variance) { return RandStandardNormal() * sqrtf(variance) + meanValue; }


inline unsigned short FloatToHalf(float value)
{
    unsigned inu = FloatToRawIntBits(value);
    unsigned t1 = inu & 0x7fffffffu;
    unsigned t2 = inu & 0x80000000u;
    unsigned t3 = inu & 0x7f800000u;

    t1 >>= 13;
    t2 >>= 16;

    t1 -= 0x1c000;

    t1 = (t3 < 0x38800000) ? 0 : t1;
    t1 = (t3 > 0x47000000) ? 0x7bff : t1;
    t1 = (t3 == 0 ? 0 : t1);

    t1 |= t2;

    return (unsigned short)t1;
}


inline float HalfToFloat(unsigned short value)
{
    unsigned t1 = value & 0x7fffu;
    unsigned t2 = value & 0x8000u;
    unsigned t3 = value & 0x7c00u;

    t1 <<= 13;
    t2 <<= 16;

    t1 += 0x38000000;

    t1 = (t3 == 0 ? 0 : t1);

    t1 |= t2;

    float out;
    *((unsigned*)&out) = t1;
    return out;
}


__attribute__((visibility("default"))) void SinCos(float angle, float& sin, float& cos);

}


namespace Urho3D
{


class __attribute__((visibility("default"))) IntVector2
{
public:

    IntVector2() noexcept :
        x_(0),
        y_(0)
    {
    }


    IntVector2(int x, int y) noexcept :
        x_(x),
        y_(y)
    {
    }


    explicit IntVector2(const int* data) noexcept :
        x_(data[0]),
        y_(data[1])
    {
    }


    explicit IntVector2(const float* data) :
        x_((int)data[0]),
        y_((int)data[1])
    {
    }

    IntVector2(const IntVector2& rhs) noexcept = default;


    IntVector2& operator =(const IntVector2& rhs) noexcept = default;


    bool operator ==(const IntVector2& rhs) const { return x_ == rhs.x_ && y_ == rhs.y_; }


    bool operator !=(const IntVector2& rhs) const { return x_ != rhs.x_ || y_ != rhs.y_; }


    IntVector2 operator +(const IntVector2& rhs) const { return IntVector2(x_ + rhs.x_, y_ + rhs.y_); }


    IntVector2 operator -() const { return IntVector2(-x_, -y_); }


    IntVector2 operator -(const IntVector2& rhs) const { return IntVector2(x_ - rhs.x_, y_ - rhs.y_); }


    IntVector2 operator *(int rhs) const { return IntVector2(x_ * rhs, y_ * rhs); }


    IntVector2 operator *(const IntVector2& rhs) const { return IntVector2(x_ * rhs.x_, y_ * rhs.y_); }


    IntVector2 operator /(int rhs) const { return IntVector2(x_ / rhs, y_ / rhs); }


    IntVector2 operator /(const IntVector2& rhs) const { return IntVector2(x_ / rhs.x_, y_ / rhs.y_); }


    IntVector2& operator +=(const IntVector2& rhs)
    {
        x_ += rhs.x_;
        y_ += rhs.y_;
        return *this;
    }


    IntVector2& operator -=(const IntVector2& rhs)
    {
        x_ -= rhs.x_;
        y_ -= rhs.y_;
        return *this;
    }


    IntVector2& operator *=(int rhs)
    {
        x_ *= rhs;
        y_ *= rhs;
        return *this;
    }


    IntVector2& operator *=(const IntVector2& rhs)
    {
        x_ *= rhs.x_;
        y_ *= rhs.y_;
        return *this;
    }


    IntVector2& operator /=(int rhs)
    {
        x_ /= rhs;
        y_ /= rhs;
        return *this;
    }


    IntVector2& operator /=(const IntVector2& rhs)
    {
        x_ /= rhs.x_;
        y_ /= rhs.y_;
        return *this;
    }


    const int* Data() const { return &x_; }


    String ToString() const;


    unsigned ToHash() const { return (unsigned)x_ * 31 + (unsigned)y_; }


    float Length() const { return sqrtf((float)(x_ * x_ + y_ * y_)); }


    int x_;

    int y_;


    static const IntVector2 ZERO;

    static const IntVector2 LEFT;

    static const IntVector2 RIGHT;

    static const IntVector2 UP;

    static const IntVector2 DOWN;

    static const IntVector2 ONE;
};


class __attribute__((visibility("default"))) Vector2
{
public:

    Vector2() noexcept :
        x_(0.0f),
        y_(0.0f)
    {
    }


    Vector2(const Vector2& vector) noexcept = default;


    explicit Vector2(const IntVector2& vector) noexcept :
        x_((float)vector.x_),
        y_((float)vector.y_)
    {
    }


    Vector2(float x, float y) noexcept :
        x_(x),
        y_(y)
    {
    }


    explicit Vector2(const float* data) noexcept :
        x_(data[0]),
        y_(data[1])
    {
    }


    Vector2& operator =(const Vector2& rhs) noexcept = default;


    bool operator ==(const Vector2& rhs) const { return x_ == rhs.x_ && y_ == rhs.y_; }


    bool operator !=(const Vector2& rhs) const { return x_ != rhs.x_ || y_ != rhs.y_; }


    Vector2 operator +(const Vector2& rhs) const { return Vector2(x_ + rhs.x_, y_ + rhs.y_); }


    Vector2 operator -() const { return Vector2(-x_, -y_); }


    Vector2 operator -(const Vector2& rhs) const { return Vector2(x_ - rhs.x_, y_ - rhs.y_); }


    Vector2 operator *(float rhs) const { return Vector2(x_ * rhs, y_ * rhs); }


    Vector2 operator *(const Vector2& rhs) const { return Vector2(x_ * rhs.x_, y_ * rhs.y_); }


    Vector2 operator /(float rhs) const { return Vector2(x_ / rhs, y_ / rhs); }


    Vector2 operator /(const Vector2& rhs) const { return Vector2(x_ / rhs.x_, y_ / rhs.y_); }


    Vector2& operator +=(const Vector2& rhs)
    {
        x_ += rhs.x_;
        y_ += rhs.y_;
        return *this;
    }


    Vector2& operator -=(const Vector2& rhs)
    {
        x_ -= rhs.x_;
        y_ -= rhs.y_;
        return *this;
    }


    Vector2& operator *=(float rhs)
    {
        x_ *= rhs;
        y_ *= rhs;
        return *this;
    }


    Vector2& operator *=(const Vector2& rhs)
    {
        x_ *= rhs.x_;
        y_ *= rhs.y_;
        return *this;
    }


    Vector2& operator /=(float rhs)
    {
        float invRhs = 1.0f / rhs;
        x_ *= invRhs;
        y_ *= invRhs;
        return *this;
    }


    Vector2& operator /=(const Vector2& rhs)
    {
        x_ /= rhs.x_;
        y_ /= rhs.y_;
        return *this;
    }


    void Normalize()
    {
        float lenSquared = LengthSquared();
        if (!Urho3D::Equals(lenSquared, 1.0f) && lenSquared > 0.0f)
        {
            float invLen = 1.0f / sqrtf(lenSquared);
            x_ *= invLen;
            y_ *= invLen;
        }
    }


    float Length() const { return sqrtf(x_ * x_ + y_ * y_); }


    float LengthSquared() const { return x_ * x_ + y_ * y_; }


    float DotProduct(const Vector2& rhs) const { return x_ * rhs.x_ + y_ * rhs.y_; }


    float AbsDotProduct(const Vector2& rhs) const { return Urho3D::Abs(x_ * rhs.x_) + Urho3D::Abs(y_ * rhs.y_); }


    float ProjectOntoAxis(const Vector2& axis) const { return DotProduct(axis.Normalized()); }


    float Angle(const Vector2& rhs) const { return Urho3D::Acos(DotProduct(rhs) / (Length() * rhs.Length())); }


    Vector2 Abs() const { return Vector2(Urho3D::Abs(x_), Urho3D::Abs(y_)); }


    Vector2 Lerp(const Vector2& rhs, float t) const { return *this * (1.0f - t) + rhs * t; }


    bool Equals(const Vector2& rhs) const { return Urho3D::Equals(x_, rhs.x_) && Urho3D::Equals(y_, rhs.y_); }


    bool IsNaN() const { return Urho3D::IsNaN(x_) || Urho3D::IsNaN(y_); }


    Vector2 Normalized() const
    {
        float lenSquared = LengthSquared();
        if (!Urho3D::Equals(lenSquared, 1.0f) && lenSquared > 0.0f)
        {
            float invLen = 1.0f / sqrtf(lenSquared);
            return *this * invLen;
        }
        else
            return *this;
    }


    const float* Data() const { return &x_; }


    String ToString() const;


    float x_;

    float y_;


    static const Vector2 ZERO;

    static const Vector2 LEFT;

    static const Vector2 RIGHT;

    static const Vector2 UP;

    static const Vector2 DOWN;

    static const Vector2 ONE;
};


inline Vector2 operator *(float lhs, const Vector2& rhs) { return rhs * lhs; }


inline IntVector2 operator *(int lhs, const IntVector2& rhs) { return rhs * lhs; }


inline Vector2 VectorLerp(const Vector2& lhs, const Vector2& rhs, const Vector2& t) { return lhs + (rhs - lhs) * t; }


inline Vector2 VectorMin(const Vector2& lhs, const Vector2& rhs) { return Vector2(Min(lhs.x_, rhs.x_), Min(lhs.y_, rhs.y_)); }


inline Vector2 VectorMax(const Vector2& lhs, const Vector2& rhs) { return Vector2(Max(lhs.x_, rhs.x_), Max(lhs.y_, rhs.y_)); }


inline Vector2 VectorFloor(const Vector2& vec) { return Vector2(Floor(vec.x_), Floor(vec.y_)); }


inline Vector2 VectorRound(const Vector2& vec) { return Vector2(Round(vec.x_), Round(vec.y_)); }


inline Vector2 VectorCeil(const Vector2& vec) { return Vector2(Ceil(vec.x_), Ceil(vec.y_)); }


inline IntVector2 VectorFloorToInt(const Vector2& vec) { return IntVector2(FloorToInt(vec.x_), FloorToInt(vec.y_)); }


inline IntVector2 VectorRoundToInt(const Vector2& vec) { return IntVector2(RoundToInt(vec.x_), RoundToInt(vec.y_)); }


inline IntVector2 VectorCeilToInt(const Vector2& vec) { return IntVector2(CeilToInt(vec.x_), CeilToInt(vec.y_)); }


inline IntVector2 VectorMin(const IntVector2& lhs, const IntVector2& rhs) { return IntVector2(Min(lhs.x_, rhs.x_), Min(lhs.y_, rhs.y_)); }


inline IntVector2 VectorMax(const IntVector2& lhs, const IntVector2& rhs) { return IntVector2(Max(lhs.x_, rhs.x_), Max(lhs.y_, rhs.y_)); }



inline float StableRandom(const Vector2& seed) { return Fract(Sin(seed.DotProduct(Vector2(12.9898f, 78.233f)) * M_RADTODEG) * 43758.5453f); }


inline float StableRandom(float seed) { return StableRandom(Vector2(seed, seed)); }

}



namespace Urho3D
{


class __attribute__((visibility("default"))) IntVector3
{
public:

    IntVector3() noexcept :
        x_(0),
        y_(0),
        z_(0)
    {
    }


    IntVector3(int x, int y, int z) noexcept :
        x_(x),
        y_(y),
        z_(z)
    {
    }


    explicit IntVector3(const int* data) noexcept :
        x_(data[0]),
        y_(data[1]),
        z_(data[2])
    {
    }


    IntVector3(const IntVector3& rhs) noexcept = default;


    IntVector3& operator =(const IntVector3& rhs) noexcept = default;


    bool operator ==(const IntVector3& rhs) const { return x_ == rhs.x_ && y_ == rhs.y_ && z_ == rhs.z_; }


    bool operator !=(const IntVector3& rhs) const { return x_ != rhs.x_ || y_ != rhs.y_ || z_ != rhs.z_; }


    IntVector3 operator +(const IntVector3& rhs) const { return IntVector3(x_ + rhs.x_, y_ + rhs.y_, z_ + rhs.z_); }


    IntVector3 operator -() const { return IntVector3(-x_, -y_, -z_); }


    IntVector3 operator -(const IntVector3& rhs) const { return IntVector3(x_ - rhs.x_, y_ - rhs.y_, z_ - rhs.z_); }


    IntVector3 operator *(int rhs) const { return IntVector3(x_ * rhs, y_ * rhs, z_ * rhs); }


    IntVector3 operator *(const IntVector3& rhs) const { return IntVector3(x_ * rhs.x_, y_ * rhs.y_, z_ * rhs.z_); }


    IntVector3 operator /(int rhs) const { return IntVector3(x_ / rhs, y_ / rhs, z_ / rhs); }


    IntVector3 operator /(const IntVector3& rhs) const { return IntVector3(x_ / rhs.x_, y_ / rhs.y_, z_ / rhs.z_); }


    IntVector3& operator +=(const IntVector3& rhs)
    {
        x_ += rhs.x_;
        y_ += rhs.y_;
        z_ += rhs.z_;
        return *this;
    }


    IntVector3& operator -=(const IntVector3& rhs)
    {
        x_ -= rhs.x_;
        y_ -= rhs.y_;
        z_ -= rhs.z_;
        return *this;
    }


    IntVector3& operator *=(int rhs)
    {
        x_ *= rhs;
        y_ *= rhs;
        z_ *= rhs;
        return *this;
    }


    IntVector3& operator *=(const IntVector3& rhs)
    {
        x_ *= rhs.x_;
        y_ *= rhs.y_;
        z_ *= rhs.z_;
        return *this;
    }


    IntVector3& operator /=(int rhs)
    {
        x_ /= rhs;
        y_ /= rhs;
        z_ /= rhs;
        return *this;
    }


    IntVector3& operator /=(const IntVector3& rhs)
    {
        x_ /= rhs.x_;
        y_ /= rhs.y_;
        z_ /= rhs.z_;
        return *this;
    }


    const int* Data() const { return &x_; }


    String ToString() const;


    unsigned ToHash() const { return (unsigned)x_ * 31 * 31 + (unsigned)y_ * 31 + (unsigned)z_; }


    float Length() const { return sqrtf((float)(x_ * x_ + y_ * y_ + z_ * z_)); }


    int x_;

    int y_;

    int z_;


    static const IntVector3 ZERO;

    static const IntVector3 LEFT;

    static const IntVector3 RIGHT;

    static const IntVector3 UP;

    static const IntVector3 DOWN;

    static const IntVector3 FORWARD;

    static const IntVector3 BACK;

    static const IntVector3 ONE;
};


class __attribute__((visibility("default"))) Vector3
{
public:

    Vector3() noexcept :
        x_(0.0f),
        y_(0.0f),
        z_(0.0f)
    {
    }


    Vector3(const Vector3& vector) noexcept = default;


    Vector3(const Vector2& vector, float z) noexcept :
        x_(vector.x_),
        y_(vector.y_),
        z_(z)
    {
    }


    explicit Vector3(const Vector2& vector) noexcept :
        x_(vector.x_),
        y_(vector.y_),
        z_(0.0f)
    {
    }


    explicit Vector3(const IntVector3& vector) noexcept :
        x_((float)vector.x_),
        y_((float)vector.y_),
        z_((float)vector.z_)
    {
    }


    Vector3(float x, float y, float z) noexcept :
        x_(x),
        y_(y),
        z_(z)
    {
    }


    Vector3(float x, float y) noexcept :
        x_(x),
        y_(y),
        z_(0.0f)
    {
    }


    explicit Vector3(const float* data) noexcept :
        x_(data[0]),
        y_(data[1]),
        z_(data[2])
    {
    }


    Vector3& operator =(const Vector3& rhs) noexcept = default;


    bool operator ==(const Vector3& rhs) const { return x_ == rhs.x_ && y_ == rhs.y_ && z_ == rhs.z_; }


    bool operator !=(const Vector3& rhs) const { return x_ != rhs.x_ || y_ != rhs.y_ || z_ != rhs.z_; }


    Vector3 operator +(const Vector3& rhs) const { return Vector3(x_ + rhs.x_, y_ + rhs.y_, z_ + rhs.z_); }


    Vector3 operator -() const { return Vector3(-x_, -y_, -z_); }


    Vector3 operator -(const Vector3& rhs) const { return Vector3(x_ - rhs.x_, y_ - rhs.y_, z_ - rhs.z_); }


    Vector3 operator *(float rhs) const { return Vector3(x_ * rhs, y_ * rhs, z_ * rhs); }


    Vector3 operator *(const Vector3& rhs) const { return Vector3(x_ * rhs.x_, y_ * rhs.y_, z_ * rhs.z_); }


    Vector3 operator /(float rhs) const { return Vector3(x_ / rhs, y_ / rhs, z_ / rhs); }


    Vector3 operator /(const Vector3& rhs) const { return Vector3(x_ / rhs.x_, y_ / rhs.y_, z_ / rhs.z_); }


    Vector3& operator +=(const Vector3& rhs)
    {
        x_ += rhs.x_;
        y_ += rhs.y_;
        z_ += rhs.z_;
        return *this;
    }


    Vector3& operator -=(const Vector3& rhs)
    {
        x_ -= rhs.x_;
        y_ -= rhs.y_;
        z_ -= rhs.z_;
        return *this;
    }


    Vector3& operator *=(float rhs)
    {
        x_ *= rhs;
        y_ *= rhs;
        z_ *= rhs;
        return *this;
    }


    Vector3& operator *=(const Vector3& rhs)
    {
        x_ *= rhs.x_;
        y_ *= rhs.y_;
        z_ *= rhs.z_;
        return *this;
    }


    Vector3& operator /=(float rhs)
    {
        float invRhs = 1.0f / rhs;
        x_ *= invRhs;
        y_ *= invRhs;
        z_ *= invRhs;
        return *this;
    }


    Vector3& operator /=(const Vector3& rhs)
    {
        x_ /= rhs.x_;
        y_ /= rhs.y_;
        z_ /= rhs.z_;
        return *this;
    }


    void Normalize()
    {
        float lenSquared = LengthSquared();
        if (!Urho3D::Equals(lenSquared, 1.0f) && lenSquared > 0.0f)
        {
            float invLen = 1.0f / sqrtf(lenSquared);
            x_ *= invLen;
            y_ *= invLen;
            z_ *= invLen;
        }
    }


    float Length() const { return sqrtf(x_ * x_ + y_ * y_ + z_ * z_); }


    float LengthSquared() const { return x_ * x_ + y_ * y_ + z_ * z_; }


    float DotProduct(const Vector3& rhs) const { return x_ * rhs.x_ + y_ * rhs.y_ + z_ * rhs.z_; }


    float AbsDotProduct(const Vector3& rhs) const
    {
        return Urho3D::Abs(x_ * rhs.x_) + Urho3D::Abs(y_ * rhs.y_) + Urho3D::Abs(z_ * rhs.z_);
    }


    float ProjectOntoAxis(const Vector3& axis) const { return DotProduct(axis.Normalized()); }


    Vector3 ProjectOntoPlane(const Vector3& origin, const Vector3& normal) const
    {
        const Vector3 delta = *this - origin;
        return *this - normal.Normalized() * delta.ProjectOntoAxis(normal);
    }


    Vector3 ProjectOntoLine(const Vector3& from, const Vector3& to, bool clamped = false) const
    {
        const Vector3 direction = to - from;
        const float lengthSquared = direction.LengthSquared();
        float factor = (*this - from).DotProduct(direction) / lengthSquared;

        if (clamped)
            factor = Clamp(factor, 0.0f, 1.0f);

        return from + direction * factor;
    }


    float DistanceToPoint(const Vector3& point) const { return (*this - point).Length(); }


    float DistanceToPlane(const Vector3& origin, const Vector3& normal) const { return (*this - origin).ProjectOntoAxis(normal); }


    Vector3 Orthogonalize(const Vector3& axis) const { return axis.CrossProduct(*this).CrossProduct(axis).Normalized(); }


    Vector3 CrossProduct(const Vector3& rhs) const
    {
        return Vector3(
            y_ * rhs.z_ - z_ * rhs.y_,
            z_ * rhs.x_ - x_ * rhs.z_,
            x_ * rhs.y_ - y_ * rhs.x_
        );
    }


    Vector3 Abs() const { return Vector3(Urho3D::Abs(x_), Urho3D::Abs(y_), Urho3D::Abs(z_)); }


    Vector3 Lerp(const Vector3& rhs, float t) const { return *this * (1.0f - t) + rhs * t; }


    bool Equals(const Vector3& rhs) const
    {
        return Urho3D::Equals(x_, rhs.x_) && Urho3D::Equals(y_, rhs.y_) && Urho3D::Equals(z_, rhs.z_);
    }


    float Angle(const Vector3& rhs) const { return Urho3D::Acos(DotProduct(rhs) / (Length() * rhs.Length())); }


    bool IsNaN() const { return Urho3D::IsNaN(x_) || Urho3D::IsNaN(y_) || Urho3D::IsNaN(z_); }


    Vector3 Normalized() const
    {
        float lenSquared = LengthSquared();
        if (!Urho3D::Equals(lenSquared, 1.0f) && lenSquared > 0.0f)
        {
            float invLen = 1.0f / sqrtf(lenSquared);
            return *this * invLen;
        }
        else
            return *this;
    }


    const float* Data() const { return &x_; }


    String ToString() const;


    unsigned ToHash() const
    {
        unsigned hash = 37;
        hash = 37 * hash + FloatToRawIntBits(x_);
        hash = 37 * hash + FloatToRawIntBits(y_);
        hash = 37 * hash + FloatToRawIntBits(z_);

        return hash;
    }


    float x_;

    float y_;

    float z_;


    static const Vector3 ZERO;

    static const Vector3 LEFT;

    static const Vector3 RIGHT;

    static const Vector3 UP;

    static const Vector3 DOWN;

    static const Vector3 FORWARD;

    static const Vector3 BACK;

    static const Vector3 ONE;
};


inline Vector3 operator *(float lhs, const Vector3& rhs) { return rhs * lhs; }


inline IntVector3 operator *(int lhs, const IntVector3& rhs) { return rhs * lhs; }


inline Vector3 VectorLerp(const Vector3& lhs, const Vector3& rhs, const Vector3& t) { return lhs + (rhs - lhs) * t; }


inline Vector3 VectorMin(const Vector3& lhs, const Vector3& rhs) { return Vector3(Min(lhs.x_, rhs.x_), Min(lhs.y_, rhs.y_), Min(lhs.z_, rhs.z_)); }


inline Vector3 VectorMax(const Vector3& lhs, const Vector3& rhs) { return Vector3(Max(lhs.x_, rhs.x_), Max(lhs.y_, rhs.y_), Max(lhs.z_, rhs.z_)); }


inline Vector3 VectorFloor(const Vector3& vec) { return Vector3(Floor(vec.x_), Floor(vec.y_), Floor(vec.z_)); }


inline Vector3 VectorRound(const Vector3& vec) { return Vector3(Round(vec.x_), Round(vec.y_), Round(vec.z_)); }


inline Vector3 VectorCeil(const Vector3& vec) { return Vector3(Ceil(vec.x_), Ceil(vec.y_), Ceil(vec.z_)); }


inline IntVector3 VectorFloorToInt(const Vector3& vec) { return IntVector3(FloorToInt(vec.x_), FloorToInt(vec.y_), FloorToInt(vec.z_)); }


inline IntVector3 VectorRoundToInt(const Vector3& vec) { return IntVector3(RoundToInt(vec.x_), RoundToInt(vec.y_), RoundToInt(vec.z_)); }


inline IntVector3 VectorCeilToInt(const Vector3& vec) { return IntVector3(CeilToInt(vec.x_), CeilToInt(vec.y_), CeilToInt(vec.z_)); }


inline IntVector3 VectorMin(const IntVector3& lhs, const IntVector3& rhs) { return IntVector3(Min(lhs.x_, rhs.x_), Min(lhs.y_, rhs.y_), Min(lhs.z_, rhs.z_)); }


inline IntVector3 VectorMax(const IntVector3& lhs, const IntVector3& rhs) { return IntVector3(Max(lhs.x_, rhs.x_), Max(lhs.y_, rhs.y_), Max(lhs.z_, rhs.z_)); }


inline float StableRandom(const Vector3& seed) { return StableRandom(Vector2(StableRandom(Vector2(seed.x_, seed.y_)), seed.z_)); }

}


namespace Urho3D
{


class __attribute__((visibility("default"))) Vector4
{
public:

    Vector4() noexcept :
        x_(0.0f),
        y_(0.0f),
        z_(0.0f),
        w_(0.0f)
    {
    }


    Vector4(const Vector4& vector) noexcept = default;


    Vector4(const Vector3& vector, float w) noexcept :
        x_(vector.x_),
        y_(vector.y_),
        z_(vector.z_),
        w_(w)
    {
    }


    Vector4(float x, float y, float z, float w) noexcept :
        x_(x),
        y_(y),
        z_(z),
        w_(w)
    {
    }


    explicit Vector4(const float* data) noexcept :
        x_(data[0]),
        y_(data[1]),
        z_(data[2]),
        w_(data[3])
    {
    }


    Vector4& operator =(const Vector4& rhs) noexcept = default;


    bool operator ==(const Vector4& rhs) const { return x_ == rhs.x_ && y_ == rhs.y_ && z_ == rhs.z_ && w_ == rhs.w_; }


    bool operator !=(const Vector4& rhs) const { return x_ != rhs.x_ || y_ != rhs.y_ || z_ != rhs.z_ || w_ != rhs.w_; }


    Vector4 operator +(const Vector4& rhs) const { return Vector4(x_ + rhs.x_, y_ + rhs.y_, z_ + rhs.z_, w_ + rhs.w_); }


    Vector4 operator -() const { return Vector4(-x_, -y_, -z_, -w_); }


    Vector4 operator -(const Vector4& rhs) const { return Vector4(x_ - rhs.x_, y_ - rhs.y_, z_ - rhs.z_, w_ - rhs.w_); }


    Vector4 operator *(float rhs) const { return Vector4(x_ * rhs, y_ * rhs, z_ * rhs, w_ * rhs); }


    Vector4 operator *(const Vector4& rhs) const { return Vector4(x_ * rhs.x_, y_ * rhs.y_, z_ * rhs.z_, w_ * rhs.w_); }


    Vector4 operator /(float rhs) const { return Vector4(x_ / rhs, y_ / rhs, z_ / rhs, w_ / rhs); }


    Vector4 operator /(const Vector4& rhs) const { return Vector4(x_ / rhs.x_, y_ / rhs.y_, z_ / rhs.z_, w_ / rhs.w_); }


    Vector4& operator +=(const Vector4& rhs)
    {
        x_ += rhs.x_;
        y_ += rhs.y_;
        z_ += rhs.z_;
        w_ += rhs.w_;
        return *this;
    }


    Vector4& operator -=(const Vector4& rhs)
    {
        x_ -= rhs.x_;
        y_ -= rhs.y_;
        z_ -= rhs.z_;
        w_ -= rhs.w_;
        return *this;
    }


    Vector4& operator *=(float rhs)
    {
        x_ *= rhs;
        y_ *= rhs;
        z_ *= rhs;
        w_ *= rhs;
        return *this;
    }


    Vector4& operator *=(const Vector4& rhs)
    {
        x_ *= rhs.x_;
        y_ *= rhs.y_;
        z_ *= rhs.z_;
        w_ *= rhs.w_;
        return *this;
    }


    Vector4& operator /=(float rhs)
    {
        float invRhs = 1.0f / rhs;
        x_ *= invRhs;
        y_ *= invRhs;
        z_ *= invRhs;
        w_ *= invRhs;
        return *this;
    }


    Vector4& operator /=(const Vector4& rhs)
    {
        x_ /= rhs.x_;
        y_ /= rhs.y_;
        z_ /= rhs.z_;
        w_ /= rhs.w_;
        return *this;
    }


    float operator[](unsigned index) const { return (&x_)[index]; }


    float& operator[](unsigned index) { return (&x_)[index]; }


    float DotProduct(const Vector4& rhs) const { return x_ * rhs.x_ + y_ * rhs.y_ + z_ * rhs.z_ + w_ * rhs.w_; }


    float AbsDotProduct(const Vector4& rhs) const
    {
        return Urho3D::Abs(x_ * rhs.x_) + Urho3D::Abs(y_ * rhs.y_) + Urho3D::Abs(z_ * rhs.z_) + Urho3D::Abs(w_ * rhs.w_);
    }


    float ProjectOntoAxis(const Vector3& axis) const { return DotProduct(Vector4(axis.Normalized(), 0.0f)); }


    Vector4 Abs() const { return Vector4(Urho3D::Abs(x_), Urho3D::Abs(y_), Urho3D::Abs(z_), Urho3D::Abs(w_)); }


    Vector4 Lerp(const Vector4& rhs, float t) const { return *this * (1.0f - t) + rhs * t; }


    bool Equals(const Vector4& rhs) const
    {
        return Urho3D::Equals(x_, rhs.x_) && Urho3D::Equals(y_, rhs.y_) && Urho3D::Equals(z_, rhs.z_) && Urho3D::Equals(w_, rhs.w_);
    }


    bool IsNaN() const { return Urho3D::IsNaN(x_) || Urho3D::IsNaN(y_) || Urho3D::IsNaN(z_) || Urho3D::IsNaN(w_); }


    const float* Data() const { return &x_; }


    String ToString() const;


    unsigned ToHash() const
    {
        unsigned hash = 37;
        hash = 37 * hash + FloatToRawIntBits(x_);
        hash = 37 * hash + FloatToRawIntBits(y_);
        hash = 37 * hash + FloatToRawIntBits(z_);
        hash = 37 * hash + FloatToRawIntBits(w_);

        return hash;
    }


    float x_;

    float y_;

    float z_;

    float w_;


    static const Vector4 ZERO;

    static const Vector4 ONE;
};


inline Vector4 operator *(float lhs, const Vector4& rhs) { return rhs * lhs; }


inline Vector4 VectorLerp(const Vector4& lhs, const Vector4& rhs, const Vector4& t) { return lhs + (rhs - lhs) * t; }


inline Vector4 VectorMin(const Vector4& lhs, const Vector4& rhs) { return Vector4(Min(lhs.x_, rhs.x_), Min(lhs.y_, rhs.y_), Min(lhs.z_, rhs.z_), Min(lhs.w_, rhs.w_)); }


inline Vector4 VectorMax(const Vector4& lhs, const Vector4& rhs) { return Vector4(Max(lhs.x_, rhs.x_), Max(lhs.y_, rhs.y_), Max(lhs.z_, rhs.z_), Max(lhs.w_, rhs.w_)); }


inline Vector4 VectorFloor(const Vector4& vec) { return Vector4(Floor(vec.x_), Floor(vec.y_), Floor(vec.z_), Floor(vec.w_)); }


inline Vector4 VectorRound(const Vector4& vec) { return Vector4(Round(vec.x_), Round(vec.y_), Round(vec.z_), Round(vec.w_)); }


inline Vector4 VectorCeil(const Vector4& vec) { return Vector4(Ceil(vec.x_), Ceil(vec.y_), Ceil(vec.z_), Ceil(vec.w_)); }

}


namespace Urho3D
{

class String;


class __attribute__((visibility("default"))) Color
{
public:

    Color() noexcept :
        r_(1.0f),
        g_(1.0f),
        b_(1.0f),
        a_(1.0f)
    {
    }


    Color(const Color& color) noexcept = default;


    Color(const Color& color, float a) noexcept :
        r_(color.r_),
        g_(color.g_),
        b_(color.b_),
        a_(a)
    {
    }


    Color(float r, float g, float b) noexcept :
        r_(r),
        g_(g),
        b_(b),
        a_(1.0f)
    {
    }


    Color(float r, float g, float b, float a) noexcept :
        r_(r),
        g_(g),
        b_(b),
        a_(a)
    {
    }


    explicit Color(const float* data) noexcept :
        r_(data[0]),
        g_(data[1]),
        b_(data[2]),
        a_(data[3])
    {
    }


    Color& operator =(const Color& rhs) noexcept = default;


    bool operator ==(const Color& rhs) const { return r_ == rhs.r_ && g_ == rhs.g_ && b_ == rhs.b_ && a_ == rhs.a_; }


    bool operator !=(const Color& rhs) const { return r_ != rhs.r_ || g_ != rhs.g_ || b_ != rhs.b_ || a_ != rhs.a_; }


    Color operator *(float rhs) const { return Color(r_ * rhs, g_ * rhs, b_ * rhs, a_ * rhs); }


    Color operator +(const Color& rhs) const { return Color(r_ + rhs.r_, g_ + rhs.g_, b_ + rhs.b_, a_ + rhs.a_); }


    Color operator -() const { return Color(-r_, -g_, -b_, -a_); }


    Color operator -(const Color& rhs) const { return Color(r_ - rhs.r_, g_ - rhs.g_, b_ - rhs.b_, a_ - rhs.a_); }


    Color& operator +=(const Color& rhs)
    {
        r_ += rhs.r_;
        g_ += rhs.g_;
        b_ += rhs.b_;
        a_ += rhs.a_;
        return *this;
    }


    const float* Data() const { return &r_; }


    unsigned ToUInt() const;

    Vector3 ToHSL() const;

    Vector3 ToHSV() const;

    void FromUInt(unsigned color);

    void FromHSL(float h, float s, float l, float a = 1.0f);

    void FromHSV(float h, float s, float v, float a = 1.0f);


    Vector3 ToVector3() const { return Vector3(r_, g_, b_); }


    Vector4 ToVector4() const { return Vector4(r_, g_, b_, a_); }


    float SumRGB() const { return r_ + g_ + b_; }


    float Average() const { return (r_ + g_ + b_) / 3.0f; }


    float Luma() const { return r_ * 0.299f + g_ * 0.587f + b_ * 0.114f; }


    float Chroma() const;

    float Hue() const;

    float SaturationHSL() const;

    float SaturationHSV() const;


    float Value() const { return MaxRGB(); }


    float Lightness() const;


    void Bounds(float* min, float* max, bool clipped = false) const;

    float MaxRGB() const;

    float MinRGB() const;

    float Range() const;


    void Clip(bool clipAlpha = false);

    void Invert(bool invertAlpha = false);

    Color Lerp(const Color& rhs, float t) const;


    Color Abs() const { return Color(Urho3D::Abs(r_), Urho3D::Abs(g_), Urho3D::Abs(b_), Urho3D::Abs(a_)); }


    bool Equals(const Color& rhs) const
    {
        return Urho3D::Equals(r_, rhs.r_) && Urho3D::Equals(g_, rhs.g_) && Urho3D::Equals(b_, rhs.b_) && Urho3D::Equals(a_, rhs.a_);
    }


    String ToString() const;


    unsigned ToHash() const { return ToUInt(); }


    float r_;

    float g_;

    float b_;

    float a_;


    static const Color WHITE;

    static const Color GRAY;

    static const Color BLACK;

    static const Color RED;

    static const Color GREEN;

    static const Color BLUE;

    static const Color CYAN;

    static const Color MAGENTA;

    static const Color YELLOW;

    static const Color TRANSPARENT_BLACK;

protected:

    float Hue(float min, float max) const;

    float SaturationHSV(float min, float max) const;

    float SaturationHSL(float min, float max) const;

    void FromHCM(float h, float c, float m);
};


inline Color operator *(float lhs, const Color& rhs) { return rhs * lhs; }

}

namespace Urho3D
{


class __attribute__((visibility("default"))) Matrix3
{
public:

    Matrix3() noexcept :
        m00_(1.0f),
        m01_(0.0f),
        m02_(0.0f),
        m10_(0.0f),
        m11_(1.0f),
        m12_(0.0f),
        m20_(0.0f),
        m21_(0.0f),
        m22_(1.0f)
    {
    }


    Matrix3(const Matrix3& matrix) noexcept = default;


    Matrix3(float v00, float v01, float v02,
            float v10, float v11, float v12,
            float v20, float v21, float v22) noexcept :
        m00_(v00),
        m01_(v01),
        m02_(v02),
        m10_(v10),
        m11_(v11),
        m12_(v12),
        m20_(v20),
        m21_(v21),
        m22_(v22)
    {
    }


    explicit Matrix3(const float* data) noexcept :
        m00_(data[0]),
        m01_(data[1]),
        m02_(data[2]),
        m10_(data[3]),
        m11_(data[4]),
        m12_(data[5]),
        m20_(data[6]),
        m21_(data[7]),
        m22_(data[8])
    {
    }


    Matrix3& operator =(const Matrix3& rhs) noexcept = default;


    bool operator ==(const Matrix3& rhs) const
    {
        const float* leftData = Data();
        const float* rightData = rhs.Data();

        for (unsigned i = 0; i < 9; ++i)
        {
            if (leftData[i] != rightData[i])
                return false;
        }

        return true;
    }


    bool operator !=(const Matrix3& rhs) const { return !(*this == rhs); }


    Vector3 operator *(const Vector3& rhs) const
    {
        return Vector3(
            m00_ * rhs.x_ + m01_ * rhs.y_ + m02_ * rhs.z_,
            m10_ * rhs.x_ + m11_ * rhs.y_ + m12_ * rhs.z_,
            m20_ * rhs.x_ + m21_ * rhs.y_ + m22_ * rhs.z_
        );
    }


    Matrix3 operator +(const Matrix3& rhs) const
    {
        return Matrix3(
            m00_ + rhs.m00_,
            m01_ + rhs.m01_,
            m02_ + rhs.m02_,
            m10_ + rhs.m10_,
            m11_ + rhs.m11_,
            m12_ + rhs.m12_,
            m20_ + rhs.m20_,
            m21_ + rhs.m21_,
            m22_ + rhs.m22_
        );
    }


    Matrix3 operator -(const Matrix3& rhs) const
    {
        return Matrix3(
            m00_ - rhs.m00_,
            m01_ - rhs.m01_,
            m02_ - rhs.m02_,
            m10_ - rhs.m10_,
            m11_ - rhs.m11_,
            m12_ - rhs.m12_,
            m20_ - rhs.m20_,
            m21_ - rhs.m21_,
            m22_ - rhs.m22_
        );
    }


    Matrix3 operator *(float rhs) const
    {
        return Matrix3(
            m00_ * rhs,
            m01_ * rhs,
            m02_ * rhs,
            m10_ * rhs,
            m11_ * rhs,
            m12_ * rhs,
            m20_ * rhs,
            m21_ * rhs,
            m22_ * rhs
        );
    }


    Matrix3 operator *(const Matrix3& rhs) const
    {
        return Matrix3(
            m00_ * rhs.m00_ + m01_ * rhs.m10_ + m02_ * rhs.m20_,
            m00_ * rhs.m01_ + m01_ * rhs.m11_ + m02_ * rhs.m21_,
            m00_ * rhs.m02_ + m01_ * rhs.m12_ + m02_ * rhs.m22_,
            m10_ * rhs.m00_ + m11_ * rhs.m10_ + m12_ * rhs.m20_,
            m10_ * rhs.m01_ + m11_ * rhs.m11_ + m12_ * rhs.m21_,
            m10_ * rhs.m02_ + m11_ * rhs.m12_ + m12_ * rhs.m22_,
            m20_ * rhs.m00_ + m21_ * rhs.m10_ + m22_ * rhs.m20_,
            m20_ * rhs.m01_ + m21_ * rhs.m11_ + m22_ * rhs.m21_,
            m20_ * rhs.m02_ + m21_ * rhs.m12_ + m22_ * rhs.m22_
        );
    }


    void SetScale(const Vector3& scale)
    {
        m00_ = scale.x_;
        m11_ = scale.y_;
        m22_ = scale.z_;
    }


    void SetScale(float scale)
    {
        m00_ = scale;
        m11_ = scale;
        m22_ = scale;
    }


    Vector3 Scale() const
    {
        return Vector3(
            sqrtf(m00_ * m00_ + m10_ * m10_ + m20_ * m20_),
            sqrtf(m01_ * m01_ + m11_ * m11_ + m21_ * m21_),
            sqrtf(m02_ * m02_ + m12_ * m12_ + m22_ * m22_)
        );
    }


    Vector3 SignedScale(const Matrix3& rotation) const
    {
        return Vector3(
            rotation.m00_ * m00_ + rotation.m10_ * m10_ + rotation.m20_ * m20_,
            rotation.m01_ * m01_ + rotation.m11_ * m11_ + rotation.m21_ * m21_,
            rotation.m02_ * m02_ + rotation.m12_ * m12_ + rotation.m22_ * m22_
        );
    }


    Matrix3 Transpose() const
    {
        return Matrix3(
            m00_,
            m10_,
            m20_,
            m01_,
            m11_,
            m21_,
            m02_,
            m12_,
            m22_
        );
    }


    Matrix3 Scaled(const Vector3& scale) const
    {
        return Matrix3(
            m00_ * scale.x_,
            m01_ * scale.y_,
            m02_ * scale.z_,
            m10_ * scale.x_,
            m11_ * scale.y_,
            m12_ * scale.z_,
            m20_ * scale.x_,
            m21_ * scale.y_,
            m22_ * scale.z_
        );
    }


    bool Equals(const Matrix3& rhs) const
    {
        const float* leftData = Data();
        const float* rightData = rhs.Data();

        for (unsigned i = 0; i < 9; ++i)
        {
            if (!Urho3D::Equals(leftData[i], rightData[i]))
                return false;
        }

        return true;
    }


    Matrix3 Inverse() const;


    const float* Data() const { return &m00_; }


    float Element(unsigned i, unsigned j) const { return Data()[i * 3 + j]; }


    Vector3 Row(unsigned i) const { return Vector3(Element(i, 0), Element(i, 1), Element(i, 2)); }


    Vector3 Column(unsigned j) const { return Vector3(Element(0, j), Element(1, j), Element(2, j)); }


    String ToString() const;

    float m00_;
    float m01_;
    float m02_;
    float m10_;
    float m11_;
    float m12_;
    float m20_;
    float m21_;
    float m22_;


    static void BulkTranspose(float* dest, const float* src, unsigned count)
    {
        for (unsigned i = 0; i < count; ++i)
        {
            dest[0] = src[0];
            dest[1] = src[3];
            dest[2] = src[6];
            dest[3] = src[1];
            dest[4] = src[4];
            dest[5] = src[7];
            dest[6] = src[2];
            dest[7] = src[5];
            dest[8] = src[8];

            dest += 9;
            src += 9;
        }
    }


    static const Matrix3 ZERO;

    static const Matrix3 IDENTITY;
};


inline Matrix3 operator *(float lhs, const Matrix3& rhs) { return rhs * lhs; }

}

namespace Urho3D
{


class __attribute__((visibility("default"))) Quaternion
{
public:

    Quaternion() noexcept






    {

        _mm_storeu_ps(&w_, _mm_set_ps(0.f, 0.f, 0.f, 1.f));

    }


    Quaternion(const Quaternion& quat) noexcept

    {
        _mm_storeu_ps(&w_, _mm_loadu_ps(&quat.w_));
    }
    Quaternion(float w, float x, float y, float z) noexcept






    {

        _mm_storeu_ps(&w_, _mm_set_ps(z, y, x, w));

    }


    explicit Quaternion(const float* data) noexcept






    {

        _mm_storeu_ps(&w_, _mm_loadu_ps(data));

    }


    Quaternion(float angle, const Vector3& axis) noexcept
    {
        FromAngleAxis(angle, axis);
    }


    explicit Quaternion(float angle) noexcept
    {
        FromAngleAxis(angle, Vector3::FORWARD);
    }


    Quaternion(float x, float y, float z) noexcept
    {
        FromEulerAngles(x, y, z);
    }


    Quaternion(const Vector3& start, const Vector3& end) noexcept
    {
        FromRotationTo(start, end);
    }


    Quaternion(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis) noexcept
    {
        FromAxes(xAxis, yAxis, zAxis);
    }


    explicit Quaternion(const Matrix3& matrix) noexcept
    {
        FromRotationMatrix(matrix);
    }


    explicit Quaternion(__m128 wxyz) noexcept
    {
        _mm_storeu_ps(&w_, wxyz);
    }



    Quaternion& operator =(const Quaternion& rhs) noexcept
    {

        _mm_storeu_ps(&w_, _mm_loadu_ps(&rhs.w_));






        return *this;
    }


    Quaternion& operator +=(const Quaternion& rhs)
    {

        _mm_storeu_ps(&w_, _mm_add_ps(_mm_loadu_ps(&w_), _mm_loadu_ps(&rhs.w_)));






        return *this;
    }


    Quaternion& operator *=(float rhs)
    {

        _mm_storeu_ps(&w_, _mm_mul_ps(_mm_loadu_ps(&w_), _mm_set1_ps(rhs)));






        return *this;
    }


    bool operator ==(const Quaternion& rhs) const
    {

        __m128 c = _mm_cmpeq_ps(_mm_loadu_ps(&w_), _mm_loadu_ps(&rhs.w_));
        c = _mm_and_ps(c, _mm_movehl_ps(c, c));
        c = _mm_and_ps(c, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(c), (__v4sf)(__m128)(c), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        return _mm_cvtsi128_si32(_mm_castps_si128(c)) == -1;



    }


    bool operator !=(const Quaternion& rhs) const { return !(*this == rhs); }


    Quaternion operator *(float rhs) const
    {

        return Quaternion(_mm_mul_ps(_mm_loadu_ps(&w_), _mm_set1_ps(rhs)));



    }


    Quaternion operator -() const
    {

        return Quaternion(_mm_xor_ps(_mm_loadu_ps(&w_), _mm_castsi128_ps(_mm_set1_epi32((int)0x80000000UL))));



    }


    Quaternion operator +(const Quaternion& rhs) const
    {

        return Quaternion(_mm_add_ps(_mm_loadu_ps(&w_), _mm_loadu_ps(&rhs.w_)));



    }


    Quaternion operator -(const Quaternion& rhs) const
    {

        return Quaternion(_mm_sub_ps(_mm_loadu_ps(&w_), _mm_loadu_ps(&rhs.w_)));



    }


    Quaternion operator *(const Quaternion& rhs) const
    {

        __m128 q1 = _mm_loadu_ps(&w_);
        __m128 q2 = _mm_loadu_ps(&rhs.w_);
        q2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q2), (__v4sf)(__m128)(q2), ((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x3, (((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc) >> 2, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc0) >> 6) + 4); });
        const __m128 signy = _mm_castsi128_ps(_mm_set_epi32((int)0x80000000UL, (int)0x80000000UL, 0, 0));
        const __m128 signx = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(signy), (__v4sf)(__m128)(signy), ((((2) << 6) | ((0) << 4) | ((2) << 2) | (0))) & 0x3, (((((2) << 6) | ((0) << 4) | ((2) << 2) | (0))) & 0xc) >> 2, ((((((2) << 6) | ((0) << 4) | ((2) << 2) | (0))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((0) << 4) | ((2) << 2) | (0))) & 0xc0) >> 6) + 4); });
        const __m128 signz = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(signy), (__v4sf)(__m128)(signy), ((((3) << 6) | ((0) << 4) | ((0) << 2) | (3))) & 0x3, (((((3) << 6) | ((0) << 4) | ((0) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((0) << 4) | ((0) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((0) << 4) | ((0) << 2) | (3))) & 0xc0) >> 6) + 4); });
        __m128 out = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q1), (__v4sf)(__m128)(q1), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q2), (__v4sf)(__m128)(q2), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        out = _mm_add_ps(_mm_mul_ps(_mm_xor_ps(signy, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q1), (__v4sf)(__m128)(q1), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); })), __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q2), (__v4sf)(__m128)(q2), ((((1) << 6) | ((0) << 4) | ((3) << 2) | (2))) & 0x3, (((((1) << 6) | ((0) << 4) | ((3) << 2) | (2))) & 0xc) >> 2, ((((((1) << 6) | ((0) << 4) | ((3) << 2) | (2))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((0) << 4) | ((3) << 2) | (2))) & 0xc0) >> 6) + 4); })), _mm_xor_ps(signx, out));
        out = _mm_add_ps(_mm_mul_ps(_mm_xor_ps(signz, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q1), (__v4sf)(__m128)(q1), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); })), __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q2), (__v4sf)(__m128)(q2), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); })), out);
        out = _mm_add_ps(_mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q1), (__v4sf)(__m128)(q1), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), q2), out);
        return Quaternion(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(out), (__v4sf)(__m128)(out), ((((2) << 6) | ((1) << 4) | ((0) << 2) | (3))) & 0x3, (((((2) << 6) | ((1) << 4) | ((0) << 2) | (3))) & 0xc) >> 2, ((((((2) << 6) | ((1) << 4) | ((0) << 2) | (3))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((1) << 4) | ((0) << 2) | (3))) & 0xc0) >> 6) + 4); }));
    }


    Vector3 operator *(const Vector3& rhs) const
    {

        __m128 q = _mm_loadu_ps(&w_);
        q = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q), (__v4sf)(__m128)(q), ((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x3, (((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc) >> 2, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc0) >> 6) + 4); });
        __m128 v = _mm_set_ps(0.f, rhs.z_, rhs.y_, rhs.x_);
        const __m128 W = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q), (__v4sf)(__m128)(q), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); });
        const __m128 a_yzx = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q), (__v4sf)(__m128)(q), ((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0x3, (((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0xc) >> 2, ((((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0xc0) >> 6) + 4); });
        __m128 x = _mm_mul_ps(q, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v), (__v4sf)(__m128)(v), ((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0x3, (((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0xc) >> 2, ((((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((0) << 4) | ((2) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        __m128 qxv = _mm_sub_ps(x, _mm_mul_ps(a_yzx, v));
        __m128 Wv = _mm_mul_ps(W, v);
        __m128 s = _mm_add_ps(qxv, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(Wv), (__v4sf)(__m128)(Wv), ((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0x3, (((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0xc) >> 2, ((((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0xc0) >> 6) + 4); }));
        __m128 qs = _mm_mul_ps(q, s);
        __m128 y = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(qs), (__v4sf)(__m128)(qs), ((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0x3, (((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0xc) >> 2, ((((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((1) << 4) | ((0) << 2) | (2))) & 0xc0) >> 6) + 4); });
        s = _mm_sub_ps(_mm_mul_ps(a_yzx, s), y);
        s = _mm_add_ps(s, s);
        s = _mm_add_ps(s, v);

        return Vector3(
            _mm_cvtss_f32(s),
            _mm_cvtss_f32(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(s), (__v4sf)(__m128)(s), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); })),
            _mm_cvtss_f32(_mm_movehl_ps(s, s)));







    }


    void FromAngleAxis(float angle, const Vector3& axis);

    void FromEulerAngles(float x, float y, float z);

    void FromRotationTo(const Vector3& start, const Vector3& end);

    void FromAxes(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis);

    void FromRotationMatrix(const Matrix3& matrix);

    bool FromLookRotation(const Vector3& direction, const Vector3& up = Vector3::UP);


    void Normalize()
    {

        __m128 q = _mm_loadu_ps(&w_);
        __m128 n = _mm_mul_ps(q, q);
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        __m128 e = _mm_rsqrt_ps(n);
        __m128 e3 = _mm_mul_ps(_mm_mul_ps(e, e), e);
        __m128 half = _mm_set1_ps(0.5f);
        n = _mm_add_ps(e, _mm_mul_ps(half, _mm_sub_ps(e, _mm_mul_ps(n, e3))));
        _mm_storeu_ps(&w_, _mm_mul_ps(q, n));
    }


    Quaternion Normalized() const
    {

        __m128 q = _mm_loadu_ps(&w_);
        __m128 n = _mm_mul_ps(q, q);
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        __m128 e = _mm_rsqrt_ps(n);
        __m128 e3 = _mm_mul_ps(_mm_mul_ps(e, e), e);
        __m128 half = _mm_set1_ps(0.5f);
        n = _mm_add_ps(e, _mm_mul_ps(half, _mm_sub_ps(e, _mm_mul_ps(n, e3))));
        return Quaternion(_mm_mul_ps(q, n));
    }


    Quaternion Inverse() const
    {

        __m128 q = _mm_loadu_ps(&w_);
        __m128 n = _mm_mul_ps(q, q);
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        return Quaternion(_mm_div_ps(_mm_xor_ps(q, _mm_castsi128_ps(_mm_set_epi32((int)0x80000000UL, (int)0x80000000UL, (int)0x80000000UL, 0))), n));
    }


    float LengthSquared() const
    {

        __m128 q = _mm_loadu_ps(&w_);
        __m128 n = _mm_mul_ps(q, q);
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        return _mm_cvtss_f32(n);



    }


    float DotProduct(const Quaternion& rhs) const
    {

        __m128 q1 = _mm_loadu_ps(&w_);
        __m128 q2 = _mm_loadu_ps(&rhs.w_);
        __m128 n = _mm_mul_ps(q1, q2);
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        n = _mm_add_ps(n, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(n), (__v4sf)(__m128)(n), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        return _mm_cvtss_f32(n);



    }


    bool Equals(const Quaternion& rhs) const
    {
        return Urho3D::Equals(w_, rhs.w_) && Urho3D::Equals(x_, rhs.x_) && Urho3D::Equals(y_, rhs.y_) && Urho3D::Equals(z_, rhs.z_);
    }


    bool IsNaN() const { return Urho3D::IsNaN(w_) || Urho3D::IsNaN(x_) || Urho3D::IsNaN(y_) || Urho3D::IsNaN(z_); }


    Quaternion Conjugate() const
    {

        __m128 q = _mm_loadu_ps(&w_);
        return Quaternion(_mm_xor_ps(q, _mm_castsi128_ps(_mm_set_epi32((int)0x80000000UL, (int)0x80000000UL, (int)0x80000000UL, 0))));



    }


    Vector3 EulerAngles() const;

    float YawAngle() const;

    float PitchAngle() const;

    float RollAngle() const;

    Vector3 Axis() const;

    float Angle() const;

    Matrix3 RotationMatrix() const;

    Quaternion Slerp(const Quaternion& rhs, float t) const;

    Quaternion Nlerp(const Quaternion& rhs, float t, bool shortestPath = false) const;


    const float* Data() const { return &w_; }


    String ToString() const;


    float w_;

    float x_;

    float y_;

    float z_;


    static const Quaternion IDENTITY;
};

}







namespace Urho3D
{

class Matrix3x4;


class __attribute__((visibility("default"))) Matrix4
{
public:

    Matrix4() noexcept
    {

        _mm_storeu_ps(&m00_, _mm_set_ps(0.f, 0.f, 0.f, 1.f));
        _mm_storeu_ps(&m10_, _mm_set_ps(0.f, 0.f, 1.f, 0.f));
        _mm_storeu_ps(&m20_, _mm_set_ps(0.f, 1.f, 0.f, 0.f));
        _mm_storeu_ps(&m30_, _mm_set_ps(1.f, 0.f, 0.f, 0.f));

    }


    Matrix4(const Matrix4& matrix) noexcept
    {

        _mm_storeu_ps(&m00_, _mm_loadu_ps(&matrix.m00_));
        _mm_storeu_ps(&m10_, _mm_loadu_ps(&matrix.m10_));
        _mm_storeu_ps(&m20_, _mm_loadu_ps(&matrix.m20_));
        _mm_storeu_ps(&m30_, _mm_loadu_ps(&matrix.m30_));

    }


    explicit Matrix4(const Matrix3& matrix) noexcept :
        m00_(matrix.m00_),
        m01_(matrix.m01_),
        m02_(matrix.m02_),
        m03_(0.0f),
        m10_(matrix.m10_),
        m11_(matrix.m11_),
        m12_(matrix.m12_),
        m13_(0.0f),
        m20_(matrix.m20_),
        m21_(matrix.m21_),
        m22_(matrix.m22_),
        m23_(0.0f),
        m30_(0.0f),
        m31_(0.0f),
        m32_(0.0f),
        m33_(1.0f)
    {
    }


    Matrix4(float v00, float v01, float v02, float v03,
            float v10, float v11, float v12, float v13,
            float v20, float v21, float v22, float v23,
            float v30, float v31, float v32, float v33) noexcept :
        m00_(v00),
        m01_(v01),
        m02_(v02),
        m03_(v03),
        m10_(v10),
        m11_(v11),
        m12_(v12),
        m13_(v13),
        m20_(v20),
        m21_(v21),
        m22_(v22),
        m23_(v23),
        m30_(v30),
        m31_(v31),
        m32_(v32),
        m33_(v33)
    {
    }


    explicit Matrix4(const float* data) noexcept
    {

        _mm_storeu_ps(&m00_, _mm_loadu_ps(data));
        _mm_storeu_ps(&m10_, _mm_loadu_ps(data + 4));
        _mm_storeu_ps(&m20_, _mm_loadu_ps(data + 8));
        _mm_storeu_ps(&m30_, _mm_loadu_ps(data + 12));

    }


    Matrix4& operator =(const Matrix4& rhs) noexcept
    {

        _mm_storeu_ps(&m00_, _mm_loadu_ps(&rhs.m00_));
        _mm_storeu_ps(&m10_, _mm_loadu_ps(&rhs.m10_));
        _mm_storeu_ps(&m20_, _mm_loadu_ps(&rhs.m20_));
        _mm_storeu_ps(&m30_, _mm_loadu_ps(&rhs.m30_));
        return *this;
    }


    Matrix4& operator =(const Matrix3& rhs) noexcept
    {
        m00_ = rhs.m00_;
        m01_ = rhs.m01_;
        m02_ = rhs.m02_;
        m03_ = 0.0f;
        m10_ = rhs.m10_;
        m11_ = rhs.m11_;
        m12_ = rhs.m12_;
        m13_ = 0.0f;
        m20_ = rhs.m20_;
        m21_ = rhs.m21_;
        m22_ = rhs.m22_;
        m23_ = 0.0f;
        m30_ = 0.0f;
        m31_ = 0.0f;
        m32_ = 0.0f;
        m33_ = 1.0f;
        return *this;
    }


    bool operator ==(const Matrix4& rhs) const
    {

        __m128 c0 = _mm_cmpeq_ps(_mm_loadu_ps(&m00_), _mm_loadu_ps(&rhs.m00_));
        __m128 c1 = _mm_cmpeq_ps(_mm_loadu_ps(&m10_), _mm_loadu_ps(&rhs.m10_));
        c0 = _mm_and_ps(c0, c1);
        __m128 c2 = _mm_cmpeq_ps(_mm_loadu_ps(&m20_), _mm_loadu_ps(&rhs.m20_));
        __m128 c3 = _mm_cmpeq_ps(_mm_loadu_ps(&m30_), _mm_loadu_ps(&rhs.m30_));
        c2 = _mm_and_ps(c2, c3);
        c0 = _mm_and_ps(c0, c2);
        __m128 hi = _mm_movehl_ps(c0, c0);
        c0 = _mm_and_ps(c0, hi);
        hi = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(c0), (__v4sf)(__m128)(c0), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); });
        c0 = _mm_and_ps(c0, hi);
        return _mm_cvtsi128_si32(_mm_castps_si128(c0)) == -1;
    }


    bool operator !=(const Matrix4& rhs) const { return !(*this == rhs); }


    Vector3 operator *(const Vector3& rhs) const
    {

        __m128 vec = _mm_set_ps(1.f, rhs.z_, rhs.y_, rhs.x_);
        __m128 r0 = _mm_mul_ps(_mm_loadu_ps(&m00_), vec);
        __m128 r1 = _mm_mul_ps(_mm_loadu_ps(&m10_), vec);
        __m128 t0 = _mm_unpacklo_ps(r0, r1);
        __m128 t1 = _mm_unpackhi_ps(r0, r1);
        t0 = _mm_add_ps(t0, t1);
        __m128 r2 = _mm_mul_ps(_mm_loadu_ps(&m20_), vec);
        __m128 r3 = _mm_mul_ps(_mm_loadu_ps(&m30_), vec);
        __m128 t2 = _mm_unpacklo_ps(r2, r3);
        __m128 t3 = _mm_unpackhi_ps(r2, r3);
        t2 = _mm_add_ps(t2, t3);
        vec = _mm_add_ps(_mm_movelh_ps(t0, t2), _mm_movehl_ps(t2, t0));
        vec = _mm_div_ps(vec, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vec), (__v4sf)(__m128)(vec), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }));
        return Vector3(
            _mm_cvtss_f32(vec),
            _mm_cvtss_f32(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vec), (__v4sf)(__m128)(vec), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); })),
            _mm_cvtss_f32(_mm_movehl_ps(vec, vec)));
    }


    Vector4 operator *(const Vector4& rhs) const
    {

        __m128 vec = _mm_loadu_ps(&rhs.x_);
        __m128 r0 = _mm_mul_ps(_mm_loadu_ps(&m00_), vec);
        __m128 r1 = _mm_mul_ps(_mm_loadu_ps(&m10_), vec);
        __m128 t0 = _mm_unpacklo_ps(r0, r1);
        __m128 t1 = _mm_unpackhi_ps(r0, r1);
        t0 = _mm_add_ps(t0, t1);
        __m128 r2 = _mm_mul_ps(_mm_loadu_ps(&m20_), vec);
        __m128 r3 = _mm_mul_ps(_mm_loadu_ps(&m30_), vec);
        __m128 t2 = _mm_unpacklo_ps(r2, r3);
        __m128 t3 = _mm_unpackhi_ps(r2, r3);
        t2 = _mm_add_ps(t2, t3);
        vec = _mm_add_ps(_mm_movelh_ps(t0, t2), _mm_movehl_ps(t2, t0));

        Vector4 ret;
        _mm_storeu_ps(&ret.x_, vec);
        return ret;
    }


    Matrix4 operator +(const Matrix4& rhs) const
    {

        Matrix4 ret;
        _mm_storeu_ps(&ret.m00_, _mm_add_ps(_mm_loadu_ps(&m00_), _mm_loadu_ps(&rhs.m00_)));
        _mm_storeu_ps(&ret.m10_, _mm_add_ps(_mm_loadu_ps(&m10_), _mm_loadu_ps(&rhs.m10_)));
        _mm_storeu_ps(&ret.m20_, _mm_add_ps(_mm_loadu_ps(&m20_), _mm_loadu_ps(&rhs.m20_)));
        _mm_storeu_ps(&ret.m30_, _mm_add_ps(_mm_loadu_ps(&m30_), _mm_loadu_ps(&rhs.m30_)));
        return ret;
    }


    Matrix4 operator -(const Matrix4& rhs) const
    {

        Matrix4 ret;
        _mm_storeu_ps(&ret.m00_, _mm_sub_ps(_mm_loadu_ps(&m00_), _mm_loadu_ps(&rhs.m00_)));
        _mm_storeu_ps(&ret.m10_, _mm_sub_ps(_mm_loadu_ps(&m10_), _mm_loadu_ps(&rhs.m10_)));
        _mm_storeu_ps(&ret.m20_, _mm_sub_ps(_mm_loadu_ps(&m20_), _mm_loadu_ps(&rhs.m20_)));
        _mm_storeu_ps(&ret.m30_, _mm_sub_ps(_mm_loadu_ps(&m30_), _mm_loadu_ps(&rhs.m30_)));
        return ret;
    }


    Matrix4 operator *(float rhs) const
    {

        Matrix4 ret;
        const __m128 mul = _mm_set1_ps(rhs);
        _mm_storeu_ps(&ret.m00_, _mm_mul_ps(_mm_loadu_ps(&m00_), mul));
        _mm_storeu_ps(&ret.m10_, _mm_mul_ps(_mm_loadu_ps(&m10_), mul));
        _mm_storeu_ps(&ret.m20_, _mm_mul_ps(_mm_loadu_ps(&m20_), mul));
        _mm_storeu_ps(&ret.m30_, _mm_mul_ps(_mm_loadu_ps(&m30_), mul));
        return ret;
    }


    Matrix4 operator *(const Matrix4& rhs) const
    {

        Matrix4 out;

        __m128 r0 = _mm_loadu_ps(&rhs.m00_);
        __m128 r1 = _mm_loadu_ps(&rhs.m10_);
        __m128 r2 = _mm_loadu_ps(&rhs.m20_);
        __m128 r3 = _mm_loadu_ps(&rhs.m30_);

        __m128 l = _mm_loadu_ps(&m00_);
        __m128 t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        __m128 t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        __m128 t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        __m128 t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m00_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m10_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m10_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m20_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m20_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m30_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m30_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        return out;
    }


    Matrix4 operator *(const Matrix3x4& rhs) const;


    void SetTranslation(const Vector3& translation)
    {
        m03_ = translation.x_;
        m13_ = translation.y_;
        m23_ = translation.z_;
    }


    void SetRotation(const Matrix3& rotation)
    {
        m00_ = rotation.m00_;
        m01_ = rotation.m01_;
        m02_ = rotation.m02_;
        m10_ = rotation.m10_;
        m11_ = rotation.m11_;
        m12_ = rotation.m12_;
        m20_ = rotation.m20_;
        m21_ = rotation.m21_;
        m22_ = rotation.m22_;
    }


    void SetScale(const Vector3& scale)
    {
        m00_ = scale.x_;
        m11_ = scale.y_;
        m22_ = scale.z_;
    }


    void SetScale(float scale)
    {
        m00_ = scale;
        m11_ = scale;
        m22_ = scale;
    }


    Matrix3 ToMatrix3() const
    {
        return Matrix3(
            m00_,
            m01_,
            m02_,
            m10_,
            m11_,
            m12_,
            m20_,
            m21_,
            m22_
        );
    }


    Matrix3 RotationMatrix() const
    {
        Vector3 invScale(
            1.0f / sqrtf(m00_ * m00_ + m10_ * m10_ + m20_ * m20_),
            1.0f / sqrtf(m01_ * m01_ + m11_ * m11_ + m21_ * m21_),
            1.0f / sqrtf(m02_ * m02_ + m12_ * m12_ + m22_ * m22_)
        );

        return ToMatrix3().Scaled(invScale);
    }


    Vector3 Translation() const
    {
        return Vector3(
            m03_,
            m13_,
            m23_
        );
    }


    Quaternion Rotation() const { return Quaternion(RotationMatrix()); }


    Vector3 Scale() const
    {
        return Vector3(
            sqrtf(m00_ * m00_ + m10_ * m10_ + m20_ * m20_),
            sqrtf(m01_ * m01_ + m11_ * m11_ + m21_ * m21_),
            sqrtf(m02_ * m02_ + m12_ * m12_ + m22_ * m22_)
        );
    }


    Vector3 SignedScale(const Matrix3& rotation) const
    {
        return Vector3(
            rotation.m00_ * m00_ + rotation.m10_ * m10_ + rotation.m20_ * m20_,
            rotation.m01_ * m01_ + rotation.m11_ * m11_ + rotation.m21_ * m21_,
            rotation.m02_ * m02_ + rotation.m12_ * m12_ + rotation.m22_ * m22_
        );
    }


    Matrix4 Transpose() const
    {

        __m128 m0 = _mm_loadu_ps(&m00_);
        __m128 m1 = _mm_loadu_ps(&m10_);
        __m128 m2 = _mm_loadu_ps(&m20_);
        __m128 m3 = _mm_loadu_ps(&m30_);
        do { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_unpacklo_ps((m0), (m1)); tmp2 = _mm_unpacklo_ps((m2), (m3)); tmp1 = _mm_unpackhi_ps((m0), (m1)); tmp3 = _mm_unpackhi_ps((m2), (m3)); (m0) = _mm_movelh_ps(tmp0, tmp2); (m1) = _mm_movehl_ps(tmp2, tmp0); (m2) = _mm_movelh_ps(tmp1, tmp3); (m3) = _mm_movehl_ps(tmp3, tmp1); } while (0);
        Matrix4 out;
        _mm_storeu_ps(&out.m00_, m0);
        _mm_storeu_ps(&out.m10_, m1);
        _mm_storeu_ps(&out.m20_, m2);
        _mm_storeu_ps(&out.m30_, m3);
        return out;
    }


    bool Equals(const Matrix4& rhs) const
    {
        const float* leftData = Data();
        const float* rightData = rhs.Data();

        for (unsigned i = 0; i < 16; ++i)
        {
            if (!Urho3D::Equals(leftData[i], rightData[i]))
                return false;
        }

        return true;
    }


    void Decompose(Vector3& translation, Quaternion& rotation, Vector3& scale) const;


    Matrix4 Inverse() const;


    const float* Data() const { return &m00_; }


    float Element(unsigned i, unsigned j) const { return Data()[i * 4 + j]; }


    Vector4 Row(unsigned i) const { return Vector4(Element(i, 0), Element(i, 1), Element(i, 2), Element(i, 3)); }


    Vector4 Column(unsigned j) const { return Vector4(Element(0, j), Element(1, j), Element(2, j), Element(3, j)); }


    String ToString() const;

    float m00_;
    float m01_;
    float m02_;
    float m03_;
    float m10_;
    float m11_;
    float m12_;
    float m13_;
    float m20_;
    float m21_;
    float m22_;
    float m23_;
    float m30_;
    float m31_;
    float m32_;
    float m33_;


    static void BulkTranspose(float* dest, const float* src, unsigned count)
    {
        for (unsigned i = 0; i < count; ++i)
        {

            __m128 m0 = _mm_loadu_ps(src);
            __m128 m1 = _mm_loadu_ps(src + 4);
            __m128 m2 = _mm_loadu_ps(src + 8);
            __m128 m3 = _mm_loadu_ps(src + 12);
            do { __m128 tmp3, tmp2, tmp1, tmp0; tmp0 = _mm_unpacklo_ps((m0), (m1)); tmp2 = _mm_unpacklo_ps((m2), (m3)); tmp1 = _mm_unpackhi_ps((m0), (m1)); tmp3 = _mm_unpackhi_ps((m2), (m3)); (m0) = _mm_movelh_ps(tmp0, tmp2); (m1) = _mm_movehl_ps(tmp2, tmp0); (m2) = _mm_movelh_ps(tmp1, tmp3); (m3) = _mm_movehl_ps(tmp3, tmp1); } while (0);
            _mm_storeu_ps(dest, m0);
            _mm_storeu_ps(dest + 4, m1);
            _mm_storeu_ps(dest + 8, m2);
            _mm_storeu_ps(dest + 12, m3);
            dest += 16;
            src += 16;
        }
    }


    static const Matrix4 ZERO;

    static const Matrix4 IDENTITY;
};


inline Matrix4 operator *(float lhs, const Matrix4& rhs) { return rhs * lhs; }

}






namespace Urho3D
{


class __attribute__((visibility("default"))) Matrix3x4
{
public:

    Matrix3x4() noexcept
    {

        _mm_storeu_ps(&m00_, _mm_set_ps(0.f, 0.f, 0.f, 1.f));
        _mm_storeu_ps(&m10_, _mm_set_ps(0.f, 0.f, 1.f, 0.f));
        _mm_storeu_ps(&m20_, _mm_set_ps(0.f, 1.f, 0.f, 0.f));

    }


    Matrix3x4(const Matrix3x4& matrix) noexcept = default;


    explicit Matrix3x4(const Matrix3& matrix) noexcept :
        m00_(matrix.m00_),
        m01_(matrix.m01_),
        m02_(matrix.m02_),
        m03_(0.0f),
        m10_(matrix.m10_),
        m11_(matrix.m11_),
        m12_(matrix.m12_),
        m13_(0.0f),
        m20_(matrix.m20_),
        m21_(matrix.m21_),
        m22_(matrix.m22_),
        m23_(0.0f)
    {
    }


    explicit Matrix3x4(const Matrix4& matrix) noexcept
    {

        _mm_storeu_ps(&m00_, _mm_loadu_ps(&matrix.m00_));
        _mm_storeu_ps(&m10_, _mm_loadu_ps(&matrix.m10_));
        _mm_storeu_ps(&m20_, _mm_loadu_ps(&matrix.m20_));

    }


    Matrix3x4(float v00, float v01, float v02, float v03,
              float v10, float v11, float v12, float v13,
              float v20, float v21, float v22, float v23) noexcept :
        m00_(v00),
        m01_(v01),
        m02_(v02),
        m03_(v03),
        m10_(v10),
        m11_(v11),
        m12_(v12),
        m13_(v13),
        m20_(v20),
        m21_(v21),
        m22_(v22),
        m23_(v23)
    {
    }


    explicit Matrix3x4(const float* data) noexcept
    {

        _mm_storeu_ps(&m00_, _mm_loadu_ps(data));
        _mm_storeu_ps(&m10_, _mm_loadu_ps(data + 4));
        _mm_storeu_ps(&m20_, _mm_loadu_ps(data + 8));

    }


    Matrix3x4(const Vector3& translation, const Quaternion& rotation, float scale) noexcept
    {

        __m128 t = _mm_set_ps(1.f, translation.z_, translation.y_, translation.x_);
        __m128 q = _mm_loadu_ps(&rotation.w_);
        __m128 s = _mm_set_ps(1.f, scale, scale, scale);
        SetFromTRS(t, q, s);




    }


    Matrix3x4(const Vector3& translation, const Quaternion& rotation, const Vector3& scale) noexcept
    {

        __m128 t = _mm_set_ps(1.f, translation.z_, translation.y_, translation.x_);
        __m128 q = _mm_loadu_ps(&rotation.w_);
        __m128 s = _mm_set_ps(1.f, scale.z_, scale.y_, scale.x_);
        SetFromTRS(t, q, s);




    }


    Matrix3x4& operator =(const Matrix3x4& rhs) noexcept = default;


    Matrix3x4& operator =(const Matrix3& rhs) noexcept
    {
        m00_ = rhs.m00_;
        m01_ = rhs.m01_;
        m02_ = rhs.m02_;
        m03_ = 0.0f;
        m10_ = rhs.m10_;
        m11_ = rhs.m11_;
        m12_ = rhs.m12_;
        m13_ = 0.0f;
        m20_ = rhs.m20_;
        m21_ = rhs.m21_;
        m22_ = rhs.m22_;
        m23_ = 0.0f;
        return *this;
    }


    Matrix3x4& operator =(const Matrix4& rhs) noexcept
    {

        _mm_storeu_ps(&m00_, _mm_loadu_ps(&rhs.m00_));
        _mm_storeu_ps(&m10_, _mm_loadu_ps(&rhs.m10_));
        _mm_storeu_ps(&m20_, _mm_loadu_ps(&rhs.m20_));
        return *this;
    }


    bool operator ==(const Matrix3x4& rhs) const
    {

        __m128 c0 = _mm_cmpeq_ps(_mm_loadu_ps(&m00_), _mm_loadu_ps(&rhs.m00_));
        __m128 c1 = _mm_cmpeq_ps(_mm_loadu_ps(&m10_), _mm_loadu_ps(&rhs.m10_));
        c0 = _mm_and_ps(c0, c1);
        __m128 c2 = _mm_cmpeq_ps(_mm_loadu_ps(&m20_), _mm_loadu_ps(&rhs.m20_));
        c0 = _mm_and_ps(c0, c2);
        __m128 hi = _mm_movehl_ps(c0, c0);
        c0 = _mm_and_ps(c0, hi);
        hi = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(c0), (__v4sf)(__m128)(c0), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); });
        c0 = _mm_and_ps(c0, hi);
        return _mm_cvtsi128_si32(_mm_castps_si128(c0)) == -1;
    }


    bool operator !=(const Matrix3x4& rhs) const { return !(*this == rhs); }


    Vector3 operator *(const Vector3& rhs) const
    {

        __m128 vec = _mm_set_ps(1.f, rhs.z_, rhs.y_, rhs.x_);
        __m128 r0 = _mm_mul_ps(_mm_loadu_ps(&m00_), vec);
        __m128 r1 = _mm_mul_ps(_mm_loadu_ps(&m10_), vec);
        __m128 t0 = _mm_unpacklo_ps(r0, r1);
        __m128 t1 = _mm_unpackhi_ps(r0, r1);
        t0 = _mm_add_ps(t0, t1);
        __m128 r2 = _mm_mul_ps(_mm_loadu_ps(&m20_), vec);
        __m128 r3 = _mm_setzero_ps();
        __m128 t2 = _mm_unpacklo_ps(r2, r3);
        __m128 t3 = _mm_unpackhi_ps(r2, r3);
        t2 = _mm_add_ps(t2, t3);
        vec = _mm_add_ps(_mm_movelh_ps(t0, t2), _mm_movehl_ps(t2, t0));

        return Vector3(
            _mm_cvtss_f32(vec),
            _mm_cvtss_f32(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vec), (__v4sf)(__m128)(vec), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); })),
            _mm_cvtss_f32(_mm_movehl_ps(vec, vec)));







    }


    Vector3 operator *(const Vector4& rhs) const
    {

        __m128 vec = _mm_loadu_ps(&rhs.x_);
        __m128 r0 = _mm_mul_ps(_mm_loadu_ps(&m00_), vec);
        __m128 r1 = _mm_mul_ps(_mm_loadu_ps(&m10_), vec);
        __m128 t0 = _mm_unpacklo_ps(r0, r1);
        __m128 t1 = _mm_unpackhi_ps(r0, r1);
        t0 = _mm_add_ps(t0, t1);
        __m128 r2 = _mm_mul_ps(_mm_loadu_ps(&m20_), vec);
        __m128 r3 = _mm_setzero_ps();
        __m128 t2 = _mm_unpacklo_ps(r2, r3);
        __m128 t3 = _mm_unpackhi_ps(r2, r3);
        t2 = _mm_add_ps(t2, t3);
        vec = _mm_add_ps(_mm_movelh_ps(t0, t2), _mm_movehl_ps(t2, t0));

        return Vector3(
            _mm_cvtss_f32(vec),
            _mm_cvtss_f32(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vec), (__v4sf)(__m128)(vec), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); })),
            _mm_cvtss_f32(_mm_movehl_ps(vec, vec)));







    }


    Matrix3x4 operator +(const Matrix3x4& rhs) const
    {

        Matrix3x4 ret;
        _mm_storeu_ps(&ret.m00_, _mm_add_ps(_mm_loadu_ps(&m00_), _mm_loadu_ps(&rhs.m00_)));
        _mm_storeu_ps(&ret.m10_, _mm_add_ps(_mm_loadu_ps(&m10_), _mm_loadu_ps(&rhs.m10_)));
        _mm_storeu_ps(&ret.m20_, _mm_add_ps(_mm_loadu_ps(&m20_), _mm_loadu_ps(&rhs.m20_)));
        return ret;
    }


    Matrix3x4 operator -(const Matrix3x4& rhs) const
    {

        Matrix3x4 ret;
        _mm_storeu_ps(&ret.m00_, _mm_sub_ps(_mm_loadu_ps(&m00_), _mm_loadu_ps(&rhs.m00_)));
        _mm_storeu_ps(&ret.m10_, _mm_sub_ps(_mm_loadu_ps(&m10_), _mm_loadu_ps(&rhs.m10_)));
        _mm_storeu_ps(&ret.m20_, _mm_sub_ps(_mm_loadu_ps(&m20_), _mm_loadu_ps(&rhs.m20_)));
        return ret;
    }


    Matrix3x4 operator *(float rhs) const
    {

        Matrix3x4 ret;
        const __m128 mul = _mm_set1_ps(rhs);
        _mm_storeu_ps(&ret.m00_, _mm_mul_ps(_mm_loadu_ps(&m00_), mul));
        _mm_storeu_ps(&ret.m10_, _mm_mul_ps(_mm_loadu_ps(&m10_), mul));
        _mm_storeu_ps(&ret.m20_, _mm_mul_ps(_mm_loadu_ps(&m20_), mul));
        return ret;
    }


    Matrix3x4 operator *(const Matrix3x4& rhs) const
    {

        Matrix3x4 out;

        __m128 r0 = _mm_loadu_ps(&rhs.m00_);
        __m128 r1 = _mm_loadu_ps(&rhs.m10_);
        __m128 r2 = _mm_loadu_ps(&rhs.m20_);
        __m128 r3 = _mm_set_ps(1.f, 0.f, 0.f, 0.f);

        __m128 l = _mm_loadu_ps(&m00_);
        __m128 t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        __m128 t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        __m128 t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        __m128 t3 = _mm_mul_ps(l, r3);
        _mm_storeu_ps(&out.m00_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m10_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(l, r3);
        _mm_storeu_ps(&out.m10_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m20_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(l, r3);
        _mm_storeu_ps(&out.m20_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        return out;
    }


    Matrix4 operator *(const Matrix4& rhs) const
    {

        Matrix4 out;

        __m128 r0 = _mm_loadu_ps(&rhs.m00_);
        __m128 r1 = _mm_loadu_ps(&rhs.m10_);
        __m128 r2 = _mm_loadu_ps(&rhs.m20_);
        __m128 r3 = _mm_loadu_ps(&rhs.m30_);

        __m128 l = _mm_loadu_ps(&m00_);
        __m128 t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        __m128 t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        __m128 t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        __m128 t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m00_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m10_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m10_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        l = _mm_loadu_ps(&m20_);
        t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x3, (((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc) >> 2, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((0) << 4) | ((0) << 2) | (0))) & 0xc0) >> 6) + 4); }), r0);
        t1 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x3, (((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((1) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }), r1);
        t2 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x3, (((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); }), r2);
        t3 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(l), (__v4sf)(__m128)(l), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (3))) & 0xc0) >> 6) + 4); }), r3);
        _mm_storeu_ps(&out.m20_, _mm_add_ps(_mm_add_ps(t0, t1), _mm_add_ps(t2, t3)));

        _mm_storeu_ps(&out.m30_, r3);

        return out;
    }


    void SetTranslation(const Vector3& translation)
    {
        m03_ = translation.x_;
        m13_ = translation.y_;
        m23_ = translation.z_;
    }


    void SetRotation(const Matrix3& rotation)
    {
        m00_ = rotation.m00_;
        m01_ = rotation.m01_;
        m02_ = rotation.m02_;
        m10_ = rotation.m10_;
        m11_ = rotation.m11_;
        m12_ = rotation.m12_;
        m20_ = rotation.m20_;
        m21_ = rotation.m21_;
        m22_ = rotation.m22_;
    }


    void SetScale(const Vector3& scale)
    {
        m00_ = scale.x_;
        m11_ = scale.y_;
        m22_ = scale.z_;
    }


    void SetScale(float scale)
    {
        m00_ = scale;
        m11_ = scale;
        m22_ = scale;
    }


    Matrix3 ToMatrix3() const
    {
        return Matrix3(
            m00_,
            m01_,
            m02_,
            m10_,
            m11_,
            m12_,
            m20_,
            m21_,
            m22_
        );
    }


    Matrix4 ToMatrix4() const
    {

        Matrix4 ret;
        _mm_storeu_ps(&ret.m00_, _mm_loadu_ps(&m00_));
        _mm_storeu_ps(&ret.m10_, _mm_loadu_ps(&m10_));
        _mm_storeu_ps(&ret.m20_, _mm_loadu_ps(&m20_));
        _mm_storeu_ps(&ret.m30_, _mm_set_ps(1.f, 0.f, 0.f, 0.f));
        return ret;
    }


    Matrix3 RotationMatrix() const
    {
        Vector3 invScale(
            1.0f / sqrtf(m00_ * m00_ + m10_ * m10_ + m20_ * m20_),
            1.0f / sqrtf(m01_ * m01_ + m11_ * m11_ + m21_ * m21_),
            1.0f / sqrtf(m02_ * m02_ + m12_ * m12_ + m22_ * m22_)
        );

        return ToMatrix3().Scaled(invScale);
    }


    Vector3 Translation() const
    {
        return Vector3(
            m03_,
            m13_,
            m23_
        );
    }


    Quaternion Rotation() const { return Quaternion(RotationMatrix()); }


    Vector3 Scale() const
    {
        return Vector3(
            sqrtf(m00_ * m00_ + m10_ * m10_ + m20_ * m20_),
            sqrtf(m01_ * m01_ + m11_ * m11_ + m21_ * m21_),
            sqrtf(m02_ * m02_ + m12_ * m12_ + m22_ * m22_)
        );
    }


    Vector3 SignedScale(const Matrix3& rotation) const
    {
        return Vector3(
            rotation.m00_ * m00_ + rotation.m10_ * m10_ + rotation.m20_ * m20_,
            rotation.m01_ * m01_ + rotation.m11_ * m11_ + rotation.m21_ * m21_,
            rotation.m02_ * m02_ + rotation.m12_ * m12_ + rotation.m22_ * m22_
        );
    }


    bool Equals(const Matrix3x4& rhs) const
    {
        const float* leftData = Data();
        const float* rightData = rhs.Data();

        for (unsigned i = 0; i < 12; ++i)
        {
            if (!Urho3D::Equals(leftData[i], rightData[i]))
                return false;
        }

        return true;
    }


    void Decompose(Vector3& translation, Quaternion& rotation, Vector3& scale) const;


    Matrix3x4 Inverse() const;


    const float* Data() const { return &m00_; }


    float Element(unsigned i, unsigned j) const { return Data()[i * 4 + j]; }


    Vector4 Row(unsigned i) const { return Vector4(Element(i, 0), Element(i, 1), Element(i, 2), Element(i, 3)); }


    Vector3 Column(unsigned j) const { return Vector3(Element(0, j), Element(1, j), Element(2, j)); }


    String ToString() const;

    float m00_;
    float m01_;
    float m02_;
    float m03_;
    float m10_;
    float m11_;
    float m12_;
    float m13_;
    float m20_;
    float m21_;
    float m22_;
    float m23_;


    static const Matrix3x4 ZERO;

    static const Matrix3x4 IDENTITY;


private:

    void inline SetFromTRS(__m128 t, __m128 q, __m128 s)
    {
        q = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q), (__v4sf)(__m128)(q), ((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x3, (((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc) >> 2, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc0) >> 6) + 4); });
        __m128 one = _mm_set_ps(0, 0, 0, 1);
        const __m128 sseX1 = _mm_castsi128_ps(_mm_set_epi32((int)0x80000000UL, (int)0x80000000UL, 0, (int)0x80000000UL));
        __m128 q2 = _mm_add_ps(q, q);
        __m128 t2 = _mm_add_ss(_mm_xor_ps(_mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q), (__v4sf)(__m128)(q), ((((3) << 6) | ((3) << 4) | ((3) << 2) | (2))) & 0x3, (((((3) << 6) | ((3) << 4) | ((3) << 2) | (2))) & 0xc) >> 2, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (2))) & 0x30) >> 4) + 4, ((((((3) << 6) | ((3) << 4) | ((3) << 2) | (2))) & 0xc0) >> 6) + 4); }), __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q2), (__v4sf)(__m128)(q2), ((((0) << 6) | ((1) << 4) | ((2) << 2) | (2))) & 0x3, (((((0) << 6) | ((1) << 4) | ((2) << 2) | (2))) & 0xc) >> 2, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (2))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((1) << 4) | ((2) << 2) | (2))) & 0xc0) >> 6) + 4); })), sseX1), one);
        const __m128 sseX0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(sseX1), (__v4sf)(__m128)(sseX1), ((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x3, (((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc) >> 2, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0x30) >> 4) + 4, ((((((0) << 6) | ((3) << 4) | ((2) << 2) | (1))) & 0xc0) >> 6) + 4); });
        __m128 t0 = _mm_mul_ps(__extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q), (__v4sf)(__m128)(q), ((((1) << 6) | ((0) << 4) | ((0) << 2) | (1))) & 0x3, (((((1) << 6) | ((0) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((1) << 6) | ((0) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((1) << 6) | ((0) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); }), __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(q2), (__v4sf)(__m128)(q2), ((((2) << 6) | ((2) << 4) | ((1) << 2) | (1))) & 0x3, (((((2) << 6) | ((2) << 4) | ((1) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((2) << 4) | ((1) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((2) << 4) | ((1) << 2) | (1))) & 0xc0) >> 6) + 4); }));
        __m128 t1 = _mm_xor_ps(t0, sseX0);
        __m128 r0 = _mm_sub_ps(t2, t1);
        __m128 xx2 = _mm_mul_ss(q, q2);
        __m128 r1 = _mm_sub_ps(_mm_xor_ps(t2, sseX0), _mm_move_ss(t1, xx2));
        r1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(r1), (__v4sf)(__m128)(r1), ((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x3, (((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((3) << 4) | ((0) << 2) | (1))) & 0xc0) >> 6) + 4); });
        __m128 r2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(_mm_movehl_ps(r0, r1)), (__v4sf)(__m128)(_mm_sub_ss(_mm_sub_ss(one, xx2), t0)), ((((2) << 6) | ((0) << 4) | ((3) << 2) | (1))) & 0x3, (((((2) << 6) | ((0) << 4) | ((3) << 2) | (1))) & 0xc) >> 2, ((((((2) << 6) | ((0) << 4) | ((3) << 2) | (1))) & 0x30) >> 4) + 4, ((((((2) << 6) | ((0) << 4) | ((3) << 2) | (1))) & 0xc0) >> 6) + 4); });
        __m128 tmp0 = _mm_unpacklo_ps(r0, r1);
        __m128 tmp2 = _mm_unpacklo_ps(r2, t);
        __m128 tmp1 = _mm_unpackhi_ps(r0, r1);
        __m128 tmp3 = _mm_unpackhi_ps(r2, t);
        _mm_storeu_ps(&m00_, _mm_mul_ps(_mm_movelh_ps(tmp0, tmp2), s));
        _mm_storeu_ps(&m10_, _mm_mul_ps(_mm_movehl_ps(tmp2, tmp0), s));
        _mm_storeu_ps(&m20_, _mm_mul_ps(_mm_movelh_ps(tmp1, tmp3), s));
    }

};


inline Matrix3x4 operator *(float lhs, const Matrix3x4& rhs) { return rhs * lhs; }

}

namespace Urho3D
{


class __attribute__((visibility("default"))) Rect
{
public:

    Rect() noexcept :
        min_(M_INFINITY, M_INFINITY),
        max_(-M_INFINITY, -M_INFINITY)
    {
    }


    Rect(const Vector2& min, const Vector2& max) noexcept :
        min_(min),
        max_(max)
    {
    }


    Rect(float left, float top, float right, float bottom) noexcept :
        min_(left, top),
        max_(right, bottom)
    {
    }


    explicit Rect(const Vector4& vector) noexcept :
        min_(vector.x_, vector.y_),
        max_(vector.z_, vector.w_)
    {
    }


    explicit Rect(const float* data) noexcept :
        min_(data[0], data[1]),
        max_(data[2], data[3])
    {
    }


    Rect(const Rect& rect) noexcept = default;


    Rect& operator =(const Rect& rhs) noexcept = default;


    bool operator ==(const Rect& rhs) const { return min_ == rhs.min_ && max_ == rhs.max_; }


    bool operator !=(const Rect& rhs) const { return min_ != rhs.min_ || max_ != rhs.max_; }


    Rect& operator +=(const Rect& rhs)
    {
        min_ += rhs.min_;
        max_ += rhs.max_;
        return *this;
    }


    Rect& operator -=(const Rect& rhs)
    {
        min_ -= rhs.min_;
        max_ -= rhs.max_;
        return *this;
    }


    Rect& operator /=(float value)
    {
        min_ /= value;
        max_ /= value;
        return *this;
    }


    Rect& operator *=(float value)
    {
        min_ *= value;
        max_ *= value;
        return *this;
    }


    Rect operator /(float value) const
    {
        return Rect(min_ / value, max_ / value);
    }


    Rect operator *(float value) const
    {
        return Rect(min_ * value, max_ * value);
    }


    Rect operator +(const Rect& rhs) const
    {
        return Rect(min_ + rhs.min_, max_ + rhs.max_);
    }


    Rect operator -(const Rect& rhs) const
    {
        return Rect(min_ - rhs.min_, max_ - rhs.max_);
    }


    void Define(const Rect& rect)
    {
        min_ = rect.min_;
        max_ = rect.max_;
    }


    void Define(const Vector2& min, const Vector2& max)
    {
        min_ = min;
        max_ = max;
    }


    void Define(const Vector2& point)
    {
        min_ = max_ = point;
    }


    void Merge(const Vector2& point)
    {
        if (point.x_ < min_.x_)
            min_.x_ = point.x_;
        if (point.x_ > max_.x_)
            max_.x_ = point.x_;
        if (point.y_ < min_.y_)
            min_.y_ = point.y_;
        if (point.y_ > max_.y_)
            max_.y_ = point.y_;
    }


    void Merge(const Rect& rect)
    {
        if (rect.min_.x_ < min_.x_)
            min_.x_ = rect.min_.x_;
        if (rect.min_.y_ < min_.y_)
            min_.y_ = rect.min_.y_;
        if (rect.max_.x_ > max_.x_)
            max_.x_ = rect.max_.x_;
        if (rect.max_.y_ > max_.y_)
            max_.y_ = rect.max_.y_;
    }


    void Clear()
    {
        min_ = Vector2(M_INFINITY, M_INFINITY);
        max_ = Vector2(-M_INFINITY, -M_INFINITY);
    }


    void Clip(const Rect& rect);


    bool Defined() const
    {
        return min_.x_ != M_INFINITY;
    }


    Vector2 Center() const { return (max_ + min_) * 0.5f; }


    Vector2 Size() const { return max_ - min_; }


    Vector2 HalfSize() const { return (max_ - min_) * 0.5f; }


    bool Equals(const Rect& rhs) const { return min_.Equals(rhs.min_) && max_.Equals(rhs.max_); }


    Intersection IsInside(const Vector2& point) const
    {
        if (point.x_ < min_.x_ || point.y_ < min_.y_ || point.x_ > max_.x_ || point.y_ > max_.y_)
            return OUTSIDE;
        else
            return INSIDE;
    }


    Intersection IsInside(const Rect& rect) const
    {
        if (rect.max_.x_ < min_.x_ || rect.min_.x_ > max_.x_ || rect.max_.y_ < min_.y_ || rect.min_.y_ > max_.y_)
            return OUTSIDE;
        else if (rect.min_.x_ < min_.x_ || rect.max_.x_ > max_.x_ || rect.min_.y_ < min_.y_ || rect.max_.y_ > max_.y_)
            return INTERSECTS;
        else
            return INSIDE;
    }


    const void* Data() const { return &min_.x_; }


    Vector4 ToVector4() const { return Vector4(min_.x_, min_.y_, max_.x_, max_.y_); }


    String ToString() const;


    Vector2 Min() const { return min_; }


    Vector2 Max() const { return max_; }


    float Left() const { return min_.x_; }


    float Top() const { return min_.y_; }


    float Right() const { return max_.x_; }


    float Bottom() const { return max_.y_; }


    Vector2 min_;

    Vector2 max_;


    static const Rect FULL;

    static const Rect POSITIVE;

    static const Rect ZERO;
};


class __attribute__((visibility("default"))) IntRect
{
public:

    IntRect() noexcept :
        left_(0),
        top_(0),
        right_(0),
        bottom_(0)
    {
    }


    IntRect(const IntVector2& min, const IntVector2& max) noexcept :
        left_(min.x_),
        top_(min.y_),
        right_(max.x_),
        bottom_(max.y_)
    {
    }


    IntRect(int left, int top, int right, int bottom) noexcept :
        left_(left),
        top_(top),
        right_(right),
        bottom_(bottom)
    {
    }


    explicit IntRect(const int* data) noexcept :
        left_(data[0]),
        top_(data[1]),
        right_(data[2]),
        bottom_(data[3])
    {
    }


    bool operator ==(const IntRect& rhs) const
    {
        return left_ == rhs.left_ && top_ == rhs.top_ && right_ == rhs.right_ && bottom_ == rhs.bottom_;
    }


    bool operator !=(const IntRect& rhs) const
    {
        return left_ != rhs.left_ || top_ != rhs.top_ || right_ != rhs.right_ || bottom_ != rhs.bottom_;
    }


    IntRect& operator +=(const IntRect& rhs)
    {
        left_ += rhs.left_;
        top_ += rhs.top_;
        right_ += rhs.right_;
        bottom_ += rhs.bottom_;
        return *this;
    }


    IntRect& operator -=(const IntRect& rhs)
    {
        left_ -= rhs.left_;
        top_ -= rhs.top_;
        right_ -= rhs.right_;
        bottom_ -= rhs.bottom_;
        return *this;
    }


    IntRect& operator /=(float value)
    {
        left_ = static_cast<int>(left_ / value);
        top_ = static_cast<int>(top_ / value);
        right_ = static_cast<int>(right_ / value);
        bottom_ = static_cast<int>(bottom_ / value);
        return *this;
    }


    IntRect& operator *=(float value)
    {
        left_ = static_cast<int>(left_ * value);
        top_ = static_cast<int>(top_ * value);
        right_ = static_cast<int>(right_ * value);
        bottom_ = static_cast<int>(bottom_ * value);
        return *this;
    }


    IntRect operator /(float value) const
    {
        return {
            static_cast<int>(left_ / value), static_cast<int>(top_ / value),
            static_cast<int>(right_ / value), static_cast<int>(bottom_ / value)
        };
    }


    IntRect operator *(float value) const
    {
        return {
            static_cast<int>(left_ * value), static_cast<int>(top_ * value),
            static_cast<int>(right_ * value), static_cast<int>(bottom_ * value)
        };
    }


    IntRect operator +(const IntRect& rhs) const
    {
        return {
            left_ + rhs.left_, top_ + rhs.top_,
            right_ + rhs.right_, bottom_ + rhs.bottom_
        };
    }


    IntRect operator -(const IntRect& rhs) const
    {
        return {
            left_ - rhs.left_, top_ - rhs.top_,
            right_ - rhs.right_, bottom_ - rhs.bottom_
        };
    }


    IntVector2 Size() const { return IntVector2(Width(), Height()); }


    int Width() const { return right_ - left_; }


    int Height() const { return bottom_ - top_; }


    Intersection IsInside(const IntVector2& point) const
    {
        if (point.x_ < left_ || point.y_ < top_ || point.x_ >= right_ || point.y_ >= bottom_)
            return OUTSIDE;
        else
            return INSIDE;
    }



    void Clip(const IntRect& rect);



    void Merge(const IntRect& rect);


    const int* Data() const { return &left_; }


    String ToString() const;


    IntVector2 Min() const { return {left_, top_}; }


    IntVector2 Max() const { return {right_, bottom_}; }


    int Left() const { return left_; }


    int Top() const { return top_; }


    int Right() const { return right_; }


    int Bottom() const { return bottom_; }


    int left_;

    int top_;

    int right_;

    int bottom_;


    static const IntRect ZERO;
};

}









#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop


namespace Urho3D
{


enum VariantType
{
    VAR_NONE = 0,
    VAR_INT,
    VAR_BOOL,
    VAR_FLOAT,
    VAR_VECTOR2,
    VAR_VECTOR3,
    VAR_VECTOR4,
    VAR_QUATERNION,
    VAR_COLOR,
    VAR_STRING,
    VAR_BUFFER,
    VAR_VOIDPTR,
    VAR_RESOURCEREF,
    VAR_RESOURCEREFLIST,
    VAR_VARIANTVECTOR,
    VAR_VARIANTMAP,
    VAR_INTRECT,
    VAR_INTVECTOR2,
    VAR_PTR,
    VAR_MATRIX3,
    VAR_MATRIX3X4,
    VAR_MATRIX4,
    VAR_DOUBLE,
    VAR_STRINGVECTOR,
    VAR_RECT,
    VAR_INTVECTOR3,
    VAR_INT64,

    VAR_CUSTOM_HEAP,
    VAR_CUSTOM_STACK,
    MAX_VAR_TYPES
};

class Variant;
class VectorBuffer;


using VariantVector = Vector<Variant>;


using StringVector = Vector<String>;


using VariantMap = HashMap<StringHash, Variant>;


struct __attribute__((visibility("default"))) ResourceRef
{

    ResourceRef() = default;


    explicit ResourceRef(StringHash type) :
        type_(type)
    {
    }


    ResourceRef(StringHash type, const String& name) :
        type_(type),
        name_(name)
    {
    }


    ResourceRef(const String& type, const String& name) :
        type_(type),
        name_(name)
    {
    }


    ResourceRef(const char* type, const char* name) :
        type_(type),
        name_(name)
    {
    }


    ResourceRef(const ResourceRef& rhs) = default;


    StringHash type_;

    String name_;


    bool operator ==(const ResourceRef& rhs) const { return type_ == rhs.type_ && name_ == rhs.name_; }


    bool operator !=(const ResourceRef& rhs) const { return type_ != rhs.type_ || name_ != rhs.name_; }
};


struct __attribute__((visibility("default"))) ResourceRefList
{

    ResourceRefList() = default;


    explicit ResourceRefList(StringHash type) :
        type_(type)
    {
    }


    ResourceRefList(StringHash type, const StringVector& names) :
        type_(type),
        names_(names)
    {
    }


    StringHash type_;

    StringVector names_;


    bool operator ==(const ResourceRefList& rhs) const { return type_ == rhs.type_ && names_ == rhs.names_; }


    bool operator !=(const ResourceRefList& rhs) const { return type_ != rhs.type_ || names_ != rhs.names_; }
};


class CustomVariantValue
{

    template <class T> friend class CustomVariantValueImpl;

private:

    explicit CustomVariantValue(const std::type_info& typeInfo) : typeInfo_(typeInfo) {}

public:

    CustomVariantValue() : typeInfo_(typeid(void)) { }

    virtual ~CustomVariantValue() = default;


    const std::type_info& GetTypeInfo() const { return typeInfo_; }

    template <class T> bool IsType() const { return GetTypeInfo() == typeid(T); }

    template <class T> T* GetValuePtr();

    template <class T> const T* GetValuePtr() const;


    virtual bool Assign(const CustomVariantValue& rhs) { return false; }

    virtual CustomVariantValue* Clone() const { return nullptr; }

    virtual void Clone(void* dest) const { }

    virtual unsigned GetSize() const { return sizeof(CustomVariantValue); }


    virtual bool Compare(const CustomVariantValue& rhs) const { (void)rhs; return false; }

    virtual bool IsZero() const { return false; }

    virtual String ToString() const { return String::EMPTY; }

private:

    const std::type_info& typeInfo_;
};


template <class T> struct CustomVariantValueTraits
{

    static bool Compare(const T& lhs, const T& rhs) { (void)lhs, rhs; return false; }

    static bool IsZero(const T& value) { (void)value; return false; }

    static String ToString(const T& value) { (void)value; return String::EMPTY; }
};


template <class T> class CustomVariantValueImpl final : public CustomVariantValue
{
public:

    using ClassName = CustomVariantValueImpl<T>;

    using Traits = CustomVariantValueTraits<T>;

    explicit CustomVariantValueImpl(const T& value) : CustomVariantValue(typeid(T)), value_(value) {}

    void SetValue(const T& value) { value_ = value; }

    T& GetValue() { return value_; }

    const T& GetValue() const { return value_; }


    bool Assign(const CustomVariantValue& rhs) override
    {
        if (const T* rhsValue = rhs.GetValuePtr<T>())
        {
            SetValue(*rhsValue);
            return true;
        }
        return false;
    }

    CustomVariantValue* Clone() const override { return new ClassName(value_); }

    void Clone(void* dest) const override { new (dest) ClassName(value_); }

    unsigned GetSize() const override { return sizeof(ClassName); }


    bool Compare(const CustomVariantValue& rhs) const override
    {
        const T* rhsValue = rhs.GetValuePtr<T>();
        return rhsValue && Traits::Compare(value_, *rhsValue);
    }

    bool IsZero() const override { return Traits::IsZero(value_);}

    String ToString() const override { return Traits::ToString(value_); }

private:

    T value_;
};


template <typename T> CustomVariantValueImpl<T> MakeCustomValue(const T& value) { return CustomVariantValueImpl<T>(value); }


static const unsigned VARIANT_VALUE_SIZE = sizeof(void*) * 4;


union VariantValue
{
    unsigned char storage_[VARIANT_VALUE_SIZE];
    int int_;
    bool bool_;
    float float_;
    double double_;
    long long int64_;
    void* voidPtr_;
    WeakPtr<RefCounted> weakPtr_;
    Vector2 vector2_;
    Vector3 vector3_;
    Vector4 vector4_;
    Rect rect_;
    IntVector2 intVector2_;
    IntVector3 intVector3_;
    IntRect intRect_;
    Matrix3* matrix3_;
    Matrix3x4* matrix3x4_;
    Matrix4* matrix4_;
    Quaternion quaternion_;
    Color color_;
    String string_;
    StringVector stringVector_;
    VariantVector variantVector_;
    VariantMap variantMap_;
    PODVector<unsigned char> buffer_;
    ResourceRef resourceRef_;
    ResourceRefList resourceRefList_;
    CustomVariantValue* customValueHeap_;
    CustomVariantValue customValueStack_;


    VariantValue() { }

    VariantValue(const VariantValue& value) = delete;

    ~VariantValue() { }
};

static_assert(sizeof(VariantValue) == VARIANT_VALUE_SIZE, "Unexpected size of VariantValue");


class __attribute__((visibility("default"))) Variant
{
public:

    Variant() = default;


    Variant(int value)
    {
        *this = value;
    }


    Variant(long long value)
    {
        *this = value;
    }


    Variant(unsigned value)
    {
        *this = (int)value;
    }


    Variant(unsigned long long value)
    {
        *this = (long long)value;
    }


    Variant(const StringHash& value)
    {
        *this = (int)value.Value();
    }


    Variant(bool value)
    {
        *this = value;
    }


    Variant(float value)
    {
        *this = value;
    }


    Variant(double value)
    {
        *this = value;
    }


    Variant(const Vector2& value)
    {
        *this = value;
    }


    Variant(const Vector3& value)
    {
        *this = value;
    }


    Variant(const Vector4& value)
    {
        *this = value;
    }


    Variant(const Quaternion& value)
    {
        *this = value;
    }


    Variant(const Color& value)
    {
        *this = value;
    }


    Variant(const String& value)
    {
        *this = value;
    }


    Variant(const char* value)
    {
        *this = value;
    }


    Variant(const PODVector<unsigned char>& value)
    {
        *this = value;
    }


    Variant(const VectorBuffer& value)
    {
        *this = value;
    }


    Variant(void* value)
    {
        *this = value;
    }


    Variant(const ResourceRef& value)
    {
        *this = value;
    }


    Variant(const ResourceRefList& value)
    {
        *this = value;
    }


    Variant(const VariantVector& value)
    {
        *this = value;
    }


    Variant(const VariantMap& value)
    {
        *this = value;
    }


    Variant(const StringVector& value)
    {
        *this = value;
    }


    Variant(const Rect& value)
    {
        *this = value;
    }


    Variant(const IntRect& value)
    {
        *this = value;
    }


    Variant(const IntVector2& value)
    {
        *this = value;
    }


    Variant(const IntVector3& value)
    {
        *this = value;
    }


    Variant(RefCounted* value)
    {
        *this = value;
    }


    Variant(const Matrix3& value)
    {
        *this = value;
    }


    Variant(const Matrix3x4& value)
    {
        *this = value;
    }


    Variant(const Matrix4& value)
    {
        *this = value;
    }


    template <class T>
    Variant(const CustomVariantValueImpl<T>& value)
    {
        *this = value;
    }


    Variant(const String& type, const String& value)
    {
        FromString(type, value);
    }


    Variant(VariantType type, const String& value)
    {
        FromString(type, value);
    }


    Variant(const char* type, const char* value)
    {
        FromString(type, value);
    }


    Variant(VariantType type, const char* value)
    {
        FromString(type, value);
    }


    Variant(const Variant& value)
    {
        *this = value;
    }


    ~Variant()
    {
        SetType(VAR_NONE);
    }


    void Clear()
    {
        SetType(VAR_NONE);
    }


    Variant& operator =(const Variant& rhs);


    Variant& operator =(int rhs)
    {
        SetType(VAR_INT);
        value_.int_ = rhs;
        return *this;
    }


    Variant& operator =(long long rhs)
    {
        SetType(VAR_INT64);
        value_.int64_ = rhs;
        return *this;
    }


    Variant& operator =(unsigned long long rhs)
    {
        SetType(VAR_INT64);
        value_.int64_ = static_cast<long long>(rhs);
        return *this;
    }


    Variant& operator =(unsigned rhs)
    {
        SetType(VAR_INT);
        value_.int_ = (int)rhs;
        return *this;
    }


    Variant& operator =(const StringHash& rhs)
    {
        SetType(VAR_INT);
        value_.int_ = (int)rhs.Value();
        return *this;
    }


    Variant& operator =(bool rhs)
    {
        SetType(VAR_BOOL);
        value_.bool_ = rhs;
        return *this;
    }


    Variant& operator =(float rhs)
    {
        SetType(VAR_FLOAT);
        value_.float_ = rhs;
        return *this;
    }


    Variant& operator =(double rhs)
    {
        SetType(VAR_DOUBLE);
        value_.double_ = rhs;
        return *this;
    }


    Variant& operator =(const Vector2& rhs)
    {
        SetType(VAR_VECTOR2);
        value_.vector2_ = rhs;
        return *this;
    }


    Variant& operator =(const Vector3& rhs)
    {
        SetType(VAR_VECTOR3);
        value_.vector3_ = rhs;
        return *this;
    }


    Variant& operator =(const Vector4& rhs)
    {
        SetType(VAR_VECTOR4);
        value_.vector4_ = rhs;
        return *this;
    }


    Variant& operator =(const Quaternion& rhs)
    {
        SetType(VAR_QUATERNION);
        value_.quaternion_ = rhs;
        return *this;
    }


    Variant& operator =(const Color& rhs)
    {
        SetType(VAR_COLOR);
        value_.color_ = rhs;
        return *this;
    }


    Variant& operator =(const String& rhs)
    {
        SetType(VAR_STRING);
        value_.string_ = rhs;
        return *this;
    }


    Variant& operator =(const char* rhs)
    {
        SetType(VAR_STRING);
        value_.string_ = rhs;
        return *this;
    }


    Variant& operator =(const PODVector<unsigned char>& rhs)
    {
        SetType(VAR_BUFFER);
        value_.buffer_ = rhs;
        return *this;
    }


    Variant& operator =(const VectorBuffer& rhs);


    Variant& operator =(void* rhs)
    {
        SetType(VAR_VOIDPTR);
        value_.voidPtr_ = rhs;
        return *this;
    }


    Variant& operator =(const ResourceRef& rhs)
    {
        SetType(VAR_RESOURCEREF);
        value_.resourceRef_ = rhs;
        return *this;
    }


    Variant& operator =(const ResourceRefList& rhs)
    {
        SetType(VAR_RESOURCEREFLIST);
        value_.resourceRefList_ = rhs;
        return *this;
    }


    Variant& operator =(const VariantVector& rhs)
    {
        SetType(VAR_VARIANTVECTOR);
        value_.variantVector_ = rhs;
        return *this;
    }


    Variant& operator =(const StringVector& rhs)
    {
        SetType(VAR_STRINGVECTOR);
        value_.stringVector_ = rhs;
        return *this;
    }


    Variant& operator =(const VariantMap& rhs)
    {
        SetType(VAR_VARIANTMAP);
        value_.variantMap_ = rhs;
        return *this;
    }


    Variant& operator =(const Rect& rhs)
    {
        SetType(VAR_RECT);
        value_.rect_ = rhs;
        return *this;
    }


    Variant& operator =(const IntRect& rhs)
    {
        SetType(VAR_INTRECT);
        value_.intRect_ = rhs;
        return *this;
    }


    Variant& operator =(const IntVector2& rhs)
    {
        SetType(VAR_INTVECTOR2);
        value_.intVector2_ = rhs;
        return *this;
    }


    Variant& operator =(const IntVector3& rhs)
    {
        SetType(VAR_INTVECTOR3);
        value_.intVector3_ = rhs;
        return *this;
    }


    Variant& operator =(RefCounted* rhs)
    {
        SetType(VAR_PTR);
        value_.weakPtr_ = rhs;
        return *this;
    }


    Variant& operator =(const Matrix3& rhs)
    {
        SetType(VAR_MATRIX3);
        *value_.matrix3_ = rhs;
        return *this;
    }


    Variant& operator =(const Matrix3x4& rhs)
    {
        SetType(VAR_MATRIX3X4);
        *value_.matrix3x4_ = rhs;
        return *this;
    }


    Variant& operator =(const Matrix4& rhs)
    {
        SetType(VAR_MATRIX4);
        *value_.matrix4_ = rhs;
        return *this;
    }


    template <class T>
    Variant& operator =(const CustomVariantValueImpl<T>& value)
    {
        SetCustomVariantValue(value);
        return *this;
    }


    bool operator ==(const Variant& rhs) const;


    bool operator ==(int rhs) const { return type_ == VAR_INT ? value_.int_ == rhs : false; }


    bool operator ==(unsigned rhs) const { return type_ == VAR_INT ? value_.int_ == static_cast<int>(rhs) : false; }


    bool operator ==(long long rhs) const { return type_ == VAR_INT64 ? value_.int64_ == rhs : false; }


    bool operator ==(unsigned long long rhs) const { return type_ == VAR_INT64 ? value_.int64_ == static_cast<long long>(rhs) : false; }


    bool operator ==(bool rhs) const { return type_ == VAR_BOOL ? value_.bool_ == rhs : false; }


    bool operator ==(float rhs) const { return type_ == VAR_FLOAT ? value_.float_ == rhs : false; }


    bool operator ==(double rhs) const { return type_ == VAR_DOUBLE ? value_.double_ == rhs : false; }


    bool operator ==(const Vector2& rhs) const
    {
        return type_ == VAR_VECTOR2 ? value_.vector2_ == rhs : false;
    }


    bool operator ==(const Vector3& rhs) const
    {
        return type_ == VAR_VECTOR3 ? value_.vector3_ == rhs : false;
    }


    bool operator ==(const Vector4& rhs) const
    {
        return type_ == VAR_VECTOR4 ? value_.vector4_ == rhs : false;
    }


    bool operator ==(const Quaternion& rhs) const
    {
        return type_ == VAR_QUATERNION ? value_.quaternion_ == rhs : false;
    }


    bool operator ==(const Color& rhs) const
    {
        return type_ == VAR_COLOR ? value_.color_ == rhs : false;
    }


    bool operator ==(const String& rhs) const
    {
        return type_ == VAR_STRING ? value_.string_ == rhs : false;
    }


    bool operator ==(const PODVector<unsigned char>& rhs) const;

    bool operator ==(const VectorBuffer& rhs) const;


    bool operator ==(void* rhs) const
    {
        if (type_ == VAR_VOIDPTR)
            return value_.voidPtr_ == rhs;
        else if (type_ == VAR_PTR)
            return value_.weakPtr_ == rhs;
        else
            return false;
    }


    bool operator ==(const ResourceRef& rhs) const
    {
        return type_ == VAR_RESOURCEREF ? value_.resourceRef_ == rhs : false;
    }


    bool operator ==(const ResourceRefList& rhs) const
    {
        return type_ == VAR_RESOURCEREFLIST ? value_.resourceRefList_ == rhs : false;
    }


    bool operator ==(const VariantVector& rhs) const
    {
        return type_ == VAR_VARIANTVECTOR ? value_.variantVector_ == rhs : false;
    }


    bool operator ==(const StringVector& rhs) const
    {
        return type_ == VAR_STRINGVECTOR ? value_.stringVector_ == rhs : false;
    }


    bool operator ==(const VariantMap& rhs) const
    {
        return type_ == VAR_VARIANTMAP ? value_.variantMap_ == rhs : false;
    }


    bool operator ==(const Rect& rhs) const
    {
        return type_ == VAR_RECT ? value_.rect_ == rhs : false;
    }


    bool operator ==(const IntRect& rhs) const
    {
        return type_ == VAR_INTRECT ? value_.intRect_ == rhs : false;
    }


    bool operator ==(const IntVector2& rhs) const
    {
        return type_ == VAR_INTVECTOR2 ? value_.intVector2_ == rhs : false;
    }


    bool operator ==(const IntVector3& rhs) const
    {
        return type_ == VAR_INTVECTOR3 ? value_.intVector3_ == rhs : false;
    }


    bool operator ==(const StringHash& rhs) const { return type_ == VAR_INT ? static_cast<unsigned>(value_.int_) == rhs.Value() : false; }


    bool operator ==(RefCounted* rhs) const
    {
        if (type_ == VAR_PTR)
            return value_.weakPtr_ == rhs;
        else if (type_ == VAR_VOIDPTR)
            return value_.voidPtr_ == rhs;
        else
            return false;
    }


    bool operator ==(const Matrix3& rhs) const
    {
        return type_ == VAR_MATRIX3 ? *value_.matrix3_ == rhs : false;
    }


    bool operator ==(const Matrix3x4& rhs) const
    {
        return type_ == VAR_MATRIX3X4 ? *value_.matrix3x4_ == rhs : false;
    }


    bool operator ==(const Matrix4& rhs) const
    {
        return type_ == VAR_MATRIX4 ? *value_.matrix4_ == rhs : false;
    }


    bool operator !=(const Variant& rhs) const { return !(*this == rhs); }


    bool operator !=(int rhs) const { return !(*this == rhs); }


    bool operator !=(unsigned rhs) const { return !(*this == rhs); }


    bool operator !=(long long rhs) const { return !(*this == rhs); }


    bool operator !=(unsigned long long rhs) const { return !(*this == rhs); }


    bool operator !=(bool rhs) const { return !(*this == rhs); }


    bool operator !=(float rhs) const { return !(*this == rhs); }


    bool operator !=(double rhs) const { return !(*this == rhs); }


    bool operator !=(const Vector2& rhs) const { return !(*this == rhs); }


    bool operator !=(const Vector3& rhs) const { return !(*this == rhs); }


    bool operator !=(const Vector4& rhs) const { return !(*this == rhs); }


    bool operator !=(const Quaternion& rhs) const { return !(*this == rhs); }


    bool operator !=(const String& rhs) const { return !(*this == rhs); }


    bool operator !=(const PODVector<unsigned char>& rhs) const { return !(*this == rhs); }


    bool operator !=(const VectorBuffer& rhs) const { return !(*this == rhs); }


    bool operator !=(void* rhs) const { return !(*this == rhs); }


    bool operator !=(const ResourceRef& rhs) const { return !(*this == rhs); }


    bool operator !=(const ResourceRefList& rhs) const { return !(*this == rhs); }


    bool operator !=(const VariantVector& rhs) const { return !(*this == rhs); }


    bool operator !=(const StringVector& rhs) const { return !(*this == rhs); }


    bool operator !=(const VariantMap& rhs) const { return !(*this == rhs); }


    bool operator !=(const Rect& rhs) const { return !(*this == rhs); }


    bool operator !=(const IntRect& rhs) const { return !(*this == rhs); }


    bool operator !=(const IntVector2& rhs) const { return !(*this == rhs); }


    bool operator !=(const IntVector3& rhs) const { return !(*this == rhs); }


    bool operator !=(const StringHash& rhs) const { return !(*this == rhs); }


    bool operator !=(RefCounted* rhs) const { return !(*this == rhs); }


    bool operator !=(const Matrix3& rhs) const { return !(*this == rhs); }


    bool operator !=(const Matrix3x4& rhs) const { return !(*this == rhs); }


    bool operator !=(const Matrix4& rhs) const { return !(*this == rhs); }


    void FromString(const String& type, const String& value);

    void FromString(const char* type, const char* value);

    void FromString(VariantType type, const String& value);

    void FromString(VariantType type, const char* value);

    void SetBuffer(const void* data, unsigned size);

    void SetCustomVariantValue(const CustomVariantValue& value);

    template <class T> void SetCustom(const T& value) { SetCustomVariantValue(MakeCustomValue<T>(value)); }


    int GetInt() const
    {
        if (type_ == VAR_INT)
            return value_.int_;
        else if (type_ == VAR_FLOAT)
            return static_cast<int>(value_.float_);
        else if (type_ == VAR_DOUBLE)
            return static_cast<int>(value_.double_);
        else
            return 0;
    }


    long long GetInt64() const
    {
        if (type_ == VAR_INT64)
            return value_.int64_;
        else if (type_ == VAR_INT)
            return value_.int_;
        else if (type_ == VAR_FLOAT)
            return static_cast<long long>(value_.float_);
        else if (type_ == VAR_DOUBLE)
            return static_cast<long long>(value_.double_);
        else
            return 0;
    }


    unsigned long long GetUInt64() const
    {
        if (type_ == VAR_INT64)
            return static_cast<unsigned long long>(value_.int64_);
        else if (type_ == VAR_INT)
            return static_cast<unsigned long long>(value_.int_);
        else if (type_ == VAR_FLOAT)
            return static_cast<unsigned long long>(value_.float_);
        else if (type_ == VAR_DOUBLE)
            return static_cast<unsigned long long>(value_.double_);
        else
            return 0;
    }


    unsigned GetUInt() const
    {
        if (type_ == VAR_INT)
            return static_cast<unsigned>(value_.int_);
        else if (type_ == VAR_FLOAT)
            return static_cast<unsigned>(value_.float_);
        else if (type_ == VAR_DOUBLE)
            return static_cast<unsigned>(value_.double_);
        else
            return 0;
    }


    StringHash GetStringHash() const { return StringHash(GetUInt()); }


    bool GetBool() const { return type_ == VAR_BOOL ? value_.bool_ : false; }


    float GetFloat() const
    {
        if (type_ == VAR_FLOAT)
            return value_.float_;
        else if (type_ == VAR_DOUBLE)
            return static_cast<float>(value_.double_);
        else if (type_ == VAR_INT)
            return static_cast<float>(value_.int_);
        else if (type_ == VAR_INT64)
            return static_cast<float>(value_.int64_);
        else
            return 0.0f;
    }


    double GetDouble() const
    {
        if (type_ == VAR_DOUBLE)
            return value_.double_;
        else if (type_ == VAR_FLOAT)
            return value_.float_;
        else if (type_ == VAR_INT)
            return static_cast<double>(value_.int_);
        else if (type_ == VAR_INT64)
            return static_cast<double>(value_.int64_);
        else
            return 0.0;
    }


    const Vector2& GetVector2() const { return type_ == VAR_VECTOR2 ? value_.vector2_ : Vector2::ZERO; }


    const Vector3& GetVector3() const { return type_ == VAR_VECTOR3 ? value_.vector3_ : Vector3::ZERO; }


    const Vector4& GetVector4() const { return type_ == VAR_VECTOR4 ? value_.vector4_ : Vector4::ZERO; }


    const Quaternion& GetQuaternion() const
    {
        return type_ == VAR_QUATERNION ? value_.quaternion_ : Quaternion::IDENTITY;
    }


    const Color& GetColor() const { return (type_ == VAR_COLOR || type_ == VAR_VECTOR4) ? value_.color_ : Color::WHITE; }


    const String& GetString() const { return type_ == VAR_STRING ? value_.string_ : String::EMPTY; }


    const PODVector<unsigned char>& GetBuffer() const
    {
        return type_ == VAR_BUFFER ? value_.buffer_ : emptyBuffer;
    }


    VectorBuffer GetVectorBuffer() const;


    void* GetVoidPtr() const
    {
        if (type_ == VAR_VOIDPTR)
            return value_.voidPtr_;
        else if (type_ == VAR_PTR)
            return value_.weakPtr_;
        else
            return nullptr;
    }


    const ResourceRef& GetResourceRef() const
    {
        return type_ == VAR_RESOURCEREF ? value_.resourceRef_ : emptyResourceRef;
    }


    const ResourceRefList& GetResourceRefList() const
    {
        return type_ == VAR_RESOURCEREFLIST ? value_.resourceRefList_ : emptyResourceRefList;
    }


    const VariantVector& GetVariantVector() const
    {
        return type_ == VAR_VARIANTVECTOR ? value_.variantVector_ : emptyVariantVector;
    }


    const StringVector& GetStringVector() const
    {
        return type_ == VAR_STRINGVECTOR ? value_.stringVector_ : emptyStringVector;
    }


    const VariantMap& GetVariantMap() const
    {
        return type_ == VAR_VARIANTMAP ? value_.variantMap_ : emptyVariantMap;
    }


    const Rect& GetRect() const { return type_ == VAR_RECT ? value_.rect_ : Rect::ZERO; }


    const IntRect& GetIntRect() const { return type_ == VAR_INTRECT ? value_.intRect_ : IntRect::ZERO; }


    const IntVector2& GetIntVector2() const
    {
        return type_ == VAR_INTVECTOR2 ? value_.intVector2_ : IntVector2::ZERO;
    }


    const IntVector3& GetIntVector3() const
    {
        return type_ == VAR_INTVECTOR3 ? value_.intVector3_ : IntVector3::ZERO;
    }


    RefCounted* GetPtr() const
    {
        return type_ == VAR_PTR ? value_.weakPtr_ : nullptr;
    }


    const Matrix3& GetMatrix3() const
    {
        return type_ == VAR_MATRIX3 ? *value_.matrix3_ : Matrix3::IDENTITY;
    }


    const Matrix3x4& GetMatrix3x4() const
    {
        return type_ == VAR_MATRIX3X4 ? *value_.matrix3x4_ : Matrix3x4::IDENTITY;
    }


    const Matrix4& GetMatrix4() const
    {
        return type_ == VAR_MATRIX4 ? *value_.matrix4_ : Matrix4::IDENTITY;
    }


    CustomVariantValue* GetCustomVariantValuePtr()
    {
        return const_cast<CustomVariantValue*>(const_cast<const Variant*>(this)->GetCustomVariantValuePtr());
    }


    const CustomVariantValue* GetCustomVariantValuePtr() const
    {
        if (type_ == VAR_CUSTOM_HEAP)
            return value_.customValueHeap_;
        else if (type_ == VAR_CUSTOM_STACK)
            return &value_.customValueStack_;
        else
            return nullptr;
    }


    template <class T> T GetCustom() const
    {
        if (const CustomVariantValue* value = GetCustomVariantValuePtr())
        {
            if (value->IsType<T>())
                return *value->GetValuePtr<T>();
        }
        return T();
    }


    template <class T> bool IsCustomType() const
    {
        if (const CustomVariantValue* custom = GetCustomVariantValuePtr())
            return custom->IsType<T>();
        else
            return false;
    }


    VariantType GetType() const { return type_; }


    String GetTypeName() const;

    String ToString() const;

    bool IsZero() const;


    bool IsEmpty() const { return type_ == VAR_NONE; }


    bool IsCustom() const { return type_ == VAR_CUSTOM_HEAP || type_ == VAR_CUSTOM_STACK; }


    template <class T> T Get() const;


    PODVector<unsigned char>* GetBufferPtr()
    {
        return type_ == VAR_BUFFER ? &value_.buffer_ : nullptr;
    }


    VariantVector* GetVariantVectorPtr() { return type_ == VAR_VARIANTVECTOR ? &value_.variantVector_ : nullptr; }


    StringVector* GetStringVectorPtr() { return type_ == VAR_STRINGVECTOR ? &value_.stringVector_ : nullptr; }


    VariantMap* GetVariantMapPtr() { return type_ == VAR_VARIANTMAP ? &value_.variantMap_ : nullptr; }


    template <class T> T* GetCustomPtr()
    {
        if (CustomVariantValue* value = GetCustomVariantValuePtr())
        {
            if (value->IsType<T>())
                return value->GetValuePtr<T>();
        }
        return nullptr;
    }


    static String GetTypeName(VariantType type);

    static VariantType GetTypeFromName(const String& typeName);

    static VariantType GetTypeFromName(const char* typeName);


    static const Variant EMPTY;

    static const PODVector<unsigned char> emptyBuffer;

    static const ResourceRef emptyResourceRef;

    static const ResourceRefList emptyResourceRefList;

    static const VariantMap emptyVariantMap;

    static const VariantVector emptyVariantVector;

    static const StringVector emptyStringVector;

private:

    void SetType(VariantType newType);


    VariantType type_ = VAR_NONE;

    VariantValue value_;
};


template <typename T> VariantType GetVariantType();


template <> inline VariantType GetVariantType<int>() { return VAR_INT; }

template <> inline VariantType GetVariantType<unsigned>() { return VAR_INT; }

template <> inline VariantType GetVariantType<long long>() { return VAR_INT64; }

template <> inline VariantType GetVariantType<unsigned long long>() { return VAR_INT64; }

template <> inline VariantType GetVariantType<bool>() { return VAR_BOOL; }

template <> inline VariantType GetVariantType<float>() { return VAR_FLOAT; }

template <> inline VariantType GetVariantType<double>() { return VAR_DOUBLE; }

template <> inline VariantType GetVariantType<Vector2>() { return VAR_VECTOR2; }

template <> inline VariantType GetVariantType<Vector3>() { return VAR_VECTOR3; }

template <> inline VariantType GetVariantType<Vector4>() { return VAR_VECTOR4; }

template <> inline VariantType GetVariantType<Quaternion>() { return VAR_QUATERNION; }

template <> inline VariantType GetVariantType<Color>() { return VAR_COLOR; }

template <> inline VariantType GetVariantType<String>() { return VAR_STRING; }

template <> inline VariantType GetVariantType<StringHash>() { return VAR_INT; }

template <> inline VariantType GetVariantType<PODVector<unsigned char> >() { return VAR_BUFFER; }

template <> inline VariantType GetVariantType<ResourceRef>() { return VAR_RESOURCEREF; }

template <> inline VariantType GetVariantType<ResourceRefList>() { return VAR_RESOURCEREFLIST; }

template <> inline VariantType GetVariantType<VariantVector>() { return VAR_VARIANTVECTOR; }

template <> inline VariantType GetVariantType<StringVector>() { return VAR_STRINGVECTOR; }

template <> inline VariantType GetVariantType<VariantMap>() { return VAR_VARIANTMAP; }

template <> inline VariantType GetVariantType<Rect>() { return VAR_RECT; }

template <> inline VariantType GetVariantType<IntRect>() { return VAR_INTRECT; }

template <> inline VariantType GetVariantType<IntVector2>() { return VAR_INTVECTOR2; }

template <> inline VariantType GetVariantType<IntVector3>() { return VAR_INTVECTOR3; }

template <> inline VariantType GetVariantType<Matrix3>() { return VAR_MATRIX3; }

template <> inline VariantType GetVariantType<Matrix3x4>() { return VAR_MATRIX3X4; }

template <> inline VariantType GetVariantType<Matrix4>() { return VAR_MATRIX4; }


template <> __attribute__((visibility("default"))) int Variant::Get<int>() const;

template <> __attribute__((visibility("default"))) unsigned Variant::Get<unsigned>() const;

template <> __attribute__((visibility("default"))) long long Variant::Get<long long>() const;

template <> __attribute__((visibility("default"))) unsigned long long Variant::Get<unsigned long long>() const;

template <> __attribute__((visibility("default"))) StringHash Variant::Get<StringHash>() const;

template <> __attribute__((visibility("default"))) bool Variant::Get<bool>() const;

template <> __attribute__((visibility("default"))) float Variant::Get<float>() const;

template <> __attribute__((visibility("default"))) double Variant::Get<double>() const;

template <> __attribute__((visibility("default"))) const Vector2& Variant::Get<const Vector2&>() const;

template <> __attribute__((visibility("default"))) const Vector3& Variant::Get<const Vector3&>() const;

template <> __attribute__((visibility("default"))) const Vector4& Variant::Get<const Vector4&>() const;

template <> __attribute__((visibility("default"))) const Quaternion& Variant::Get<const Quaternion&>() const;

template <> __attribute__((visibility("default"))) const Color& Variant::Get<const Color&>() const;

template <> __attribute__((visibility("default"))) const String& Variant::Get<const String&>() const;

template <> __attribute__((visibility("default"))) const Rect& Variant::Get<const Rect&>() const;

template <> __attribute__((visibility("default"))) const IntRect& Variant::Get<const IntRect&>() const;

template <> __attribute__((visibility("default"))) const IntVector2& Variant::Get<const IntVector2&>() const;

template <> __attribute__((visibility("default"))) const IntVector3& Variant::Get<const IntVector3&>() const;

template <> __attribute__((visibility("default"))) const PODVector<unsigned char>& Variant::Get<const PODVector<unsigned char>&>() const;

template <> __attribute__((visibility("default"))) void* Variant::Get<void*>() const;

template <> __attribute__((visibility("default"))) RefCounted* Variant::Get<RefCounted*>() const;

template <> __attribute__((visibility("default"))) const Matrix3& Variant::Get<const Matrix3&>() const;

template <> __attribute__((visibility("default"))) const Matrix3x4& Variant::Get<const Matrix3x4&>() const;

template <> __attribute__((visibility("default"))) const Matrix4& Variant::Get<const Matrix4&>() const;

template <> __attribute__((visibility("default"))) ResourceRef Variant::Get<ResourceRef>() const;

template <> __attribute__((visibility("default"))) ResourceRefList Variant::Get<ResourceRefList>() const;

template <> __attribute__((visibility("default"))) VariantVector Variant::Get<VariantVector>() const;

template <> __attribute__((visibility("default"))) StringVector Variant::Get<StringVector>() const;

template <> __attribute__((visibility("default"))) VariantMap Variant::Get<VariantMap>() const;

template <> __attribute__((visibility("default"))) Vector2 Variant::Get<Vector2>() const;

template <> __attribute__((visibility("default"))) Vector3 Variant::Get<Vector3>() const;

template <> __attribute__((visibility("default"))) Vector4 Variant::Get<Vector4>() const;

template <> __attribute__((visibility("default"))) Quaternion Variant::Get<Quaternion>() const;

template <> __attribute__((visibility("default"))) Color Variant::Get<Color>() const;

template <> __attribute__((visibility("default"))) String Variant::Get<String>() const;

template <> __attribute__((visibility("default"))) Rect Variant::Get<Rect>() const;

template <> __attribute__((visibility("default"))) IntRect Variant::Get<IntRect>() const;

template <> __attribute__((visibility("default"))) IntVector2 Variant::Get<IntVector2>() const;

template <> __attribute__((visibility("default"))) IntVector3 Variant::Get<IntVector3>() const;

template <> __attribute__((visibility("default"))) PODVector<unsigned char> Variant::Get<PODVector<unsigned char> >() const;

template <> __attribute__((visibility("default"))) Matrix3 Variant::Get<Matrix3>() const;

template <> __attribute__((visibility("default"))) Matrix3x4 Variant::Get<Matrix3x4>() const;

template <> __attribute__((visibility("default"))) Matrix4 Variant::Get<Matrix4>() const;


template <class T> T* CustomVariantValue::GetValuePtr()
{
    if (IsType<T>())
    {
        auto impl = static_cast<CustomVariantValueImpl<T>*>(this);
        return &impl->GetValue();
    }
    return nullptr;
}

template <class T> const T* CustomVariantValue::GetValuePtr() const
{
    if (IsType<T>())
    {
        auto impl = static_cast<const CustomVariantValueImpl<T>*>(this);
        return &impl->GetValue();
    }
    return nullptr;
}

}
























namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);


    explicit
    logic_error(const char*);



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);

    explicit domain_error(const char*);

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);

    explicit invalid_argument(const char*);

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);

    explicit length_error(const char*);

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);

    explicit out_of_range(const char*);

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);


    explicit
    runtime_error(const char*);



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);

    explicit range_error(const char*);

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);

    explicit overflow_error(const char*);

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);

    explicit underflow_error(const char*);

    virtual ~underflow_error() noexcept;
  };




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>())))
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)"),

        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };


}
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct allocator_arg_t { };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : is_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = &__a;
      return __ret;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(noexcept(swap(std::declval<_Head&>(),
        std::declval<_Head&>()))
        && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(noexcept(swap(std::declval<_Head&>(), std::declval<_Head&>())))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
 explicit
        constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<const _UElements&,
     _Elements>...>::value>::type>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _T1& __a1, const _T2& __a2)
      : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        explicit
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<std::size_t __i, typename _Tp>
    struct tuple_element;





  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;



  template<typename _Tp>
    struct tuple_size;



  template<typename _Tp>
    struct tuple_size<const _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }

  template<typename... _Elements>
    tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };

  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }


  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*) noexcept;


  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };





  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (!is_member_pointer<_Functor>::value
       && !is_function<_Functor>::value
       && !is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor&(_Args&&...)>::type
    >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }

  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
             (is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args&&...)>::type
           >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return std::mem_fn(__f)(std::forward<_Args>(__args)...);
    }


  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (is_pointer<_Functor>::value
       && is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor(_Args&&...)>::type
    >::type
    __invoke(_Functor __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }






  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp, typename = __void_t<>> struct __has_argument_type : false_type { }; template<typename _Tp> struct __has_argument_type<_Tp, __void_t<typename _Tp::argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_first_argument_type : false_type { }; template<typename _Tp> struct __has_first_argument_type<_Tp, __void_t<typename _Tp::first_argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_second_argument_type : false_type { }; template<typename _Tp> struct __has_second_argument_type<_Tp, __void_t<typename _Tp::second_argument_type>> : true_type { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return __invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }



  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __class_type = _Class;
      using __arg_types = _Pack<_ArgTypes...>;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) const ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) const ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) volatile ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) volatile ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) const volatile ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) const volatile ; using __lvalue = true_type; using __rvalue = true_type; using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) const &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) const &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) volatile &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) volatile &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) const volatile &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) const volatile &; using __lvalue = true_type; using __rvalue = false_type; using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) const &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) const &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) volatile &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) volatile &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes...) const volatile &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __pmf_type = _Res (_Class::*)(_ArgTypes... ...) const volatile &&; using __lvalue = false_type; using __rvalue = true_type; using __vararg = true_type; };




  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Class = typename _Traits::__class_type;
      using _ArgTypes = typename _Traits::__arg_types;
      using _Pmf = typename _Traits::__pmf_type;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;



      template<typename _Args>
 using _CheckArgs = typename conditional<_Varargs::value,
   __bool_constant<(_Args::value >= _ArgTypes::value)>,
   _AllConvertible<_Args, _ArgTypes>
 >::type;

    public:
      using result_type = typename _Traits::__result_type;

      explicit _Mem_fn_base(_Pmf __pmf) : _M_pmf(__pmf) { }


      template<typename... _Args, typename _Req
               = _Require<typename _Traits::__lvalue,
                          _CheckArgs<_Pack<_Args...>>>>
 result_type
 operator()(_Class& __object, _Args&&... __args) const
 { return (__object.*_M_pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req
               = _Require<typename _Traits::__rvalue,
                          _CheckArgs<_Pack<_Args...>>>>
 result_type
 operator()(_Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*_M_pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req
               = _Require<typename _Traits::__lvalue,
                          _CheckArgs<_Pack<_Args...>>>>
 result_type
 operator()(_Class* __object, _Args&&... __args) const
 { return (__object->*_M_pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args, typename _Req
               = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,
                          _CheckArgs<_Pack<_Args...>>>>
 result_type
 operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }


      template<typename _Tp, typename... _Args, typename _Req
               = _Require<is_base_of<_Class, _Tp>, typename _Traits::__lvalue,
                          _CheckArgs<_Pack<_Args...>>>>
 result_type
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      template<typename _Tp, typename... _Args>
 result_type
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*_M_pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 result_type
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*_M_pmf)(std::forward<_Args>(__args)...); }

      _Pmf _M_pmf;
    };


  template<typename _Res, typename _Class>
    class _Mem_fn_base<_Res _Class::*, false>
    {
      using __pm_type = _Res _Class::*;




      template<typename _Tp>
 auto
 _M_call(_Tp&& __object, const _Class *) const noexcept
 -> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())
 { return std::forward<_Tp>(__object).*_M_pm; }

      template<typename _Tp, typename _Up>
 auto
 _M_call(_Tp&& __object, _Up * const *) const noexcept
 -> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())
 { return (*std::forward<_Tp>(__object)).*_M_pm; }

      template<typename _Tp>
 auto
 _M_call(_Tp&& __ptr, const volatile void*) const
 noexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))
 -> decltype((*__ptr).*std::declval<__pm_type&>())
 { return (*__ptr).*_M_pm; }

      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

    public:
      explicit
      _Mem_fn_base(_Res _Class::*__pm) noexcept : _M_pm(__pm) { }


      _Res&
      operator()(_Class& __object) const noexcept
      { return __object.*_M_pm; }

      const _Res&
      operator()(const _Class& __object) const noexcept
      { return __object.*_M_pm; }

      _Res&&
      operator()(_Class&& __object) const noexcept
      { return std::forward<_Class>(__object).*_M_pm; }

      const _Res&&
      operator()(const _Class&& __object) const noexcept
      { return std::forward<const _Class>(__object).*_M_pm; }


      _Res&
      operator()(_Class* __object) const noexcept
      { return __object->*_M_pm; }

      const _Res&
      operator()(const _Class* __object) const noexcept
      { return __object->*_M_pm; }


      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>
 auto
 operator()(_Tp&& __unknown) const
 noexcept(noexcept(std::declval<_Mem_fn_base*>()->_M_call
     (std::forward<_Tp>(__unknown), &__unknown)))
 -> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))
 { return _M_call(std::forward<_Tp>(__unknown), &__unknown); }

      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>
 auto
 operator()(reference_wrapper<_Tp> __ref) const
 noexcept(noexcept(std::declval<_Mem_fn_base&>()(__ref.get())))
 -> decltype((*this)(__ref.get()))
 { return (*this)(__ref.get()); }

    private:
      _Res _Class::*_M_pm;
    };

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }







  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };






  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };







  namespace placeholders
  {





    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;

  }
  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };





  struct _No_tuple_element;






  template<std::size_t __i, typename _Tuple, bool _IsSafe>
    struct _Safe_tuple_element_impl
    : tuple_element<__i, _Tuple> { };






  template<std::size_t __i, typename _Tuple>
    struct _Safe_tuple_element_impl<__i, _Tuple, false>
    {
      typedef _No_tuple_element type;
    };





 template<std::size_t __i, typename _Tuple>
   struct _Safe_tuple_element
   : _Safe_tuple_element_impl<__i, _Tuple,
         (__i < tuple_size<_Tuple>::value)>
   { };
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;





  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      typedef _Tp& result_type;





      template<typename _CVRef, typename _Tuple>
 result_type
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };






  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(std::get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Signature> class result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 class result<_CVMu(_CVArg, _Tuple)>
 {



   typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
      - 1), _Tuple>::type
     __base_type;

 public:
   typedef typename add_rvalue_reference<__base_type>::type type;
 };

      template<typename _Tuple>
 typename result<_Mu(_Arg, _Tuple)>::type
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _Signature> struct result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 struct result<_CVMu(_CVArg, _Tuple)>
 {
   typedef typename add_lvalue_reference<_CVArg>::type type;
 };


      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor&>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename _Tp, typename... _Up>
        explicit
        _Bind_simple(_Tp&& __f, _Up&&... __args)
        : _M_bound(std::forward<_Tp>(__f), std::forward<_Up>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:
      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* const& __fp)
   { return __fp; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* const& __mp)
   { return __mp; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
 }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      template<typename _Func,
        typename _Res2 = typename result_of<_Func(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
      function(const function& __x);
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
      explicit operator bool() const noexcept
      { return !_M_empty(); }
      _Res operator()(_ArgTypes... __args) const;
      const type_info& target_type() const noexcept;
      template<typename _Functor> _Functor* target() noexcept;


      template<typename _Functor> const _Functor* target() const noexcept;


    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}



namespace Urho3D
{

class Context;
class EventHandler;


class __attribute__((visibility("default"))) TypeInfo
{
public:

    TypeInfo(const char* typeName, const TypeInfo* baseTypeInfo);

    ~TypeInfo();


    bool IsTypeOf(StringHash type) const;

    bool IsTypeOf(const TypeInfo* typeInfo) const;

    template<typename T> bool IsTypeOf() const { return IsTypeOf(T::GetTypeInfoStatic()); }


    StringHash GetType() const { return type_; }

    const String& GetTypeName() const { return typeName_;}

    const TypeInfo* GetBaseTypeInfo() const { return baseTypeInfo_; }

private:

    StringHash type_;

    String typeName_;

    const TypeInfo* baseTypeInfo_;
};
class __attribute__((visibility("default"))) Object : public RefCounted
{
    friend class Context;

public:

    explicit Object(Context* context);

    ~Object() override;


    virtual StringHash GetType() const = 0;

    virtual const String& GetTypeName() const = 0;

    virtual const TypeInfo* GetTypeInfo() const = 0;

    virtual void OnEvent(Object* sender, StringHash eventType, VariantMap& eventData);


    static const TypeInfo* GetTypeInfoStatic() { return nullptr; }

    bool IsInstanceOf(StringHash type) const;

    bool IsInstanceOf(const TypeInfo* typeInfo) const;

    template<typename T> bool IsInstanceOf() const { return IsInstanceOf(T::GetTypeInfoStatic()); }

    template<typename T> T* Cast() { return IsInstanceOf<T>() ? static_cast<T*>(this) : nullptr; }

    template<typename T> const T* Cast() const { return IsInstanceOf<T>() ? static_cast<const T*>(this) : nullptr; }


    void SubscribeToEvent(StringHash eventType, EventHandler* handler);

    void SubscribeToEvent(Object* sender, StringHash eventType, EventHandler* handler);

    void SubscribeToEvent(StringHash eventType, const std::function<void(StringHash, VariantMap&)>& function, void* userData = nullptr);

    void SubscribeToEvent(Object* sender, StringHash eventType, const std::function<void(StringHash, VariantMap&)>& function, void* userData = nullptr);

    void UnsubscribeFromEvent(StringHash eventType);

    void UnsubscribeFromEvent(Object* sender, StringHash eventType);

    void UnsubscribeFromEvents(Object* sender);

    void UnsubscribeFromAllEvents();

    void UnsubscribeFromAllEventsExcept(const PODVector<StringHash>& exceptions, bool onlyUserData);

    void SendEvent(StringHash eventType);

    void SendEvent(StringHash eventType, VariantMap& eventData);

    VariantMap& GetEventDataMap() const;

    template <typename... Args> void SendEvent(StringHash eventType, Args... args)
    {
        SendEvent(eventType, GetEventDataMap().Populate(args...));
    }


    Context* GetContext() const { return context_; }

    const Variant& GetGlobalVar(StringHash key) const;

    const VariantMap& GetGlobalVars() const;

    void SetGlobalVar(StringHash key, const Variant& value);

    Object* GetSubsystem(StringHash type) const;

    Object* GetEventSender() const;

    EventHandler* GetEventHandler() const;

    bool HasSubscribedToEvent(StringHash eventType) const;

    bool HasSubscribedToEvent(Object* sender, StringHash eventType) const;


    bool HasEventHandlers() const { return !eventHandlers_.Empty(); }


    template <class T> T* GetSubsystem() const;

    const String& GetCategory() const;


    void SetBlockEvents(bool block) { blockEvents_ = block; }

    bool GetBlockEvents() const { return blockEvents_; }

protected:

    Context* context_;

private:

    EventHandler* FindEventHandler(StringHash eventType, EventHandler** previous = nullptr) const;

    EventHandler* FindSpecificEventHandler(Object* sender, EventHandler** previous = nullptr) const;

    EventHandler* FindSpecificEventHandler(Object* sender, StringHash eventType, EventHandler** previous = nullptr) const;

    void RemoveEventSender(Object* sender);


    LinkedList<EventHandler> eventHandlers_;


    bool blockEvents_;
};

template <class T> T* Object::GetSubsystem() const { return static_cast<T*>(GetSubsystem(T::GetTypeStatic())); }


class __attribute__((visibility("default"))) ObjectFactory : public RefCounted
{
public:

    explicit ObjectFactory(Context* context) :
        context_(context)
    {
        ((context_) ? static_cast<void> (0) : __assert_fail ("context_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/Object.h", 206, __PRETTY_FUNCTION__));
    }


    virtual SharedPtr<Object> CreateObject() = 0;


    Context* GetContext() const { return context_; }


    const TypeInfo* GetTypeInfo() const { return typeInfo_; }


    StringHash GetType() const { return typeInfo_->GetType(); }


    const String& GetTypeName() const { return typeInfo_->GetTypeName(); }

protected:

    Context* context_;

    const TypeInfo* typeInfo_{};
};


template <class T> class ObjectFactoryImpl : public ObjectFactory
{
public:

    explicit ObjectFactoryImpl(Context* context) :
        ObjectFactory(context)
    {
        typeInfo_ = T::GetTypeInfoStatic();
    }


    SharedPtr<Object> CreateObject() override { return SharedPtr<Object>(new T(context_)); }
};


class __attribute__((visibility("default"))) EventHandler : public LinkedListNode
{
public:

    explicit EventHandler(Object* receiver, void* userData = nullptr) :
        receiver_(receiver),
        sender_(nullptr),
        userData_(userData)
    {
    }


    virtual ~EventHandler() = default;


    void SetSenderAndEventType(Object* sender, StringHash eventType)
    {
        sender_ = sender;
        eventType_ = eventType;
    }


    virtual void Invoke(VariantMap& eventData) = 0;

    virtual EventHandler* Clone() const = 0;


    Object* GetReceiver() const { return receiver_; }


    Object* GetSender() const { return sender_; }


    const StringHash& GetEventType() const { return eventType_; }


    void* GetUserData() const { return userData_; }

protected:

    Object* receiver_;

    Object* sender_;

    StringHash eventType_;

    void* userData_;
};


template <class T> class EventHandlerImpl : public EventHandler
{
public:
    using HandlerFunctionPtr = void (T::*)(StringHash, VariantMap&);


    EventHandlerImpl(T* receiver, HandlerFunctionPtr function, void* userData = nullptr) :
        EventHandler(receiver, userData),
        function_(function)
    {
        ((receiver_) ? static_cast<void> (0) : __assert_fail ("receiver_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/Object.h", 307, __PRETTY_FUNCTION__));
        ((function_) ? static_cast<void> (0) : __assert_fail ("function_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/Object.h", 308, __PRETTY_FUNCTION__));
    }


    void Invoke(VariantMap& eventData) override
    {
        auto* receiver = static_cast<T*>(receiver_);
        (receiver->*function_)(eventType_, eventData);
    }


    EventHandler* Clone() const override
    {
        return new EventHandlerImpl(static_cast<T*>(receiver_), function_, userData_);
    }

private:

    HandlerFunctionPtr function_;
};


class EventHandler11Impl : public EventHandler
{
public:

    explicit EventHandler11Impl(std::function<void(StringHash, VariantMap&)> function, void* userData = nullptr) :
        EventHandler(nullptr, userData),
        function_(std::move(function))
    {
        ((function_) ? static_cast<void> (0) : __assert_fail ("function_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Core/Object.h", 338, __PRETTY_FUNCTION__));
    }


    void Invoke(VariantMap& eventData) override
    {
        function_(eventType_, eventData);
    }


    EventHandler* Clone() const override
    {
        return new EventHandler11Impl(function_, userData_);
    }

private:

    std::function<void(StringHash, VariantMap&)> function_;
};


__attribute__((visibility("default"))) StringHashRegister& GetEventNameRegister();
}


class asIScriptContext;
class asIScriptEngine;
class asIScriptModule;
class asITypeInfo;

struct asSMessageInfo;

namespace Urho3D
{

extern const char* LOGIC_CATEGORY;

class ResourceRouter;
class Scene;
class ScriptFile;
class ScriptInstance;


enum DumpMode
{
    DOXYGEN = 0,
    C_HEADER,
    MAX_DUMP_MODES
};


class __attribute__((visibility("default"))) Script : public Object
{
    public: using ClassName = Script; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Script", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class ScriptFile;

public:

    explicit Script(Context* context);

    ~Script() override;


    bool Execute(const String& line);

    void SetDefaultScriptFile(ScriptFile* file);

    void SetDefaultScene(Scene* scene);

    void SetExecuteConsoleCommands(bool enable);

    void DumpAPI(DumpMode mode = DOXYGEN, const String& sourceTree = String::EMPTY);

    void MessageCallback(const asSMessageInfo* msg);

    void ExceptionCallback(asIScriptContext* context);

    static String GetCallStack(asIScriptContext* context);


    asIScriptEngine* GetScriptEngine() const { return scriptEngine_; }


    asIScriptContext* GetImmediateContext() const { return immediateContext_; }


    ScriptFile* GetDefaultScriptFile() const;

    Scene* GetDefaultScene() const;


    bool GetExecuteConsoleCommands() const { return executeConsoleCommands_; }


    void ClearObjectTypeCache();

    asITypeInfo* GetObjectType(const char* declaration);


    Mutex& GetModuleMutex() { return moduleMutex_; }


    const char** GetEnumValues(int asTypeID);


private:

    void IncScriptNestingLevel() { ++scriptNestingLevel_; }


    void DecScriptNestingLevel() { --scriptNestingLevel_; }


    unsigned GetScriptNestingLevel() { return scriptNestingLevel_; }


    asIScriptContext* GetScriptFileContext();

    void OutputAPIRow(DumpMode mode, const String& row, bool removeReference = false, const String& separator = ";");

    void HandleConsoleCommand(StringHash eventType, VariantMap& eventData);


    asIScriptEngine* scriptEngine_;

    asIScriptContext* immediateContext_;

    WeakPtr<ScriptFile> defaultScriptFile_;

    WeakPtr<Scene> defaultScene_;

    Vector<asIScriptContext*> scriptFileContexts_;

    HashMap<const char*, asITypeInfo*> objectTypes_;

    HashMap<int, PODVector<const char*>> enumValues_;

    SharedPtr<ResourceRouter> router_;

    Mutex moduleMutex_;

    unsigned scriptNestingLevel_;

    bool executeConsoleCommands_;
};


void __attribute__((visibility("default"))) RegisterScriptLibrary(Context* context);

}

class asILockableSharedBool;
class asIScriptFunction;
class asIScriptObject;

namespace Urho3D
{

class Object;


struct DelayedCall
{

    float period_;

    float delay_;

    bool repeat_;

    String declaration_;

    VariantVector parameters_;
};


class __attribute__((visibility("default"))) ScriptEventListener
{
public:

    virtual ~ScriptEventListener() = default;


    virtual void AddEventHandler(StringHash eventType, const String& handlerName) = 0;

    virtual void AddEventHandler(Object* sender, StringHash eventType, const String& handlerName) = 0;

    virtual void RemoveEventHandler(StringHash eventType) = 0;

    virtual void RemoveEventHandler(Object* sender, StringHash eventType) = 0;

    virtual void RemoveEventHandlers(Object* sender) = 0;

    virtual void RemoveEventHandlers() = 0;

    virtual void RemoveEventHandlersExcept(const PODVector<StringHash>& exceptions) = 0;

    virtual bool HasEventHandler(StringHash eventType) const = 0;

    virtual bool HasEventHandler(Object* sender, StringHash eventType) const = 0;
};

}





namespace Urho3D
{


template <class T> class HashSet : public HashBase
{
public:

    struct Node : public HashNodeBase
    {

        Node() = default;


        explicit Node(const T& key) :
            key_(key)
        {
        }


        T key_;


        Node* Next() const { return static_cast<Node*>(next_); }


        Node* Prev() const { return static_cast<Node*>(prev_); }


        Node* Down() const { return static_cast<Node*>(down_); }
    };


    struct Iterator : public HashIteratorBase
    {

        Iterator() = default;


        explicit Iterator(Node* ptr) :
            HashIteratorBase(ptr)
        {
        }


        Iterator& operator ++()
        {
            GotoNext();
            return *this;
        }


        Iterator operator ++(int)
        {
            Iterator it = *this;
            GotoNext();
            return it;
        }


        Iterator& operator --()
        {
            GotoPrev();
            return *this;
        }


        Iterator operator --(int)
        {
            Iterator it = *this;
            GotoPrev();
            return it;
        }


        const T* operator ->() const { return &(static_cast<Node*>(ptr_))->key_; }


        const T& operator *() const { return (static_cast<Node*>(ptr_))->key_; }
    };


    struct ConstIterator : public HashIteratorBase
    {

        ConstIterator() = default;


        explicit ConstIterator(Node* ptr) :
            HashIteratorBase(ptr)
        {
        }


        ConstIterator(const Iterator& rhs) :
            HashIteratorBase(rhs.ptr_)
        {
        }


        ConstIterator& operator =(const Iterator& rhs)
        {
            ptr_ = rhs.ptr_;
            return *this;
        }


        ConstIterator& operator ++()
        {
            GotoNext();
            return *this;
        }


        ConstIterator operator ++(int)
        {
            ConstIterator it = *this;
            GotoNext();
            return it;
        }


        ConstIterator& operator --()
        {
            GotoPrev();
            return *this;
        }


        ConstIterator operator --(int)
        {
            ConstIterator it = *this;
            GotoPrev();
            return it;
        }


        const T* operator ->() const { return &(static_cast<Node*>(ptr_))->key_; }


        const T& operator *() const { return (static_cast<Node*>(ptr_))->key_; }
    };


    HashSet()
    {

        allocator_ = AllocatorInitialize((unsigned)sizeof(Node));
        head_ = tail_ = ReserveNode();
    }


    HashSet(const HashSet<T>& set)
    {

        allocator_ = AllocatorInitialize((unsigned)sizeof(Node), set.Size() + 1);
        head_ = tail_ = ReserveNode();
        *this = set;
    }


    HashSet(HashSet<T> && set) noexcept
    {
        Swap(set);
    }


    HashSet(const std::initializer_list<T>& list) : HashSet()
    {
        for (auto it = list.begin(); it != list.end(); it++)
        {
            Insert(*it);
        }
    }


    ~HashSet()
    {
        if (allocator_)
        {
            Clear();
            FreeNode(Tail());
            AllocatorUninitialize(allocator_);
            delete[] ptrs_;
        }
    }


    HashSet& operator =(const HashSet<T>& rhs)
    {

        if (&rhs != this)
        {
            Clear();
            Insert(rhs);
        }
        return *this;
    }


    HashSet& operator =(HashSet<T> && rhs) noexcept
    {
        ((&rhs != this) ? static_cast<void> (0) : __assert_fail ("&rhs != this", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Scene/../Container/HashSet.h", 233, __PRETTY_FUNCTION__));
        Swap(rhs);
        return *this;
    }


    HashSet& operator +=(const T& rhs)
    {
        Insert(rhs);
        return *this;
    }


    HashSet& operator +=(const HashSet<T>& rhs)
    {
        Insert(rhs);
        return *this;
    }


    bool operator ==(const HashSet<T>& rhs) const
    {
        if (rhs.Size() != Size())
            return false;

        ConstIterator it = Begin();
        while (it != End())
        {
            if (!rhs.Contains(*it))
                return false;
            ++it;
        }

        return true;
    }


    bool operator !=(const HashSet<T>& rhs) const
    {
        if (rhs.Size() != Size())
            return true;

        ConstIterator it = Begin();
        while (it != End())
        {
            if (!rhs.Contains(*it))
                return true;
            ++it;
        }

        return false;
    }


    Iterator Insert(const T& key)
    {

        if (!ptrs_)
        {
            AllocateBuckets(Size(), MIN_BUCKETS);
            Rehash();
        }

        unsigned hashKey = Hash(key);

        Node* existing = FindNode(key, hashKey);
        if (existing)
            return Iterator(existing);

        Node* newNode = InsertNode(Tail(), key);
        newNode->down_ = Ptrs()[hashKey];
        Ptrs()[hashKey] = newNode;


        if (Size() > NumBuckets() * MAX_LOAD_FACTOR)
        {
            AllocateBuckets(Size(), NumBuckets() << 1);
            Rehash();
        }

        return Iterator(newNode);
    }


    Iterator Insert(const T& key, bool& exists)
    {
        unsigned oldSize = Size();
        Iterator ret = Insert(key);
        exists = (Size() == oldSize);
        return ret;
    }


    void Insert(const HashSet<T>& set)
    {
        ConstIterator it = set.Begin();
        ConstIterator end = set.End();
        while (it != end)
            Insert(*it++);
    }


    Iterator Insert(const ConstIterator& it)
    {
        return Iterator(InsertNode(*it));
    }


    bool Erase(const T& key)
    {
        if (!ptrs_)
            return false;

        unsigned hashKey = Hash(key);

        Node* previous;
        Node* node = FindNode(key, hashKey, previous);
        if (!node)
            return false;

        if (previous)
            previous->down_ = node->down_;
        else
            Ptrs()[hashKey] = node->down_;

        EraseNode(node);
        return true;
    }


    Iterator Erase(const Iterator& it)
    {
        if (!ptrs_ || !it.ptr_)
            return End();

        auto* node = static_cast<Node*>(it.ptr_);
        Node* next = node->Next();

        unsigned hashKey = Hash(node->key_);

        Node* previous = 0;
        auto* current = static_cast<Node*>(Ptrs()[hashKey]);
        while (current && current != node)
        {
            previous = current;
            current = current->Down();
        }

        ((current == node) ? static_cast<void> (0) : __assert_fail ("current == node", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Scene/../Container/HashSet.h", 381, __PRETTY_FUNCTION__));

        if (previous)
            previous->down_ = node->down_;
        else
            Ptrs()[hashKey] = node->down_;

        EraseNode(node);
        return Iterator(next);
    }


    void Clear()
    {

        ResetPtrs();

        if (Size())
        {
            for (Iterator i = Begin(); i != End();)
            {
                FreeNode(static_cast<Node*>(i++.ptr_));
                i.ptr_->prev_ = 0;
            }

            head_ = tail_;
            SetSize(0);
        }
    }


    void Sort()
    {
        unsigned numKeys = Size();
        if (!numKeys)
            return;

        auto** ptrs = new Node* [numKeys];
        Node* ptr = Head();

        for (unsigned i = 0; i < numKeys; ++i)
        {
            ptrs[i] = ptr;
            ptr = ptr->Next();
        }

        Urho3D::Sort(RandomAccessIterator<Node*>(ptrs), RandomAccessIterator<Node*>(ptrs + numKeys), CompareNodes);

        head_ = ptrs[0];
        ptrs[0]->prev_ = 0;
        for (unsigned i = 1; i < numKeys; ++i)
        {
            ptrs[i - 1]->next_ = ptrs[i];
            ptrs[i]->prev_ = ptrs[i - 1];
        }
        ptrs[numKeys - 1]->next_ = tail_;
        tail_->prev_ = ptrs[numKeys - 1];

        delete[] ptrs;
    }


    bool Rehash(unsigned numBuckets)
    {
        if (numBuckets == NumBuckets())
            return true;
        if (!numBuckets || numBuckets < Size() / MAX_LOAD_FACTOR)
            return false;


        unsigned check = numBuckets;
        while (!(check & 1u))
            check >>= 1;
        if (check != 1)
            return false;

        AllocateBuckets(Size(), numBuckets);
        Rehash();
        return true;
    }


    Iterator Find(const T& key)
    {
        if (!ptrs_)
            return End();

        unsigned hashKey = Hash(key);
        Node* node = FindNode(key, hashKey);
        if (node)
            return Iterator(node);
        else
            return End();
    }


    ConstIterator Find(const T& key) const
    {
        if (!ptrs_)
            return End();

        unsigned hashKey = Hash(key);
        Node* node = FindNode(key, hashKey);
        if (node)
            return ConstIterator(node);
        else
            return End();
    }


    bool Contains(const T& key) const
    {
        if (!ptrs_)
            return false;

        unsigned hashKey = Hash(key);
        return FindNode(key, hashKey) != 0;
    }


    Iterator Begin() { return Iterator(Head()); }


    ConstIterator Begin() const { return ConstIterator(Head()); }


    Iterator End() { return Iterator(Tail()); }


    ConstIterator End() const { return ConstIterator(Tail()); }


    const T& Front() const { return *Begin(); }


    const T& Back() const { return *(--End()); }

private:

    Node* Head() const { return static_cast<Node*>(head_); }


    Node* Tail() const { return static_cast<Node*>(tail_); }


    Node* FindNode(const T& key, unsigned hashKey) const
    {
        auto* node = static_cast<Node*>(Ptrs()[hashKey]);
        while (node)
        {
            if (node->key_ == key)
                return node;
            node = node->Down();
        }

        return 0;
    }


    Node* FindNode(const T& key, unsigned hashKey, Node*& previous) const
    {
        previous = 0;

        auto* node = static_cast<Node*>(Ptrs()[hashKey]);
        while (node)
        {
            if (node->key_ == key)
                return node;
            previous = node;
            node = node->Down();
        }

        return 0;
    }


    Node* InsertNode(Node* dest, const T& key)
    {
        if (!dest)
            return 0;

        Node* newNode = ReserveNode(key);
        Node* prev = dest->Prev();
        newNode->next_ = dest;
        newNode->prev_ = prev;
        if (prev)
            prev->next_ = newNode;
        dest->prev_ = newNode;


        if (dest == Head())
            head_ = newNode;

        SetSize(Size() + 1);

        return newNode;
    }


    Node* EraseNode(Node* node)
    {

        if (!node || node == tail_)
            return Tail();

        Node* prev = node->Prev();
        Node* next = node->Next();
        if (prev)
            prev->next_ = next;
        next->prev_ = prev;


        if (node == Head())
            head_ = next;

        FreeNode(node);
        SetSize(Size() - 1);

        return next;
    }


    Node* ReserveNode()
    {
        auto* newNode = static_cast<Node*>(AllocatorReserve(allocator_));
        new(newNode) Node();
        return newNode;
    }


    Node* ReserveNode(const T& key)
    {
        auto* newNode = static_cast<Node*>(AllocatorReserve(allocator_));
        new(newNode) Node(key);
        return newNode;
    }


    void FreeNode(Node* node)
    {
        (node)->~Node();
        AllocatorFree(allocator_, node);
    }


    void Rehash()
    {
        for (Iterator it = Begin(); it != End(); ++it)
        {
            auto* node = static_cast<Node*>(it.ptr_);
            unsigned hashKey = Hash(*it);
            node->down_ = Ptrs()[hashKey];
            Ptrs()[hashKey] = node;
        }
    }


    static bool CompareNodes(Node*& lhs, Node*& rhs) { return lhs->key_ < rhs->key_; }


    unsigned Hash(const T& key) const { return MakeHash(key) & (NumBuckets() - 1); }
};

template <class T> typename Urho3D::HashSet<T>::ConstIterator begin(const Urho3D::HashSet<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::HashSet<T>::ConstIterator end(const Urho3D::HashSet<T>& v) { return v.End(); }

template <class T> typename Urho3D::HashSet<T>::Iterator begin(Urho3D::HashSet<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::HashSet<T>::Iterator end(Urho3D::HashSet<T>& v) { return v.End(); }

}

namespace Urho3D
{


template <typename T> struct IsFlagSet
{
    constexpr static bool value_ = false;
};
template <class E, class = typename std::enable_if<IsFlagSet<E>::value_>::type>
class FlagSet
{
public:

    using Enum = E;

    using Integer = typename std::underlying_type<Enum>::type;

public:

    explicit FlagSet(Integer value)
        : value_(value)
    {
    }

    FlagSet() = default;


    FlagSet(const FlagSet& another) = default;


    FlagSet(const Enum value)
        : value_(static_cast<Integer>(value))
    {
    }


    FlagSet& operator = (const FlagSet& rhs) = default;


    FlagSet& operator &= (const Enum value)
    {
        value_ &= static_cast<Integer>(value);
        return *this;
    }


    FlagSet& operator &= (const FlagSet value)
    {
        value_ &= value.value_;
        return *this;
    }


    FlagSet& operator |= (const Enum value)
    {
        value_ |= static_cast<Integer>(value);
        return *this;
    }


    FlagSet& operator |= (const FlagSet value)
    {
        value_ |= value.value_;
        return *this;
    }


    FlagSet& operator ^= (const Enum value)
    {
        value_ ^= static_cast<Integer>(value);
        return *this;
    }


    FlagSet& operator ^= (const FlagSet value)
    {
        value_ ^= value.value_;
        return *this;
    }


    FlagSet operator & (const Enum value) const
    {
        return FlagSet(value_ & static_cast<Integer>(value));
    }


    FlagSet operator & (const FlagSet value) const
    {
        return FlagSet(value_ & value.value_);
    }


    FlagSet operator | (const Enum value) const
    {
        return FlagSet(value_ | static_cast<Integer>(value));
    }


    FlagSet operator | (const FlagSet value) const
    {
        return FlagSet(value_ | value.value_);
    }


    FlagSet operator ^ (const Enum value) const
    {
        return FlagSet(value_ ^ static_cast<Integer>(value));
    }


    FlagSet operator ^ (const FlagSet value) const
    {
        return FlagSet(value_ ^ value.value_);
    }


    FlagSet operator ~ () const
    {
        return FlagSet(~value_);
    }


    bool operator ! () const
    {
        return !value_;
    }


    operator bool () const
    {
        return value_ != 0;
    }


    operator Integer() const
    {
        return value_;
    }


    explicit operator Enum() const
    {
        return static_cast<Enum>(value_);
    }


    explicit operator double() const
    {
        return static_cast<double>(value_);
    }


    bool operator ==(Enum rhs) const
    {
        return value_ == static_cast<Integer>(rhs);
    }


    bool operator ==(FlagSet rhs) const
    {
        return value_ == rhs.value_;
    }


    bool operator !=(Enum rhs) const
    {
        return !(*this == rhs);
    }


    bool operator !=(FlagSet rhs) const
    {
        return !(*this == rhs);
    }


    inline bool Test(const Enum value) const
    {
        return Test(static_cast<Integer>(value));
    }


    inline bool Test(const Integer flags) const
    {
        return (value_ & flags) == flags && (flags != 0 || value_ == flags);
    }


    Integer AsInteger() const { return value_; }


    Integer& AsInteger() { return value_; }

protected:

    Integer value_ = 0;
};

}


template <class Enum, class = typename std::enable_if<Urho3D::IsFlagSet<Enum>::value_>::type>
Urho3D::FlagSet<Enum> operator |(const Enum lhs, const Enum rhs)
{
    return Urho3D::FlagSet<Enum>(lhs) | rhs;
}


template <class Enum, class = typename std::enable_if<Urho3D::IsFlagSet<Enum>::value_>::type>
Urho3D::FlagSet<Enum> operator & (const Enum lhs, const Enum rhs)
{
    return Urho3D::FlagSet<Enum>(lhs) & rhs;
}


template <class Enum, class = typename std::enable_if<Urho3D::IsFlagSet<Enum>::value_>::type>
Urho3D::FlagSet<Enum> operator ^ (const Enum lhs, const Enum rhs)
{
    return Urho3D::FlagSet<Enum>(lhs) ^ rhs;
}


template <class Enum, class = typename std::enable_if<Urho3D::IsFlagSet<Enum>::value_>::type>
Urho3D::FlagSet<Enum> operator ~ (const Enum rhs)
{
    return ~Urho3D::FlagSet<Enum>(rhs);
}




namespace Urho3D
{

enum AttributeMode
{

    AM_EDIT = 0x0,

    AM_FILE = 0x1,

    AM_NET = 0x2,

    AM_DEFAULT = 0x3,

    AM_LATESTDATA = 0x4,

    AM_NOEDIT = 0x8,

    AM_NODEID = 0x10,

    AM_COMPONENTID = 0x20,

    AM_NODEIDVECTOR = 0x40,

    AM_FILEREADONLY = 0x81,
};
template<> struct IsFlagSet<AttributeMode> { constexpr static bool value_ = true; }; using AttributeModeFlags = FlagSet<AttributeMode>;

class Serializable;


class __attribute__((visibility("default"))) AttributeAccessor : public RefCounted
{
public:

    virtual void Get(const Serializable* ptr, Variant& dest) const = 0;

    virtual void Set(Serializable* ptr, const Variant& src) = 0;
};


struct AttributeInfo
{

    AttributeInfo() = default;


    AttributeInfo(VariantType type, const char* name, const SharedPtr<AttributeAccessor>& accessor, const char** enumNames, const Variant& defaultValue, AttributeModeFlags mode) :
        type_(type),
        name_(name),
        enumNames_(enumNames),
        accessor_(accessor),
        defaultValue_(defaultValue),
        mode_(mode)
    {
    }


    const Variant& GetMetadata(const StringHash& key) const
    {
        auto elem = metadata_.Find(key);
        return elem != metadata_.End() ? elem->second_ : Variant::EMPTY;
    }


    template <class T> T GetMetadata(const StringHash& key) const
    {
        return GetMetadata(key).Get<T>();
    }


    VariantType type_ = VAR_NONE;

    String name_;

    const char** enumNames_ = nullptr;

    SharedPtr<AttributeAccessor> accessor_;

    Variant defaultValue_;

    AttributeModeFlags mode_ = AM_DEFAULT;

    VariantMap metadata_;

    void* ptr_ = nullptr;
};


struct AttributeHandle
{
    friend class Context;
private:

    AttributeHandle() = default;

    AttributeHandle(const AttributeHandle& another) = default;

    AttributeInfo* attributeInfo_ = nullptr;

    AttributeInfo* networkAttributeInfo_ = nullptr;
public:

    AttributeHandle& SetMetadata(StringHash key, const Variant& value)
    {
        if (attributeInfo_)
            attributeInfo_->metadata_[key] = value;
        if (networkAttributeInfo_)
            networkAttributeInfo_->metadata_[key] = value;
        return *this;
    }
};

}





namespace Urho3D
{

class Connection;
class Deserializer;
class Serializer;
class XMLElement;
class JSONValue;

struct DirtyBits;
struct NetworkState;
struct ReplicationState;


class __attribute__((visibility("default"))) Serializable : public Object
{
    public: using ClassName = Serializable; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Serializable", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Serializable(Context* context);

    ~Serializable() override;


    virtual void OnSetAttribute(const AttributeInfo& attr, const Variant& src);

    virtual void OnGetAttribute(const AttributeInfo& attr, Variant& dest) const;

    virtual const Vector<AttributeInfo>* GetAttributes() const;

    virtual const Vector<AttributeInfo>* GetNetworkAttributes() const;

    virtual bool Load(Deserializer& source);

    virtual bool Save(Serializer& dest) const;

    virtual bool LoadXML(const XMLElement& source);

    virtual bool SaveXML(XMLElement& dest) const;

    virtual bool LoadJSON(const JSONValue& source);

    virtual bool SaveJSON(JSONValue& dest) const;


    virtual void ApplyAttributes() { }


    virtual bool SaveDefaultAttributes() const { return false; }


    virtual void MarkNetworkUpdate() { }


    virtual void SetBasePath(const String& basePath) {}

    virtual const String& GetBasePath() const { return String::EMPTY; }


    bool SetAttribute(unsigned index, const Variant& value);

    bool SetAttribute(const String& name, const Variant& value);

    void SetInstanceDefault(bool enable) { setInstanceDefault_ = enable; }

    void ResetToDefault();

    void RemoveInstanceDefault();

    void SetTemporary(bool enable);

    void SetInterceptNetworkUpdate(const String& attributeName, bool enable);

    void AllocateNetworkState();

    void WriteInitialDeltaUpdate(Serializer& dest, unsigned char timeStamp);

    void WriteDeltaUpdate(Serializer& dest, const DirtyBits& attributeBits, unsigned char timeStamp);

    void WriteLatestDataUpdate(Serializer& dest, unsigned char timeStamp);

    bool ReadDeltaUpdate(Deserializer& source);

    bool ReadLatestDataUpdate(Deserializer& source);


    Variant GetAttribute(unsigned index) const;

    Variant GetAttribute(const String& name) const;

    Variant GetAttributeDefault(unsigned index) const;

    Variant GetAttributeDefault(const String& name) const;

    unsigned GetNumAttributes() const;

    unsigned GetNumNetworkAttributes() const;


    bool IsTemporary() const { return temporary_; }


    bool GetInterceptNetworkUpdate(const String& attributeName) const;


    NetworkState* GetNetworkState() const { return networkState_.Get(); }

protected:

    UniquePtr<NetworkState> networkState_;

private:

    void SetInstanceDefault(const String& name, const Variant& defaultValue);

    Variant GetInstanceDefault(const String& name) const;


    UniquePtr<VariantMap> instanceDefaultValues_;

    bool setInstanceDefault_;

    bool temporary_;
};


template <class TClassType, class TGetFunction, class TSetFunction>
class VariantAttributeAccessorImpl : public AttributeAccessor
{
public:

    VariantAttributeAccessorImpl(TGetFunction getFunction, TSetFunction setFunction) : getFunction_(getFunction), setFunction_(setFunction) { }


    void Get(const Serializable* ptr, Variant& value) const override
    {
        ((ptr) ? static_cast<void> (0) : __assert_fail ("ptr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Scene/../Scene/Serializable.h", 167, __PRETTY_FUNCTION__));
        const auto classPtr = static_cast<const TClassType*>(ptr);
        getFunction_(*classPtr, value);
    }


    void Set(Serializable* ptr, const Variant& value) override
    {
        ((ptr) ? static_cast<void> (0) : __assert_fail ("ptr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../Scene/../Scene/Serializable.h", 175, __PRETTY_FUNCTION__));
        auto classPtr = static_cast<TClassType*>(ptr);
        setFunction_(*classPtr, value);
    }

private:

    TGetFunction getFunction_;

    TSetFunction setFunction_;
};





template <class TClassType, class TGetFunction, class TSetFunction>
SharedPtr<AttributeAccessor> MakeVariantAttributeAccessor(TGetFunction getFunction, TSetFunction setFunction)
{
    return SharedPtr<AttributeAccessor>(new VariantAttributeAccessorImpl<TClassType, TGetFunction, TSetFunction>(getFunction, setFunction));
}
namespace AttributeMetadata
{

    static const StringHash P_VECTOR_STRUCT_ELEMENTS("VectorStructElements");
}
}

namespace Urho3D
{


enum WrapMode
{

    WM_LOOP = 0,

    WM_ONCE,

    WM_CLAMP,
};

}

namespace Urho3D
{

class Object;
class ValueAnimation;
class Variant;
struct VAnimEventFrame;


class __attribute__((visibility("default"))) ValueAnimationInfo : public RefCounted
{
public:

    ValueAnimationInfo(ValueAnimation* animation, WrapMode wrapMode, float speed);

    ValueAnimationInfo(Object* target, ValueAnimation* animation, WrapMode wrapMode, float speed);

    ValueAnimationInfo(const ValueAnimationInfo& other);

    ~ValueAnimationInfo() override;


    bool Update(float timeStep);

    bool SetTime(float time);


    void SetWrapMode(WrapMode wrapMode) { wrapMode_ = wrapMode; }


    void SetSpeed(float speed) { speed_ = speed; }


    Object* GetTarget() const;


    ValueAnimation* GetAnimation() const { return animation_; }


    WrapMode GetWrapMode() const { return wrapMode_; }


    float GetTime() const { return currentTime_; }


    float GetSpeed() const { return speed_; }

protected:

    virtual void ApplyValue(const Variant& newValue);

    float CalculateScaledTime(float currentTime, bool& finished) const;

    void GetEventFrames(float beginTime, float endTime, PODVector<const VAnimEventFrame*>& eventFrames);


    WeakPtr<Object> target_;

    SharedPtr<ValueAnimation> animation_;

    WrapMode wrapMode_;

    float speed_;

    float currentTime_;

    float lastScaledTime_;
};

}


namespace Urho3D
{

class Animatable;
class ValueAnimation;
class AttributeAnimationInfo;
class ObjectAnimation;


class AttributeAnimationInfo : public ValueAnimationInfo
{
public:

    AttributeAnimationInfo
        (Animatable* animatable, const AttributeInfo& attributeInfo, ValueAnimation* attributeAnimation, WrapMode wrapMode,
            float speed);

    AttributeAnimationInfo(const AttributeAnimationInfo& other);

    ~AttributeAnimationInfo() override;


    const AttributeInfo& GetAttributeInfo() const { return attributeInfo_; }

protected:

    void ApplyValue(const Variant& newValue) override;

private:

    const AttributeInfo& attributeInfo_;
};


class __attribute__((visibility("default"))) Animatable : public Serializable
{
    public: using ClassName = Animatable; using BaseClassName = Serializable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Animatable", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Animatable(Context* context);

    ~Animatable() override;

    static void RegisterObject(Context* context);


    bool LoadXML(const XMLElement& source) override;

    bool SaveXML(XMLElement& dest) const override;

    bool LoadJSON(const JSONValue& source) override;

    bool SaveJSON(JSONValue& dest) const override;


    void SetAnimationEnabled(bool enable);

    void SetAnimationTime(float time);


    void SetObjectAnimation(ObjectAnimation* objectAnimation);

    void SetAttributeAnimation
        (const String& name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f);

    void SetAttributeAnimationWrapMode(const String& name, WrapMode wrapMode);

    void SetAttributeAnimationSpeed(const String& name, float speed);

    void SetAttributeAnimationTime(const String& name, float time);

    void RemoveObjectAnimation();

    void RemoveAttributeAnimation(const String& name);


    bool GetAnimationEnabled() const { return animationEnabled_; }


    ObjectAnimation* GetObjectAnimation() const;

    ValueAnimation* GetAttributeAnimation(const String& name) const;

    WrapMode GetAttributeAnimationWrapMode(const String& name) const;

    float GetAttributeAnimationSpeed(const String& name) const;

    float GetAttributeAnimationTime(const String& name) const;


    void SetObjectAnimationAttr(const ResourceRef& value);

    ResourceRef GetObjectAnimationAttr() const;

protected:

    virtual void OnAttributeAnimationAdded() = 0;

    virtual void OnAttributeAnimationRemoved() = 0;

    virtual Animatable* FindAttributeAnimationTarget(const String& name, String& outName);

    void SetObjectAttributeAnimation(const String& name, ValueAnimation* attributeAnimation, WrapMode wrapMode, float speed);

    void OnObjectAnimationAdded(ObjectAnimation* objectAnimation);

    void OnObjectAnimationRemoved(ObjectAnimation* objectAnimation);

    void UpdateAttributeAnimations(float timeStep);

    bool IsAnimatedNetworkAttribute(const AttributeInfo& attrInfo) const;

    AttributeAnimationInfo* GetAttributeAnimationInfo(const String& name) const;

    void HandleAttributeAnimationAdded(StringHash eventType, VariantMap& eventData);

    void HandleAttributeAnimationRemoved(StringHash eventType, VariantMap& eventData);


    bool animationEnabled_;

    SharedPtr<ObjectAnimation> objectAnimation_;

    HashSet<const AttributeInfo*> animatedNetworkAttributes_;

    HashMap<String, SharedPtr<AttributeAnimationInfo> > attributeAnimationInfos_;
};

}


namespace Urho3D
{

class DebugRenderer;
class Node;
class Scene;

struct ComponentReplicationState;


enum AutoRemoveMode
{
    REMOVE_DISABLED = 0,
    REMOVE_COMPONENT,
    REMOVE_NODE
};


class __attribute__((visibility("default"))) Component : public Animatable
{
    public: using ClassName = Component; using BaseClassName = Animatable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Component", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class Node;
    friend class Scene;

public:

    explicit Component(Context* context);

    ~Component() override;


    virtual void OnSetEnabled() { }


    bool Save(Serializer& dest) const override;

    bool SaveXML(XMLElement& dest) const override;

    bool SaveJSON(JSONValue& dest) const override;

    void MarkNetworkUpdate() override;

    virtual void GetDependencyNodes(PODVector<Node*>& dest);

    virtual void DrawDebugGeometry(DebugRenderer* debug, bool depthTest);


    void SetEnabled(bool enable);

    void Remove();


    unsigned GetID() const { return id_; }

    bool IsReplicated() const;


    Node* GetNode() const { return node_; }


    Scene* GetScene() const;


    bool IsEnabled() const { return enabled_; }

    bool IsEnabledEffective() const;


    Component* GetComponent(StringHash type) const;

    void GetComponents(PODVector<Component*>& dest, StringHash type) const;

    template <class T> T* GetComponent() const;

    template <class T> void GetComponents(PODVector<T*>& dest) const;


    void AddReplicationState(ComponentReplicationState* state);

    void PrepareNetworkUpdate();

    void CleanupConnection(Connection* connection);


    virtual const String& GetBasePath() const;

protected:

    void OnAttributeAnimationAdded() override;

    void OnAttributeAnimationRemoved() override;

    virtual void OnNodeSet(Node* node);

    virtual void OnSceneSet(Scene* scene);

    virtual void OnMarkedDirty(Node* node);

    virtual void OnNodeSetEnabled(Node* node);

    void SetID(unsigned id);

    void SetNode(Node* node);

    void HandleAttributeAnimationUpdate(StringHash eventType, VariantMap& eventData);

    Component* GetFixedUpdateSource();

    void DoAutoRemove(AutoRemoveMode mode);


    Node* node_;

    unsigned id_;

    bool networkUpdate_;

    bool enabled_;
};

template <class T> T* Component::GetComponent() const { return static_cast<T*>(GetComponent(T::GetTypeStatic())); }

template <class T> void Component::GetComponents(PODVector<T*>& dest) const
{
    GetComponents(reinterpret_cast<PODVector<Component*>&>(dest), T::GetTypeStatic());
}

}


class asIScriptFunction;
class asIScriptObject;
class asIScriptContext;

namespace Urho3D
{

class Script;
class ScriptFile;


enum ScriptInstanceMethod
{
    METHOD_START = 0,
    METHOD_STOP,
    METHOD_DELAYEDSTART,
    METHOD_UPDATE,
    METHOD_POSTUPDATE,
    METHOD_FIXEDUPDATE,
    METHOD_FIXEDPOSTUPDATE,
    METHOD_LOAD,
    METHOD_SAVE,
    METHOD_READNETWORKUPDATE,
    METHOD_WRITENETWORKUPDATE,
    METHOD_APPLYATTRIBUTES,
    METHOD_TRANSFORMCHANGED,
    MAX_SCRIPT_METHODS
};


class __attribute__((visibility("default"))) ScriptInstance : public Component, public ScriptEventListener
{
    public: using ClassName = ScriptInstance; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ScriptInstance", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ScriptInstance(Context* context);

    ~ScriptInstance() override;

    static void RegisterObject(Context* context);


    void OnSetAttribute(const AttributeInfo& attr, const Variant& src) override;

    void OnGetAttribute(const AttributeInfo& attr, Variant& dest) const override;


    const Vector<AttributeInfo>* GetAttributes() const override { return &attributeInfos_; }


    void ApplyAttributes() override;

    void OnSetEnabled() override;


    void AddEventHandler(StringHash eventType, const String& handlerName) override;

    void AddEventHandler(Object* sender, StringHash eventType, const String& handlerName) override;

    void RemoveEventHandler(StringHash eventType) override;

    void RemoveEventHandler(Object* sender, StringHash eventType) override;

    void RemoveEventHandlers(Object* sender) override;

    void RemoveEventHandlers() override;

    void RemoveEventHandlersExcept(const PODVector<StringHash>& exceptions) override;

    bool HasEventHandler(StringHash eventType) const override;

    bool HasEventHandler(Object* sender, StringHash eventType) const override;


    bool CreateObject(ScriptFile* scriptFile, const String& className);

    void SetScriptFile(ScriptFile* scriptFile);

    void SetClassName(const String& className);

    bool Execute(const String& declaration, const VariantVector& parameters = Variant::emptyVariantVector);

    bool Execute(asIScriptFunction* method, const VariantVector& parameters = Variant::emptyVariantVector);

    void DelayedExecute
        (float delay, bool repeat, const String& declaration, const VariantVector& parameters = Variant::emptyVariantVector);

    void ClearDelayedExecute(const String& declaration = String::EMPTY);


    ScriptFile* GetScriptFile() const { return scriptFile_; }


    asIScriptObject* GetScriptObject() const { return scriptObject_; }


    const String& GetClassName() const { return className_; }


    bool IsA(const String& className) const;

    bool HasMethod(const String& declaration) const;


    void SetScriptFileAttr(const ResourceRef& value);

    void SetDelayedCallsAttr(const PODVector<unsigned char>& value);

    void SetScriptDataAttr(const PODVector<unsigned char>& data);

    void SetScriptNetworkDataAttr(const PODVector<unsigned char>& data);

    ResourceRef GetScriptFileAttr() const;

    PODVector<unsigned char> GetDelayedCallsAttr() const;

    PODVector<unsigned char> GetScriptDataAttr() const;

    PODVector<unsigned char> GetScriptNetworkDataAttr() const;

protected:

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

private:

    void CreateObject();

    void ReleaseObject();

    void GetScriptMethods();

    void GetScriptAttributes();

    void StoreScriptAttributes();

    void RestoreScriptAttributes();

    void ClearScriptMethods();

    void ClearScriptAttributes();

    void UpdateEventSubscription();

    void HandleSceneUpdate(StringHash eventType, VariantMap& eventData);

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);


    void HandlePhysicsPreStep(StringHash eventType, VariantMap& eventData);

    void HandlePhysicsPostStep(StringHash eventType, VariantMap& eventData);


    void HandleScriptEvent(StringHash eventType, VariantMap& eventData);

    void HandleScriptFileReload(StringHash eventType, VariantMap& eventData);

    void HandleScriptFileReloadFinished(StringHash eventType, VariantMap& eventData);


    WeakPtr<ScriptFile> scriptFile_;

    asIScriptObject* scriptObject_{};

    String className_;

    asIScriptFunction* methods_[MAX_SCRIPT_METHODS]{};

    Vector<DelayedCall> delayedCalls_;

    Vector<AttributeInfo> attributeInfos_;

    HashMap<AttributeInfo*, unsigned> idAttributes_;

    HashMap<String, Variant> storedAttributes_;

    bool subscribed_{};

    bool subscribedPostFixed_{};
};


__attribute__((visibility("default"))) asIScriptContext* GetActiveASContext();

__attribute__((visibility("default"))) Context* GetScriptContext();

__attribute__((visibility("default"))) ScriptInstance* GetScriptContextInstance();

__attribute__((visibility("default"))) Node* GetScriptContextNode();

__attribute__((visibility("default"))) Scene* GetScriptContextScene();

__attribute__((visibility("default"))) ScriptEventListener* GetScriptContextEventListener();

__attribute__((visibility("default"))) Object* GetScriptContextEventListenerObject();

}

namespace Urho3D
{


static const String SOUND_MASTER = "Master";
static const String SOUND_EFFECT = "Effect";
static const String SOUND_AMBIENT = "Ambient";
static const String SOUND_VOICE = "Voice";
static const String SOUND_MUSIC = "Music";

}



namespace Urho3D
{

class Audio;
class Sound;
class SoundStream;


static const int STREAM_BUFFER_LENGTH = 100;


class __attribute__((visibility("default"))) SoundSource : public Component
{
    public: using ClassName = SoundSource; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SoundSource", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit SoundSource(Context* context);

    ~SoundSource() override;

    static void RegisterObject(Context* context);


    void Seek(float seekTime);

    void Play(Sound* sound);

    void Play(Sound* sound, float frequency);

    void Play(Sound* sound, float frequency, float gain);

    void Play(Sound* sound, float frequency, float gain, float panning);

    void Play(SoundStream* stream);

    void Stop();

    void SetSoundType(const String& type);

    void SetFrequency(float frequency);

    void SetGain(float gain);

    void SetAttenuation(float attenuation);

    void SetPanning(float panning);

    void SetAutoRemoveMode(AutoRemoveMode mode);

    void SetPlayPosition(signed char* pos);


    Sound* GetSound() const { return sound_; }


    volatile signed char* GetPlayPosition() const { return position_; }


    String GetSoundType() const { return soundType_; }


    float GetTimePosition() const { return timePosition_; }


    float GetFrequency() const { return frequency_; }


    float GetGain() const { return gain_; }


    float GetAttenuation() const { return attenuation_; }


    float GetPanning() const { return panning_; }


    AutoRemoveMode GetAutoRemoveMode() const { return autoRemove_; }


    bool IsPlaying() const;


    virtual void Update(float timeStep);

    void Mix(int* dest, unsigned samples, int mixRate, bool stereo, bool interpolation);

    void UpdateMasterGain();


    void SetSoundAttr(const ResourceRef& value);

    void SetPositionAttr(int value);

    ResourceRef GetSoundAttr() const;

    void SetPlayingAttr(bool value);

    int GetPositionAttr() const;

protected:

    WeakPtr<Audio> audio_;

    String soundType_;

    StringHash soundTypeHash_;

    float frequency_;

    float gain_;

    float attenuation_;

    float panning_;

    float masterGain_{};

    bool sendFinishedEvent_;

    AutoRemoveMode autoRemove_;

private:

    void PlayLockless(Sound* sound);

    void PlayLockless(const SharedPtr<SoundStream>& stream);

    void StopLockless();

    void SetPlayPositionLockless(signed char* pos);

    void MixMonoToMono(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixMonoToStereo(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixMonoToMonoIP(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixMonoToStereoIP(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixStereoToMono(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixStereoToStereo(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixStereoToMonoIP(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixStereoToStereoIP(Sound* sound, int* dest, unsigned samples, int mixRate);

    void MixZeroVolume(Sound* sound, unsigned samples, int mixRate);

    void MixNull(float timeStep);


    SharedPtr<Sound> sound_;

    SharedPtr<SoundStream> soundStream_;

    volatile signed char* position_;

    volatile int fractPosition_;

    volatile float timePosition_;

    SharedPtr<Sound> streamBuffer_;

    int unusedStreamSize_;
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) EventReceiverGroup : public RefCounted
{
public:

    EventReceiverGroup() :
        inSend_(0),
        dirty_(false)
    {
    }


    void BeginSendEvent();


    void EndSendEvent();


    void Add(Object* object);


    void Remove(Object* object);


    PODVector<Object*> receivers_;

private:

    unsigned inSend_;

    bool dirty_;
};


class __attribute__((visibility("default"))) Context : public RefCounted
{
    friend class Object;

public:

    Context();

    ~Context() override;


    template <class T> inline SharedPtr<T> CreateObject()
    {
        return StaticCast<T>(CreateObject(T::GetTypeStatic()));
    }

    SharedPtr<Object> CreateObject(StringHash objectType);

    void RegisterFactory(ObjectFactory* factory);

    void RegisterFactory(ObjectFactory* factory, const char* category);

    void RegisterSubsystem(Object* object);

    void RemoveSubsystem(StringHash objectType);

    AttributeHandle RegisterAttribute(StringHash objectType, const AttributeInfo& attr);

    void RemoveAttribute(StringHash objectType, const char* name);

    void RemoveAllAttributes(StringHash objectType);

    void UpdateAttributeDefaultValue(StringHash objectType, const char* name, const Variant& defaultValue);

    VariantMap& GetEventDataMap();

    bool RequireSDL(unsigned int sdlFlags);

    void ReleaseSDL();


    void RequireIK();

    void ReleaseIK();



    void CopyBaseAttributes(StringHash baseType, StringHash derivedType);

    template <class T> void RegisterFactory();

    template <class T> void RegisterFactory(const char* category);

    template <class T> T* RegisterSubsystem();

    template <class T> void RemoveSubsystem();

    template <class T> AttributeHandle RegisterAttribute(const AttributeInfo& attr);

    template <class T> void RemoveAttribute(const char* name);

    template <class T> void RemoveAllAttributes();

    template <class T, class U> void CopyBaseAttributes();

    template <class T> void UpdateAttributeDefaultValue(const char* name, const Variant& defaultValue);


    Object* GetSubsystem(StringHash type) const;


    const Variant& GetGlobalVar(StringHash key) const;


    const VariantMap& GetGlobalVars() const { return globalVars_; }


    void SetGlobalVar(StringHash key, const Variant& value);


    const HashMap<StringHash, SharedPtr<Object> >& GetSubsystems() const { return subsystems_; }


    const HashMap<StringHash, SharedPtr<ObjectFactory> >& GetObjectFactories() const { return factories_; }


    const HashMap<String, Vector<StringHash> >& GetObjectCategories() const { return objectCategories_; }


    Object* GetEventSender() const;


    EventHandler* GetEventHandler() const { return eventHandler_; }


    const String& GetTypeName(StringHash objectType) const;

    AttributeInfo* GetAttribute(StringHash objectType, const char* name);

    template <class T> T* GetSubsystem() const;

    template <class T> AttributeInfo* GetAttribute(const char* name);


    const Vector<AttributeInfo>* GetAttributes(StringHash type) const
    {
        HashMap<StringHash, Vector<AttributeInfo> >::ConstIterator i = attributes_.Find(type);
        return i != attributes_.End() ? &i->second_ : nullptr;
    }


    const Vector<AttributeInfo>* GetNetworkAttributes(StringHash type) const
    {
        HashMap<StringHash, Vector<AttributeInfo> >::ConstIterator i = networkAttributes_.Find(type);
        return i != networkAttributes_.End() ? &i->second_ : nullptr;
    }


    const HashMap<StringHash, Vector<AttributeInfo> >& GetAllAttributes() const { return attributes_; }


    EventReceiverGroup* GetEventReceivers(Object* sender, StringHash eventType)
    {
        HashMap<Object*, HashMap<StringHash, SharedPtr<EventReceiverGroup> > >::Iterator i = specificEventReceivers_.Find(sender);
        if (i != specificEventReceivers_.End())
        {
            HashMap<StringHash, SharedPtr<EventReceiverGroup> >::Iterator j = i->second_.Find(eventType);
            return j != i->second_.End() ? j->second_ : nullptr;
        }
        else
            return nullptr;
    }


    EventReceiverGroup* GetEventReceivers(StringHash eventType)
    {
        HashMap<StringHash, SharedPtr<EventReceiverGroup> >::Iterator i = eventReceivers_.Find(eventType);
        return i != eventReceivers_.End() ? i->second_ : nullptr;
    }

private:

    void AddEventReceiver(Object* receiver, StringHash eventType);

    void AddEventReceiver(Object* receiver, Object* sender, StringHash eventType);

    void RemoveEventSender(Object* sender);

    void RemoveEventReceiver(Object* receiver, Object* sender, StringHash eventType);

    void RemoveEventReceiver(Object* receiver, StringHash eventType);

    void BeginSendEvent(Object* sender, StringHash eventType);

    void EndSendEvent();


    void SetEventHandler(EventHandler* handler) { eventHandler_ = handler; }


    HashMap<StringHash, SharedPtr<ObjectFactory> > factories_;

    HashMap<StringHash, SharedPtr<Object> > subsystems_;

    HashMap<StringHash, Vector<AttributeInfo> > attributes_;

    HashMap<StringHash, Vector<AttributeInfo> > networkAttributes_;

    HashMap<StringHash, SharedPtr<EventReceiverGroup> > eventReceivers_;

    HashMap<Object*, HashMap<StringHash, SharedPtr<EventReceiverGroup> > > specificEventReceivers_;

    PODVector<Object*> eventSenders_;

    PODVector<VariantMap*> eventDataMaps_;

    EventHandler* eventHandler_;

    HashMap<String, Vector<StringHash> > objectCategories_;

    VariantMap globalVars_;
};

template <class T> void Context::RegisterFactory() { RegisterFactory(new ObjectFactoryImpl<T>(this)); }

template <class T> void Context::RegisterFactory(const char* category)
{
    RegisterFactory(new ObjectFactoryImpl<T>(this), category);
}

template <class T> T* Context::RegisterSubsystem()
{
    auto* subsystem = new T(this);
    RegisterSubsystem(subsystem);
    return subsystem;
}

template <class T> void Context::RemoveSubsystem() { RemoveSubsystem(T::GetTypeStatic()); }

template <class T> AttributeHandle Context::RegisterAttribute(const AttributeInfo& attr) { return RegisterAttribute(T::GetTypeStatic(), attr); }

template <class T> void Context::RemoveAttribute(const char* name) { RemoveAttribute(T::GetTypeStatic(), name); }

template <class T> void Context::RemoveAllAttributes() { RemoveAllAttributes(T::GetTypeStatic()); }

template <class T, class U> void Context::CopyBaseAttributes() { CopyBaseAttributes(T::GetTypeStatic(), U::GetTypeStatic()); }

template <class T> T* Context::GetSubsystem() const { return static_cast<T*>(GetSubsystem(T::GetTypeStatic())); }

template <class T> AttributeInfo* Context::GetAttribute(const char* name) { return GetAttribute(T::GetTypeStatic(), name); }

template <class T> void Context::UpdateAttributeDefaultValue(const char* name, const Variant& defaultValue)
{
    UpdateAttributeDefaultValue(T::GetTypeStatic(), name, defaultValue);
}

}



namespace Urho3D
{

class Vector3;
enum PrimitiveType
{
    TRIANGLE_LIST = 0,
    LINE_LIST,
    POINT_LIST,
    TRIANGLE_STRIP,
    LINE_STRIP,
    TRIANGLE_FAN
};


enum GeometryType
{
    GEOM_STATIC = 0,
    GEOM_SKINNED = 1,
    GEOM_INSTANCED = 2,
    GEOM_BILLBOARD = 3,
    GEOM_DIRBILLBOARD = 4,
    GEOM_TRAIL_FACE_CAMERA = 5,
    GEOM_TRAIL_BONE = 6,
    MAX_GEOMETRYTYPES = 7,

    GEOM_STATIC_NOINSTANCING = 7,
};


enum BlendMode
{
    BLEND_REPLACE = 0,
    BLEND_ADD,
    BLEND_MULTIPLY,
    BLEND_ALPHA,
    BLEND_ADDALPHA,
    BLEND_PREMULALPHA,
    BLEND_INVDESTALPHA,
    BLEND_SUBTRACT,
    BLEND_SUBTRACTALPHA,
    MAX_BLENDMODES
};


enum CompareMode
{
    CMP_ALWAYS = 0,
    CMP_EQUAL,
    CMP_NOTEQUAL,
    CMP_LESS,
    CMP_LESSEQUAL,
    CMP_GREATER,
    CMP_GREATEREQUAL,
    MAX_COMPAREMODES
};


enum CullMode
{
    CULL_NONE = 0,
    CULL_CCW,
    CULL_CW,
    MAX_CULLMODES
};


enum FillMode
{
    FILL_SOLID = 0,
    FILL_WIREFRAME,
    FILL_POINT
};


enum StencilOp
{
    OP_KEEP = 0,
    OP_ZERO,
    OP_REF,
    OP_INCR,
    OP_DECR
};


enum LockState
{
    LOCK_NONE = 0,
    LOCK_HARDWARE,
    LOCK_SHADOW,
    LOCK_SCRATCH
};


enum LegacyVertexElement
{
    ELEMENT_POSITION = 0,
    ELEMENT_NORMAL,
    ELEMENT_COLOR,
    ELEMENT_TEXCOORD1,
    ELEMENT_TEXCOORD2,
    ELEMENT_CUBETEXCOORD1,
    ELEMENT_CUBETEXCOORD2,
    ELEMENT_TANGENT,
    ELEMENT_BLENDWEIGHTS,
    ELEMENT_BLENDINDICES,
    ELEMENT_INSTANCEMATRIX1,
    ELEMENT_INSTANCEMATRIX2,
    ELEMENT_INSTANCEMATRIX3,

    ELEMENT_OBJECTINDEX,
    MAX_LEGACY_VERTEX_ELEMENTS
};


enum VertexElementType
{
    TYPE_INT = 0,
    TYPE_FLOAT,
    TYPE_VECTOR2,
    TYPE_VECTOR3,
    TYPE_VECTOR4,
    TYPE_UBYTE4,
    TYPE_UBYTE4_NORM,
    MAX_VERTEX_ELEMENT_TYPES
};


enum VertexElementSemantic
{
    SEM_POSITION = 0,
    SEM_NORMAL,
    SEM_BINORMAL,
    SEM_TANGENT,
    SEM_TEXCOORD,
    SEM_COLOR,
    SEM_BLENDWEIGHTS,
    SEM_BLENDINDICES,
    SEM_OBJECTINDEX,
    MAX_VERTEX_ELEMENT_SEMANTICS
};


struct __attribute__((visibility("default"))) VertexElement
{

    VertexElement() noexcept :
        type_(TYPE_VECTOR3),
        semantic_(SEM_POSITION),
        index_(0),
        perInstance_(false),
        offset_(0)
    {
    }


    VertexElement(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0, bool perInstance = false) noexcept :
        type_(type),
        semantic_(semantic),
        index_(index),
        perInstance_(perInstance),
        offset_(0)
    {
    }


    bool operator ==(const VertexElement& rhs) const { return type_ == rhs.type_ && semantic_ == rhs.semantic_ && index_ == rhs.index_ && perInstance_ == rhs.perInstance_; }


    bool operator !=(const VertexElement& rhs) const { return !(*this == rhs); }


    VertexElementType type_;

    VertexElementSemantic semantic_;

    unsigned char index_;

    bool perInstance_;

    unsigned offset_;
};


extern __attribute__((visibility("default"))) const unsigned ELEMENT_TYPESIZES[];


extern __attribute__((visibility("default"))) const VertexElement LEGACY_VERTEXELEMENTS[];


enum TextureFilterMode
{
    FILTER_NEAREST = 0,
    FILTER_BILINEAR,
    FILTER_TRILINEAR,
    FILTER_ANISOTROPIC,
    FILTER_NEAREST_ANISOTROPIC,
    FILTER_DEFAULT,
    MAX_FILTERMODES
};


enum TextureAddressMode
{
    ADDRESS_WRAP = 0,
    ADDRESS_MIRROR,
    ADDRESS_CLAMP,
    ADDRESS_BORDER,
    MAX_ADDRESSMODES
};


enum TextureCoordinate
{
    COORD_U = 0,
    COORD_V,
    COORD_W,
    MAX_COORDS
};


enum TextureUsage
{
    TEXTURE_STATIC = 0,
    TEXTURE_DYNAMIC,
    TEXTURE_RENDERTARGET,
    TEXTURE_DEPTHSTENCIL
};


enum CubeMapFace
{
    FACE_POSITIVE_X = 0,
    FACE_NEGATIVE_X,
    FACE_POSITIVE_Y,
    FACE_NEGATIVE_Y,
    FACE_POSITIVE_Z,
    FACE_NEGATIVE_Z,
    MAX_CUBEMAP_FACES
};


enum CubeMapLayout
{
    CML_HORIZONTAL = 0,
    CML_HORIZONTALNVIDIA,
    CML_HORIZONTALCROSS,
    CML_VERTICALCROSS,
    CML_BLENDER
};


enum RenderSurfaceUpdateMode
{
    SURFACE_MANUALUPDATE = 0,
    SURFACE_UPDATEVISIBLE,
    SURFACE_UPDATEALWAYS
};


enum ShaderType
{
    VS = 0,
    PS,
};


enum ShaderParameterGroup
{
    SP_FRAME = 0,
    SP_CAMERA,
    SP_ZONE,
    SP_LIGHT,
    SP_MATERIAL,
    SP_OBJECT,
    SP_CUSTOM,
    MAX_SHADER_PARAMETER_GROUPS
};


enum TextureUnit
{
    TU_DIFFUSE = 0,
    TU_ALBEDOBUFFER = 0,
    TU_NORMAL = 1,
    TU_NORMALBUFFER = 1,
    TU_SPECULAR = 2,
    TU_EMISSIVE = 3,
    TU_ENVIRONMENT = 4,

    TU_VOLUMEMAP = 5,
    TU_CUSTOM1 = 6,
    TU_CUSTOM2 = 7,
    TU_LIGHTRAMP = 8,
    TU_LIGHTSHAPE = 9,
    TU_SHADOWMAP = 10,
    TU_FACESELECT = 11,
    TU_INDIRECTION = 12,
    TU_DEPTHBUFFER = 13,
    TU_LIGHTBUFFER = 14,
    TU_ZONE = 15,
    MAX_MATERIAL_TEXTURE_UNITS = 8,
    MAX_TEXTURE_UNITS = 16







};


enum FaceCameraMode
{
    FC_NONE = 0,
    FC_ROTATE_XYZ,
    FC_ROTATE_Y,
    FC_LOOKAT_XYZ,
    FC_LOOKAT_Y,
    FC_LOOKAT_MIXED,
    FC_DIRECTION,
};


enum ShadowQuality
{
    SHADOWQUALITY_SIMPLE_16BIT = 0,
    SHADOWQUALITY_SIMPLE_24BIT,
    SHADOWQUALITY_PCF_16BIT,
    SHADOWQUALITY_PCF_24BIT,
    SHADOWQUALITY_VSM,
    SHADOWQUALITY_BLUR_VSM
};


extern __attribute__((visibility("default"))) const StringHash VSP_AMBIENTSTARTCOLOR;
extern __attribute__((visibility("default"))) const StringHash VSP_AMBIENTENDCOLOR;
extern __attribute__((visibility("default"))) const StringHash VSP_BILLBOARDROT;
extern __attribute__((visibility("default"))) const StringHash VSP_CAMERAPOS;
extern __attribute__((visibility("default"))) const StringHash VSP_CLIPPLANE;
extern __attribute__((visibility("default"))) const StringHash VSP_NEARCLIP;
extern __attribute__((visibility("default"))) const StringHash VSP_FARCLIP;
extern __attribute__((visibility("default"))) const StringHash VSP_DEPTHMODE;
extern __attribute__((visibility("default"))) const StringHash VSP_DELTATIME;
extern __attribute__((visibility("default"))) const StringHash VSP_ELAPSEDTIME;
extern __attribute__((visibility("default"))) const StringHash VSP_FRUSTUMSIZE;
extern __attribute__((visibility("default"))) const StringHash VSP_GBUFFEROFFSETS;
extern __attribute__((visibility("default"))) const StringHash VSP_LIGHTDIR;
extern __attribute__((visibility("default"))) const StringHash VSP_LIGHTPOS;
extern __attribute__((visibility("default"))) const StringHash VSP_NORMALOFFSETSCALE;
extern __attribute__((visibility("default"))) const StringHash VSP_MODEL;
extern __attribute__((visibility("default"))) const StringHash VSP_VIEW;
extern __attribute__((visibility("default"))) const StringHash VSP_VIEWINV;
extern __attribute__((visibility("default"))) const StringHash VSP_VIEWPROJ;
extern __attribute__((visibility("default"))) const StringHash VSP_UOFFSET;
extern __attribute__((visibility("default"))) const StringHash VSP_VOFFSET;
extern __attribute__((visibility("default"))) const StringHash VSP_ZONE;
extern __attribute__((visibility("default"))) const StringHash VSP_LIGHTMATRICES;
extern __attribute__((visibility("default"))) const StringHash VSP_SKINMATRICES;
extern __attribute__((visibility("default"))) const StringHash VSP_VERTEXLIGHTS;
extern __attribute__((visibility("default"))) const StringHash PSP_AMBIENTCOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_CAMERAPOS;
extern __attribute__((visibility("default"))) const StringHash PSP_DELTATIME;
extern __attribute__((visibility("default"))) const StringHash PSP_DEPTHRECONSTRUCT;
extern __attribute__((visibility("default"))) const StringHash PSP_ELAPSEDTIME;
extern __attribute__((visibility("default"))) const StringHash PSP_FOGCOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_FOGPARAMS;
extern __attribute__((visibility("default"))) const StringHash PSP_GBUFFERINVSIZE;
extern __attribute__((visibility("default"))) const StringHash PSP_LIGHTCOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_LIGHTDIR;
extern __attribute__((visibility("default"))) const StringHash PSP_LIGHTPOS;
extern __attribute__((visibility("default"))) const StringHash PSP_NORMALOFFSETSCALE;
extern __attribute__((visibility("default"))) const StringHash PSP_MATDIFFCOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_MATEMISSIVECOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_MATENVMAPCOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_MATSPECCOLOR;
extern __attribute__((visibility("default"))) const StringHash PSP_NEARCLIP;
extern __attribute__((visibility("default"))) const StringHash PSP_FARCLIP;
extern __attribute__((visibility("default"))) const StringHash PSP_SHADOWCUBEADJUST;
extern __attribute__((visibility("default"))) const StringHash PSP_SHADOWDEPTHFADE;
extern __attribute__((visibility("default"))) const StringHash PSP_SHADOWINTENSITY;
extern __attribute__((visibility("default"))) const StringHash PSP_SHADOWMAPINVSIZE;
extern __attribute__((visibility("default"))) const StringHash PSP_SHADOWSPLITS;
extern __attribute__((visibility("default"))) const StringHash PSP_LIGHTMATRICES;
extern __attribute__((visibility("default"))) const StringHash PSP_VSMSHADOWPARAMS;
extern __attribute__((visibility("default"))) const StringHash PSP_ROUGHNESS;
extern __attribute__((visibility("default"))) const StringHash PSP_METALLIC;
extern __attribute__((visibility("default"))) const StringHash PSP_LIGHTRAD;
extern __attribute__((visibility("default"))) const StringHash PSP_LIGHTLENGTH;
extern __attribute__((visibility("default"))) const StringHash PSP_ZONEMIN;
extern __attribute__((visibility("default"))) const StringHash PSP_ZONEMAX;


extern __attribute__((visibility("default"))) const Vector3 DOT_SCALE;

enum MaterialQuality : unsigned
{
    QUALITY_LOW = 0,
    QUALITY_MEDIUM = 1,
    QUALITY_HIGH = 2,
    QUALITY_MAX = 15,
};

enum ClearTarget : unsigned
{
    CLEAR_COLOR = 0x1,
    CLEAR_DEPTH = 0x2,
    CLEAR_STENCIL = 0x4,
};
template<> struct IsFlagSet<ClearTarget> { constexpr static bool value_ = true; }; using ClearTargetFlags = FlagSet<ClearTarget>;


enum VertexMask : unsigned
{
    MASK_NONE = 0x0,
    MASK_POSITION = 0x1,
    MASK_NORMAL = 0x2,
    MASK_COLOR = 0x4,
    MASK_TEXCOORD1 = 0x8,
    MASK_TEXCOORD2 = 0x10,
    MASK_CUBETEXCOORD1 = 0x20,
    MASK_CUBETEXCOORD2 = 0x40,
    MASK_TANGENT = 0x80,
    MASK_BLENDWEIGHTS = 0x100,
    MASK_BLENDINDICES = 0x200,
    MASK_INSTANCEMATRIX1 = 0x400,
    MASK_INSTANCEMATRIX2 = 0x800,
    MASK_INSTANCEMATRIX3 = 0x1000,
    MASK_OBJECTINDEX = 0x2000,
};
template<> struct IsFlagSet<VertexMask> { constexpr static bool value_ = true; }; using VertexMaskFlags = FlagSet<VertexMask>;

static const int MAX_RENDERTARGETS = 4;
static const int MAX_VERTEX_STREAMS = 4;
static const int MAX_CONSTANT_REGISTERS = 256;

static const int BITS_PER_COMPONENT = 8;
}

namespace Urho3D
{

class Polyhedron;
class Frustum;
class Matrix3;
class Matrix4;
class Matrix3x4;
class Sphere;


class __attribute__((visibility("default"))) BoundingBox
{
public:

    BoundingBox() noexcept :
        min_(M_INFINITY, M_INFINITY, M_INFINITY),
        max_(-M_INFINITY, -M_INFINITY, -M_INFINITY)
    {
    }


    BoundingBox(const BoundingBox& box) noexcept :
        min_(box.min_),
        max_(box.max_)
    {
    }


    explicit BoundingBox(const Rect& rect) noexcept :
        min_(Vector3(rect.min_, 0.0f)),
        max_(Vector3(rect.max_, 0.0f))
    {
    }


    BoundingBox(const Vector3& min, const Vector3& max) noexcept :
        min_(min),
        max_(max)
    {
    }


    BoundingBox(float min, float max) noexcept :
        min_(Vector3(min, min, min)),
        max_(Vector3(max, max, max))
    {
    }


    BoundingBox(__m128 min, __m128 max) noexcept
    {
        _mm_storeu_ps(&min_.x_, min);
        _mm_storeu_ps(&max_.x_, max);
    }



    BoundingBox(const Vector3* vertices, unsigned count) :
        min_(M_INFINITY, M_INFINITY, M_INFINITY),
        max_(-M_INFINITY, -M_INFINITY, -M_INFINITY)
    {
        Define(vertices, count);
    }


    explicit BoundingBox(const Frustum& frustum) :
        min_(M_INFINITY, M_INFINITY, M_INFINITY),
        max_(-M_INFINITY, -M_INFINITY, -M_INFINITY)
    {
        Define(frustum);
    }


    explicit BoundingBox(const Polyhedron& poly) :
        min_(M_INFINITY, M_INFINITY, M_INFINITY),
        max_(-M_INFINITY, -M_INFINITY, -M_INFINITY)
    {
        Define(poly);
    }


    explicit BoundingBox(const Sphere& sphere) :
        min_(M_INFINITY, M_INFINITY, M_INFINITY),
        max_(-M_INFINITY, -M_INFINITY, -M_INFINITY)
    {
        Define(sphere);
    }


    BoundingBox& operator =(const BoundingBox& rhs) noexcept
    {
        min_ = rhs.min_;
        max_ = rhs.max_;
        return *this;
    }


    BoundingBox& operator =(const Rect& rhs) noexcept
    {
        min_ = Vector3(rhs.min_, 0.0f);
        max_ = Vector3(rhs.max_, 0.0f);
        return *this;
    }


    bool operator ==(const BoundingBox& rhs) const { return (min_ == rhs.min_ && max_ == rhs.max_); }


    bool operator !=(const BoundingBox& rhs) const { return (min_ != rhs.min_ || max_ != rhs.max_); }


    void Define(const BoundingBox& box)
    {
        Define(box.min_, box.max_);
    }


    void Define(const Rect& rect)
    {
        Define(Vector3(rect.min_, 0.0f), Vector3(rect.max_, 0.0f));
    }


    void Define(const Vector3& min, const Vector3& max)
    {
        min_ = min;
        max_ = max;
    }


    void Define(float min, float max)
    {
        min_ = Vector3(min, min, min);
        max_ = Vector3(max, max, max);
    }


    void Define(const Vector3& point)
    {
        min_ = max_ = point;
    }


    void Merge(const Vector3& point)
    {

        __m128 vec = _mm_set_ps(1.f, point.z_, point.y_, point.x_);
        _mm_storeu_ps(&min_.x_, _mm_min_ps(_mm_loadu_ps(&min_.x_), vec));
        _mm_storeu_ps(&max_.x_, _mm_max_ps(_mm_loadu_ps(&max_.x_), vec));
    }


    void Merge(const BoundingBox& box)
    {

        _mm_storeu_ps(&min_.x_, _mm_min_ps(_mm_loadu_ps(&min_.x_), _mm_loadu_ps(&box.min_.x_)));
        _mm_storeu_ps(&max_.x_, _mm_max_ps(_mm_loadu_ps(&max_.x_), _mm_loadu_ps(&box.max_.x_)));
    }


    void Define(const Vector3* vertices, unsigned count);

    void Define(const Frustum& frustum);

    void Define(const Polyhedron& poly);

    void Define(const Sphere& sphere);

    void Merge(const Vector3* vertices, unsigned count);

    void Merge(const Frustum& frustum);

    void Merge(const Polyhedron& poly);

    void Merge(const Sphere& sphere);

    void Clip(const BoundingBox& box);

    void Transform(const Matrix3& transform);

    void Transform(const Matrix3x4& transform);


    void Clear()
    {

        _mm_storeu_ps(&min_.x_, _mm_set1_ps(M_INFINITY));
        _mm_storeu_ps(&max_.x_, _mm_set1_ps(-M_INFINITY));




    }


    bool Defined() const
    {
        return min_.x_ != M_INFINITY;
    }


    Vector3 Center() const { return (max_ + min_) * 0.5f; }


    Vector3 Size() const { return max_ - min_; }


    Vector3 HalfSize() const { return (max_ - min_) * 0.5f; }


    BoundingBox Transformed(const Matrix3& transform) const;

    BoundingBox Transformed(const Matrix3x4& transform) const;

    Rect Projected(const Matrix4& projection) const;

    float DistanceToPoint(const Vector3& point) const;


    Intersection IsInside(const Vector3& point) const
    {
        if (point.x_ < min_.x_ || point.x_ > max_.x_ || point.y_ < min_.y_ || point.y_ > max_.y_ ||
            point.z_ < min_.z_ || point.z_ > max_.z_)
            return OUTSIDE;
        else
            return INSIDE;
    }


    Intersection IsInside(const BoundingBox& box) const
    {
        if (box.max_.x_ < min_.x_ || box.min_.x_ > max_.x_ || box.max_.y_ < min_.y_ || box.min_.y_ > max_.y_ ||
            box.max_.z_ < min_.z_ || box.min_.z_ > max_.z_)
            return OUTSIDE;
        else if (box.min_.x_ < min_.x_ || box.max_.x_ > max_.x_ || box.min_.y_ < min_.y_ || box.max_.y_ > max_.y_ ||
                 box.min_.z_ < min_.z_ || box.max_.z_ > max_.z_)
            return INTERSECTS;
        else
            return INSIDE;
    }


    Intersection IsInsideFast(const BoundingBox& box) const
    {
        if (box.max_.x_ < min_.x_ || box.min_.x_ > max_.x_ || box.max_.y_ < min_.y_ || box.min_.y_ > max_.y_ ||
            box.max_.z_ < min_.z_ || box.min_.z_ > max_.z_)
            return OUTSIDE;
        else
            return INSIDE;
    }


    Intersection IsInside(const Sphere& sphere) const;

    Intersection IsInsideFast(const Sphere& sphere) const;


    String ToString() const;


    Vector3 min_;
    float dummyMin_{};

    Vector3 max_;
    float dummyMax_{};
};

}



namespace Urho3D
{

static const unsigned DRAWABLE_UNDEFINED = 0x0;
static const unsigned DRAWABLE_GEOMETRY = 0x1;
static const unsigned DRAWABLE_LIGHT = 0x2;
static const unsigned DRAWABLE_ZONE = 0x4;
static const unsigned DRAWABLE_GEOMETRY2D = 0x8;
static const unsigned DRAWABLE_ANY = 0xff;
static const unsigned DEFAULT_VIEWMASK = M_MAX_UNSIGNED;
static const unsigned DEFAULT_LIGHTMASK = M_MAX_UNSIGNED;
static const unsigned DEFAULT_SHADOWMASK = M_MAX_UNSIGNED;
static const unsigned DEFAULT_ZONEMASK = M_MAX_UNSIGNED;
static const int MAX_VERTEX_LIGHTS = 4;
static const float ANIMATION_LOD_BASESCALE = 2500.0f;

class Camera;
class File;
class Geometry;
class Light;
class Material;
class OcclusionBuffer;
class Octant;
class RayOctreeQuery;
class Zone;
struct RayQueryResult;
struct WorkItem;


enum UpdateGeometryType
{
    UPDATE_NONE = 0,
    UPDATE_MAIN_THREAD,
    UPDATE_WORKER_THREAD
};


struct FrameInfo
{

    unsigned frameNumber_;

    float timeStep_;

    IntVector2 viewSize_;

    Camera* camera_;
};


struct __attribute__((visibility("default"))) SourceBatch
{

    SourceBatch();

    SourceBatch(const SourceBatch& batch);

    ~SourceBatch();


    SourceBatch& operator =(const SourceBatch& rhs);


    float distance_{};

    Geometry* geometry_{};

    SharedPtr<Material> material_;

    const Matrix3x4* worldTransform_{&Matrix3x4::IDENTITY};

    unsigned numWorldTransforms_{1};

    void* instancingData_{};

    GeometryType geometryType_{GEOM_STATIC};
};


class __attribute__((visibility("default"))) Drawable : public Component
{
    public: using ClassName = Drawable; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Drawable", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class Octant;
    friend class Octree;
    friend void UpdateDrawablesWork(const WorkItem* item, unsigned threadIndex);

public:

    Drawable(Context* context, unsigned char drawableFlags);

    ~Drawable() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;

    virtual void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results);

    virtual void Update(const FrameInfo& frame) { }

    virtual void UpdateBatches(const FrameInfo& frame);

    virtual void UpdateGeometry(const FrameInfo& frame) { }


    virtual UpdateGeometryType GetUpdateGeometryType() { return UPDATE_NONE; }


    virtual Geometry* GetLodGeometry(unsigned batchIndex, unsigned level);


    virtual unsigned GetNumOccluderTriangles() { return 0; }


    virtual bool DrawOcclusion(OcclusionBuffer* buffer);

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetDrawDistance(float distance);

    void SetShadowDistance(float distance);

    void SetLodBias(float bias);

    void SetViewMask(unsigned mask);

    void SetLightMask(unsigned mask);

    void SetShadowMask(unsigned mask);

    void SetZoneMask(unsigned mask);

    void SetMaxLights(unsigned num);

    void SetCastShadows(bool enable);

    void SetOccluder(bool enable);

    void SetOccludee(bool enable);

    void MarkForUpdate();


    const BoundingBox& GetBoundingBox() const { return boundingBox_; }


    const BoundingBox& GetWorldBoundingBox();


    unsigned char GetDrawableFlags() const { return drawableFlags_; }


    float GetDrawDistance() const { return drawDistance_; }


    float GetShadowDistance() const { return shadowDistance_; }


    float GetLodBias() const { return lodBias_; }


    unsigned GetViewMask() const { return viewMask_; }


    unsigned GetLightMask() const { return lightMask_; }


    unsigned GetShadowMask() const { return shadowMask_; }


    unsigned GetZoneMask() const { return zoneMask_; }


    unsigned GetMaxLights() const { return maxLights_; }


    bool GetCastShadows() const { return castShadows_; }


    bool IsOccluder() const { return occluder_; }


    bool IsOccludee() const { return occludee_; }


    bool IsInView() const;

    bool IsInView(Camera* camera) const;


    const Vector<SourceBatch>& GetBatches() const { return batches_; }


    void SetZone(Zone* zone, bool temporary = false);

    void SetSortValue(float value);


    void SetMinMaxZ(float minZ, float maxZ)
    {
        minZ_ = minZ;
        maxZ_ = maxZ;
    }


    void MarkInView(const FrameInfo& frame);

    void MarkInView(unsigned frameNumber);

    void LimitLights();

    void LimitVertexLights(bool removeConvertedLights);


    void SetBasePass(unsigned batchIndex) { basePassFlags_ |= (1u << batchIndex); }


    Octant* GetOctant() const { return octant_; }


    Zone* GetZone() const { return zone_; }


    bool IsZoneDirty() const { return zoneDirty_; }


    float GetDistance() const { return distance_; }


    float GetLodDistance() const { return lodDistance_; }


    float GetSortValue() const { return sortValue_; }


    bool IsInView(const FrameInfo& frame, bool anyCamera = false) const;


    bool HasBasePass(unsigned batchIndex) const { return (basePassFlags_ & (1u << batchIndex)) != 0; }


    const PODVector<Light*>& GetLights() const { return lights_; }


    const PODVector<Light*>& GetVertexLights() const { return vertexLights_; }


    Light* GetFirstLight() const { return firstLight_; }


    float GetMinZ() const { return minZ_; }


    float GetMaxZ() const { return maxZ_; }


    void AddLight(Light* light)
    {
        if (!firstLight_)
            firstLight_ = light;



        if (maxLights_)
            lights_.Push(light);
    }


    void AddVertexLight(Light* light)
    {
        vertexLights_.Push(light);
    }

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

    virtual void OnWorldBoundingBoxUpdate() = 0;


    virtual void OnRemoveFromOctree() { }


    void AddToOctree();

    void RemoveFromOctree();


    void SetOctant(Octant* octant) { octant_ = octant; }


    BoundingBox worldBoundingBox_;

    BoundingBox boundingBox_;

    Vector<SourceBatch> batches_;

    unsigned char drawableFlags_;

    bool worldBoundingBoxDirty_;

    bool castShadows_;

    bool occluder_;

    bool occludee_;

    bool updateQueued_;

    bool zoneDirty_;

    Octant* octant_;

    Zone* zone_;

    unsigned viewMask_;

    unsigned lightMask_;

    unsigned shadowMask_;

    unsigned zoneMask_;

    unsigned viewFrameNumber_;

    float distance_;

    float lodDistance_;

    float drawDistance_;

    float shadowDistance_;

    float sortValue_;

    float minZ_;

    float maxZ_;

    float lodBias_;

    unsigned basePassFlags_;

    unsigned maxLights_;

    PODVector<Camera*> viewCameras_;

    Light* firstLight_;

    PODVector<Light*> lights_;

    PODVector<Light*> vertexLights_;
};

inline bool CompareDrawables(Drawable* lhs, Drawable* rhs)
{
    return lhs->GetSortValue() < rhs->GetSortValue();
}

__attribute__((visibility("default"))) bool WriteDrawablesToOBJ(PODVector<Drawable*> drawables, File* outputFile, bool asZUp, bool asRightHanded, bool writeLightmapUV = false);

}

namespace Urho3D
{

class Model;


struct StaticModelGeometryData
{

    Vector3 center_;

    unsigned lodLevel_;
};


class __attribute__((visibility("default"))) StaticModel : public Drawable
{
    public: using ClassName = StaticModel; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("StaticModel", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit StaticModel(Context* context);

    ~StaticModel() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    Geometry* GetLodGeometry(unsigned batchIndex, unsigned level) override;

    unsigned GetNumOccluderTriangles() override;

    bool DrawOcclusion(OcclusionBuffer* buffer) override;


    virtual void SetModel(Model* model);

    virtual void SetMaterial(Material* material);

    virtual bool SetMaterial(unsigned index, Material* material);

    void SetOcclusionLodLevel(unsigned level);

    void ApplyMaterialList(const String& fileName = String::EMPTY);


    Model* GetModel() const { return model_; }


    unsigned GetNumGeometries() const { return geometries_.Size(); }


    virtual Material* GetMaterial() const { return GetMaterial(0); }

    virtual Material* GetMaterial(unsigned index) const;


    unsigned GetOcclusionLodLevel() const { return occlusionLodLevel_; }


    bool IsInside(const Vector3& point) const;

    bool IsInsideLocal(const Vector3& point) const;


    void SetModelAttr(const ResourceRef& value);

    void SetMaterialsAttr(const ResourceRefList& value);

    ResourceRef GetModelAttr() const;

    const ResourceRefList& GetMaterialsAttr() const;

protected:

    void OnWorldBoundingBoxUpdate() override;

    void SetBoundingBox(const BoundingBox& box);

    void SetNumGeometries(unsigned num);

    void ResetLodLevels();

    void CalculateLodLevels();


    PODVector<StaticModelGeometryData> geometryData_;

    Vector<Vector<SharedPtr<Geometry> > > geometries_;

    SharedPtr<Model> model_;

    unsigned occlusionLodLevel_;

    mutable ResourceRefList materialsAttr_;

private:

    void HandleModelReloadFinished(StringHash eventType, VariantMap& eventData);
};

}

namespace Urho3D
{

class Graphics;


union GPUObjectHandle
{

    void* ptr_;

    unsigned name_;
};


class __attribute__((visibility("default"))) GPUObject
{
public:

    explicit GPUObject(Graphics* graphics);

    virtual ~GPUObject();


    virtual void OnDeviceLost();

    virtual void OnDeviceReset();

    virtual void Release();


    void ClearDataLost();


    Graphics* GetGraphics() const;

    void* GetGPUObject() const { return object_.ptr_; }

    unsigned GetGPUObjectName() const { return object_.name_; }

    bool IsDataLost() const { return dataLost_; }

    bool HasPendingData() const { return dataPending_; }

protected:

    WeakPtr<Graphics> graphics_;

    GPUObjectHandle object_{};

    bool dataLost_{};

    bool dataPending_{};
};

}



namespace Urho3D
{


class __attribute__((visibility("default"))) Timer
{
public:

    Timer();


    unsigned GetMSec(bool reset);

    void Reset();

private:

    unsigned startTime_{};
};


class __attribute__((visibility("default"))) HiresTimer
{
    friend class Time;

public:

    HiresTimer();


    long long GetUSec(bool reset);

    void Reset();


    static bool IsSupported() { return supported; }


    static long long GetFrequency() { return frequency; }

private:

    long long startTime_{};


    static bool supported;

    static long long frequency;
};


class __attribute__((visibility("default"))) Time : public Object
{
    public: using ClassName = Time; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Time", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Time(Context* context);

    ~Time() override;


    void BeginFrame(float timeStep);

    void EndFrame();

    void SetTimerPeriod(unsigned mSec);


    unsigned GetFrameNumber() const { return frameNumber_; }


    float GetTimeStep() const { return timeStep_; }


    unsigned GetTimerPeriod() const { return timerPeriod_; }


    float GetElapsedTime();


    float GetFramesPerSecond() const;


    static unsigned GetSystemTime();

    static unsigned GetTimeSinceEpoch();

    static String GetTimeStamp();

    static void Sleep(unsigned mSec);

private:

    Timer elapsedTime_;

    unsigned frameNumber_;

    float timeStep_;

    unsigned timerPeriod_;
};

}

namespace Urho3D
{


enum JSONValueType
{

    JSON_NULL = 0,

    JSON_BOOL,

    JSON_NUMBER,

    JSON_STRING,

    JSON_ARRAY,

    JSON_OBJECT
};


enum JSONNumberType
{

    JSONNT_NAN = 0,

    JSONNT_INT,

    JSONNT_UINT,

    JSONNT_FLOAT_DOUBLE
};

class JSONValue;


using JSONArray = Vector<JSONValue>;

using JSONObject = HashMap<String, JSONValue>;

using JSONObjectIterator = JSONObject::Iterator;

using ConstJSONObjectIterator = JSONObject::ConstIterator;


class __attribute__((visibility("default"))) JSONValue
{
public:

    JSONValue() :
        type_(0)
    {
    }

    JSONValue(bool value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(int value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(unsigned value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(float value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(double value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(const String& value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(const char* value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(const JSONArray& value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(const JSONObject& value) :
        type_(0)
    {
        *this = value;
    }

    JSONValue(const JSONValue& value) :
        type_(0)
    {
        *this = value;
    }

    ~JSONValue()
    {
        SetType(JSON_NULL);
    }


    JSONValue& operator =(bool rhs);

    JSONValue& operator =(int rhs);

    JSONValue& operator =(unsigned rhs);

    JSONValue& operator =(float rhs);

    JSONValue& operator =(double rhs);

    JSONValue& operator =(const String& rhs);

    JSONValue& operator =(const char* rhs);

    JSONValue& operator =(const JSONArray& rhs);

    JSONValue& operator =(const JSONObject& rhs);

    JSONValue& operator =(const JSONValue& rhs);


    JSONValueType GetValueType() const;

    JSONNumberType GetNumberType() const;

    String GetValueTypeName() const;

    String GetNumberTypeName() const;


    bool IsNull() const { return GetValueType() == JSON_NULL; }

    bool IsBool() const { return GetValueType() == JSON_BOOL; }

    bool IsNumber() const { return GetValueType() == JSON_NUMBER; }

    bool IsString() const { return GetValueType() == JSON_STRING; }

    bool IsArray() const { return GetValueType() == JSON_ARRAY; }

    bool IsObject() const { return GetValueType() == JSON_OBJECT; }


    bool GetBool(bool defaultValue = false) const { return IsBool() ? boolValue_ : defaultValue;}

    int GetInt(int defaultValue = 0) const { return IsNumber() ? (int)numberValue_ : defaultValue; }

    unsigned GetUInt(unsigned defaultValue = 0) const { return IsNumber() ? (unsigned)numberValue_ : defaultValue; }

    float GetFloat(float defaultValue = 0.0f) const { return IsNumber() ? (float)numberValue_ : defaultValue; }

    double GetDouble(double defaultValue = 0.0) const { return IsNumber() ? numberValue_ : defaultValue; }

    const String& GetString(String defaultValue = String::EMPTY) const { return IsString() ? *stringValue_ : defaultValue;}

    const char* GetCString(const char* defaultValue = nullptr) const { return IsString() ? stringValue_->CString() : defaultValue;}

    const JSONArray& GetArray() const { return IsArray() ? *arrayValue_ : emptyArray; }

    const JSONObject& GetObject() const { return IsObject() ? *objectValue_ : emptyObject; }



    JSONValue& operator [](unsigned index);

    const JSONValue& operator [](unsigned index) const;

    void Push(const JSONValue& value);

    void Pop();

    void Insert(unsigned pos, const JSONValue& value);

    void Erase(unsigned pos, unsigned length = 1);

    void Resize(unsigned newSize);

    unsigned Size() const;



    JSONValue& operator [](const String& key);

    const JSONValue& operator [](const String& key) const;

    void Set(const String& key, const JSONValue& value);

    const JSONValue& Get(const String& key) const;

    bool Erase(const String& key);

    bool Contains(const String& key) const;

    JSONObjectIterator Begin();

    ConstJSONObjectIterator Begin() const;

    JSONObjectIterator End();

    ConstJSONObjectIterator End() const;


    void Clear();


    void SetType(JSONValueType valueType, JSONNumberType numberType = JSONNT_NAN);


    void SetVariant(const Variant& variant, Context* context = nullptr);

    Variant GetVariant() const;

    void SetVariantValue(const Variant& variant, Context* context = nullptr);

    Variant GetVariantValue(VariantType type) const;

    void SetVariantMap(const VariantMap& variantMap, Context* context = nullptr);

    VariantMap GetVariantMap() const;

    void SetVariantVector(const VariantVector& variantVector, Context* context = nullptr);

    VariantVector GetVariantVector() const;


    static const JSONValue EMPTY;

    static const JSONArray emptyArray;

    static const JSONObject emptyObject;


    static String GetValueTypeName(JSONValueType type);

    static String GetNumberTypeName(JSONNumberType type);

    static JSONValueType GetValueTypeFromName(const String& typeName);

    static JSONValueType GetValueTypeFromName(const char* typeName);

    static JSONNumberType GetNumberTypeFromName(const String& typeName);

    static JSONNumberType GetNumberTypeFromName(const char* typeName);

private:

    unsigned type_;
    union
    {

        bool boolValue_;

        double numberValue_;

        String* stringValue_;

        JSONArray* arrayValue_;

        JSONObject* objectValue_;
    };
};

}


namespace Urho3D
{

class Deserializer;
class Serializer;
class XMLElement;


enum AsyncLoadState
{

    ASYNC_DONE = 0,

    ASYNC_QUEUED = 1,

    ASYNC_LOADING = 2,

    ASYNC_SUCCESS = 3,

    ASYNC_FAIL = 4
};


class __attribute__((visibility("default"))) Resource : public Object
{
    public: using ClassName = Resource; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Resource", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Resource(Context* context);


    bool Load(Deserializer& source);

    virtual bool BeginLoad(Deserializer& source);

    virtual bool EndLoad();

    virtual bool Save(Serializer& dest) const;


    bool LoadFile(const String& fileName);

    virtual bool SaveFile(const String& fileName) const;


    void SetName(const String& name);

    void SetMemoryUse(unsigned size);

    void ResetUseTimer();

    void SetAsyncLoadState(AsyncLoadState newState);


    const String& GetName() const { return name_; }


    StringHash GetNameHash() const { return nameHash_; }


    unsigned GetMemoryUse() const { return memoryUse_; }


    unsigned GetUseTimer();


    AsyncLoadState GetAsyncLoadState() const { return asyncLoadState_; }

private:

    String name_;

    StringHash nameHash_;

    Timer useTimer_;

    unsigned memoryUse_;

    AsyncLoadState asyncLoadState_;
};


class __attribute__((visibility("default"))) ResourceWithMetadata : public Resource
{
    public: using ClassName = ResourceWithMetadata; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ResourceWithMetadata", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ResourceWithMetadata(Context* context) : Resource(context) {}


    void AddMetadata(const String& name, const Variant& value);

    void RemoveMetadata(const String& name);

    void RemoveAllMetadata();

    const Variant& GetMetadata(const String& name) const;

    bool HasMetadata() const;

protected:

    void LoadMetadataFromXML(const XMLElement& source);

    void LoadMetadataFromJSON(const JSONArray& array);

    void SaveMetadataToXML(XMLElement& destination) const;

    void CopyMetadata(const ResourceWithMetadata& source);

private:

    VariantMap metadata_;

    StringVector metadataKeys_;
};

inline const String& GetResourceName(Resource* resource)
{
    return resource ? resource->GetName() : String::EMPTY;
}

inline StringHash GetResourceType(Resource* resource, StringHash defaultType)
{
    return resource ? resource->GetType() : defaultType;
}

inline ResourceRef GetResourceRef(Resource* resource, StringHash defaultType)
{
    return ResourceRef(GetResourceType(resource, defaultType), GetResourceName(resource));
}

template <class T> Vector<String> GetResourceNames(const Vector<SharedPtr<T> >& resources)
{
    Vector<String> ret(resources.Size());
    for (unsigned i = 0; i < resources.Size(); ++i)
        ret[i] = GetResourceName(resources[i]);

    return ret;
}

template <class T> ResourceRefList GetResourceRefList(const Vector<SharedPtr<T> >& resources)
{
    return ResourceRefList(T::GetTypeStatic(), GetResourceNames(resources));
}

}


namespace Urho3D
{

static const int MAX_TEXTURE_QUALITY_LEVELS = 3;

class XMLElement;
class XMLFile;


class __attribute__((visibility("default"))) Texture : public ResourceWithMetadata, public GPUObject
{
    public: using ClassName = Texture; using BaseClassName = ResourceWithMetadata; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Texture", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Texture(Context* context);

    ~Texture() override;






    void SetNumLevels(unsigned levels);

    void SetFilterMode(TextureFilterMode mode);

    void SetAddressMode(TextureCoordinate coord, TextureAddressMode mode);

    void SetAnisotropy(unsigned level);

    void SetShadowCompare(bool enable);

    void SetBorderColor(const Color& color);

    void SetSRGB(bool enable);

    void SetBackupTexture(Texture* texture);

    void SetMipsToSkip(MaterialQuality quality, int toSkip);


    unsigned GetFormat() const { return format_; }


    bool IsCompressed() const;


    unsigned GetLevels() const { return levels_; }


    int GetWidth() const { return width_; }


    int GetHeight() const { return height_; }


    int GetDepth() const { return depth_; }


    TextureFilterMode GetFilterMode() const { return filterMode_; }


    TextureAddressMode GetAddressMode(TextureCoordinate coord) const { return addressModes_[coord]; }


    unsigned GetAnisotropy() const { return anisotropy_; }


    bool GetShadowCompare() const { return shadowCompare_; }


    const Color& GetBorderColor() const { return borderColor_; }


    bool GetSRGB() const { return sRGB_; }


    int GetMultiSample() const { return multiSample_; }


    bool GetAutoResolve() const { return autoResolve_; }


    bool IsResolveDirty() const { return resolveDirty_; }


    bool GetLevelsDirty() const { return levelsDirty_; }


    Texture* GetBackupTexture() const { return backupTexture_; }


    int GetMipsToSkip(MaterialQuality quality) const;

    int GetLevelWidth(unsigned level) const;

    int GetLevelHeight(unsigned level) const;

    int GetLevelDepth(unsigned level) const;


    TextureUsage GetUsage() const { return usage_; }


    unsigned GetDataSize(int width, int height) const;

    unsigned GetDataSize(int width, int height, int depth) const;

    unsigned GetRowDataSize(int width) const;

    unsigned GetComponents() const;


    bool GetParametersDirty() const;


    void SetParameters(XMLFile* file);

    void SetParameters(const XMLElement& element);

    void SetParametersDirty();

    void UpdateParameters();


    void* GetShaderResourceView() const { return shaderResourceView_; }


    void* GetSampler() const { return sampler_; }


    void* GetResolveTexture() const { return resolveTexture_; }


    unsigned GetTarget() const { return target_; }


    unsigned GetSRGBFormat(unsigned format);


    void SetResolveDirty(bool enable) { resolveDirty_ = enable; }


    void SetLevelsDirty();

    void RegenerateLevels();


    static unsigned CheckMaxLevels(int width, int height, unsigned requestedLevels);

    static unsigned CheckMaxLevels(int width, int height, int depth, unsigned requestedLevels);

    static unsigned GetSRVFormat(unsigned format);

    static unsigned GetDSVFormat(unsigned format);

    static unsigned GetExternalFormat(unsigned format);

    static unsigned GetDataType(unsigned format);

protected:

    void CheckTextureBudget(StringHash type);

    virtual bool Create() { return true; }


    unsigned target_{};


    void* shaderResourceView_{};

    void* sampler_{};

    void* resolveTexture_{};


    unsigned format_{};

    TextureUsage usage_{TEXTURE_STATIC};

    unsigned levels_{};

    unsigned requestedLevels_{};

    int width_{};

    int height_{};

    int depth_{};

    bool shadowCompare_{};

    TextureFilterMode filterMode_{FILTER_DEFAULT};

    TextureAddressMode addressModes_[MAX_COORDS]{ADDRESS_WRAP, ADDRESS_WRAP, ADDRESS_WRAP};

    unsigned anisotropy_{};

    unsigned mipsToSkip_[MAX_TEXTURE_QUALITY_LEVELS]{2, 1, 0};

    Color borderColor_;

    int multiSample_{1};

    bool sRGB_{};

    bool parametersDirty_{true};

    bool autoResolve_{};

    bool resolveDirty_{};

    bool levelsDirty_{};

    SharedPtr<Texture> backupTexture_;
};

}




namespace Urho3D
{


template <class T> class SharedArrayPtr
{
public:

    SharedArrayPtr() :
        ptr_(nullptr),
        refCount_(nullptr)
    {
    }


    SharedArrayPtr(const SharedArrayPtr<T>& rhs) :
        ptr_(rhs.ptr_),
        refCount_(rhs.refCount_)
    {
        AddRef();
    }


    explicit SharedArrayPtr(T* ptr) :
        ptr_(ptr),
        refCount_(new RefCount())
    {
        AddRef();
    }


    ~SharedArrayPtr()
    {
        ReleaseRef();
    }


    SharedArrayPtr<T>& operator =(const SharedArrayPtr<T>& rhs)
    {
        if (ptr_ == rhs.ptr_)
            return *this;

        ReleaseRef();
        ptr_ = rhs.ptr_;
        refCount_ = rhs.refCount_;
        AddRef();

        return *this;
    }


    SharedArrayPtr<T>& operator =(T* ptr)
    {
        if (ptr_ == ptr)
            return *this;

        ReleaseRef();

        if (ptr)
        {
            ptr_ = ptr;
            refCount_ = new RefCount();
            AddRef();
        }

        return *this;
    }


    T* operator ->() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 101, __PRETTY_FUNCTION__));
        return ptr_;
    }


    T& operator *() const
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 108, __PRETTY_FUNCTION__));
        return *ptr_;
    }


    T& operator [](int index)
    {
        ((ptr_) ? static_cast<void> (0) : __assert_fail ("ptr_", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 115, __PRETTY_FUNCTION__));
        return ptr_[index];
    }


    bool operator ==(const SharedArrayPtr<T>& rhs) const { return ptr_ == rhs.ptr_; }


    bool operator !=(const SharedArrayPtr<T>& rhs) const { return ptr_ != rhs.ptr_; }


    bool operator <(const SharedArrayPtr<T>& rhs) const { return ptr_ < rhs.ptr_; }


    operator T*() const { return ptr_; }


    void Reset() { ReleaseRef(); }


    template <class U> void StaticCast(const SharedArrayPtr<U>& rhs)
    {
        ReleaseRef();
        ptr_ = static_cast<T*>(rhs.Get());
        refCount_ = rhs.RefCountPtr();
        AddRef();
    }


    template <class U> void ReinterpretCast(const SharedArrayPtr<U>& rhs)
    {
        ReleaseRef();
        ptr_ = reinterpret_cast<T*>(rhs.Get());
        refCount_ = rhs.RefCountPtr();
        AddRef();
    }


    bool Null() const { return ptr_ == 0; }


    bool NotNull() const { return ptr_ != 0; }


    T* Get() const { return ptr_; }


    int Refs() const { return refCount_ ? refCount_->refs_ : 0; }


    int WeakRefs() const { return refCount_ ? refCount_->weakRefs_ : 0; }


    RefCount* RefCountPtr() const { return refCount_; }


    unsigned ToHash() const { return (unsigned)((size_t)ptr_ / sizeof(T)); }

private:

    template <class U> SharedArrayPtr<T>& operator =(const SharedArrayPtr<U>& rhs);


    void AddRef()
    {
        if (refCount_)
        {
            ((refCount_->refs_ >= 0) ? static_cast<void> (0) : __assert_fail ("refCount_->refs_ >= 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 182, __PRETTY_FUNCTION__));
            ++(refCount_->refs_);
        }
    }


    void ReleaseRef()
    {
        if (refCount_)
        {
            ((refCount_->refs_ > 0) ? static_cast<void> (0) : __assert_fail ("refCount_->refs_ > 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 192, __PRETTY_FUNCTION__));
            --(refCount_->refs_);
            if (!refCount_->refs_)
            {
                refCount_->refs_ = -1;
                delete[] ptr_;
            }

            if (refCount_->refs_ < 0 && !refCount_->weakRefs_)
                delete refCount_;
        }

        ptr_ = nullptr;
        refCount_ = nullptr;
    }


    T* ptr_;

    RefCount* refCount_;
};


template <class T, class U> SharedArrayPtr<T> StaticCast(const SharedArrayPtr<U>& ptr)
{
    SharedArrayPtr<T> ret;
    ret.StaticCast(ptr);
    return ret;
}


template <class T, class U> SharedArrayPtr<T> ReinterpretCast(const SharedArrayPtr<U>& ptr)
{
    SharedArrayPtr<T> ret;
    ret.ReinterpretCast(ptr);
    return ret;
}


template <class T> class WeakArrayPtr
{
public:

    WeakArrayPtr() :
        ptr_(0),
        refCount_(nullptr)
    {
    }


    WeakArrayPtr(const WeakArrayPtr<T>& rhs) :
        ptr_(rhs.ptr_),
        refCount_(rhs.refCount_)
    {
        AddRef();
    }


    explicit WeakArrayPtr(const SharedArrayPtr<T>& rhs) :
        ptr_(rhs.Get()),
        refCount_(rhs.RefCountPtr())
    {
        AddRef();
    }


    ~WeakArrayPtr()
    {
        ReleaseRef();
    }


    WeakArrayPtr<T>& operator =(const SharedArrayPtr<T>& rhs)
    {
        if (ptr_ == rhs.Get() && refCount_ == rhs.RefCountPtr())
            return *this;

        ReleaseRef();
        ptr_ = rhs.Get();
        refCount_ = rhs.RefCountPtr();
        AddRef();

        return *this;
    }


    WeakArrayPtr<T>& operator =(const WeakArrayPtr<T>& rhs)
    {
        if (ptr_ == rhs.ptr_ && refCount_ == rhs.refCount_)
            return *this;

        ReleaseRef();
        ptr_ = rhs.ptr_;
        refCount_ = rhs.refCount_;
        AddRef();

        return *this;
    }


    SharedArrayPtr<T> Lock() const
    {
        if (Expired())
            return SharedArrayPtr<T>();
        else
            return SharedArrayPtr<T>(ptr_, refCount_);
    }


    T* Get() const
    {
        if (Expired())
            return 0;
        else
            return ptr_;
    }


    T* operator ->() const
    {
        T* rawPtr = Get();
        ((rawPtr) ? static_cast<void> (0) : __assert_fail ("rawPtr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 313, __PRETTY_FUNCTION__));
        return rawPtr;
    }


    T& operator *() const
    {
        T* rawPtr = Get();
        ((rawPtr) ? static_cast<void> (0) : __assert_fail ("rawPtr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 321, __PRETTY_FUNCTION__));
        return *rawPtr;
    }


    T& operator [](const int index)
    {
        T* rawPtr = Get();
        ((rawPtr) ? static_cast<void> (0) : __assert_fail ("rawPtr", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 329, __PRETTY_FUNCTION__));
        return (*rawPtr)[index];
    }


    bool operator ==(const WeakArrayPtr<T>& rhs) const { return ptr_ == rhs.ptr_ && refCount_ == rhs.refCount_; }


    bool operator !=(const WeakArrayPtr<T>& rhs) const { return ptr_ != rhs.ptr_ || refCount_ != rhs.refCount_; }


    bool operator <(const WeakArrayPtr<T>& rhs) const { return ptr_ < rhs.ptr_; }


    operator T*() const { return Get(); }


    void Reset() { ReleaseRef(); }


    template <class U> void StaticCast(const WeakArrayPtr<U>& rhs)
    {
        ReleaseRef();
        ptr_ = static_cast<T*>(rhs.Get());
        refCount_ = rhs.refCount_;
        AddRef();
    }


    template <class U> void DynamicCast(const WeakArrayPtr<U>& rhs)
    {
        ReleaseRef();
        ptr_ = dynamic_cast<T*>(rhs.Get());

        if (ptr_)
        {
            refCount_ = rhs.refCount_;
            AddRef();
        }
        else
            refCount_ = 0;
    }


    bool Null() const { return refCount_ == 0; }


    bool NotNull() const { return refCount_ != 0; }


    int Refs() const { return (refCount_ && refCount_->refs_ >= 0) ? refCount_->refs_ : 0; }


    int WeakRefs() const { return refCount_ ? refCount_->weakRefs_ : 0; }


    bool Expired() const { return refCount_ ? refCount_->refs_ < 0 : true; }


    RefCount* RefCountPtr() const { return refCount_; }


    unsigned ToHash() const { return (unsigned)((size_t)ptr_ / sizeof(T)); }

private:

    template <class U> WeakArrayPtr<T>& operator =(const WeakArrayPtr<U>& rhs);


    void AddRef()
    {
        if (refCount_)
        {
            ((refCount_->weakRefs_ >= 0) ? static_cast<void> (0) : __assert_fail ("refCount_->weakRefs_ >= 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 402, __PRETTY_FUNCTION__));
            ++(refCount_->weakRefs_);
        }
    }


    void ReleaseRef()
    {
        if (refCount_)
        {
            ((refCount_->weakRefs_ >= 0) ? static_cast<void> (0) : __assert_fail ("refCount_->weakRefs_ >= 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/ArrayPtr.h", 412, __PRETTY_FUNCTION__));

            if (refCount_->weakRefs_ > 0)
                --(refCount_->weakRefs_);

            if (Expired() && !refCount_->weakRefs_)
                delete refCount_;
        }

        ptr_ = 0;
        refCount_ = 0;
    }


    T* ptr_;

    RefCount* refCount_;
};


template <class T, class U> WeakArrayPtr<T> StaticCast(const WeakArrayPtr<U>& ptr)
{
    WeakArrayPtr<T> ret;
    ret.StaticCast(ptr);
    return ret;
}


template <class T, class U> WeakArrayPtr<T> ReinterpretCast(const WeakArrayPtr<U>& ptr)
{
    WeakArrayPtr<T> ret;
    ret.ReinterpretCast(ptr);
    return ret;
}

}


namespace Urho3D
{

class Color;
class IntRect;
class IntVector2;
class IntVector3;
class Quaternion;
class Rect;
class Vector2;
class Vector3;
class Vector4;


class __attribute__((visibility("default"))) Serializer
{
public:

    virtual ~Serializer();


    virtual unsigned Write(const void* data, unsigned size) = 0;


    bool WriteInt64(long long value);

    bool WriteInt(int value);

    bool WriteShort(short value);

    bool WriteByte(signed char value);

    bool WriteUInt64(unsigned long long value);

    bool WriteUInt(unsigned value);

    bool WriteUShort(unsigned short value);

    bool WriteUByte(unsigned char value);

    bool WriteBool(bool value);

    bool WriteFloat(float value);

    bool WriteDouble(double value);

    bool WriteIntRect(const IntRect& value);

    bool WriteIntVector2(const IntVector2& value);

    bool WriteIntVector3(const IntVector3& value);

    bool WriteRect(const Rect& value);

    bool WriteVector2(const Vector2& value);

    bool WriteVector3(const Vector3& value);

    bool WritePackedVector3(const Vector3& value, float maxAbsCoord);

    bool WriteVector4(const Vector4& value);

    bool WriteQuaternion(const Quaternion& value);

    bool WritePackedQuaternion(const Quaternion& value);

    bool WriteMatrix3(const Matrix3& value);

    bool WriteMatrix3x4(const Matrix3x4& value);

    bool WriteMatrix4(const Matrix4& value);

    bool WriteColor(const Color& value);

    bool WriteBoundingBox(const BoundingBox& value);

    bool WriteString(const String& value);

    bool WriteFileID(const String& value);

    bool WriteStringHash(const StringHash& value);

    bool WriteBuffer(const PODVector<unsigned char>& value);

    bool WriteResourceRef(const ResourceRef& value);

    bool WriteResourceRefList(const ResourceRefList& value);

    bool WriteVariant(const Variant& value);

    bool WriteVariantData(const Variant& value);

    bool WriteVariantVector(const VariantVector& value);

    bool WriteStringVector(const StringVector& value);

    bool WriteVariantMap(const VariantMap& value);

    bool WriteVLE(unsigned value);

    bool WriteNetID(unsigned value);

    bool WriteLine(const String& value);
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) Deserializer
{
public:

    Deserializer();

    explicit Deserializer(unsigned size);

    virtual ~Deserializer();


    virtual unsigned Read(void* dest, unsigned size) = 0;

    virtual unsigned Seek(unsigned position) = 0;

    virtual const String& GetName() const;

    virtual unsigned GetChecksum();

    virtual bool IsEof() const { return position_ >= size_; }


    unsigned SeekRelative(int delta);

    unsigned GetPosition() const { return position_; }

    unsigned Tell() const { return position_; }


    unsigned GetSize() const { return size_; }


    long long ReadInt64();

    int ReadInt();

    short ReadShort();

    signed char ReadByte();

    unsigned long long ReadUInt64();

    unsigned ReadUInt();

    unsigned short ReadUShort();

    unsigned char ReadUByte();

    bool ReadBool();

    float ReadFloat();

    double ReadDouble();

    IntRect ReadIntRect();

    IntVector2 ReadIntVector2();

    IntVector3 ReadIntVector3();

    Rect ReadRect();

    Vector2 ReadVector2();

    Vector3 ReadVector3();

    Vector3 ReadPackedVector3(float maxAbsCoord);

    Vector4 ReadVector4();

    Quaternion ReadQuaternion();

    Quaternion ReadPackedQuaternion();

    Matrix3 ReadMatrix3();

    Matrix3x4 ReadMatrix3x4();

    Matrix4 ReadMatrix4();

    Color ReadColor();

    BoundingBox ReadBoundingBox();

    String ReadString();

    String ReadFileID();

    StringHash ReadStringHash();

    PODVector<unsigned char> ReadBuffer();

    ResourceRef ReadResourceRef();

    ResourceRefList ReadResourceRefList();

    Variant ReadVariant();

    Variant ReadVariant(VariantType type);

    VariantVector ReadVariantVector();

    StringVector ReadStringVector();

    VariantMap ReadVariantMap();

    unsigned ReadVLE();

    unsigned ReadNetID();

    String ReadLine();

protected:

    unsigned position_;

    unsigned size_;
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) AbstractFile : public Deserializer, public Serializer
{
public:

    AbstractFile() : Deserializer() { }

    explicit AbstractFile(unsigned int size) : Deserializer(size) { }

    ~AbstractFile() override = default;
};

}






namespace Urho3D
{
enum FileMode
{
    FILE_READ = 0,
    FILE_WRITE,
    FILE_READWRITE
};

class PackageFile;


class __attribute__((visibility("default"))) File : public Object, public AbstractFile
{
    public: using ClassName = File; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("File", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit File(Context* context);

    File(Context* context, const String& fileName, FileMode mode = FILE_READ);

    File(Context* context, PackageFile* package, const String& fileName);

    ~File() override;


    unsigned Read(void* dest, unsigned size) override;

    unsigned Seek(unsigned position) override;

    unsigned Write(const void* data, unsigned size) override;


    const String& GetName() const override { return fileName_; }


    unsigned GetChecksum() override;


    bool Open(const String& fileName, FileMode mode = FILE_READ);

    bool Open(PackageFile* package, const String& fileName);

    void Close();

    void Flush();

    void SetName(const String& name);


    FileMode GetMode() const { return mode_; }


    bool IsOpen() const;


    void* GetHandle() const { return handle_; }


    bool IsPackaged() const { return offset_ != 0; }

private:

    bool OpenInternal(const String& fileName, FileMode mode, bool fromPackage = false);

    bool ReadInternal(void* dest, unsigned size);

    void SeekInternal(unsigned newPosition);


    String fileName_;

    FileMode mode_;

    void* handle_;





    SharedArrayPtr<unsigned char> readBuffer_;

    SharedArrayPtr<unsigned char> inputBuffer_;

    unsigned readBufferOffset_;

    unsigned readBufferSize_;

    unsigned offset_;

    unsigned checksum_;

    bool compressed_;

    bool readSyncNeeded_;

    bool writeSyncNeeded_;
};

}

namespace Urho3D
{


struct ListNodeBase
{

    ListNodeBase() :
        prev_(nullptr),
        next_(nullptr)
    {
    }


    ListNodeBase* prev_;

    ListNodeBase* next_;
};


struct ListIteratorBase
{

    ListIteratorBase() :
        ptr_(nullptr)
    {
    }


    explicit ListIteratorBase(ListNodeBase* ptr) :
        ptr_(ptr)
    {
    }


    bool operator ==(const ListIteratorBase& rhs) const { return ptr_ == rhs.ptr_; }


    bool operator !=(const ListIteratorBase& rhs) const { return ptr_ != rhs.ptr_; }


    void GotoNext()
    {
        if (ptr_)
            ptr_ = ptr_->next_;
    }


    void GotoPrev()
    {
        if (ptr_)
            ptr_ = ptr_->prev_;
    }


    ListNodeBase* ptr_;
};


class __attribute__((visibility("default"))) ListBase
{
public:

    ListBase() :
        head_(nullptr),
        tail_(nullptr),
        allocator_(nullptr),
        size_(0)
    {
    }


    void Swap(ListBase& rhs)
    {
        Urho3D::Swap(head_, rhs.head_);
        Urho3D::Swap(tail_, rhs.tail_);
        Urho3D::Swap(allocator_, rhs.allocator_);
        Urho3D::Swap(size_, rhs.size_);
    }

protected:

    ListNodeBase* head_;

    ListNodeBase* tail_;

    AllocatorBlock* allocator_;

    unsigned size_;
};

}



namespace Urho3D
{


template <class T> class List : public ListBase
{
public:

    struct Node : public ListNodeBase
    {

        Node() = default;


        explicit Node(const T& value) :
            value_(value)
        {
        }


        T value_;


        Node* Next() const { return static_cast<Node*>(next_); }


        Node* Prev() { return static_cast<Node*>(prev_); }
    };


    struct Iterator : public ListIteratorBase
    {

        Iterator() = default;


        explicit Iterator(Node* ptr) :
            ListIteratorBase(ptr)
        {
        }


        Iterator& operator ++()
        {
            GotoNext();
            return *this;
        }


        Iterator operator ++(int)
        {
            Iterator it = *this;
            GotoNext();
            return it;
        }


        Iterator& operator --()
        {
            GotoPrev();
            return *this;
        }


        Iterator operator --(int)
        {
            Iterator it = *this;
            GotoPrev();
            return it;
        }


        T* operator ->() const { return &(static_cast<Node*>(ptr_))->value_; }


        T& operator *() const { return (static_cast<Node*>(ptr_))->value_; }
    };


    struct ConstIterator : public ListIteratorBase
    {

        ConstIterator() = default;


        explicit ConstIterator(Node* ptr) :
            ListIteratorBase(ptr)
        {
        }


        ConstIterator(const Iterator& rhs) :
            ListIteratorBase(rhs.ptr_)
        {
        }


        ConstIterator& operator =(const Iterator& rhs)
        {
            ptr_ = rhs.ptr_;
            return *this;
        }


        ConstIterator& operator ++()
        {
            GotoNext();
            return *this;
        }


        ConstIterator operator ++(int)
        {
            ConstIterator it = *this;
            GotoNext();
            return it;
        }


        ConstIterator& operator --()
        {
            GotoPrev();
            return *this;
        }


        ConstIterator operator --(int)
        {
            ConstIterator it = *this;
            GotoPrev();
            return it;
        }


        const T* operator ->() const { return &(static_cast<Node*>(ptr_))->value_; }


        const T& operator *() const { return (static_cast<Node*>(ptr_))->value_; }
    };


    List()
    {
        allocator_ = AllocatorInitialize((unsigned)sizeof(Node));
        head_ = tail_ = ReserveNode();
    }


    List(const List<T>& list)
    {

        allocator_ = AllocatorInitialize((unsigned)sizeof(Node), list.Size() + 1);
        head_ = tail_ = ReserveNode();
        *this = list;
    }


    List(List<T> && list) noexcept
    {
        Swap(list);
    }


    List(const std::initializer_list<T>& list) : List()
    {
        for (auto it = list.begin(); it != list.end(); it++)
        {
            Push(*it);
        }
    }


    ~List()
    {
        Clear();
        FreeNode(Tail());
        AllocatorUninitialize(allocator_);
    }


    List& operator =(const List<T>& rhs)
    {

        if (&rhs != this)
        {
            Clear();
            Insert(End(), rhs);
        }
        return *this;
    }


    List& operator =(List<T> && rhs) noexcept
    {
        ((&rhs != this) ? static_cast<void> (0) : __assert_fail ("&rhs != this", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/AngelScript/../IO/../Container/List.h", 222, __PRETTY_FUNCTION__));
        Swap(rhs);
        return *this;
    }


    List& operator +=(const T& rhs)
    {
        Push(rhs);
        return *this;
    }


    List& operator +=(const List<T>& rhs)
    {
        Insert(End(), rhs);
        return *this;
    }


    bool operator ==(const List<T>& rhs) const
    {
        if (rhs.size_ != size_)
            return false;

        ConstIterator i = Begin();
        ConstIterator j = rhs.Begin();
        while (i != End())
        {
            if (*i != *j)
                return false;
            ++i;
            ++j;
        }

        return true;
    }


    bool operator !=(const List<T>& rhs) const
    {
        if (rhs.size_ != size_)
            return true;

        ConstIterator i = Begin();
        ConstIterator j = rhs.Begin();
        while (i != End())
        {
            if (*i != *j)
                return true;
            ++i;
            ++j;
        }

        return false;
    }


    void Push(const T& value) { InsertNode(Tail(), value); }


    void PushFront(const T& value) { InsertNode(Head(), value); }


    void Insert(const Iterator& dest, const T& value) { InsertNode(static_cast<Node*>(dest.ptr_), value); }


    void Insert(const Iterator& dest, const List<T>& list)
    {
        auto* destNode = static_cast<Node*>(dest.ptr_);
        ConstIterator it = list.Begin();
        ConstIterator end = list.End();
        while (it != end)
            InsertNode(destNode, *it++);
    }


    void Insert(const Iterator& dest, const ConstIterator& start, const ConstIterator& end)
    {
        auto* destNode = static_cast<Node*>(dest.ptr_);
        ConstIterator it = start;
        while (it != end)
            InsertNode(destNode, *it++);
    }


    void Insert(const Iterator& dest, const T* start, const T* end)
    {
        auto* destNode = static_cast<Node*>(dest.ptr_);
        const T* ptr = start;
        while (ptr != end)
            InsertNode(destNode, *ptr++);
    }


    void Pop()
    {
        if (size_)
            Erase(--End());
    }


    void PopFront()
    {
        if (size_)
            Erase(Begin());
    }


    Iterator Erase(Iterator it)
    {
        return Iterator(EraseNode(static_cast<Node*>(it.ptr_)));
    }


    Iterator Erase(const Iterator& start, const Iterator& end)
    {
        Iterator it = start;
        while (it != end)
            it = Erase(it);

        return it;
    }


    void Clear()
    {
        if (Size())
        {
            for (Iterator i = Begin(); i != End();)
            {
                FreeNode(static_cast<Node*>(i++.ptr_));
                i.ptr_->prev_ = 0;
            }

            head_ = tail_;
            size_ = 0;
        }
    }


    void Resize(unsigned newSize)
    {
        while (size_ > newSize)
            Pop();

        while (size_ < newSize)
            InsertNode(Tail(), T());
    }


    Iterator Find(const T& value)
    {
        Iterator it = Begin();
        while (it != End() && *it != value)
            ++it;
        return it;
    }


    ConstIterator Find(const T& value) const
    {
        ConstIterator it = Begin();
        while (it != End() && *it != value)
            ++it;
        return it;
    }


    bool Contains(const T& value) const { return Find(value) != End(); }


    Iterator Begin() { return Iterator(Head()); }


    ConstIterator Begin() const { return ConstIterator(Head()); }


    Iterator End() { return Iterator(Tail()); }


    ConstIterator End() const { return ConstIterator(Tail()); }


    T& Front() { return *Begin(); }


    const T& Front() const { return *Begin(); }


    T& Back() { return *(--End()); }


    const T& Back() const { return *(--End()); }


    unsigned Size() const { return size_; }


    bool Empty() const { return size_ == 0; }

private:

    Node* Head() const { return static_cast<Node*>(head_); }


    Node* Tail() const { return static_cast<Node*>(tail_); }


    void InsertNode(Node* dest, const T& value)
    {
        if (!dest)
            return;

        Node* newNode = ReserveNode(value);
        Node* prev = dest->Prev();
        newNode->next_ = dest;
        newNode->prev_ = prev;
        if (prev)
            prev->next_ = newNode;
        dest->prev_ = newNode;


        if (dest == Head())
            head_ = newNode;

        ++size_;
    }


    Node* EraseNode(Node* node)
    {

        if (!node || node == tail_)
            return Tail();

        Node* prev = node->Prev();
        Node* next = node->Next();
        if (prev)
            prev->next_ = next;
        next->prev_ = prev;


        if (node == Head())
            head_ = next;

        FreeNode(node);
        --size_;

        return next;
    }


    Node* ReserveNode()
    {
        auto* newNode = static_cast<Node*>(AllocatorReserve(allocator_));
        new(newNode) Node();
        return newNode;
    }


    Node* ReserveNode(const T& value)
    {
        auto* newNode = static_cast<Node*>(AllocatorReserve(allocator_));
        new(newNode) Node(value);
        return newNode;
    }


    void FreeNode(Node* node)
    {
        (node)->~Node();
        AllocatorFree(allocator_, node);
    }
};

template <class T> typename Urho3D::List<T>::ConstIterator begin(const Urho3D::List<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::List<T>::ConstIterator end(const Urho3D::List<T>& v) { return v.End(); }

template <class T> typename Urho3D::List<T>::Iterator begin(Urho3D::List<T>& v) { return v.Begin(); }

template <class T> typename Urho3D::List<T>::Iterator end(Urho3D::List<T>& v) { return v.End(); }

}



namespace Urho3D
{


__attribute__((visibility("default"))) bool ToBool(const String& source);

__attribute__((visibility("default"))) bool ToBool(const char* source);

__attribute__((visibility("default"))) float ToFloat(const String& source);

__attribute__((visibility("default"))) float ToFloat(const char* source);

__attribute__((visibility("default"))) double ToDouble(const String& source);

__attribute__((visibility("default"))) double ToDouble(const char* source);

__attribute__((visibility("default"))) int ToInt(const String& source, int base = 10);

__attribute__((visibility("default"))) int ToInt(const char* source, int base = 10);

__attribute__((visibility("default"))) unsigned ToUInt(const String& source, int base = 10);

__attribute__((visibility("default"))) unsigned ToUInt(const char* source, int base = 10);

__attribute__((visibility("default"))) long long ToInt64(const String& source, int base = 10);

__attribute__((visibility("default"))) long long ToInt64(const char* source, int base = 10);

__attribute__((visibility("default"))) unsigned long long ToUInt64(const String& source, int base = 10);

__attribute__((visibility("default"))) unsigned long long ToUInt64(const char* source, int base = 10);

__attribute__((visibility("default"))) Color ToColor(const String& source);

__attribute__((visibility("default"))) Color ToColor(const char* source);

__attribute__((visibility("default"))) IntRect ToIntRect(const String& source);

__attribute__((visibility("default"))) IntRect ToIntRect(const char* source);

__attribute__((visibility("default"))) IntVector2 ToIntVector2(const String& source);

__attribute__((visibility("default"))) IntVector2 ToIntVector2(const char* source);

__attribute__((visibility("default"))) IntVector3 ToIntVector3(const String& source);

__attribute__((visibility("default"))) IntVector3 ToIntVector3(const char* source);

__attribute__((visibility("default"))) Quaternion ToQuaternion(const String& source);

__attribute__((visibility("default"))) Quaternion ToQuaternion(const char* source);

__attribute__((visibility("default"))) Rect ToRect(const String& source);

__attribute__((visibility("default"))) Rect ToRect(const char* source);

__attribute__((visibility("default"))) Vector2 ToVector2(const String& source);

__attribute__((visibility("default"))) Vector2 ToVector2(const char* source);

__attribute__((visibility("default"))) Vector3 ToVector3(const String& source);

__attribute__((visibility("default"))) Vector3 ToVector3(const char* source);

__attribute__((visibility("default"))) Vector4 ToVector4(const String& source, bool allowMissingCoords = false);

__attribute__((visibility("default"))) Vector4 ToVector4(const char* source, bool allowMissingCoords = false);

__attribute__((visibility("default"))) Variant ToVectorVariant(const String& source);

__attribute__((visibility("default"))) Variant ToVectorVariant(const char* source);

__attribute__((visibility("default"))) Matrix3 ToMatrix3(const String& source);

__attribute__((visibility("default"))) Matrix3 ToMatrix3(const char* source);

__attribute__((visibility("default"))) Matrix3x4 ToMatrix3x4(const String& source);

__attribute__((visibility("default"))) Matrix3x4 ToMatrix3x4(const char* source);

__attribute__((visibility("default"))) Matrix4 ToMatrix4(const String& source);

__attribute__((visibility("default"))) Matrix4 ToMatrix4(const char* source);

__attribute__((visibility("default"))) String ToString(void* value);

__attribute__((visibility("default"))) String ToStringHex(unsigned value);

__attribute__((visibility("default"))) void BufferToString(String& dest, const void* data, unsigned size);

__attribute__((visibility("default"))) void StringToBuffer(PODVector<unsigned char>& dest, const String& source);

__attribute__((visibility("default"))) void StringToBuffer(PODVector<unsigned char>& dest, const char* source);

__attribute__((visibility("default"))) unsigned GetStringListIndex(const String& value, const String* strings, unsigned defaultIndex, bool caseSensitive = false);

__attribute__((visibility("default"))) unsigned GetStringListIndex(const char* value, const String* strings, unsigned defaultIndex, bool caseSensitive = false);

__attribute__((visibility("default"))) unsigned GetStringListIndex(const char* value, const char** strings, unsigned defaultIndex, bool caseSensitive = false);

__attribute__((visibility("default"))) String ToString(const char* formatString, ...);

__attribute__((visibility("default"))) bool IsAlpha(unsigned ch);

__attribute__((visibility("default"))) bool IsDigit(unsigned ch);

__attribute__((visibility("default"))) unsigned ToUpper(unsigned ch);

__attribute__((visibility("default"))) unsigned ToLower(unsigned ch);

__attribute__((visibility("default"))) String GetFileSizeString(unsigned long long memorySize);

__attribute__((visibility("default"))) PODVector<unsigned char> DecodeBase64(String encodedString);
template <class T> T FromString(const char* source);

template <> inline const char* FromString<const char*>(const char* source) { return source; }
template <> inline String FromString<String>(const char* source) { return source; }
template <> inline bool FromString<bool>(const char* source) { return ToBool(source); }
template <> inline float FromString<float>(const char* source) { return ToFloat(source); }
template <> inline double FromString<double>(const char* source) { return ToDouble(source); }
template <> inline int FromString<int>(const char* source) { return ToInt(source); }
template <> inline unsigned FromString<unsigned>(const char* source) { return ToUInt(source); }
template <> inline Color FromString<Color>(const char* source) { return ToColor(source); }
template <> inline IntRect FromString<IntRect>(const char* source) { return ToIntRect(source); }
template <> inline IntVector2 FromString<IntVector2>(const char* source) { return ToIntVector2(source); }
template <> inline IntVector3 FromString<IntVector3>(const char* source) { return ToIntVector3(source); }
template <> inline Quaternion FromString<Quaternion>(const char* source) { return ToQuaternion(source); }
template <> inline Rect FromString<Rect>(const char* source) { return ToRect(source); }
template <> inline Vector2 FromString<Vector2>(const char* source) { return ToVector2(source); }
template <> inline Vector3 FromString<Vector3>(const char* source) { return ToVector3(source); }
template <> inline Vector4 FromString<Vector4>(const char* source) { return ToVector4(source); }
template <> inline Variant FromString<Variant>(const char* source) { return ToVectorVariant(source); }
template <> inline Matrix3 FromString<Matrix3>(const char* source) { return ToMatrix3(source); }
template <> inline Matrix3x4 FromString<Matrix3x4>(const char* source) { return ToMatrix3x4(source); }
template <> inline Matrix4 FromString<Matrix4>(const char* source) { return ToMatrix4(source); }


template <class T> T FromString(const String& source) { return FromString<T>(source.CString()); }

}


namespace Urho3D
{


static const int LOG_RAW = -1;

static const int LOG_TRACE = 0;

static const int LOG_DEBUG = 1;

static const int LOG_INFO = 2;

static const int LOG_WARNING = 3;

static const int LOG_ERROR = 4;

static const int LOG_NONE = 5;

class File;


struct StoredLogMessage
{

    StoredLogMessage() = default;


    StoredLogMessage(const String& message, int level, bool error) :
        message_(message),
        level_(level),
        error_(error)
    {
    }


    String message_;

    int level_{};

    bool error_{};
};


class __attribute__((visibility("default"))) Log : public Object
{
    public: using ClassName = Log; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Log", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Log(Context* context);

    ~Log() override;


    void Open(const String& fileName);

    void Close();

    void SetLevel(int level);

    void SetTimeStamp(bool enable);

    void SetQuiet(bool quiet);


    int GetLevel() const { return level_; }


    bool GetTimeStamp() const { return timeStamp_; }


    String GetLastMessage() const { return lastMessage_; }


    bool IsQuiet() const { return quiet_; }


    static void Write(int level, const String& message);

    static void WriteRaw(const String& message, bool error = false);

private:

    void HandleEndFrame(StringHash eventType, VariantMap& eventData);


    Mutex logMutex_;

    List<StoredLogMessage> threadMessages_;

    SharedPtr<File> logFile_;

    String lastMessage_;

    int level_;

    bool timeStamp_;

    bool inWrite_;

    bool quiet_;
};
}

namespace Urho3D
{


class __attribute__((visibility("default"))) VectorBuffer : public AbstractFile
{
public:

    VectorBuffer();

    explicit VectorBuffer(const PODVector<unsigned char>& data);

    VectorBuffer(const void* data, unsigned size);

    VectorBuffer(Deserializer& source, unsigned size);


    unsigned Read(void* dest, unsigned size) override;

    unsigned Seek(unsigned position) override;

    unsigned Write(const void* data, unsigned size) override;


    void SetData(const PODVector<unsigned char>& data);

    void SetData(const void* data, unsigned size);

    void SetData(Deserializer& source, unsigned size);

    void Clear();

    void Resize(unsigned size);


    const unsigned char* GetData() const { return size_ ? &buffer_[0] : nullptr; }


    unsigned char* GetModifiableData() { return size_ ? &buffer_[0] : nullptr; }


    const PODVector<unsigned char>& GetBuffer() const { return buffer_; }

private:

    PODVector<unsigned char> buffer_;
};

}



namespace Urho3D
{

class Component;
class Connection;
class Node;
class Scene;
class SceneResolver;

struct NodeReplicationState;


enum CreateMode
{
    REPLICATED = 0,
    LOCAL = 1
};


enum TransformSpace
{
    TS_LOCAL = 0,
    TS_PARENT,
    TS_WORLD
};


struct __attribute__((visibility("default"))) NodeImpl
{

    PODVector<Node*> dependencyNodes_;

    Connection* owner_;

    String name_;

    StringVector tags_;

    StringHash nameHash_;

    mutable VectorBuffer attrBuffer_;

    String basePath_;
};


class __attribute__((visibility("default"))) Node : public Animatable
{
    public: using ClassName = Node; using BaseClassName = Animatable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Node", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class Connection;

public:

    explicit Node(Context* context);

    ~Node() override;

    static void RegisterObject(Context* context);


    bool Load(Deserializer& source) override;

    bool LoadXML(const XMLElement& source) override;

    bool LoadJSON(const JSONValue& source) override;

    bool Save(Serializer& dest) const override;

    bool SaveXML(XMLElement& dest) const override;

    bool SaveJSON(JSONValue& dest) const override;

    void ApplyAttributes() override;


    bool SaveDefaultAttributes() const override { return true; }


    void MarkNetworkUpdate() override;

    virtual void AddReplicationState(NodeReplicationState* state);


    bool SaveXML(Serializer& dest, const String& indentation = "\t") const;

    bool SaveJSON(Serializer& dest, const String& indentation = "\t") const;

    void SetName(const String& name);


    virtual void SetBasePath(const String& basePath);


    void SetTags(const StringVector& tags);

    void AddTag(const String& tag);

    void AddTags(const String& tags, char separator = ';');

    void AddTags(const StringVector& tags);

    bool RemoveTag(const String& tag);

    void RemoveAllTags();


    void SetPosition(const Vector3& position);


    void SetPosition2D(const Vector2& position) { SetPosition(Vector3(position)); }


    void SetPosition2D(float x, float y) { SetPosition(Vector3(x, y, 0.0f)); }


    void SetRotation(const Quaternion& rotation);


    void SetRotation2D(float rotation) { SetRotation(Quaternion(rotation)); }


    void SetDirection(const Vector3& direction);

    void SetScale(float scale);

    void SetScale(const Vector3& scale);


    void SetScale2D(const Vector2& scale) { SetScale(Vector3(scale, 1.0f)); }


    void SetScale2D(float x, float y) { SetScale(Vector3(x, y, 1.0f)); }


    void SetTransform(const Vector3& position, const Quaternion& rotation);

    void SetTransform(const Vector3& position, const Quaternion& rotation, float scale);

    void SetTransform(const Vector3& position, const Quaternion& rotation, const Vector3& scale);

    void SetTransform(const Matrix3x4& matrix);


    void SetTransform2D(const Vector2& position, float rotation) { SetTransform(Vector3(position), Quaternion(rotation)); }


    void SetTransform2D(const Vector2& position, float rotation, float scale)
    {
        SetTransform(Vector3(position), Quaternion(rotation), scale);
    }


    void SetTransform2D(const Vector2& position, float rotation, const Vector2& scale)
    {
        SetTransform(Vector3(position), Quaternion(rotation), Vector3(scale, 1.0f));
    }


    void SetWorldPosition(const Vector3& position);


    void SetWorldPosition2D(const Vector2& position) { SetWorldPosition(Vector3(position)); }


    void SetWorldPosition2D(float x, float y) { SetWorldPosition(Vector3(x, y, 0.0f)); }


    void SetWorldRotation(const Quaternion& rotation);


    void SetWorldRotation2D(float rotation) { SetWorldRotation(Quaternion(rotation)); }


    void SetWorldDirection(const Vector3& direction);

    void SetWorldScale(float scale);

    void SetWorldScale(const Vector3& scale);


    void SetWorldScale2D(const Vector2& scale) { SetWorldScale(Vector3(scale, 1.0f)); }


    void SetWorldScale2D(float x, float y) { SetWorldScale(Vector3(x, y, 1.0f)); }


    void SetWorldTransform(const Vector3& position, const Quaternion& rotation);

    void SetWorldTransform(const Vector3& position, const Quaternion& rotation, float scale);

    void SetWorldTransform(const Vector3& position, const Quaternion& rotation, const Vector3& scale);


    void SetWorldTransform2D(const Vector2& position, float rotation)
    {
        SetWorldTransform(Vector3(position), Quaternion(rotation));
    }


    void SetWorldTransform2D(const Vector2& position, float rotation, float scale)
    {
        SetWorldTransform(Vector3(position), Quaternion(rotation), scale);
    }


    void SetWorldTransform2D(const Vector2& position, float rotation, const Vector2& scale)
    {
        SetWorldTransform(Vector3(position), Quaternion(rotation), Vector3(scale, 1.0f));
    }


    void Translate(const Vector3& delta, TransformSpace space = TS_LOCAL);


    void Translate2D(const Vector2& delta, TransformSpace space = TS_LOCAL) { Translate(Vector3(delta), space); }


    void Rotate(const Quaternion& delta, TransformSpace space = TS_LOCAL);


    void Rotate2D(float delta, TransformSpace space = TS_LOCAL) { Rotate(Quaternion(delta), space); }


    void RotateAround(const Vector3& point, const Quaternion& delta, TransformSpace space = TS_LOCAL);


    void RotateAround2D(const Vector2& point, float delta, TransformSpace space = TS_LOCAL)
    {
        RotateAround(Vector3(point), Quaternion(delta), space);
    }


    void Pitch(float angle, TransformSpace space = TS_LOCAL);

    void Yaw(float angle, TransformSpace space = TS_LOCAL);

    void Roll(float angle, TransformSpace space = TS_LOCAL);

    bool LookAt(const Vector3& target, const Vector3& up = Vector3::UP, TransformSpace space = TS_WORLD);

    void Scale(float scale);

    void Scale(const Vector3& scale);


    void Scale2D(const Vector2& scale) { Scale(Vector3(scale, 1.0f)); }


    void SetEnabled(bool enable);

    void SetDeepEnabled(bool enable);

    void ResetDeepEnabled();

    void SetEnabledRecursive(bool enable);

    void SetOwner(Connection* owner);

    void MarkDirty();

    Node* CreateChild(const String& name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0, bool temporary = false);

    Node* CreateTemporaryChild(const String& name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0);

    void AddChild(Node* node, unsigned index = M_MAX_UNSIGNED);

    void RemoveChild(Node* node);

    void RemoveAllChildren();

    void RemoveChildren(bool removeReplicated, bool removeLocal, bool recursive);

    Component* CreateComponent(StringHash type, CreateMode mode = REPLICATED, unsigned id = 0);

    Component* GetOrCreateComponent(StringHash type, CreateMode mode = REPLICATED, unsigned id = 0);

    Component* CloneComponent(Component* component, unsigned id = 0);

    Component* CloneComponent(Component* component, CreateMode mode, unsigned id = 0);

    void RemoveComponent(Component* component);

    void RemoveComponent(StringHash type);

    void RemoveComponents(bool removeReplicated, bool removeLocal);

    void RemoveComponents(StringHash type);

    void RemoveAllComponents();

    void ReorderComponent(Component* component, unsigned index);

    Node* Clone(CreateMode mode = REPLICATED);

    void Remove();

    void SetParent(Node* parent);

    void SetVar(StringHash key, const Variant& value);

    void AddListener(Component* component);

    void RemoveListener(Component* component);

    template <class T> T* CreateComponent(CreateMode mode = REPLICATED, unsigned id = 0);

    template <class T> T* GetOrCreateComponent(CreateMode mode = REPLICATED, unsigned id = 0);

    template <class T> void RemoveComponent();

    template <class T> void RemoveComponents();


    unsigned GetID() const { return id_; }

    bool IsReplicated() const;


    const String& GetName() const { return impl_->name_; }


    StringHash GetNameHash() const { return impl_->nameHash_; }


    virtual const String& GetBasePath() const { return impl_->basePath_; }


    const StringVector& GetTags() const { return impl_->tags_; }


    bool HasTag(const String& tag) const;


    Node* GetParent() const { return parent_; }


    Scene* GetScene() const { return scene_; }


    bool IsChildOf(Node* node) const;


    bool IsEnabled() const { return enabled_; }


    bool IsEnabledSelf() const { return enabledPrev_; }


    Connection* GetOwner() const { return impl_->owner_; }


    const Vector3& GetPosition() const { return position_; }


    Vector2 GetPosition2D() const { return Vector2(position_.x_, position_.y_); }


    const Quaternion& GetRotation() const { return rotation_; }


    float GetRotation2D() const { return rotation_.RollAngle(); }


    Vector3 GetDirection() const { return rotation_ * Vector3::FORWARD; }


    Vector3 GetUp() const { return rotation_ * Vector3::UP; }


    Vector3 GetRight() const { return rotation_ * Vector3::RIGHT; }


    const Vector3& GetScale() const { return scale_; }


    Vector2 GetScale2D() const { return Vector2(scale_.x_, scale_.y_); }


    Matrix3x4 GetTransform() const { return Matrix3x4(position_, rotation_, scale_); }


    Vector3 GetWorldPosition() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldTransform_.Translation();
    }


    Vector2 GetWorldPosition2D() const
    {
        Vector3 worldPosition = GetWorldPosition();
        return Vector2(worldPosition.x_, worldPosition.y_);
    }


    Quaternion GetWorldRotation() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldRotation_;
    }


    float GetWorldRotation2D() const
    {
        return GetWorldRotation().RollAngle();
    }


    Vector3 GetWorldDirection() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldRotation_ * Vector3::FORWARD;
    }


    Vector3 GetWorldUp() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldRotation_ * Vector3::UP;
    }


    Vector3 GetWorldRight() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldRotation_ * Vector3::RIGHT;
    }


    Vector3 GetWorldScale() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldTransform_.Scale();
    }


    Vector3 GetSignedWorldScale() const;


    Vector2 GetWorldScale2D() const
    {
        Vector3 worldScale = GetWorldScale();
        return Vector2(worldScale.x_, worldScale.y_);
    }


    const Matrix3x4& GetWorldTransform() const
    {
        if (dirty_)
            UpdateWorldTransform();

        return worldTransform_;
    }


    Vector3 LocalToWorld(const Vector3& position) const;

    Vector3 LocalToWorld(const Vector4& vector) const;

    Vector2 LocalToWorld2D(const Vector2& vector) const;

    Vector3 WorldToLocal(const Vector3& position) const;

    Vector3 WorldToLocal(const Vector4& vector) const;

    Vector2 WorldToLocal2D(const Vector2& vector) const;


    bool IsDirty() const { return dirty_; }


    unsigned GetNumChildren(bool recursive = false) const;


    const Vector<SharedPtr<Node> >& GetChildren() const { return children_; }


    void GetChildren(PODVector<Node*>& dest, bool recursive = false) const;

    PODVector<Node*> GetChildren(bool recursive) const;

    void GetChildrenWithComponent(PODVector<Node*>& dest, StringHash type, bool recursive = false) const;

    PODVector<Node*> GetChildrenWithComponent(StringHash type, bool recursive = false) const;

    void GetChildrenWithTag(PODVector<Node*>& dest, const String& tag, bool recursive = false) const;

    PODVector<Node*> GetChildrenWithTag(const String& tag, bool recursive = false) const;


    Node* GetChild(unsigned index) const;

    Node* GetChild(const String& name, bool recursive = false) const;

    Node* GetChild(const char* name, bool recursive = false) const;

    Node* GetChild(StringHash nameHash, bool recursive = false) const;


    unsigned GetNumComponents() const { return components_.Size(); }


    unsigned GetNumNetworkComponents() const;


    const Vector<SharedPtr<Component> >& GetComponents() const { return components_; }


    void GetComponents(PODVector<Component*>& dest, StringHash type, bool recursive = false) const;

    Component* GetComponent(StringHash type, bool recursive = false) const;

    Component* GetParentComponent(StringHash type, bool fullTraversal = false) const;

    bool HasComponent(StringHash type) const;

    const Vector<WeakPtr<Component> > GetListeners() const { return listeners_; }


    const Variant& GetVar(StringHash key) const;


    const VariantMap& GetVars() const { return vars_; }


    template <class T> T* GetDerivedComponent(bool recursive = false) const;

    template <class T> T* GetParentDerivedComponent(bool fullTraversal = false) const;

    template <class T> void GetDerivedComponents(PODVector<T*>& dest, bool recursive = false, bool clearVector = true) const;

    template <class T> void GetChildrenWithComponent(PODVector<Node*>& dest, bool recursive = false) const;

    template <class T> T* GetComponent(bool recursive = false) const;

    template <class T> T* GetParentComponent(bool fullTraversal = false) const;

    template <class T> void GetComponents(PODVector<T*>& dest, bool recursive = false) const;

    template <class T> bool HasComponent() const;


    void SetID(unsigned id);

    void SetScene(Scene* scene);

    void ResetScene();

    void SetNetPositionAttr(const Vector3& value);

    void SetNetRotationAttr(const PODVector<unsigned char>& value);

    void SetNetParentAttr(const PODVector<unsigned char>& value);

    const Vector3& GetNetPositionAttr() const;

    const PODVector<unsigned char>& GetNetRotationAttr() const;

    const PODVector<unsigned char>& GetNetParentAttr() const;

    bool Load(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false,
        CreateMode mode = REPLICATED);

    bool LoadXML(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false,
        CreateMode mode = REPLICATED);

    bool LoadJSON(const JSONValue& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false,
        CreateMode mode = REPLICATED);

    const PODVector<Node*>& GetDependencyNodes() const { return impl_->dependencyNodes_; }


    void PrepareNetworkUpdate();

    void CleanupConnection(Connection* connection);

    void MarkReplicationDirty();

    Node* CreateChild(unsigned id, CreateMode mode, bool temporary = false);

    void AddComponent(Component* component, unsigned id, CreateMode mode);

    unsigned GetNumPersistentChildren() const;

    unsigned GetNumPersistentComponents() const;


    void SetPositionSilent(const Vector3& position) { position_ = position; }


    void SetRotationSilent(const Quaternion& rotation) { rotation_ = rotation; }


    void SetScaleSilent(const Vector3& scale) { scale_ = scale; }


    void SetTransformSilent(const Vector3& position, const Quaternion& rotation, const Vector3& scale);

protected:

    void OnAttributeAnimationAdded() override;

    void OnAttributeAnimationRemoved() override;

    Animatable* FindAttributeAnimationTarget(const String& name, String& outName) override;

private:

    void SetEnabled(bool enable, bool recursive, bool storeSelf);

    Component* SafeCreateComponent(const String& typeName, StringHash type, CreateMode mode, unsigned id);

    void UpdateWorldTransform() const;

    void RemoveChild(Vector<SharedPtr<Node> >::Iterator i);

    void GetChildrenRecursive(PODVector<Node*>& dest) const;

    void GetChildrenWithComponentRecursive(PODVector<Node*>& dest, StringHash type) const;

    void GetChildrenWithTagRecursive(PODVector<Node*>& dest, const String& tag) const;

    void GetComponentsRecursive(PODVector<Component*>& dest, StringHash type) const;

    Node* CloneRecursive(Node* parent, SceneResolver& resolver, CreateMode mode);

    void RemoveComponent(Vector<SharedPtr<Component> >::Iterator i);

    void HandleAttributeAnimationUpdate(StringHash eventType, VariantMap& eventData);


    mutable Matrix3x4 worldTransform_;

    mutable bool dirty_;

    bool enabled_;

    bool enabledPrev_;

protected:

    bool networkUpdate_;

private:

    Node* parent_;

    Scene* scene_;

    unsigned id_;

    Vector3 position_;

    Quaternion rotation_;

    Vector3 scale_;

    mutable Quaternion worldRotation_;

    Vector<SharedPtr<Component> > components_;

    Vector<SharedPtr<Node> > children_;

    Vector<WeakPtr<Component> > listeners_;

    UniquePtr<NodeImpl> impl_;

protected:

    VariantMap vars_;
};

template <class T> T* Node::CreateComponent(CreateMode mode, unsigned id)
{
    return static_cast<T*>(CreateComponent(T::GetTypeStatic(), mode, id));
}

template <class T> T* Node::GetOrCreateComponent(CreateMode mode, unsigned id)
{
    return static_cast<T*>(GetOrCreateComponent(T::GetTypeStatic(), mode, id));
}

template <class T> void Node::RemoveComponent() { RemoveComponent(T::GetTypeStatic()); }

template <class T> void Node::RemoveComponents() { RemoveComponents(T::GetTypeStatic()); }

template <class T> void Node::GetChildrenWithComponent(PODVector<Node*>& dest, bool recursive) const
{
    GetChildrenWithComponent(dest, T::GetTypeStatic(), recursive);
}

template <class T> T* Node::GetComponent(bool recursive) const { return static_cast<T*>(GetComponent(T::GetTypeStatic(), recursive)); }

template <class T> T* Node::GetParentComponent(bool fullTraversal) const { return static_cast<T*>(GetParentComponent(T::GetTypeStatic(), fullTraversal)); }

template <class T> void Node::GetComponents(PODVector<T*>& dest, bool recursive) const
{
    GetComponents(reinterpret_cast<PODVector<Component*>&>(dest), T::GetTypeStatic(), recursive);
}

template <class T> bool Node::HasComponent() const { return HasComponent(T::GetTypeStatic()); }

template <class T> T* Node::GetDerivedComponent(bool recursive) const
{
    for (Vector<SharedPtr<Component> >::ConstIterator i = components_.Begin(); i != components_.End(); ++i)
    {
        auto* component = dynamic_cast<T*>(i->Get());
        if (component)
            return component;
    }

    if (recursive)
    {
        for (Vector<SharedPtr<Node> >::ConstIterator i = children_.Begin(); i != children_.End(); ++i)
        {
            T* component = (*i)->GetDerivedComponent<T>(true);
            if (component)
                return component;
        }
    }

    return nullptr;
}

template <class T> T* Node::GetParentDerivedComponent(bool fullTraversal) const
{
    Node* current = GetParent();
    while (current)
    {
        T* soughtComponent = current->GetDerivedComponent<T>();
        if (soughtComponent)
            return soughtComponent;

        if (fullTraversal)
            current = current->GetParent();
        else
            break;
    }
    return 0;
}

template <class T> void Node::GetDerivedComponents(PODVector<T*>& dest, bool recursive, bool clearVector) const
{
    if (clearVector)
        dest.Clear();

    for (Vector<SharedPtr<Component> >::ConstIterator i = components_.Begin(); i != components_.End(); ++i)
    {
        auto* component = dynamic_cast<T*>(i->Get());
        if (component)
            dest.Push(component);
    }

    if (recursive)
    {
        for (Vector<SharedPtr<Node> >::ConstIterator i = children_.Begin(); i != children_.End(); ++i)
            (*i)->GetDerivedComponents<T>(dest, true, false);
    }
}

}



extern "C" {





extern const char * SDL_GetPlatform (void);



}






extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();
}
typedef enum
{
    SDL_FALSE = 0,
    SDL_TRUE = 1
} SDL_bool;







typedef int8_t Sint8;





typedef uint8_t Uint8;





typedef int16_t Sint16;





typedef uint16_t Uint16;





typedef int32_t Sint32;





typedef uint32_t Uint32;






typedef int64_t Sint64;





typedef uint64_t Uint64;
typedef int SDL_compile_time_assert_uint8[(sizeof(Uint8) == 1) * 2 - 1];
typedef int SDL_compile_time_assert_sint8[(sizeof(Sint8) == 1) * 2 - 1];
typedef int SDL_compile_time_assert_uint16[(sizeof(Uint16) == 2) * 2 - 1];
typedef int SDL_compile_time_assert_sint16[(sizeof(Sint16) == 2) * 2 - 1];
typedef int SDL_compile_time_assert_uint32[(sizeof(Uint32) == 4) * 2 - 1];
typedef int SDL_compile_time_assert_sint32[(sizeof(Sint32) == 4) * 2 - 1];
typedef int SDL_compile_time_assert_uint64[(sizeof(Uint64) == 8) * 2 - 1];
typedef int SDL_compile_time_assert_sint64[(sizeof(Sint64) == 8) * 2 - 1];
typedef enum
{
    DUMMY_ENUM_VALUE
} SDL_DUMMY_ENUM;

typedef int SDL_compile_time_assert_enum[(sizeof(SDL_DUMMY_ENUM) == sizeof(int)) * 2 - 1];







extern "C" {
extern void * SDL_malloc(size_t size);
extern void * SDL_calloc(size_t nmemb, size_t size);
extern void * SDL_realloc(void *mem, size_t size);
extern void SDL_free(void *mem);

typedef void *( *SDL_malloc_func)(size_t size);
typedef void *( *SDL_calloc_func)(size_t nmemb, size_t size);
typedef void *( *SDL_realloc_func)(void *mem, size_t size);
typedef void ( *SDL_free_func)(void *mem);




extern void SDL_GetMemoryFunctions(SDL_malloc_func *malloc_func,
                                                    SDL_calloc_func *calloc_func,
                                                    SDL_realloc_func *realloc_func,
                                                    SDL_free_func *free_func);
extern int SDL_SetMemoryFunctions(SDL_malloc_func malloc_func,
                                                   SDL_calloc_func calloc_func,
                                                   SDL_realloc_func realloc_func,
                                                   SDL_free_func free_func);




extern int SDL_GetNumAllocations(void);

extern char * SDL_getenv(const char *name);
extern int SDL_setenv(const char *name, const char *value, int overwrite);

extern void SDL_qsort(void *base, size_t nmemb, size_t size, int (*compare) (const void *, const void *));

extern int SDL_abs(int x);






extern int SDL_isdigit(int x);
extern int SDL_isspace(int x);
extern int SDL_toupper(int x);
extern int SDL_tolower(int x);

extern void * SDL_memset( void *dst, int c, size_t len);





__attribute__((always_inline)) static __inline__ void SDL_memset4(void *dst, Uint32 val, size_t dwords)
{
    size_t _n = (dwords + 3) / 4;
    Uint32 *_p = static_cast<Uint32 *>(dst);
    Uint32 _val = (val);
    if (dwords == 0)
        return;
    switch (dwords % 4)
    {
        case 0: do { *_p++ = _val;
        case 3: *_p++ = _val;
        case 2: *_p++ = _val;
        case 1: *_p++ = _val;
        } while ( --_n );
    }

}


extern void * SDL_memcpy( void *dst, const void *src, size_t len);

extern void * SDL_memmove( void *dst, const void *src, size_t len);
extern int SDL_memcmp(const void *s1, const void *s2, size_t len);

extern size_t SDL_wcslen(const wchar_t *wstr);
extern size_t SDL_wcslcpy( wchar_t *dst, const wchar_t *src, size_t maxlen);
extern size_t SDL_wcslcat( wchar_t *dst, const wchar_t *src, size_t maxlen);
extern int SDL_wcscmp(const wchar_t *str1, const wchar_t *str2);

extern size_t SDL_strlen(const char *str);
extern size_t SDL_strlcpy( char *dst, const char *src, size_t maxlen);
extern size_t SDL_utf8strlcpy( char *dst, const char *src, size_t dst_bytes);
extern size_t SDL_strlcat( char *dst, const char *src, size_t maxlen);
extern char * SDL_strdup(const char *str);
extern char * SDL_strrev(char *str);
extern char * SDL_strupr(char *str);
extern char * SDL_strlwr(char *str);
extern char * SDL_strchr(const char *str, int c);
extern char * SDL_strrchr(const char *str, int c);
extern char * SDL_strstr(const char *haystack, const char *needle);
extern size_t SDL_utf8strlen(const char *str);

extern char * SDL_itoa(int value, char *str, int radix);
extern char * SDL_uitoa(unsigned int value, char *str, int radix);
extern char * SDL_ltoa(long value, char *str, int radix);
extern char * SDL_ultoa(unsigned long value, char *str, int radix);
extern char * SDL_lltoa(Sint64 value, char *str, int radix);
extern char * SDL_ulltoa(Uint64 value, char *str, int radix);

extern int SDL_atoi(const char *str);
extern double SDL_atof(const char *str);
extern long SDL_strtol(const char *str, char **endp, int base);
extern unsigned long SDL_strtoul(const char *str, char **endp, int base);
extern Sint64 SDL_strtoll(const char *str, char **endp, int base);
extern Uint64 SDL_strtoull(const char *str, char **endp, int base);
extern double SDL_strtod(const char *str, char **endp);

extern int SDL_strcmp(const char *str1, const char *str2);
extern int SDL_strncmp(const char *str1, const char *str2, size_t maxlen);
extern int SDL_strcasecmp(const char *str1, const char *str2);
extern int SDL_strncasecmp(const char *str1, const char *str2, size_t len);

extern int SDL_sscanf(const char *text, const char *fmt, ...) __attribute__ (( format( __scanf__, 2, 2 +1 )));
extern int SDL_vsscanf(const char *text, const char *fmt, va_list ap);
extern int SDL_snprintf( char *text, size_t maxlen, const char *fmt, ... ) __attribute__ (( format( __printf__, 3, 3 +1 )));
extern int SDL_vsnprintf( char *text, size_t maxlen, const char *fmt, va_list ap);







extern double SDL_acos(double x);
extern double SDL_asin(double x);
extern double SDL_atan(double x);
extern double SDL_atan2(double x, double y);
extern double SDL_ceil(double x);
extern double SDL_copysign(double x, double y);
extern double SDL_cos(double x);
extern float SDL_cosf(float x);
extern double SDL_fabs(double x);
extern double SDL_floor(double x);
extern double SDL_log(double x);
extern double SDL_pow(double x, double y);
extern double SDL_scalbn(double x, int n);
extern double SDL_sin(double x);
extern float SDL_sinf(float x);
extern double SDL_sqrt(double x);
extern float SDL_sqrtf(float x);
extern double SDL_tan(double x);
extern float SDL_tanf(float x);
typedef struct _SDL_iconv_t *SDL_iconv_t;
extern SDL_iconv_t SDL_iconv_open(const char *tocode,
                                                   const char *fromcode);
extern int SDL_iconv_close(SDL_iconv_t cd);
extern size_t SDL_iconv(SDL_iconv_t cd, const char **inbuf,
                                         size_t * inbytesleft, char **outbuf,
                                         size_t * outbytesleft);




extern char * SDL_iconv_string(const char *tocode,
                                               const char *fromcode,
                                               const char *inbuf,
                                               size_t inbytesleft);
__attribute__((always_inline)) static __inline__ void *SDL_memcpy4( void *dst, const void *src, size_t dwords)
{
    return SDL_memcpy(dst, src, dwords * 4);
}



}




extern "C" {




extern int SDL_SetError( const char *fmt, ...) __attribute__ (( format( __printf__, 1, 1 +1 )));
extern const char * SDL_GetError(void);
extern void SDL_ClearError(void);
typedef enum
{
    SDL_ENOMEM,
    SDL_EFREAD,
    SDL_EFWRITE,
    SDL_EFSEEK,
    SDL_UNSUPPORTED,
    SDL_LASTERROR
} SDL_errorcode;

extern int SDL_Error(SDL_errorcode code);




}





extern "C" {
struct _SDL_Joystick;
typedef struct _SDL_Joystick SDL_Joystick;


typedef struct {
    Uint8 data[16];
} SDL_JoystickGUID;
typedef Sint32 SDL_JoystickID;

typedef enum
{
    SDL_JOYSTICK_TYPE_UNKNOWN,
    SDL_JOYSTICK_TYPE_GAMECONTROLLER,
    SDL_JOYSTICK_TYPE_WHEEL,
    SDL_JOYSTICK_TYPE_ARCADE_STICK,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK,
    SDL_JOYSTICK_TYPE_DANCE_PAD,
    SDL_JOYSTICK_TYPE_GUITAR,
    SDL_JOYSTICK_TYPE_DRUM_KIT,
    SDL_JOYSTICK_TYPE_ARCADE_PAD,
    SDL_JOYSTICK_TYPE_THROTTLE
} SDL_JoystickType;

typedef enum
{
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY,
    SDL_JOYSTICK_POWER_LOW,
    SDL_JOYSTICK_POWER_MEDIUM,
    SDL_JOYSTICK_POWER_FULL,
    SDL_JOYSTICK_POWER_WIRED,
    SDL_JOYSTICK_POWER_MAX
} SDL_JoystickPowerLevel;
extern void SDL_LockJoysticks(void);
extern void SDL_UnlockJoysticks(void);




extern int SDL_NumJoysticks(void);






extern const char * SDL_JoystickNameForIndex(int device_index);





extern SDL_JoystickGUID SDL_JoystickGetDeviceGUID(int device_index);






extern Uint16 SDL_JoystickGetDeviceVendor(int device_index);






extern Uint16 SDL_JoystickGetDeviceProduct(int device_index);






extern Uint16 SDL_JoystickGetDeviceProductVersion(int device_index);





extern SDL_JoystickType SDL_JoystickGetDeviceType(int device_index);






extern SDL_JoystickID SDL_JoystickGetDeviceInstanceID(int device_index);
extern SDL_Joystick * SDL_JoystickOpen(int device_index);




extern SDL_Joystick * SDL_JoystickFromInstanceID(SDL_JoystickID joyid);





extern const char * SDL_JoystickName(SDL_Joystick * joystick);




extern SDL_JoystickGUID SDL_JoystickGetGUID(SDL_Joystick * joystick);





extern Uint16 SDL_JoystickGetVendor(SDL_Joystick * joystick);





extern Uint16 SDL_JoystickGetProduct(SDL_Joystick * joystick);





extern Uint16 SDL_JoystickGetProductVersion(SDL_Joystick * joystick);




extern SDL_JoystickType SDL_JoystickGetType(SDL_Joystick * joystick);





extern void SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char *pszGUID, int cbGUID);




extern SDL_JoystickGUID SDL_JoystickGetGUIDFromString(const char *pchGUID);




extern SDL_bool SDL_JoystickGetAttached(SDL_Joystick * joystick);




extern SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick * joystick);




extern int SDL_JoystickNumAxes(SDL_Joystick * joystick);







extern int SDL_JoystickNumBalls(SDL_Joystick * joystick);




extern int SDL_JoystickNumHats(SDL_Joystick * joystick);




extern int SDL_JoystickNumButtons(SDL_Joystick * joystick);







extern void SDL_JoystickUpdate(void);
extern int SDL_JoystickEventState(int state);
extern Sint16 SDL_JoystickGetAxis(SDL_Joystick * joystick,
                                                   int axis);
extern SDL_bool SDL_JoystickGetAxisInitialState(SDL_Joystick * joystick,
                                                   int axis, Sint16 *state);
extern Uint8 SDL_JoystickGetHat(SDL_Joystick * joystick,
                                                 int hat);
extern int SDL_JoystickGetBall(SDL_Joystick * joystick,
                                                int ball, int *dx, int *dy);






extern Uint8 SDL_JoystickGetButton(SDL_Joystick * joystick,
                                                    int button);




extern void SDL_JoystickClose(SDL_Joystick * joystick);




extern SDL_JoystickPowerLevel SDL_JoystickCurrentPowerLevel(SDL_Joystick * joystick);



}




extern "C" {
typedef struct SDL_RWops
{



    Sint64 ( * size) (struct SDL_RWops * context);







    Sint64 ( * seek) (struct SDL_RWops * context, Sint64 offset,
                             int whence);







    size_t ( * read) (struct SDL_RWops * context, void *ptr,
                             size_t size, size_t maxnum);







    size_t ( * write) (struct SDL_RWops * context, const void *ptr,
                              size_t size, size_t num);






    int ( * close) (struct SDL_RWops * context);

    Uint32 type;
    union
    {
        struct
        {
            SDL_bool autoclose;
            FILE *fp;
        } stdio;

        struct
        {
            Uint8 *base;
            Uint8 *here;
            Uint8 *stop;
        } mem;
        struct
        {
            void *data1;
            void *data2;
        } unknown;
    } hidden;

} SDL_RWops;
extern SDL_RWops * SDL_RWFromFile(const char *file,
                                                  const char *mode);


extern SDL_RWops * SDL_RWFromFP(FILE * fp,
                                                SDL_bool autoclose);





extern SDL_RWops * SDL_RWFromMem(void *mem, int size);
extern SDL_RWops * SDL_RWFromConstMem(const void *mem,
                                                      int size);




extern SDL_RWops * SDL_AllocRW(void);
extern void SDL_FreeRW(SDL_RWops * area);
extern void * SDL_LoadFile_RW(SDL_RWops * src, size_t *datasize,
                                                    int freesrc);
extern Uint8 SDL_ReadU8(SDL_RWops * src);
extern Uint16 SDL_ReadLE16(SDL_RWops * src);
extern Uint16 SDL_ReadBE16(SDL_RWops * src);
extern Uint32 SDL_ReadLE32(SDL_RWops * src);
extern Uint32 SDL_ReadBE32(SDL_RWops * src);
extern Uint64 SDL_ReadLE64(SDL_RWops * src);
extern Uint64 SDL_ReadBE64(SDL_RWops * src);
extern size_t SDL_WriteU8(SDL_RWops * dst, Uint8 value);
extern size_t SDL_WriteLE16(SDL_RWops * dst, Uint16 value);
extern size_t SDL_WriteBE16(SDL_RWops * dst, Uint16 value);
extern size_t SDL_WriteLE32(SDL_RWops * dst, Uint32 value);
extern size_t SDL_WriteBE32(SDL_RWops * dst, Uint32 value);
extern size_t SDL_WriteLE64(SDL_RWops * dst, Uint64 value);
extern size_t SDL_WriteBE64(SDL_RWops * dst, Uint64 value);




}






extern "C" {
struct _SDL_GameController;
typedef struct _SDL_GameController SDL_GameController;


typedef enum
{
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON,
    SDL_CONTROLLER_BINDTYPE_AXIS,
    SDL_CONTROLLER_BINDTYPE_HAT
} SDL_GameControllerBindType;




typedef struct SDL_GameControllerButtonBind
{
    SDL_GameControllerBindType bindType;
    union
    {
        int button;
        int axis;
        struct {
            int hat;
            int hat_mask;
        } hat;
    } value;

} SDL_GameControllerButtonBind;
extern int SDL_GameControllerAddMappingsFromRW(SDL_RWops * rw, int freerw);
extern int SDL_GameControllerAddMapping(const char* mappingString);






extern int SDL_GameControllerNumMappings(void);






extern char * SDL_GameControllerMappingForIndex(int mapping_index);






extern char * SDL_GameControllerMappingForGUID(SDL_JoystickGUID guid);






extern char * SDL_GameControllerMapping(SDL_GameController * gamecontroller);




extern SDL_bool SDL_IsGameController(int joystick_index);






extern const char * SDL_GameControllerNameForIndex(int joystick_index);
extern SDL_GameController * SDL_GameControllerOpen(int joystick_index);




extern SDL_GameController * SDL_GameControllerFromInstanceID(SDL_JoystickID joyid);




extern const char * SDL_GameControllerName(SDL_GameController *gamecontroller);





extern Uint16 SDL_GameControllerGetVendor(SDL_GameController * gamecontroller);





extern Uint16 SDL_GameControllerGetProduct(SDL_GameController * gamecontroller);





extern Uint16 SDL_GameControllerGetProductVersion(SDL_GameController * gamecontroller);





extern SDL_bool SDL_GameControllerGetAttached(SDL_GameController *gamecontroller);




extern SDL_Joystick * SDL_GameControllerGetJoystick(SDL_GameController *gamecontroller);
extern int SDL_GameControllerEventState(int state);







extern void SDL_GameControllerUpdate(void);
typedef enum
{
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX,
    SDL_CONTROLLER_AXIS_LEFTY,
    SDL_CONTROLLER_AXIS_RIGHTX,
    SDL_CONTROLLER_AXIS_RIGHTY,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
    SDL_CONTROLLER_AXIS_MAX
} SDL_GameControllerAxis;




extern SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const char *pchString);




extern const char* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis);




extern SDL_GameControllerButtonBind
SDL_GameControllerGetBindForAxis(SDL_GameController *gamecontroller,
                                 SDL_GameControllerAxis axis);
extern Sint16
SDL_GameControllerGetAxis(SDL_GameController *gamecontroller,
                          SDL_GameControllerAxis axis);




typedef enum
{
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A,
    SDL_CONTROLLER_BUTTON_B,
    SDL_CONTROLLER_BUTTON_X,
    SDL_CONTROLLER_BUTTON_Y,
    SDL_CONTROLLER_BUTTON_BACK,
    SDL_CONTROLLER_BUTTON_GUIDE,
    SDL_CONTROLLER_BUTTON_START,
    SDL_CONTROLLER_BUTTON_LEFTSTICK,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
    SDL_CONTROLLER_BUTTON_DPAD_UP,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT,
    SDL_CONTROLLER_BUTTON_MAX
} SDL_GameControllerButton;




extern SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const char *pchString);




extern const char* SDL_GameControllerGetStringForButton(SDL_GameControllerButton button);




extern SDL_GameControllerButtonBind
SDL_GameControllerGetBindForButton(SDL_GameController *gamecontroller,
                                   SDL_GameControllerButton button);







extern Uint8 SDL_GameControllerGetButton(SDL_GameController *gamecontroller,
                                                          SDL_GameControllerButton button);




extern void SDL_GameControllerClose(SDL_GameController *gamecontroller);




}


typedef enum
{
    SDL_SCANCODE_UNKNOWN = 0,
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,

    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,

    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,

    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49,
    SDL_SCANCODE_NONUSHASH = 50,
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53,
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,

    SDL_SCANCODE_CAPSLOCK = 57,

    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,

    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73,

    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,

    SDL_SCANCODE_NUMLOCKCLEAR = 83,

    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,

    SDL_SCANCODE_NONUSBACKSLASH = 100,
    SDL_SCANCODE_APPLICATION = 101,
    SDL_SCANCODE_POWER = 102,


    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,




    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,

    SDL_SCANCODE_INTERNATIONAL1 = 135,

    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144,
    SDL_SCANCODE_LANG2 = 145,
    SDL_SCANCODE_LANG3 = 146,
    SDL_SCANCODE_LANG4 = 147,
    SDL_SCANCODE_LANG5 = 148,
    SDL_SCANCODE_LANG6 = 149,
    SDL_SCANCODE_LANG7 = 150,
    SDL_SCANCODE_LANG8 = 151,
    SDL_SCANCODE_LANG9 = 152,

    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,

    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,

    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226,
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230,
    SDL_SCANCODE_RGUI = 231,

    SDL_SCANCODE_MODE = 257,
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    SDL_SCANCODE_DISPLAYSWITCH = 277,

    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,

    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,





    SDL_NUM_SCANCODES = 512

} SDL_Scancode;
typedef Sint32 SDL_Keycode;




enum
{
    SDLK_UNKNOWN = 0,

    SDLK_RETURN = '\r',
    SDLK_ESCAPE = '\033',
    SDLK_BACKSPACE = '\b',
    SDLK_TAB = '\t',
    SDLK_SPACE = ' ',
    SDLK_EXCLAIM = '!',
    SDLK_QUOTEDBL = '"',
    SDLK_HASH = '#',
    SDLK_PERCENT = '%',
    SDLK_DOLLAR = '$',
    SDLK_AMPERSAND = '&',
    SDLK_QUOTE = '\'',
    SDLK_LEFTPAREN = '(',
    SDLK_RIGHTPAREN = ')',
    SDLK_ASTERISK = '*',
    SDLK_PLUS = '+',
    SDLK_COMMA = ',',
    SDLK_MINUS = '-',
    SDLK_PERIOD = '.',
    SDLK_SLASH = '/',
    SDLK_0 = '0',
    SDLK_1 = '1',
    SDLK_2 = '2',
    SDLK_3 = '3',
    SDLK_4 = '4',
    SDLK_5 = '5',
    SDLK_6 = '6',
    SDLK_7 = '7',
    SDLK_8 = '8',
    SDLK_9 = '9',
    SDLK_COLON = ':',
    SDLK_SEMICOLON = ';',
    SDLK_LESS = '<',
    SDLK_EQUALS = '=',
    SDLK_GREATER = '>',
    SDLK_QUESTION = '?',
    SDLK_AT = '@',



    SDLK_LEFTBRACKET = '[',
    SDLK_BACKSLASH = '\\',
    SDLK_RIGHTBRACKET = ']',
    SDLK_CARET = '^',
    SDLK_UNDERSCORE = '_',
    SDLK_BACKQUOTE = '`',
    SDLK_a = 'a',
    SDLK_b = 'b',
    SDLK_c = 'c',
    SDLK_d = 'd',
    SDLK_e = 'e',
    SDLK_f = 'f',
    SDLK_g = 'g',
    SDLK_h = 'h',
    SDLK_i = 'i',
    SDLK_j = 'j',
    SDLK_k = 'k',
    SDLK_l = 'l',
    SDLK_m = 'm',
    SDLK_n = 'n',
    SDLK_o = 'o',
    SDLK_p = 'p',
    SDLK_q = 'q',
    SDLK_r = 'r',
    SDLK_s = 's',
    SDLK_t = 't',
    SDLK_u = 'u',
    SDLK_v = 'v',
    SDLK_w = 'w',
    SDLK_x = 'x',
    SDLK_y = 'y',
    SDLK_z = 'z',

    SDLK_CAPSLOCK = (SDL_SCANCODE_CAPSLOCK | (1<<30)),

    SDLK_F1 = (SDL_SCANCODE_F1 | (1<<30)),
    SDLK_F2 = (SDL_SCANCODE_F2 | (1<<30)),
    SDLK_F3 = (SDL_SCANCODE_F3 | (1<<30)),
    SDLK_F4 = (SDL_SCANCODE_F4 | (1<<30)),
    SDLK_F5 = (SDL_SCANCODE_F5 | (1<<30)),
    SDLK_F6 = (SDL_SCANCODE_F6 | (1<<30)),
    SDLK_F7 = (SDL_SCANCODE_F7 | (1<<30)),
    SDLK_F8 = (SDL_SCANCODE_F8 | (1<<30)),
    SDLK_F9 = (SDL_SCANCODE_F9 | (1<<30)),
    SDLK_F10 = (SDL_SCANCODE_F10 | (1<<30)),
    SDLK_F11 = (SDL_SCANCODE_F11 | (1<<30)),
    SDLK_F12 = (SDL_SCANCODE_F12 | (1<<30)),

    SDLK_PRINTSCREEN = (SDL_SCANCODE_PRINTSCREEN | (1<<30)),
    SDLK_SCROLLLOCK = (SDL_SCANCODE_SCROLLLOCK | (1<<30)),
    SDLK_PAUSE = (SDL_SCANCODE_PAUSE | (1<<30)),
    SDLK_INSERT = (SDL_SCANCODE_INSERT | (1<<30)),
    SDLK_HOME = (SDL_SCANCODE_HOME | (1<<30)),
    SDLK_PAGEUP = (SDL_SCANCODE_PAGEUP | (1<<30)),
    SDLK_DELETE = '\177',
    SDLK_END = (SDL_SCANCODE_END | (1<<30)),
    SDLK_PAGEDOWN = (SDL_SCANCODE_PAGEDOWN | (1<<30)),
    SDLK_RIGHT = (SDL_SCANCODE_RIGHT | (1<<30)),
    SDLK_LEFT = (SDL_SCANCODE_LEFT | (1<<30)),
    SDLK_DOWN = (SDL_SCANCODE_DOWN | (1<<30)),
    SDLK_UP = (SDL_SCANCODE_UP | (1<<30)),

    SDLK_NUMLOCKCLEAR = (SDL_SCANCODE_NUMLOCKCLEAR | (1<<30)),
    SDLK_KP_DIVIDE = (SDL_SCANCODE_KP_DIVIDE | (1<<30)),
    SDLK_KP_MULTIPLY = (SDL_SCANCODE_KP_MULTIPLY | (1<<30)),
    SDLK_KP_MINUS = (SDL_SCANCODE_KP_MINUS | (1<<30)),
    SDLK_KP_PLUS = (SDL_SCANCODE_KP_PLUS | (1<<30)),
    SDLK_KP_ENTER = (SDL_SCANCODE_KP_ENTER | (1<<30)),
    SDLK_KP_1 = (SDL_SCANCODE_KP_1 | (1<<30)),
    SDLK_KP_2 = (SDL_SCANCODE_KP_2 | (1<<30)),
    SDLK_KP_3 = (SDL_SCANCODE_KP_3 | (1<<30)),
    SDLK_KP_4 = (SDL_SCANCODE_KP_4 | (1<<30)),
    SDLK_KP_5 = (SDL_SCANCODE_KP_5 | (1<<30)),
    SDLK_KP_6 = (SDL_SCANCODE_KP_6 | (1<<30)),
    SDLK_KP_7 = (SDL_SCANCODE_KP_7 | (1<<30)),
    SDLK_KP_8 = (SDL_SCANCODE_KP_8 | (1<<30)),
    SDLK_KP_9 = (SDL_SCANCODE_KP_9 | (1<<30)),
    SDLK_KP_0 = (SDL_SCANCODE_KP_0 | (1<<30)),
    SDLK_KP_PERIOD = (SDL_SCANCODE_KP_PERIOD | (1<<30)),

    SDLK_APPLICATION = (SDL_SCANCODE_APPLICATION | (1<<30)),
    SDLK_POWER = (SDL_SCANCODE_POWER | (1<<30)),
    SDLK_KP_EQUALS = (SDL_SCANCODE_KP_EQUALS | (1<<30)),
    SDLK_F13 = (SDL_SCANCODE_F13 | (1<<30)),
    SDLK_F14 = (SDL_SCANCODE_F14 | (1<<30)),
    SDLK_F15 = (SDL_SCANCODE_F15 | (1<<30)),
    SDLK_F16 = (SDL_SCANCODE_F16 | (1<<30)),
    SDLK_F17 = (SDL_SCANCODE_F17 | (1<<30)),
    SDLK_F18 = (SDL_SCANCODE_F18 | (1<<30)),
    SDLK_F19 = (SDL_SCANCODE_F19 | (1<<30)),
    SDLK_F20 = (SDL_SCANCODE_F20 | (1<<30)),
    SDLK_F21 = (SDL_SCANCODE_F21 | (1<<30)),
    SDLK_F22 = (SDL_SCANCODE_F22 | (1<<30)),
    SDLK_F23 = (SDL_SCANCODE_F23 | (1<<30)),
    SDLK_F24 = (SDL_SCANCODE_F24 | (1<<30)),
    SDLK_EXECUTE = (SDL_SCANCODE_EXECUTE | (1<<30)),
    SDLK_HELP = (SDL_SCANCODE_HELP | (1<<30)),
    SDLK_MENU = (SDL_SCANCODE_MENU | (1<<30)),
    SDLK_SELECT = (SDL_SCANCODE_SELECT | (1<<30)),
    SDLK_STOP = (SDL_SCANCODE_STOP | (1<<30)),
    SDLK_AGAIN = (SDL_SCANCODE_AGAIN | (1<<30)),
    SDLK_UNDO = (SDL_SCANCODE_UNDO | (1<<30)),
    SDLK_CUT = (SDL_SCANCODE_CUT | (1<<30)),
    SDLK_COPY = (SDL_SCANCODE_COPY | (1<<30)),
    SDLK_PASTE = (SDL_SCANCODE_PASTE | (1<<30)),
    SDLK_FIND = (SDL_SCANCODE_FIND | (1<<30)),
    SDLK_MUTE = (SDL_SCANCODE_MUTE | (1<<30)),
    SDLK_VOLUMEUP = (SDL_SCANCODE_VOLUMEUP | (1<<30)),
    SDLK_VOLUMEDOWN = (SDL_SCANCODE_VOLUMEDOWN | (1<<30)),
    SDLK_KP_COMMA = (SDL_SCANCODE_KP_COMMA | (1<<30)),
    SDLK_KP_EQUALSAS400 =
        (SDL_SCANCODE_KP_EQUALSAS400 | (1<<30)),

    SDLK_ALTERASE = (SDL_SCANCODE_ALTERASE | (1<<30)),
    SDLK_SYSREQ = (SDL_SCANCODE_SYSREQ | (1<<30)),
    SDLK_CANCEL = (SDL_SCANCODE_CANCEL | (1<<30)),
    SDLK_CLEAR = (SDL_SCANCODE_CLEAR | (1<<30)),
    SDLK_PRIOR = (SDL_SCANCODE_PRIOR | (1<<30)),
    SDLK_RETURN2 = (SDL_SCANCODE_RETURN2 | (1<<30)),
    SDLK_SEPARATOR = (SDL_SCANCODE_SEPARATOR | (1<<30)),
    SDLK_OUT = (SDL_SCANCODE_OUT | (1<<30)),
    SDLK_OPER = (SDL_SCANCODE_OPER | (1<<30)),
    SDLK_CLEARAGAIN = (SDL_SCANCODE_CLEARAGAIN | (1<<30)),
    SDLK_CRSEL = (SDL_SCANCODE_CRSEL | (1<<30)),
    SDLK_EXSEL = (SDL_SCANCODE_EXSEL | (1<<30)),

    SDLK_KP_00 = (SDL_SCANCODE_KP_00 | (1<<30)),
    SDLK_KP_000 = (SDL_SCANCODE_KP_000 | (1<<30)),
    SDLK_THOUSANDSSEPARATOR =
        (SDL_SCANCODE_THOUSANDSSEPARATOR | (1<<30)),
    SDLK_DECIMALSEPARATOR =
        (SDL_SCANCODE_DECIMALSEPARATOR | (1<<30)),
    SDLK_CURRENCYUNIT = (SDL_SCANCODE_CURRENCYUNIT | (1<<30)),
    SDLK_CURRENCYSUBUNIT =
        (SDL_SCANCODE_CURRENCYSUBUNIT | (1<<30)),
    SDLK_KP_LEFTPAREN = (SDL_SCANCODE_KP_LEFTPAREN | (1<<30)),
    SDLK_KP_RIGHTPAREN = (SDL_SCANCODE_KP_RIGHTPAREN | (1<<30)),
    SDLK_KP_LEFTBRACE = (SDL_SCANCODE_KP_LEFTBRACE | (1<<30)),
    SDLK_KP_RIGHTBRACE = (SDL_SCANCODE_KP_RIGHTBRACE | (1<<30)),
    SDLK_KP_TAB = (SDL_SCANCODE_KP_TAB | (1<<30)),
    SDLK_KP_BACKSPACE = (SDL_SCANCODE_KP_BACKSPACE | (1<<30)),
    SDLK_KP_A = (SDL_SCANCODE_KP_A | (1<<30)),
    SDLK_KP_B = (SDL_SCANCODE_KP_B | (1<<30)),
    SDLK_KP_C = (SDL_SCANCODE_KP_C | (1<<30)),
    SDLK_KP_D = (SDL_SCANCODE_KP_D | (1<<30)),
    SDLK_KP_E = (SDL_SCANCODE_KP_E | (1<<30)),
    SDLK_KP_F = (SDL_SCANCODE_KP_F | (1<<30)),
    SDLK_KP_XOR = (SDL_SCANCODE_KP_XOR | (1<<30)),
    SDLK_KP_POWER = (SDL_SCANCODE_KP_POWER | (1<<30)),
    SDLK_KP_PERCENT = (SDL_SCANCODE_KP_PERCENT | (1<<30)),
    SDLK_KP_LESS = (SDL_SCANCODE_KP_LESS | (1<<30)),
    SDLK_KP_GREATER = (SDL_SCANCODE_KP_GREATER | (1<<30)),
    SDLK_KP_AMPERSAND = (SDL_SCANCODE_KP_AMPERSAND | (1<<30)),
    SDLK_KP_DBLAMPERSAND =
        (SDL_SCANCODE_KP_DBLAMPERSAND | (1<<30)),
    SDLK_KP_VERTICALBAR =
        (SDL_SCANCODE_KP_VERTICALBAR | (1<<30)),
    SDLK_KP_DBLVERTICALBAR =
        (SDL_SCANCODE_KP_DBLVERTICALBAR | (1<<30)),
    SDLK_KP_COLON = (SDL_SCANCODE_KP_COLON | (1<<30)),
    SDLK_KP_HASH = (SDL_SCANCODE_KP_HASH | (1<<30)),
    SDLK_KP_SPACE = (SDL_SCANCODE_KP_SPACE | (1<<30)),
    SDLK_KP_AT = (SDL_SCANCODE_KP_AT | (1<<30)),
    SDLK_KP_EXCLAM = (SDL_SCANCODE_KP_EXCLAM | (1<<30)),
    SDLK_KP_MEMSTORE = (SDL_SCANCODE_KP_MEMSTORE | (1<<30)),
    SDLK_KP_MEMRECALL = (SDL_SCANCODE_KP_MEMRECALL | (1<<30)),
    SDLK_KP_MEMCLEAR = (SDL_SCANCODE_KP_MEMCLEAR | (1<<30)),
    SDLK_KP_MEMADD = (SDL_SCANCODE_KP_MEMADD | (1<<30)),
    SDLK_KP_MEMSUBTRACT =
        (SDL_SCANCODE_KP_MEMSUBTRACT | (1<<30)),
    SDLK_KP_MEMMULTIPLY =
        (SDL_SCANCODE_KP_MEMMULTIPLY | (1<<30)),
    SDLK_KP_MEMDIVIDE = (SDL_SCANCODE_KP_MEMDIVIDE | (1<<30)),
    SDLK_KP_PLUSMINUS = (SDL_SCANCODE_KP_PLUSMINUS | (1<<30)),
    SDLK_KP_CLEAR = (SDL_SCANCODE_KP_CLEAR | (1<<30)),
    SDLK_KP_CLEARENTRY = (SDL_SCANCODE_KP_CLEARENTRY | (1<<30)),
    SDLK_KP_BINARY = (SDL_SCANCODE_KP_BINARY | (1<<30)),
    SDLK_KP_OCTAL = (SDL_SCANCODE_KP_OCTAL | (1<<30)),
    SDLK_KP_DECIMAL = (SDL_SCANCODE_KP_DECIMAL | (1<<30)),
    SDLK_KP_HEXADECIMAL =
        (SDL_SCANCODE_KP_HEXADECIMAL | (1<<30)),

    SDLK_LCTRL = (SDL_SCANCODE_LCTRL | (1<<30)),
    SDLK_LSHIFT = (SDL_SCANCODE_LSHIFT | (1<<30)),
    SDLK_LALT = (SDL_SCANCODE_LALT | (1<<30)),
    SDLK_LGUI = (SDL_SCANCODE_LGUI | (1<<30)),
    SDLK_RCTRL = (SDL_SCANCODE_RCTRL | (1<<30)),
    SDLK_RSHIFT = (SDL_SCANCODE_RSHIFT | (1<<30)),
    SDLK_RALT = (SDL_SCANCODE_RALT | (1<<30)),
    SDLK_RGUI = (SDL_SCANCODE_RGUI | (1<<30)),

    SDLK_MODE = (SDL_SCANCODE_MODE | (1<<30)),

    SDLK_AUDIONEXT = (SDL_SCANCODE_AUDIONEXT | (1<<30)),
    SDLK_AUDIOPREV = (SDL_SCANCODE_AUDIOPREV | (1<<30)),
    SDLK_AUDIOSTOP = (SDL_SCANCODE_AUDIOSTOP | (1<<30)),
    SDLK_AUDIOPLAY = (SDL_SCANCODE_AUDIOPLAY | (1<<30)),
    SDLK_AUDIOMUTE = (SDL_SCANCODE_AUDIOMUTE | (1<<30)),
    SDLK_MEDIASELECT = (SDL_SCANCODE_MEDIASELECT | (1<<30)),
    SDLK_WWW = (SDL_SCANCODE_WWW | (1<<30)),
    SDLK_MAIL = (SDL_SCANCODE_MAIL | (1<<30)),
    SDLK_CALCULATOR = (SDL_SCANCODE_CALCULATOR | (1<<30)),
    SDLK_COMPUTER = (SDL_SCANCODE_COMPUTER | (1<<30)),
    SDLK_AC_SEARCH = (SDL_SCANCODE_AC_SEARCH | (1<<30)),
    SDLK_AC_HOME = (SDL_SCANCODE_AC_HOME | (1<<30)),
    SDLK_AC_BACK = (SDL_SCANCODE_AC_BACK | (1<<30)),
    SDLK_AC_FORWARD = (SDL_SCANCODE_AC_FORWARD | (1<<30)),
    SDLK_AC_STOP = (SDL_SCANCODE_AC_STOP | (1<<30)),
    SDLK_AC_REFRESH = (SDL_SCANCODE_AC_REFRESH | (1<<30)),
    SDLK_AC_BOOKMARKS = (SDL_SCANCODE_AC_BOOKMARKS | (1<<30)),

    SDLK_BRIGHTNESSDOWN =
        (SDL_SCANCODE_BRIGHTNESSDOWN | (1<<30)),
    SDLK_BRIGHTNESSUP = (SDL_SCANCODE_BRIGHTNESSUP | (1<<30)),
    SDLK_DISPLAYSWITCH = (SDL_SCANCODE_DISPLAYSWITCH | (1<<30)),
    SDLK_KBDILLUMTOGGLE =
        (SDL_SCANCODE_KBDILLUMTOGGLE | (1<<30)),
    SDLK_KBDILLUMDOWN = (SDL_SCANCODE_KBDILLUMDOWN | (1<<30)),
    SDLK_KBDILLUMUP = (SDL_SCANCODE_KBDILLUMUP | (1<<30)),
    SDLK_EJECT = (SDL_SCANCODE_EJECT | (1<<30)),
    SDLK_SLEEP = (SDL_SCANCODE_SLEEP | (1<<30)),
    SDLK_APP1 = (SDL_SCANCODE_APP1 | (1<<30)),
    SDLK_APP2 = (SDL_SCANCODE_APP2 | (1<<30)),

    SDLK_AUDIOREWIND = (SDL_SCANCODE_AUDIOREWIND | (1<<30)),
    SDLK_AUDIOFASTFORWARD = (SDL_SCANCODE_AUDIOFASTFORWARD | (1<<30))
};




typedef enum
{
    KMOD_NONE = 0x0000,
    KMOD_LSHIFT = 0x0001,
    KMOD_RSHIFT = 0x0002,
    KMOD_LCTRL = 0x0040,
    KMOD_RCTRL = 0x0080,
    KMOD_LALT = 0x0100,
    KMOD_RALT = 0x0200,
    KMOD_LGUI = 0x0400,
    KMOD_RGUI = 0x0800,
    KMOD_NUM = 0x1000,
    KMOD_CAPS = 0x2000,
    KMOD_MODE = 0x4000,
    KMOD_RESERVED = 0x8000
} SDL_Keymod;


extern "C" {
__attribute__((always_inline)) static __inline__ Uint16
SDL_Swap16(Uint16 x)
{
  __asm__("xchgb %b0,%h0": "=Q"(x):"0"(x));
    return x;
}
__attribute__((always_inline)) static __inline__ Uint32
SDL_Swap32(Uint32 x)
{
  __asm__("bswapl %0": "=r"(x):"0"(x));
    return x;
}
__attribute__((always_inline)) static __inline__ Uint64
SDL_Swap64(Uint64 x)
{
  __asm__("bswapq %0": "=r"(x):"0"(x));
    return x;
}
__attribute__((always_inline)) static __inline__ float
SDL_SwapFloat(float x)
{
    union
    {
        float f;
        Uint32 ui32;
    } swapper;
    swapper.f = x;
    swapper.ui32 = SDL_Swap32(swapper.ui32);
    return swapper.f;
}
}





extern "C" {
enum
{
    SDL_PIXELTYPE_UNKNOWN,
    SDL_PIXELTYPE_INDEX1,
    SDL_PIXELTYPE_INDEX4,
    SDL_PIXELTYPE_INDEX8,
    SDL_PIXELTYPE_PACKED8,
    SDL_PIXELTYPE_PACKED16,
    SDL_PIXELTYPE_PACKED32,
    SDL_PIXELTYPE_ARRAYU8,
    SDL_PIXELTYPE_ARRAYU16,
    SDL_PIXELTYPE_ARRAYU32,
    SDL_PIXELTYPE_ARRAYF16,
    SDL_PIXELTYPE_ARRAYF32
};


enum
{
    SDL_BITMAPORDER_NONE,
    SDL_BITMAPORDER_4321,
    SDL_BITMAPORDER_1234
};


enum
{
    SDL_PACKEDORDER_NONE,
    SDL_PACKEDORDER_XRGB,
    SDL_PACKEDORDER_RGBX,
    SDL_PACKEDORDER_ARGB,
    SDL_PACKEDORDER_RGBA,
    SDL_PACKEDORDER_XBGR,
    SDL_PACKEDORDER_BGRX,
    SDL_PACKEDORDER_ABGR,
    SDL_PACKEDORDER_BGRA
};




enum
{
    SDL_ARRAYORDER_NONE,
    SDL_ARRAYORDER_RGB,
    SDL_ARRAYORDER_RGBA,
    SDL_ARRAYORDER_ARGB,
    SDL_ARRAYORDER_BGR,
    SDL_ARRAYORDER_BGRA,
    SDL_ARRAYORDER_ABGR
};


enum
{
    SDL_PACKEDLAYOUT_NONE,
    SDL_PACKEDLAYOUT_332,
    SDL_PACKEDLAYOUT_4444,
    SDL_PACKEDLAYOUT_1555,
    SDL_PACKEDLAYOUT_5551,
    SDL_PACKEDLAYOUT_565,
    SDL_PACKEDLAYOUT_8888,
    SDL_PACKEDLAYOUT_2101010,
    SDL_PACKEDLAYOUT_1010102
};
enum
{
    SDL_PIXELFORMAT_UNKNOWN,
    SDL_PIXELFORMAT_INDEX1LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX1MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX1) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((1) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX4LSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_4321) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX4MSB =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX4) << 24) | ((SDL_BITMAPORDER_1234) << 20) | ((0) << 16) | ((4) << 8) | ((0) << 0)),

    SDL_PIXELFORMAT_INDEX8 =
        ((1 << 28) | ((SDL_PIXELTYPE_INDEX8) << 24) | ((0) << 20) | ((0) << 16) | ((8) << 8) | ((1) << 0)),
    SDL_PIXELFORMAT_RGB332 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED8) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_332) << 16) | ((8) << 8) | ((1) << 0)),

    SDL_PIXELFORMAT_RGB444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((12) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGR555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((15) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ARGB4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGBA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ABGR4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGRA4444 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_4444) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ARGB1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGBA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_ABGR1555 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_1555) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGRA5551 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_5551) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_BGR565 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED16) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_565) << 16) | ((16) << 8) | ((2) << 0)),

    SDL_PIXELFORMAT_RGB24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_RGB) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),

    SDL_PIXELFORMAT_BGR24 =
        ((1 << 28) | ((SDL_PIXELTYPE_ARRAYU8) << 24) | ((SDL_ARRAYORDER_BGR) << 20) | ((0) << 16) | ((24) << 8) | ((3) << 0)),

    SDL_PIXELFORMAT_RGB888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XRGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_RGBX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGR888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_XBGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGRX8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRX) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((24) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ARGB8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_RGBA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_RGBA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ABGR8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ABGR) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_BGRA8888 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_BGRA) << 20) | ((SDL_PACKEDLAYOUT_8888) << 16) | ((32) << 8) | ((4) << 0)),

    SDL_PIXELFORMAT_ARGB2101010 =
        ((1 << 28) | ((SDL_PIXELTYPE_PACKED32) << 24) | ((SDL_PACKEDORDER_ARGB) << 20) | ((SDL_PACKEDLAYOUT_2101010) << 16) | ((32) << 8) | ((4) << 0)),
    SDL_PIXELFORMAT_RGBA32 = SDL_PIXELFORMAT_ABGR8888,
    SDL_PIXELFORMAT_ARGB32 = SDL_PIXELFORMAT_BGRA8888,
    SDL_PIXELFORMAT_BGRA32 = SDL_PIXELFORMAT_ARGB8888,
    SDL_PIXELFORMAT_ABGR32 = SDL_PIXELFORMAT_RGBA8888,


    SDL_PIXELFORMAT_YV12 =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_IYUV =
        ((static_cast<Uint32>(static_cast<Uint8>(('I'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 24)),
    SDL_PIXELFORMAT_YUY2 =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_UYVY =
        ((static_cast<Uint32>(static_cast<Uint8>(('U'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 24)),
    SDL_PIXELFORMAT_YVYU =
        ((static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('Y'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('U'))) << 24)),
    SDL_PIXELFORMAT_NV12 =
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 24)),
    SDL_PIXELFORMAT_NV21 =
        ((static_cast<Uint32>(static_cast<Uint8>(('N'))) << 0) | (static_cast<Uint32>(static_cast<Uint8>(('V'))) << 8) | (static_cast<Uint32>(static_cast<Uint8>(('2'))) << 16) | (static_cast<Uint32>(static_cast<Uint8>(('1'))) << 24))
};

typedef struct SDL_Color
{
    Uint8 r;
    Uint8 g;
    Uint8 b;
    Uint8 a;
} SDL_Color;


typedef struct SDL_Palette
{
    int ncolors;
    SDL_Color *colors;
    Uint32 version;
    int refcount;
} SDL_Palette;




typedef struct SDL_PixelFormat
{
    Uint32 format;
    SDL_Palette *palette;
    Uint8 BitsPerPixel;
    Uint8 BytesPerPixel;
    Uint8 padding[2];
    Uint32 Rmask;
    Uint32 Gmask;
    Uint32 Bmask;
    Uint32 Amask;
    Uint8 Rloss;
    Uint8 Gloss;
    Uint8 Bloss;
    Uint8 Aloss;
    Uint8 Rshift;
    Uint8 Gshift;
    Uint8 Bshift;
    Uint8 Ashift;
    int refcount;
    struct SDL_PixelFormat *next;
} SDL_PixelFormat;




extern const char* SDL_GetPixelFormatName(Uint32 format);
extern SDL_bool SDL_PixelFormatEnumToMasks(Uint32 format,
                                                            int *bpp,
                                                            Uint32 * Rmask,
                                                            Uint32 * Gmask,
                                                            Uint32 * Bmask,
                                                            Uint32 * Amask);
extern Uint32 SDL_MasksToPixelFormatEnum(int bpp,
                                                          Uint32 Rmask,
                                                          Uint32 Gmask,
                                                          Uint32 Bmask,
                                                          Uint32 Amask);




extern SDL_PixelFormat * SDL_AllocFormat(Uint32 pixel_format);




extern void SDL_FreeFormat(SDL_PixelFormat *format);
extern SDL_Palette * SDL_AllocPalette(int ncolors);




extern int SDL_SetPixelFormatPalette(SDL_PixelFormat * format,
                                                      SDL_Palette *palette);
extern int SDL_SetPaletteColors(SDL_Palette * palette,
                                                 const SDL_Color * colors,
                                                 int firstcolor, int ncolors);






extern void SDL_FreePalette(SDL_Palette * palette);






extern Uint32 SDL_MapRGB(const SDL_PixelFormat * format,
                                          Uint8 r, Uint8 g, Uint8 b);






extern Uint32 SDL_MapRGBA(const SDL_PixelFormat * format,
                                           Uint8 r, Uint8 g, Uint8 b,
                                           Uint8 a);






extern void SDL_GetRGB(Uint32 pixel,
                                        const SDL_PixelFormat * format,
                                        Uint8 * r, Uint8 * g, Uint8 * b);






extern void SDL_GetRGBA(Uint32 pixel,
                                         const SDL_PixelFormat * format,
                                         Uint8 * r, Uint8 * g, Uint8 * b,
                                         Uint8 * a);




extern void SDL_CalculateGammaRamp(float gamma, Uint16 * ramp);




}




extern "C" {
typedef struct SDL_Point
{
    int x;
    int y;
} SDL_Point;
typedef struct SDL_Rect
{
    int x, y;
    int w, h;
} SDL_Rect;




__attribute__((always_inline)) static __inline__ SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)
{
    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&
             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;
}




__attribute__((always_inline)) static __inline__ SDL_bool SDL_RectEmpty(const SDL_Rect *r)
{
    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;
}




__attribute__((always_inline)) static __inline__ SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)
{
    return (a && b && (a->x == b->x) && (a->y == b->y) &&
            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;
}






extern SDL_bool SDL_HasIntersection(const SDL_Rect * A,
                                                     const SDL_Rect * B);






extern SDL_bool SDL_IntersectRect(const SDL_Rect * A,
                                                   const SDL_Rect * B,
                                                   SDL_Rect * result);




extern void SDL_UnionRect(const SDL_Rect * A,
                                           const SDL_Rect * B,
                                           SDL_Rect * result);






extern SDL_bool SDL_EnclosePoints(const SDL_Point * points,
                                                   int count,
                                                   const SDL_Rect * clip,
                                                   SDL_Rect * result);






extern SDL_bool SDL_IntersectRectAndLine(const SDL_Rect *
                                                          rect, int *X1,
                                                          int *Y1, int *X2,
                                                          int *Y2);



}




extern "C" {





typedef enum
{
    SDL_BLENDMODE_NONE = 0x00000000,

    SDL_BLENDMODE_BLEND = 0x00000001,


    SDL_BLENDMODE_ADD = 0x00000002,


    SDL_BLENDMODE_MOD = 0x00000004,


    SDL_BLENDMODE_INVALID = 0x7FFFFFFF



} SDL_BlendMode;




typedef enum
{
    SDL_BLENDOPERATION_ADD = 0x1,
    SDL_BLENDOPERATION_SUBTRACT = 0x2,
    SDL_BLENDOPERATION_REV_SUBTRACT = 0x3,
    SDL_BLENDOPERATION_MINIMUM = 0x4,
    SDL_BLENDOPERATION_MAXIMUM = 0x5

} SDL_BlendOperation;




typedef enum
{
    SDL_BLENDFACTOR_ZERO = 0x1,
    SDL_BLENDFACTOR_ONE = 0x2,
    SDL_BLENDFACTOR_SRC_COLOR = 0x3,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 0x4,
    SDL_BLENDFACTOR_SRC_ALPHA = 0x5,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 0x6,
    SDL_BLENDFACTOR_DST_COLOR = 0x7,
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 0x8,
    SDL_BLENDFACTOR_DST_ALPHA = 0x9,
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 0xA

} SDL_BlendFactor;
extern SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor,
                                                                 SDL_BlendFactor dstColorFactor,
                                                                 SDL_BlendOperation colorOperation,
                                                                 SDL_BlendFactor srcAlphaFactor,
                                                                 SDL_BlendFactor dstAlphaFactor,
                                                                 SDL_BlendOperation alphaOperation);



}






extern "C" {
typedef struct SDL_Surface
{
    Uint32 flags;
    SDL_PixelFormat *format;
    int w, h;
    int pitch;
    void *pixels;


    void *userdata;


    int locked;
    void *lock_data;


    SDL_Rect clip_rect;


    struct SDL_BlitMap *map;


    int refcount;
} SDL_Surface;




typedef int ( *SDL_blit) (struct SDL_Surface * src, SDL_Rect * srcrect,
                                 struct SDL_Surface * dst, SDL_Rect * dstrect);
extern SDL_Surface * SDL_CreateRGBSurface
    (Uint32 flags, int width, int height, int depth,
     Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);


extern SDL_Surface * SDL_CreateRGBSurfaceWithFormat
    (Uint32 flags, int width, int height, int depth, Uint32 format);

extern SDL_Surface * SDL_CreateRGBSurfaceFrom(void *pixels,
                                                              int width,
                                                              int height,
                                                              int depth,
                                                              int pitch,
                                                              Uint32 Rmask,
                                                              Uint32 Gmask,
                                                              Uint32 Bmask,
                                                              Uint32 Amask);
extern SDL_Surface * SDL_CreateRGBSurfaceWithFormatFrom
    (void *pixels, int width, int height, int depth, int pitch, Uint32 format);
extern void SDL_FreeSurface(SDL_Surface * surface);
extern int SDL_SetSurfacePalette(SDL_Surface * surface,
                                                  SDL_Palette * palette);
extern int SDL_LockSurface(SDL_Surface * surface);

extern void SDL_UnlockSurface(SDL_Surface * surface);
extern SDL_Surface * SDL_LoadBMP_RW(SDL_RWops * src,
                                                    int freesrc);
extern int SDL_SaveBMP_RW
    (SDL_Surface * surface, SDL_RWops * dst, int freedst);
extern int SDL_SetSurfaceRLE(SDL_Surface * surface,
                                              int flag);
extern int SDL_SetColorKey(SDL_Surface * surface,
                                            int flag, Uint32 key);
extern int SDL_GetColorKey(SDL_Surface * surface,
                                            Uint32 * key);
extern int SDL_SetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 r, Uint8 g, Uint8 b);
extern int SDL_GetSurfaceColorMod(SDL_Surface * surface,
                                                   Uint8 * r, Uint8 * g,
                                                   Uint8 * b);
extern int SDL_SetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 alpha);
extern int SDL_GetSurfaceAlphaMod(SDL_Surface * surface,
                                                   Uint8 * alpha);
extern int SDL_SetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode blendMode);
extern int SDL_GetSurfaceBlendMode(SDL_Surface * surface,
                                                    SDL_BlendMode *blendMode);
extern SDL_bool SDL_SetClipRect(SDL_Surface * surface,
                                                 const SDL_Rect * rect);







extern void SDL_GetClipRect(SDL_Surface * surface,
                                             SDL_Rect * rect);




extern SDL_Surface * SDL_DuplicateSurface(SDL_Surface * surface);
extern SDL_Surface * SDL_ConvertSurface
    (SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags);
extern SDL_Surface * SDL_ConvertSurfaceFormat
    (SDL_Surface * src, Uint32 pixel_format, Uint32 flags);






extern int SDL_ConvertPixels(int width, int height,
                                              Uint32 src_format,
                                              const void * src, int src_pitch,
                                              Uint32 dst_format,
                                              void * dst, int dst_pitch);
extern int SDL_FillRect
    (SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
extern int SDL_FillRects
    (SDL_Surface * dst, const SDL_Rect * rects, int count, Uint32 color);
extern int SDL_UpperBlit
    (SDL_Surface * src, const SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);





extern int SDL_LowerBlit
    (SDL_Surface * src, SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);







extern int SDL_SoftStretch(SDL_Surface * src,
                                            const SDL_Rect * srcrect,
                                            SDL_Surface * dst,
                                            const SDL_Rect * dstrect);







extern int SDL_UpperBlitScaled
    (SDL_Surface * src, const SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);





extern int SDL_LowerBlitScaled
    (SDL_Surface * src, SDL_Rect * srcrect,
    SDL_Surface * dst, SDL_Rect * dstrect);




}





extern "C" {
typedef struct
{
    Uint32 format;
    int w;
    int h;
    int refresh_rate;
    void *driverdata;
} SDL_DisplayMode;
typedef struct SDL_Window SDL_Window;






typedef enum
{

    SDL_WINDOW_FULLSCREEN = 0x00000001,
    SDL_WINDOW_OPENGL = 0x00000002,
    SDL_WINDOW_SHOWN = 0x00000004,
    SDL_WINDOW_HIDDEN = 0x00000008,
    SDL_WINDOW_BORDERLESS = 0x00000010,
    SDL_WINDOW_RESIZABLE = 0x00000020,
    SDL_WINDOW_MINIMIZED = 0x00000040,
    SDL_WINDOW_MAXIMIZED = 0x00000080,
    SDL_WINDOW_INPUT_GRABBED = 0x00000100,
    SDL_WINDOW_INPUT_FOCUS = 0x00000200,
    SDL_WINDOW_MOUSE_FOCUS = 0x00000400,
    SDL_WINDOW_FULLSCREEN_DESKTOP = ( SDL_WINDOW_FULLSCREEN | 0x00001000 ),
    SDL_WINDOW_FOREIGN = 0x00000800,
    SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000,
    SDL_WINDOW_MOUSE_CAPTURE = 0x00004000,
    SDL_WINDOW_ALWAYS_ON_TOP = 0x00008000,
    SDL_WINDOW_SKIP_TASKBAR = 0x00010000,
    SDL_WINDOW_UTILITY = 0x00020000,
    SDL_WINDOW_TOOLTIP = 0x00040000,
    SDL_WINDOW_POPUP_MENU = 0x00080000,
    SDL_WINDOW_VULKAN = 0x10000000
} SDL_WindowFlags;
typedef enum
{
    SDL_WINDOWEVENT_NONE,
    SDL_WINDOWEVENT_SHOWN,
    SDL_WINDOWEVENT_HIDDEN,
    SDL_WINDOWEVENT_EXPOSED,

    SDL_WINDOWEVENT_MOVED,

    SDL_WINDOWEVENT_RESIZED,
    SDL_WINDOWEVENT_SIZE_CHANGED,


    SDL_WINDOWEVENT_MINIMIZED,
    SDL_WINDOWEVENT_MAXIMIZED,
    SDL_WINDOWEVENT_RESTORED,

    SDL_WINDOWEVENT_ENTER,
    SDL_WINDOWEVENT_LEAVE,
    SDL_WINDOWEVENT_FOCUS_GAINED,
    SDL_WINDOWEVENT_FOCUS_LOST,
    SDL_WINDOWEVENT_CLOSE,
    SDL_WINDOWEVENT_TAKE_FOCUS,
    SDL_WINDOWEVENT_HIT_TEST
} SDL_WindowEventID;




typedef void *SDL_GLContext;




typedef enum
{
    SDL_GL_RED_SIZE,
    SDL_GL_GREEN_SIZE,
    SDL_GL_BLUE_SIZE,
    SDL_GL_ALPHA_SIZE,
    SDL_GL_BUFFER_SIZE,
    SDL_GL_DOUBLEBUFFER,
    SDL_GL_DEPTH_SIZE,
    SDL_GL_STENCIL_SIZE,
    SDL_GL_ACCUM_RED_SIZE,
    SDL_GL_ACCUM_GREEN_SIZE,
    SDL_GL_ACCUM_BLUE_SIZE,
    SDL_GL_ACCUM_ALPHA_SIZE,
    SDL_GL_STEREO,
    SDL_GL_MULTISAMPLEBUFFERS,
    SDL_GL_MULTISAMPLESAMPLES,
    SDL_GL_ACCELERATED_VISUAL,
    SDL_GL_RETAINED_BACKING,
    SDL_GL_CONTEXT_MAJOR_VERSION,
    SDL_GL_CONTEXT_MINOR_VERSION,
    SDL_GL_CONTEXT_EGL,
    SDL_GL_CONTEXT_FLAGS,
    SDL_GL_CONTEXT_PROFILE_MASK,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
    SDL_GL_CONTEXT_RESET_NOTIFICATION,
    SDL_GL_CONTEXT_NO_ERROR
} SDL_GLattr;

typedef enum
{
    SDL_GL_CONTEXT_PROFILE_CORE = 0x0001,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 0x0002,
    SDL_GL_CONTEXT_PROFILE_ES = 0x0004
} SDL_GLprofile;

typedef enum
{
    SDL_GL_CONTEXT_DEBUG_FLAG = 0x0001,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 0x0004,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 0x0008
} SDL_GLcontextFlag;

typedef enum
{
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0x0000,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x0001
} SDL_GLcontextReleaseFlag;

typedef enum
{
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 0x0001
} SDL_GLContextResetNotification;
extern int SDL_GetNumVideoDrivers(void);
extern const char * SDL_GetVideoDriver(int index);
extern int SDL_VideoInit(const char *driver_name);
extern void SDL_VideoQuit(void);
extern const char * SDL_GetCurrentVideoDriver(void);






extern int SDL_GetNumVideoDisplays(void);
extern const char * SDL_GetDisplayName(int displayIndex);
extern int SDL_GetDisplayBounds(int displayIndex, SDL_Rect * rect);
extern int SDL_GetDisplayDPI(int displayIndex, float * ddpi, float * hdpi, float * vdpi);
extern int SDL_GetDisplayUsableBounds(int displayIndex, SDL_Rect * rect);






extern int SDL_GetNumDisplayModes(int displayIndex);
extern int SDL_GetDisplayMode(int displayIndex, int modeIndex,
                                               SDL_DisplayMode * mode);




extern int SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode * mode);




extern int SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode * mode);
extern SDL_DisplayMode * SDL_GetClosestDisplayMode(int displayIndex, const SDL_DisplayMode * mode, SDL_DisplayMode * closest);







extern int SDL_GetWindowDisplayIndex(SDL_Window * window);
extern int SDL_SetWindowDisplayMode(SDL_Window * window,
                                                     const SDL_DisplayMode
                                                         * mode);
extern int SDL_GetWindowDisplayMode(SDL_Window * window,
                                                     SDL_DisplayMode * mode);




extern Uint32 SDL_GetWindowPixelFormat(SDL_Window * window);
extern SDL_Window * SDL_CreateWindow(const char *title,
                                                      int x, int y, int w,
                                                      int h, Uint32 flags);
extern SDL_Window * SDL_CreateWindowFrom(const void *data, Uint32 flags);




extern Uint32 SDL_GetWindowID(SDL_Window * window);




extern SDL_Window * SDL_GetWindowFromID(Uint32 id);




extern Uint32 SDL_GetWindowFlags(SDL_Window * window);






extern void SDL_SetWindowTitle(SDL_Window * window,
                                                const char *title);






extern const char * SDL_GetWindowTitle(SDL_Window * window);







extern void SDL_SetWindowIcon(SDL_Window * window,
                                               SDL_Surface * icon);
extern void* SDL_SetWindowData(SDL_Window * window,
                                                const char *name,
                                                void *userdata);
extern void * SDL_GetWindowData(SDL_Window * window,
                                                const char *name);
extern void SDL_SetWindowPosition(SDL_Window * window,
                                                   int x, int y);
extern void SDL_GetWindowPosition(SDL_Window * window,
                                                   int *x, int *y);
extern void SDL_SetWindowSize(SDL_Window * window, int w,
                                               int h);
extern void SDL_GetWindowSize(SDL_Window * window, int *w,
                                               int *h);
extern int SDL_GetWindowBordersSize(SDL_Window * window,
                                                     int *top, int *left,
                                                     int *bottom, int *right);
extern void SDL_SetWindowMinimumSize(SDL_Window * window,
                                                      int min_w, int min_h);
extern void SDL_GetWindowMinimumSize(SDL_Window * window,
                                                      int *w, int *h);
extern void SDL_SetWindowMaximumSize(SDL_Window * window,
                                                      int max_w, int max_h);
extern void SDL_GetWindowMaximumSize(SDL_Window * window,
                                                      int *w, int *h);
extern void SDL_SetWindowBordered(SDL_Window * window,
                                                   SDL_bool bordered);
extern void SDL_SetWindowResizable(SDL_Window * window,
                                                    SDL_bool resizable);






extern void SDL_ShowWindow(SDL_Window * window);






extern void SDL_HideWindow(SDL_Window * window);




extern void SDL_RaiseWindow(SDL_Window * window);






extern void SDL_MaximizeWindow(SDL_Window * window);






extern void SDL_MinimizeWindow(SDL_Window * window);







extern void SDL_RestoreWindow(SDL_Window * window);
extern int SDL_SetWindowFullscreen(SDL_Window * window,
                                                    Uint32 flags);
extern SDL_Surface * SDL_GetWindowSurface(SDL_Window * window);
extern int SDL_UpdateWindowSurface(SDL_Window * window);
extern int SDL_UpdateWindowSurfaceRects(SDL_Window * window,
                                                         const SDL_Rect * rects,
                                                         int numrects);
extern void SDL_SetWindowGrab(SDL_Window * window,
                                               SDL_bool grabbed);
extern SDL_bool SDL_GetWindowGrab(SDL_Window * window);
extern SDL_Window * SDL_GetGrabbedWindow(void);
extern int SDL_SetWindowBrightness(SDL_Window * window, float brightness);
extern float SDL_GetWindowBrightness(SDL_Window * window);
extern int SDL_SetWindowOpacity(SDL_Window * window, float opacity);
extern int SDL_GetWindowOpacity(SDL_Window * window, float * out_opacity);
extern int SDL_SetWindowModalFor(SDL_Window * modal_window, SDL_Window * parent_window);
extern int SDL_SetWindowInputFocus(SDL_Window * window);
extern int SDL_SetWindowGammaRamp(SDL_Window * window,
                                                   const Uint16 * red,
                                                   const Uint16 * green,
                                                   const Uint16 * blue);
extern int SDL_GetWindowGammaRamp(SDL_Window * window,
                                                   Uint16 * red,
                                                   Uint16 * green,
                                                   Uint16 * blue);






typedef enum
{
    SDL_HITTEST_NORMAL,
    SDL_HITTEST_DRAGGABLE,
    SDL_HITTEST_RESIZE_TOPLEFT,
    SDL_HITTEST_RESIZE_TOP,
    SDL_HITTEST_RESIZE_TOPRIGHT,
    SDL_HITTEST_RESIZE_RIGHT,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT,
    SDL_HITTEST_RESIZE_BOTTOM,
    SDL_HITTEST_RESIZE_BOTTOMLEFT,
    SDL_HITTEST_RESIZE_LEFT
} SDL_HitTestResult;






typedef SDL_HitTestResult ( *SDL_HitTest)(SDL_Window *win,
                                                 const SDL_Point *area,
                                                 void *data);
extern int SDL_SetWindowHitTest(SDL_Window * window,
                                                 SDL_HitTest callback,
                                                 void *callback_data);




extern void SDL_DestroyWindow(SDL_Window * window);
extern SDL_bool SDL_IsScreenSaverEnabled(void);







extern void SDL_EnableScreenSaver(void);







extern void SDL_DisableScreenSaver(void);
extern int SDL_GL_LoadLibrary(const char *path);




extern void * SDL_GL_GetProcAddress(const char *proc);






extern void SDL_GL_UnloadLibrary(void);





extern SDL_bool SDL_GL_ExtensionSupported(const char
                                                           *extension);




extern void SDL_GL_ResetAttributes(void);






extern int SDL_GL_SetAttribute(SDL_GLattr attr, int value);







extern int SDL_GL_GetAttribute(SDL_GLattr attr, int *value);







extern SDL_GLContext SDL_GL_CreateContext(SDL_Window *
                                                           window);






extern int SDL_GL_MakeCurrent(SDL_Window * window,
                                               SDL_GLContext context);




extern SDL_Window* SDL_GL_GetCurrentWindow(void);




extern SDL_GLContext SDL_GL_GetCurrentContext(void);
extern void SDL_GL_GetDrawableSize(SDL_Window * window, int *w,
                                                    int *h);
extern int SDL_GL_SetSwapInterval(int interval);
extern int SDL_GL_GetSwapInterval(void);





extern void SDL_GL_SwapWindow(SDL_Window * window);






extern void SDL_GL_DeleteContext(SDL_GLContext context);






}





extern "C" {


typedef struct SDL_Cursor SDL_Cursor;




typedef enum
{
    SDL_SYSTEM_CURSOR_ARROW,
    SDL_SYSTEM_CURSOR_IBEAM,
    SDL_SYSTEM_CURSOR_WAIT,
    SDL_SYSTEM_CURSOR_CROSSHAIR,
    SDL_SYSTEM_CURSOR_WAITARROW,
    SDL_SYSTEM_CURSOR_SIZENWSE,
    SDL_SYSTEM_CURSOR_SIZENESW,
    SDL_SYSTEM_CURSOR_SIZEWE,
    SDL_SYSTEM_CURSOR_SIZENS,
    SDL_SYSTEM_CURSOR_SIZEALL,
    SDL_SYSTEM_CURSOR_NO,
    SDL_SYSTEM_CURSOR_HAND,
    SDL_NUM_SYSTEM_CURSORS
} SDL_SystemCursor;




typedef enum
{
    SDL_MOUSEWHEEL_NORMAL,
    SDL_MOUSEWHEEL_FLIPPED
} SDL_MouseWheelDirection;






extern SDL_Window * SDL_GetMouseFocus(void);
extern Uint32 SDL_GetMouseState(int *x, int *y);
extern Uint32 SDL_GetGlobalMouseState(int *x, int *y);
extern Uint32 SDL_GetRelativeMouseState(int *x, int *y);
extern void SDL_WarpMouseInWindow(SDL_Window * window,
                                                   int x, int y);
extern int SDL_WarpMouseGlobal(int x, int y);
extern int SDL_SetRelativeMouseMode(SDL_bool enabled);
extern int SDL_CaptureMouse(SDL_bool enabled);






extern SDL_bool SDL_GetRelativeMouseMode(void);
extern SDL_Cursor * SDL_CreateCursor(const Uint8 * data,
                                                     const Uint8 * mask,
                                                     int w, int h, int hot_x,
                                                     int hot_y);






extern SDL_Cursor * SDL_CreateColorCursor(SDL_Surface *surface,
                                                          int hot_x,
                                                          int hot_y);






extern SDL_Cursor * SDL_CreateSystemCursor(SDL_SystemCursor id);




extern void SDL_SetCursor(SDL_Cursor * cursor);




extern SDL_Cursor * SDL_GetCursor(void);




extern SDL_Cursor * SDL_GetDefaultCursor(void);
extern void SDL_FreeCursor(SDL_Cursor * cursor);
extern int SDL_ShowCursor(int toggle);
}




namespace Urho3D
{

enum MouseButton : unsigned
{
    MOUSEB_NONE,
    MOUSEB_LEFT = (1 << ((1)-1)),
    MOUSEB_MIDDLE = (1 << ((2)-1)),
    MOUSEB_RIGHT = (1 << ((3)-1)),
    MOUSEB_X1 = (1 << ((4)-1)),
    MOUSEB_X2 = (1 << ((5)-1)),
    MOUSEB_ANY = M_MAX_UNSIGNED
};
template<> struct IsFlagSet<MouseButton> { constexpr static bool value_ = true; }; using MouseButtonFlags = FlagSet<MouseButton>;

enum Qualifier : unsigned
{
    QUAL_NONE = 0,
    QUAL_SHIFT = 1,
    QUAL_CTRL = 2,
    QUAL_ALT = 4,
    QUAL_ANY = 8
};
template<> struct IsFlagSet<Qualifier> { constexpr static bool value_ = true; }; using QualifierFlags = FlagSet<Qualifier>;


enum Key : unsigned
{
    KEY_UNKNOWN = SDLK_UNKNOWN,
    KEY_A = SDLK_a,
    KEY_B = SDLK_b,
    KEY_C = SDLK_c,
    KEY_D = SDLK_d,
    KEY_E = SDLK_e,
    KEY_F = SDLK_f,
    KEY_G = SDLK_g,
    KEY_H = SDLK_h,
    KEY_I = SDLK_i,
    KEY_J = SDLK_j,
    KEY_K = SDLK_k,
    KEY_L = SDLK_l,
    KEY_M = SDLK_m,
    KEY_N = SDLK_n,
    KEY_O = SDLK_o,
    KEY_P = SDLK_p,
    KEY_Q = SDLK_q,
    KEY_R = SDLK_r,
    KEY_S = SDLK_s,
    KEY_T = SDLK_t,
    KEY_U = SDLK_u,
    KEY_V = SDLK_v,
    KEY_W = SDLK_w,
    KEY_X = SDLK_x,
    KEY_Y = SDLK_y,
    KEY_Z = SDLK_z,
    KEY_0 = SDLK_0,
    KEY_1 = SDLK_1,
    KEY_2 = SDLK_2,
    KEY_3 = SDLK_3,
    KEY_4 = SDLK_4,
    KEY_5 = SDLK_5,
    KEY_6 = SDLK_6,
    KEY_7 = SDLK_7,
    KEY_8 = SDLK_8,
    KEY_9 = SDLK_9,
    KEY_BACKSPACE = SDLK_BACKSPACE,
    KEY_TAB = SDLK_TAB,
    KEY_RETURN = SDLK_RETURN,
    KEY_RETURN2 = SDLK_RETURN2,
    KEY_KP_ENTER = SDLK_KP_ENTER,
    KEY_SHIFT = SDLK_LSHIFT,
    KEY_CTRL = SDLK_LCTRL,
    KEY_ALT = SDLK_LALT,
    KEY_GUI = SDLK_LGUI,
    KEY_PAUSE = SDLK_PAUSE,
    KEY_CAPSLOCK = SDLK_CAPSLOCK,
    KEY_ESCAPE = SDLK_ESCAPE,
    KEY_SPACE = SDLK_SPACE,
    KEY_PAGEUP = SDLK_PAGEUP,
    KEY_PAGEDOWN = SDLK_PAGEDOWN,
    KEY_END = SDLK_END,
    KEY_HOME = SDLK_HOME,
    KEY_LEFT = SDLK_LEFT,
    KEY_UP = SDLK_UP,
    KEY_RIGHT = SDLK_RIGHT,
    KEY_DOWN = SDLK_DOWN,
    KEY_SELECT = SDLK_SELECT,
    KEY_PRINTSCREEN = SDLK_PRINTSCREEN,
    KEY_INSERT = SDLK_INSERT,
    KEY_DELETE = SDLK_DELETE,
    KEY_LGUI = SDLK_LGUI,
    KEY_RGUI = SDLK_RGUI,
    KEY_APPLICATION = SDLK_APPLICATION,
    KEY_KP_0 = SDLK_KP_0,
    KEY_KP_1 = SDLK_KP_1,
    KEY_KP_2 = SDLK_KP_2,
    KEY_KP_3 = SDLK_KP_3,
    KEY_KP_4 = SDLK_KP_4,
    KEY_KP_5 = SDLK_KP_5,
    KEY_KP_6 = SDLK_KP_6,
    KEY_KP_7 = SDLK_KP_7,
    KEY_KP_8 = SDLK_KP_8,
    KEY_KP_9 = SDLK_KP_9,
    KEY_KP_MULTIPLY = SDLK_KP_MULTIPLY,
    KEY_KP_PLUS = SDLK_KP_PLUS,
    KEY_KP_MINUS = SDLK_KP_MINUS,
    KEY_KP_PERIOD = SDLK_KP_PERIOD,
    KEY_KP_DIVIDE = SDLK_KP_DIVIDE,
    KEY_F1 = SDLK_F1,
    KEY_F2 = SDLK_F2,
    KEY_F3 = SDLK_F3,
    KEY_F4 = SDLK_F4,
    KEY_F5 = SDLK_F5,
    KEY_F6 = SDLK_F6,
    KEY_F7 = SDLK_F7,
    KEY_F8 = SDLK_F8,
    KEY_F9 = SDLK_F9,
    KEY_F10 = SDLK_F10,
    KEY_F11 = SDLK_F11,
    KEY_F12 = SDLK_F12,
    KEY_F13 = SDLK_F13,
    KEY_F14 = SDLK_F14,
    KEY_F15 = SDLK_F15,
    KEY_F16 = SDLK_F16,
    KEY_F17 = SDLK_F17,
    KEY_F18 = SDLK_F18,
    KEY_F19 = SDLK_F19,
    KEY_F20 = SDLK_F20,
    KEY_F21 = SDLK_F21,
    KEY_F22 = SDLK_F22,
    KEY_F23 = SDLK_F23,
    KEY_F24 = SDLK_F24,
    KEY_NUMLOCKCLEAR = SDLK_NUMLOCKCLEAR,
    KEY_SCROLLLOCK = SDLK_SCROLLLOCK,
    KEY_LSHIFT = SDLK_LSHIFT,
    KEY_RSHIFT = SDLK_RSHIFT,
    KEY_LCTRL = SDLK_LCTRL,
    KEY_RCTRL = SDLK_RCTRL,
    KEY_LALT = SDLK_LALT,
    KEY_RALT = SDLK_RALT,
    KEY_AC_BACK = SDLK_AC_BACK,
    KEY_AC_BOOKMARKS = SDLK_AC_BOOKMARKS,
    KEY_AC_FORWARD = SDLK_AC_FORWARD,
    KEY_AC_HOME = SDLK_AC_HOME,
    KEY_AC_REFRESH = SDLK_AC_REFRESH,
    KEY_AC_SEARCH = SDLK_AC_SEARCH,
    KEY_AC_STOP = SDLK_AC_STOP,
    KEY_AGAIN = SDLK_AGAIN,
    KEY_ALTERASE = SDLK_ALTERASE,
    KEY_AMPERSAND = SDLK_AMPERSAND,
    KEY_ASTERISK = SDLK_ASTERISK,
    KEY_AT = SDLK_AT,
    KEY_AUDIOMUTE = SDLK_AUDIOMUTE,
    KEY_AUDIONEXT = SDLK_AUDIONEXT,
    KEY_AUDIOPLAY = SDLK_AUDIOPLAY,
    KEY_AUDIOPREV = SDLK_AUDIOPREV,
    KEY_AUDIOSTOP = SDLK_AUDIOSTOP,
    KEY_BACKQUOTE = SDLK_BACKQUOTE,
    KEY_BACKSLASH = SDLK_BACKSLASH,
    KEY_BRIGHTNESSDOWN = SDLK_BRIGHTNESSDOWN,
    KEY_BRIGHTNESSUP = SDLK_BRIGHTNESSUP,
    KEY_CALCULATOR = SDLK_CALCULATOR,
    KEY_CANCEL = SDLK_CANCEL,
    KEY_CARET = SDLK_CARET,
    KEY_CLEAR = SDLK_CLEAR,
    KEY_CLEARAGAIN = SDLK_CLEARAGAIN,
    KEY_COLON = SDLK_COLON,
    KEY_COMMA = SDLK_COMMA,
    KEY_COMPUTER = SDLK_COMPUTER,
    KEY_COPY = SDLK_COPY,
    KEY_CRSEL = SDLK_CRSEL,
    KEY_CURRENCYSUBUNIT = SDLK_CURRENCYSUBUNIT,
    KEY_CURRENCYUNIT = SDLK_CURRENCYUNIT,
    KEY_CUT = SDLK_CUT,
    KEY_DECIMALSEPARATOR = SDLK_DECIMALSEPARATOR,
    KEY_DISPLAYSWITCH = SDLK_DISPLAYSWITCH,
    KEY_DOLLAR = SDLK_DOLLAR,
    KEY_EJECT = SDLK_EJECT,
    KEY_EQUALS = SDLK_EQUALS,
    KEY_EXCLAIM = SDLK_EXCLAIM,
    KEY_EXSEL = SDLK_EXSEL,
    KEY_FIND = SDLK_FIND,
    KEY_GREATER = SDLK_GREATER,
    KEY_HASH = SDLK_HASH,
    KEY_HELP = SDLK_HELP,
    KEY_KBDILLUMDOWN = SDLK_KBDILLUMDOWN,
    KEY_KBDILLUMTOGGLE = SDLK_KBDILLUMTOGGLE,
    KEY_KBDILLUMUP = SDLK_KBDILLUMUP,
    KEY_KP_00 = SDLK_KP_00,
    KEY_KP_000 = SDLK_KP_000,
    KEY_KP_A = SDLK_KP_A,
    KEY_KP_AMPERSAND = SDLK_KP_AMPERSAND,
    KEY_KP_AT = SDLK_KP_AT,
    KEY_KP_B = SDLK_KP_B,
    KEY_KP_BACKSPACE = SDLK_KP_BACKSPACE,
    KEY_KP_BINARY = SDLK_KP_BINARY,
    KEY_KP_C = SDLK_KP_C,
    KEY_KP_CLEAR = SDLK_KP_CLEAR,
    KEY_KP_CLEARENTRY = SDLK_KP_CLEARENTRY,
    KEY_KP_COLON = SDLK_KP_COLON,
    KEY_KP_COMMA = SDLK_KP_COMMA,
    KEY_KP_D = SDLK_KP_D,
    KEY_KP_DBLAMPERSAND = SDLK_KP_DBLAMPERSAND,
    KEY_KP_DBLVERTICALBAR = SDLK_KP_DBLVERTICALBAR,
    KEY_KP_DECIMAL = SDLK_KP_DECIMAL,
    KEY_KP_E = SDLK_KP_E,
    KEY_KP_EQUALS = SDLK_KP_EQUALS,
    KEY_KP_EQUALSAS400 = SDLK_KP_EQUALSAS400,
    KEY_KP_EXCLAM = SDLK_KP_EXCLAM,
    KEY_KP_F = SDLK_KP_F,
    KEY_KP_GREATER = SDLK_KP_GREATER,
    KEY_KP_HASH = SDLK_KP_HASH,
    KEY_KP_HEXADECIMAL = SDLK_KP_HEXADECIMAL,
    KEY_KP_LEFTBRACE = SDLK_KP_LEFTBRACE,
    KEY_KP_LEFTPAREN = SDLK_KP_LEFTPAREN,
    KEY_KP_LESS = SDLK_KP_LESS,
    KEY_KP_MEMADD = SDLK_KP_MEMADD,
    KEY_KP_MEMCLEAR = SDLK_KP_MEMCLEAR,
    KEY_KP_MEMDIVIDE = SDLK_KP_MEMDIVIDE,
    KEY_KP_MEMMULTIPLY = SDLK_KP_MEMMULTIPLY,
    KEY_KP_MEMRECALL = SDLK_KP_MEMRECALL,
    KEY_KP_MEMSTORE = SDLK_KP_MEMSTORE,
    KEY_KP_MEMSUBTRACT = SDLK_KP_MEMSUBTRACT,
    KEY_KP_OCTAL = SDLK_KP_OCTAL,
    KEY_KP_PERCENT = SDLK_KP_PERCENT,
    KEY_KP_PLUSMINUS = SDLK_KP_PLUSMINUS,
    KEY_KP_POWER = SDLK_KP_POWER,
    KEY_KP_RIGHTBRACE = SDLK_KP_RIGHTBRACE,
    KEY_KP_RIGHTPAREN = SDLK_KP_RIGHTPAREN,
    KEY_KP_SPACE = SDLK_KP_SPACE,
    KEY_KP_TAB = SDLK_KP_TAB,
    KEY_KP_VERTICALBAR = SDLK_KP_VERTICALBAR,
    KEY_KP_XOR = SDLK_KP_XOR,
    KEY_LEFTBRACKET = SDLK_LEFTBRACKET,
    KEY_LEFTPAREN = SDLK_LEFTPAREN,
    KEY_LESS = SDLK_LESS,
    KEY_MAIL = SDLK_MAIL,
    KEY_MEDIASELECT = SDLK_MEDIASELECT,
    KEY_MENU = SDLK_MENU,
    KEY_MINUS = SDLK_MINUS,
    KEY_MODE = SDLK_MODE,
    KEY_MUTE = SDLK_MUTE,
    KEY_OPER = SDLK_OPER,
    KEY_OUT = SDLK_OUT,
    KEY_PASTE = SDLK_PASTE,
    KEY_PERCENT = SDLK_PERCENT,
    KEY_PERIOD = SDLK_PERIOD,
    KEY_PLUS = SDLK_PLUS,
    KEY_POWER = SDLK_POWER,
    KEY_PRIOR = SDLK_PRIOR,
    KEY_QUESTION = SDLK_QUESTION,
    KEY_QUOTE = SDLK_QUOTE,
    KEY_QUOTEDBL = SDLK_QUOTEDBL,
    KEY_RIGHTBRACKET = SDLK_RIGHTBRACKET,
    KEY_RIGHTPAREN = SDLK_RIGHTPAREN,
    KEY_SEMICOLON = SDLK_SEMICOLON,
    KEY_SEPARATOR = SDLK_SEPARATOR,
    KEY_SLASH = SDLK_SLASH,
    KEY_SLEEP = SDLK_SLEEP,
    KEY_STOP = SDLK_STOP,
    KEY_SYSREQ = SDLK_SYSREQ,
    KEY_THOUSANDSSEPARATOR = SDLK_THOUSANDSSEPARATOR,
    KEY_UNDERSCORE = SDLK_UNDERSCORE,
    KEY_UNDO = SDLK_UNDO,
    KEY_VOLUMEDOWN = SDLK_VOLUMEDOWN,
    KEY_VOLUMEUP = SDLK_VOLUMEUP,
    KEY_WWW = SDLK_WWW,
};

enum Scancode : unsigned
{
    SCANCODE_UNKNOWN = SDL_SCANCODE_UNKNOWN,
    SCANCODE_CTRL = SDL_SCANCODE_LCTRL,
    SCANCODE_SHIFT = SDL_SCANCODE_LSHIFT,
    SCANCODE_ALT = SDL_SCANCODE_LALT,
    SCANCODE_GUI = SDL_SCANCODE_LGUI,
    SCANCODE_A = SDL_SCANCODE_A,
    SCANCODE_B = SDL_SCANCODE_B,
    SCANCODE_C = SDL_SCANCODE_C,
    SCANCODE_D = SDL_SCANCODE_D,
    SCANCODE_E = SDL_SCANCODE_E,
    SCANCODE_F = SDL_SCANCODE_F,
    SCANCODE_G = SDL_SCANCODE_G,
    SCANCODE_H = SDL_SCANCODE_H,
    SCANCODE_I = SDL_SCANCODE_I,
    SCANCODE_J = SDL_SCANCODE_J,
    SCANCODE_K = SDL_SCANCODE_K,
    SCANCODE_L = SDL_SCANCODE_L,
    SCANCODE_M = SDL_SCANCODE_M,
    SCANCODE_N = SDL_SCANCODE_N,
    SCANCODE_O = SDL_SCANCODE_O,
    SCANCODE_P = SDL_SCANCODE_P,
    SCANCODE_Q = SDL_SCANCODE_Q,
    SCANCODE_R = SDL_SCANCODE_R,
    SCANCODE_S = SDL_SCANCODE_S,
    SCANCODE_T = SDL_SCANCODE_T,
    SCANCODE_U = SDL_SCANCODE_U,
    SCANCODE_V = SDL_SCANCODE_V,
    SCANCODE_W = SDL_SCANCODE_W,
    SCANCODE_X = SDL_SCANCODE_X,
    SCANCODE_Y = SDL_SCANCODE_Y,
    SCANCODE_Z = SDL_SCANCODE_Z,
    SCANCODE_1 = SDL_SCANCODE_1,
    SCANCODE_2 = SDL_SCANCODE_2,
    SCANCODE_3 = SDL_SCANCODE_3,
    SCANCODE_4 = SDL_SCANCODE_4,
    SCANCODE_5 = SDL_SCANCODE_5,
    SCANCODE_6 = SDL_SCANCODE_6,
    SCANCODE_7 = SDL_SCANCODE_7,
    SCANCODE_8 = SDL_SCANCODE_8,
    SCANCODE_9 = SDL_SCANCODE_9,
    SCANCODE_0 = SDL_SCANCODE_0,
    SCANCODE_RETURN = SDL_SCANCODE_RETURN,
    SCANCODE_ESCAPE = SDL_SCANCODE_ESCAPE,
    SCANCODE_BACKSPACE = SDL_SCANCODE_BACKSPACE,
    SCANCODE_TAB = SDL_SCANCODE_TAB,
    SCANCODE_SPACE = SDL_SCANCODE_SPACE,
    SCANCODE_MINUS = SDL_SCANCODE_MINUS,
    SCANCODE_EQUALS = SDL_SCANCODE_EQUALS,
    SCANCODE_LEFTBRACKET = SDL_SCANCODE_LEFTBRACKET,
    SCANCODE_RIGHTBRACKET = SDL_SCANCODE_RIGHTBRACKET,
    SCANCODE_BACKSLASH = SDL_SCANCODE_BACKSLASH,
    SCANCODE_NONUSHASH = SDL_SCANCODE_NONUSHASH,
    SCANCODE_SEMICOLON = SDL_SCANCODE_SEMICOLON,
    SCANCODE_APOSTROPHE = SDL_SCANCODE_APOSTROPHE,
    SCANCODE_GRAVE = SDL_SCANCODE_GRAVE,
    SCANCODE_COMMA = SDL_SCANCODE_COMMA,
    SCANCODE_PERIOD = SDL_SCANCODE_PERIOD,
    SCANCODE_SLASH = SDL_SCANCODE_SLASH,
    SCANCODE_CAPSLOCK = SDL_SCANCODE_CAPSLOCK,
    SCANCODE_F1 = SDL_SCANCODE_F1,
    SCANCODE_F2 = SDL_SCANCODE_F2,
    SCANCODE_F3 = SDL_SCANCODE_F3,
    SCANCODE_F4 = SDL_SCANCODE_F4,
    SCANCODE_F5 = SDL_SCANCODE_F5,
    SCANCODE_F6 = SDL_SCANCODE_F6,
    SCANCODE_F7 = SDL_SCANCODE_F7,
    SCANCODE_F8 = SDL_SCANCODE_F8,
    SCANCODE_F9 = SDL_SCANCODE_F9,
    SCANCODE_F10 = SDL_SCANCODE_F10,
    SCANCODE_F11 = SDL_SCANCODE_F11,
    SCANCODE_F12 = SDL_SCANCODE_F12,
    SCANCODE_PRINTSCREEN = SDL_SCANCODE_PRINTSCREEN,
    SCANCODE_SCROLLLOCK = SDL_SCANCODE_SCROLLLOCK,
    SCANCODE_PAUSE = SDL_SCANCODE_PAUSE,
    SCANCODE_INSERT = SDL_SCANCODE_INSERT,
    SCANCODE_HOME = SDL_SCANCODE_HOME,
    SCANCODE_PAGEUP = SDL_SCANCODE_PAGEUP,
    SCANCODE_DELETE = SDL_SCANCODE_DELETE,
    SCANCODE_END = SDL_SCANCODE_END,
    SCANCODE_PAGEDOWN = SDL_SCANCODE_PAGEDOWN,
    SCANCODE_RIGHT = SDL_SCANCODE_RIGHT,
    SCANCODE_LEFT = SDL_SCANCODE_LEFT,
    SCANCODE_DOWN = SDL_SCANCODE_DOWN,
    SCANCODE_UP = SDL_SCANCODE_UP,
    SCANCODE_NUMLOCKCLEAR = SDL_SCANCODE_NUMLOCKCLEAR,
    SCANCODE_KP_DIVIDE = SDL_SCANCODE_KP_DIVIDE,
    SCANCODE_KP_MULTIPLY = SDL_SCANCODE_KP_MULTIPLY,
    SCANCODE_KP_MINUS = SDL_SCANCODE_KP_MINUS,
    SCANCODE_KP_PLUS = SDL_SCANCODE_KP_PLUS,
    SCANCODE_KP_ENTER = SDL_SCANCODE_KP_ENTER,
    SCANCODE_KP_1 = SDL_SCANCODE_KP_1,
    SCANCODE_KP_2 = SDL_SCANCODE_KP_2,
    SCANCODE_KP_3 = SDL_SCANCODE_KP_3,
    SCANCODE_KP_4 = SDL_SCANCODE_KP_4,
    SCANCODE_KP_5 = SDL_SCANCODE_KP_5,
    SCANCODE_KP_6 = SDL_SCANCODE_KP_6,
    SCANCODE_KP_7 = SDL_SCANCODE_KP_7,
    SCANCODE_KP_8 = SDL_SCANCODE_KP_8,
    SCANCODE_KP_9 = SDL_SCANCODE_KP_9,
    SCANCODE_KP_0 = SDL_SCANCODE_KP_0,
    SCANCODE_KP_PERIOD = SDL_SCANCODE_KP_PERIOD,
    SCANCODE_NONUSBACKSLASH = SDL_SCANCODE_NONUSBACKSLASH,
    SCANCODE_APPLICATION = SDL_SCANCODE_APPLICATION,
    SCANCODE_POWER = SDL_SCANCODE_POWER,
    SCANCODE_KP_EQUALS = SDL_SCANCODE_KP_EQUALS,
    SCANCODE_F13 = SDL_SCANCODE_F13,
    SCANCODE_F14 = SDL_SCANCODE_F14,
    SCANCODE_F15 = SDL_SCANCODE_F15,
    SCANCODE_F16 = SDL_SCANCODE_F16,
    SCANCODE_F17 = SDL_SCANCODE_F17,
    SCANCODE_F18 = SDL_SCANCODE_F18,
    SCANCODE_F19 = SDL_SCANCODE_F19,
    SCANCODE_F20 = SDL_SCANCODE_F20,
    SCANCODE_F21 = SDL_SCANCODE_F21,
    SCANCODE_F22 = SDL_SCANCODE_F22,
    SCANCODE_F23 = SDL_SCANCODE_F23,
    SCANCODE_F24 = SDL_SCANCODE_F24,
    SCANCODE_EXECUTE = SDL_SCANCODE_EXECUTE,
    SCANCODE_HELP = SDL_SCANCODE_HELP,
    SCANCODE_MENU = SDL_SCANCODE_MENU,
    SCANCODE_SELECT = SDL_SCANCODE_SELECT,
    SCANCODE_STOP = SDL_SCANCODE_STOP,
    SCANCODE_AGAIN = SDL_SCANCODE_AGAIN,
    SCANCODE_UNDO = SDL_SCANCODE_UNDO,
    SCANCODE_CUT = SDL_SCANCODE_CUT,
    SCANCODE_COPY = SDL_SCANCODE_COPY,
    SCANCODE_PASTE = SDL_SCANCODE_PASTE,
    SCANCODE_FIND = SDL_SCANCODE_FIND,
    SCANCODE_MUTE = SDL_SCANCODE_MUTE,
    SCANCODE_VOLUMEUP = SDL_SCANCODE_VOLUMEUP,
    SCANCODE_VOLUMEDOWN = SDL_SCANCODE_VOLUMEDOWN,
    SCANCODE_KP_COMMA = SDL_SCANCODE_KP_COMMA,
    SCANCODE_KP_EQUALSAS400 = SDL_SCANCODE_KP_EQUALSAS400,
    SCANCODE_INTERNATIONAL1 = SDL_SCANCODE_INTERNATIONAL1,
    SCANCODE_INTERNATIONAL2 = SDL_SCANCODE_INTERNATIONAL2,
    SCANCODE_INTERNATIONAL3 = SDL_SCANCODE_INTERNATIONAL3,
    SCANCODE_INTERNATIONAL4 = SDL_SCANCODE_INTERNATIONAL4,
    SCANCODE_INTERNATIONAL5 = SDL_SCANCODE_INTERNATIONAL5,
    SCANCODE_INTERNATIONAL6 = SDL_SCANCODE_INTERNATIONAL6,
    SCANCODE_INTERNATIONAL7 = SDL_SCANCODE_INTERNATIONAL7,
    SCANCODE_INTERNATIONAL8 = SDL_SCANCODE_INTERNATIONAL8,
    SCANCODE_INTERNATIONAL9 = SDL_SCANCODE_INTERNATIONAL9,
    SCANCODE_LANG1 = SDL_SCANCODE_LANG1,
    SCANCODE_LANG2 = SDL_SCANCODE_LANG2,
    SCANCODE_LANG3 = SDL_SCANCODE_LANG3,
    SCANCODE_LANG4 = SDL_SCANCODE_LANG4,
    SCANCODE_LANG5 = SDL_SCANCODE_LANG5,
    SCANCODE_LANG6 = SDL_SCANCODE_LANG6,
    SCANCODE_LANG7 = SDL_SCANCODE_LANG7,
    SCANCODE_LANG8 = SDL_SCANCODE_LANG8,
    SCANCODE_LANG9 = SDL_SCANCODE_LANG9,
    SCANCODE_ALTERASE = SDL_SCANCODE_ALTERASE,
    SCANCODE_SYSREQ = SDL_SCANCODE_SYSREQ,
    SCANCODE_CANCEL = SDL_SCANCODE_CANCEL,
    SCANCODE_CLEAR = SDL_SCANCODE_CLEAR,
    SCANCODE_PRIOR = SDL_SCANCODE_PRIOR,
    SCANCODE_RETURN2 = SDL_SCANCODE_RETURN2,
    SCANCODE_SEPARATOR = SDL_SCANCODE_SEPARATOR,
    SCANCODE_OUT = SDL_SCANCODE_OUT,
    SCANCODE_OPER = SDL_SCANCODE_OPER,
    SCANCODE_CLEARAGAIN = SDL_SCANCODE_CLEARAGAIN,
    SCANCODE_CRSEL = SDL_SCANCODE_CRSEL,
    SCANCODE_EXSEL = SDL_SCANCODE_EXSEL,
    SCANCODE_KP_00 = SDL_SCANCODE_KP_00,
    SCANCODE_KP_000 = SDL_SCANCODE_KP_000,
    SCANCODE_THOUSANDSSEPARATOR = SDL_SCANCODE_THOUSANDSSEPARATOR,
    SCANCODE_DECIMALSEPARATOR = SDL_SCANCODE_DECIMALSEPARATOR,
    SCANCODE_CURRENCYUNIT = SDL_SCANCODE_CURRENCYUNIT,
    SCANCODE_CURRENCYSUBUNIT = SDL_SCANCODE_CURRENCYSUBUNIT,
    SCANCODE_KP_LEFTPAREN = SDL_SCANCODE_KP_LEFTPAREN,
    SCANCODE_KP_RIGHTPAREN = SDL_SCANCODE_KP_RIGHTPAREN,
    SCANCODE_KP_LEFTBRACE = SDL_SCANCODE_KP_LEFTBRACE,
    SCANCODE_KP_RIGHTBRACE = SDL_SCANCODE_KP_RIGHTBRACE,
    SCANCODE_KP_TAB = SDL_SCANCODE_KP_TAB,
    SCANCODE_KP_BACKSPACE = SDL_SCANCODE_KP_BACKSPACE,
    SCANCODE_KP_A = SDL_SCANCODE_KP_A,
    SCANCODE_KP_B = SDL_SCANCODE_KP_B,
    SCANCODE_KP_C = SDL_SCANCODE_KP_C,
    SCANCODE_KP_D = SDL_SCANCODE_KP_D,
    SCANCODE_KP_E = SDL_SCANCODE_KP_E,
    SCANCODE_KP_F = SDL_SCANCODE_KP_F,
    SCANCODE_KP_XOR = SDL_SCANCODE_KP_XOR,
    SCANCODE_KP_POWER = SDL_SCANCODE_KP_POWER,
    SCANCODE_KP_PERCENT = SDL_SCANCODE_KP_PERCENT,
    SCANCODE_KP_LESS = SDL_SCANCODE_KP_LESS,
    SCANCODE_KP_GREATER = SDL_SCANCODE_KP_GREATER,
    SCANCODE_KP_AMPERSAND = SDL_SCANCODE_KP_AMPERSAND,
    SCANCODE_KP_DBLAMPERSAND = SDL_SCANCODE_KP_DBLAMPERSAND,
    SCANCODE_KP_VERTICALBAR = SDL_SCANCODE_KP_VERTICALBAR,
    SCANCODE_KP_DBLVERTICALBAR = SDL_SCANCODE_KP_DBLVERTICALBAR,
    SCANCODE_KP_COLON = SDL_SCANCODE_KP_COLON,
    SCANCODE_KP_HASH = SDL_SCANCODE_KP_HASH,
    SCANCODE_KP_SPACE = SDL_SCANCODE_KP_SPACE,
    SCANCODE_KP_AT = SDL_SCANCODE_KP_AT,
    SCANCODE_KP_EXCLAM = SDL_SCANCODE_KP_EXCLAM,
    SCANCODE_KP_MEMSTORE = SDL_SCANCODE_KP_MEMSTORE,
    SCANCODE_KP_MEMRECALL = SDL_SCANCODE_KP_MEMRECALL,
    SCANCODE_KP_MEMCLEAR = SDL_SCANCODE_KP_MEMCLEAR,
    SCANCODE_KP_MEMADD = SDL_SCANCODE_KP_MEMADD,
    SCANCODE_KP_MEMSUBTRACT = SDL_SCANCODE_KP_MEMSUBTRACT,
    SCANCODE_KP_MEMMULTIPLY = SDL_SCANCODE_KP_MEMMULTIPLY,
    SCANCODE_KP_MEMDIVIDE = SDL_SCANCODE_KP_MEMDIVIDE,
    SCANCODE_KP_PLUSMINUS = SDL_SCANCODE_KP_PLUSMINUS,
    SCANCODE_KP_CLEAR = SDL_SCANCODE_KP_CLEAR,
    SCANCODE_KP_CLEARENTRY = SDL_SCANCODE_KP_CLEARENTRY,
    SCANCODE_KP_BINARY = SDL_SCANCODE_KP_BINARY,
    SCANCODE_KP_OCTAL = SDL_SCANCODE_KP_OCTAL,
    SCANCODE_KP_DECIMAL = SDL_SCANCODE_KP_DECIMAL,
    SCANCODE_KP_HEXADECIMAL = SDL_SCANCODE_KP_HEXADECIMAL,
    SCANCODE_LCTRL = SDL_SCANCODE_LCTRL,
    SCANCODE_LSHIFT = SDL_SCANCODE_LSHIFT,
    SCANCODE_LALT = SDL_SCANCODE_LALT,
    SCANCODE_LGUI = SDL_SCANCODE_LGUI,
    SCANCODE_RCTRL = SDL_SCANCODE_RCTRL,
    SCANCODE_RSHIFT = SDL_SCANCODE_RSHIFT,
    SCANCODE_RALT = SDL_SCANCODE_RALT,
    SCANCODE_RGUI = SDL_SCANCODE_RGUI,
    SCANCODE_MODE = SDL_SCANCODE_MODE,
    SCANCODE_AUDIONEXT = SDL_SCANCODE_AUDIONEXT,
    SCANCODE_AUDIOPREV = SDL_SCANCODE_AUDIOPREV,
    SCANCODE_AUDIOSTOP = SDL_SCANCODE_AUDIOSTOP,
    SCANCODE_AUDIOPLAY = SDL_SCANCODE_AUDIOPLAY,
    SCANCODE_AUDIOMUTE = SDL_SCANCODE_AUDIOMUTE,
    SCANCODE_MEDIASELECT = SDL_SCANCODE_MEDIASELECT,
    SCANCODE_WWW = SDL_SCANCODE_WWW,
    SCANCODE_MAIL = SDL_SCANCODE_MAIL,
    SCANCODE_CALCULATOR = SDL_SCANCODE_CALCULATOR,
    SCANCODE_COMPUTER = SDL_SCANCODE_COMPUTER,
    SCANCODE_AC_SEARCH = SDL_SCANCODE_AC_SEARCH,
    SCANCODE_AC_HOME = SDL_SCANCODE_AC_HOME,
    SCANCODE_AC_BACK = SDL_SCANCODE_AC_BACK,
    SCANCODE_AC_FORWARD = SDL_SCANCODE_AC_FORWARD,
    SCANCODE_AC_STOP = SDL_SCANCODE_AC_STOP,
    SCANCODE_AC_REFRESH = SDL_SCANCODE_AC_REFRESH,
    SCANCODE_AC_BOOKMARKS = SDL_SCANCODE_AC_BOOKMARKS,
    SCANCODE_BRIGHTNESSDOWN = SDL_SCANCODE_BRIGHTNESSDOWN,
    SCANCODE_BRIGHTNESSUP = SDL_SCANCODE_BRIGHTNESSUP,
    SCANCODE_DISPLAYSWITCH = SDL_SCANCODE_DISPLAYSWITCH,
    SCANCODE_KBDILLUMTOGGLE = SDL_SCANCODE_KBDILLUMTOGGLE,
    SCANCODE_KBDILLUMDOWN = SDL_SCANCODE_KBDILLUMDOWN,
    SCANCODE_KBDILLUMUP = SDL_SCANCODE_KBDILLUMUP,
    SCANCODE_EJECT = SDL_SCANCODE_EJECT,
    SCANCODE_SLEEP = SDL_SCANCODE_SLEEP,
    SCANCODE_APP1 = SDL_SCANCODE_APP1,
    SCANCODE_APP2 = SDL_SCANCODE_APP2,
};

enum HatPosition : unsigned
{
    HAT_CENTER = 0x00,
    HAT_UP = 0x01,
    HAT_RIGHT = 0x02,
    HAT_DOWN = 0x04,
    HAT_LEFT = 0x08,
};

enum ControllerButton : unsigned
{
    CONTROLLER_BUTTON_A = SDL_CONTROLLER_BUTTON_A,
    CONTROLLER_BUTTON_B = SDL_CONTROLLER_BUTTON_B,
    CONTROLLER_BUTTON_X = SDL_CONTROLLER_BUTTON_X,
    CONTROLLER_BUTTON_Y = SDL_CONTROLLER_BUTTON_Y,
    CONTROLLER_BUTTON_BACK = SDL_CONTROLLER_BUTTON_BACK,
    CONTROLLER_BUTTON_GUIDE = SDL_CONTROLLER_BUTTON_GUIDE,
    CONTROLLER_BUTTON_START = SDL_CONTROLLER_BUTTON_START,
    CONTROLLER_BUTTON_LEFTSTICK = SDL_CONTROLLER_BUTTON_LEFTSTICK,
    CONTROLLER_BUTTON_RIGHTSTICK = SDL_CONTROLLER_BUTTON_RIGHTSTICK,
    CONTROLLER_BUTTON_LEFTSHOULDER = SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
    CONTROLLER_BUTTON_RIGHTSHOULDER = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
    CONTROLLER_BUTTON_DPAD_UP = SDL_CONTROLLER_BUTTON_DPAD_UP,
    CONTROLLER_BUTTON_DPAD_DOWN = SDL_CONTROLLER_BUTTON_DPAD_DOWN,
    CONTROLLER_BUTTON_DPAD_LEFT = SDL_CONTROLLER_BUTTON_DPAD_LEFT,
    CONTROLLER_BUTTON_DPAD_RIGHT = SDL_CONTROLLER_BUTTON_DPAD_RIGHT,
};

enum ControllerAxis : unsigned
{
    CONTROLLER_AXIS_LEFTX = SDL_CONTROLLER_AXIS_LEFTX,
    CONTROLLER_AXIS_LEFTY = SDL_CONTROLLER_AXIS_LEFTY,
    CONTROLLER_AXIS_RIGHTX = SDL_CONTROLLER_AXIS_RIGHTX,
    CONTROLLER_AXIS_RIGHTY = SDL_CONTROLLER_AXIS_RIGHTY,
    CONTROLLER_AXIS_TRIGGERLEFT = SDL_CONTROLLER_AXIS_TRIGGERLEFT,
    CONTROLLER_AXIS_TRIGGERRIGHT = SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
};

}

namespace pugi
{

struct xml_node_struct;
class xpath_node;
class xpath_node_set;
class xpath_query;
class xpath_variable_set;

}

namespace Urho3D
{

class XMLFile;
class XPathQuery;
class XPathResultSet;


class __attribute__((visibility("default"))) XMLElement
{
public:

    XMLElement();

    XMLElement(XMLFile* file, pugi::xml_node_struct* node);

    XMLElement(XMLFile* file, const XPathResultSet* resultSet, const pugi::xpath_node* xpathNode, unsigned xpathResultIndex);

    XMLElement(const XMLElement& rhs);

    ~XMLElement();

    XMLElement& operator =(const XMLElement& rhs);


    XMLElement CreateChild(const String& name);

    XMLElement CreateChild(const char* name);

    XMLElement GetOrCreateChild(const String& name);

    XMLElement GetOrCreateChild(const char* name);

    bool AppendChild(XMLElement element, bool asCopy = false);

    bool Remove();

    bool RemoveChild(const XMLElement& element);

    bool RemoveChild(const String& name);

    bool RemoveChild(const char* name);

    bool RemoveChildren(const String& name = String::EMPTY);

    bool RemoveChildren(const char* name);

    bool RemoveAttribute(const String& name = String::EMPTY);

    bool RemoveAttribute(const char* name);


    XMLElement SelectSingle(const String& query, pugi::xpath_variable_set* variables = nullptr) const;

    XMLElement SelectSinglePrepared(const XPathQuery& query) const;

    XPathResultSet Select(const String& query, pugi::xpath_variable_set* variables = nullptr) const;

    XPathResultSet SelectPrepared(const XPathQuery& query) const;


    bool SetValue(const String& value);

    bool SetValue(const char* value);

    bool SetAttribute(const String& name, const String& value);

    bool SetAttribute(const char* name, const char* value);

    bool SetAttribute(const String& value);

    bool SetAttribute(const char* value);

    bool SetBool(const String& name, bool value);

    bool SetBoundingBox(const BoundingBox& value);

    bool SetBuffer(const String& name, const void* data, unsigned size);

    bool SetBuffer(const String& name, const PODVector<unsigned char>& value);

    bool SetColor(const String& name, const Color& value);

    bool SetFloat(const String& name, float value);

    bool SetDouble(const String& name, double value);

    bool SetUInt(const String& name, unsigned value);

    bool SetInt(const String& name, int value);

    bool SetUInt64(const String& name, unsigned long long value);

    bool SetInt64(const String& name, long long value);

    bool SetIntRect(const String& name, const IntRect& value);

    bool SetIntVector2(const String& name, const IntVector2& value);

    bool SetIntVector3(const String& name, const IntVector3& value);

    bool SetRect(const String& name, const Rect& value);

    bool SetQuaternion(const String& name, const Quaternion& value);

    bool SetString(const String& name, const String& value);

    bool SetVariant(const Variant& value);

    bool SetVariantValue(const Variant& value);

    bool SetResourceRef(const ResourceRef& value);

    bool SetResourceRefList(const ResourceRefList& value);

    bool SetVariantVector(const VariantVector& value);

    bool SetStringVector(const StringVector& value);

    bool SetVariantMap(const VariantMap& value);

    bool SetVector2(const String& name, const Vector2& value);

    bool SetVector3(const String& name, const Vector3& value);

    bool SetVector4(const String& name, const Vector4& value);

    bool SetVectorVariant(const String& name, const Variant& value);

    bool SetMatrix3(const String& name, const Matrix3& value);

    bool SetMatrix3x4(const String& name, const Matrix3x4& value);

    bool SetMatrix4(const String& name, const Matrix4& value);


    bool IsNull() const;

    bool NotNull() const;

    explicit operator bool() const;

    String GetName() const;

    bool HasChild(const String& name) const;

    bool HasChild(const char* name) const;

    XMLElement GetChild(const String& name = String::EMPTY) const;

    XMLElement GetChild(const char* name) const;

    XMLElement GetNext(const String& name = String::EMPTY) const;

    XMLElement GetNext(const char* name) const;

    XMLElement GetParent() const;

    unsigned GetNumAttributes() const;

    bool HasAttribute(const String& name) const;

    bool HasAttribute(const char* name) const;

    String GetValue() const;

    String GetAttribute(const String& name = String::EMPTY) const;

    String GetAttribute(const char* name) const;

    const char* GetAttributeCString(const char* name) const;

    String GetAttributeLower(const String& name) const;

    String GetAttributeLower(const char* name) const;

    String GetAttributeUpper(const String& name) const;

    String GetAttributeUpper(const char* name) const;

    Vector<String> GetAttributeNames() const;

    bool GetBool(const String& name) const;

    PODVector<unsigned char> GetBuffer(const String& name) const;

    bool GetBuffer(const String& name, void* dest, unsigned size) const;

    BoundingBox GetBoundingBox() const;

    Color GetColor(const String& name) const;

    float GetFloat(const String& name) const;

    double GetDouble(const String& name) const;

    unsigned GetUInt(const String& name) const;

    int GetInt(const String& name) const;

    unsigned long long GetUInt64(const String& name) const;

    long long GetInt64(const String& name) const;

    IntRect GetIntRect(const String& name) const;

    IntVector2 GetIntVector2(const String& name) const;

    IntVector3 GetIntVector3(const String& name) const;

    Rect GetRect(const String& name) const;

    Quaternion GetQuaternion(const String& name) const;

    Variant GetVariant() const;

    Variant GetVariantValue(VariantType type) const;

    ResourceRef GetResourceRef() const;

    ResourceRefList GetResourceRefList() const;

    VariantVector GetVariantVector() const;

    StringVector GetStringVector() const;

    VariantMap GetVariantMap() const;

    Vector2 GetVector2(const String& name) const;

    Vector3 GetVector3(const String& name) const;

    Vector4 GetVector4(const String& name) const;

    Vector4 GetVector(const String& name) const;

    Variant GetVectorVariant(const String& name) const;

    Matrix3 GetMatrix3(const String& name) const;

    Matrix3x4 GetMatrix3x4(const String& name) const;

    Matrix4 GetMatrix4(const String& name) const;

    XMLFile* GetFile() const;


    const String& GetBasePath() const;


    pugi::xml_node_struct* GetNode() const { return node_; }


    const XPathResultSet* GetXPathResultSet() const { return xpathResultSet_; }


    const pugi::xpath_node* GetXPathNode() const { return xpathNode_; }


    unsigned GetXPathResultIndex() const { return xpathResultIndex_; }


    XMLElement NextResult() const;


    static const XMLElement EMPTY;

private:

    WeakPtr<XMLFile> file_;

    pugi::xml_node_struct* node_;

    const XPathResultSet* xpathResultSet_;

    const pugi::xpath_node* xpathNode_;

    mutable unsigned xpathResultIndex_;
};


class __attribute__((visibility("default"))) XPathResultSet
{
public:

    XPathResultSet();

    XPathResultSet(XMLFile* file, pugi::xpath_node_set* resultSet);

    XPathResultSet(const XPathResultSet& rhs);

    ~XPathResultSet();

    XPathResultSet& operator =(const XPathResultSet& rhs);


    XMLElement operator [](unsigned index) const;


    XMLElement FirstResult();

    unsigned Size() const;

    bool Empty() const;


    pugi::xpath_node_set* GetXPathNodeSet() const { return resultSet_; }

private:

    WeakPtr<XMLFile> file_;

    pugi::xpath_node_set* resultSet_;
};


class __attribute__((visibility("default"))) XPathQuery
{
public:

    XPathQuery();

    explicit XPathQuery(const String& queryString, const String& variableString = String::EMPTY);

    ~XPathQuery();

    void Bind();

    bool SetVariable(const String& name, bool value);

    bool SetVariable(const String& name, float value);

    bool SetVariable(const String& name, const String& value);

    bool SetVariable(const char* name, const char* value);

    bool SetVariable(const String& name, const XPathResultSet& value);

    bool SetQuery(const String& queryString, const String& variableString = String::EMPTY, bool bind = true);

    void Clear();

    bool EvaluateToBool(const XMLElement& element) const;

    float EvaluateToFloat(const XMLElement& element) const;

    String EvaluateToString(const XMLElement& element) const;


    XPathResultSet Evaluate(const XMLElement& element) const;


    String GetQuery() const { return queryString_; }


    pugi::xpath_query* GetXPathQuery() const { return query_.Get(); }


    pugi::xpath_variable_set* GetXPathVariableSet() const { return variables_.Get(); }

private:

    String queryString_;

    UniquePtr<pugi::xpath_query> query_;

    UniquePtr<pugi::xpath_variable_set> variables_;
};

}


namespace pugi
{

class xml_document;
class xml_node;
class xpath_node;

}

namespace Urho3D
{


class __attribute__((visibility("default"))) XMLFile : public Resource
{
    public: using ClassName = XMLFile; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("XMLFile", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit XMLFile(Context* context);

    ~XMLFile() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;

    bool Save(Serializer& dest, const String& indentation) const;


    bool FromString(const String& source);

    XMLElement CreateRoot(const String& name);

    XMLElement GetOrCreateRoot(const String& name);


    XMLElement GetRoot(const String& name = String::EMPTY);


    pugi::xml_document* GetDocument() const { return document_.Get(); }


    String ToString(const String& indentation = "\t") const;


    void Patch(XMLFile* patchFile);

    void Patch(const XMLElement& patchElement);

private:

    void PatchAdd(const pugi::xml_node& patch, pugi::xpath_node& original) const;

    void PatchReplace(const pugi::xml_node& patch, pugi::xpath_node& original) const;

    void PatchRemove(const pugi::xpath_node& original) const;


    void AddNode(const pugi::xml_node& patch, const pugi::xpath_node& original) const;

    void AddAttribute(const pugi::xml_node& patch, const pugi::xpath_node& original) const;

    bool CombineText(const pugi::xml_node& patch, const pugi::xml_node& original, bool prepend) const;


    UniquePtr<pugi::xml_document> document_;
};

}


namespace Urho3D
{


class __attribute__((visibility("default"))) Plane
{
public:

    Plane() noexcept :
        d_(0.0f)
    {
    }


    Plane(const Plane& plane) noexcept = default;


    Plane(const Vector3& v0, const Vector3& v1, const Vector3& v2) noexcept
    {
        Define(v0, v1, v2);
    }


    Plane(const Vector3& normal, const Vector3& point) noexcept
    {
        Define(normal, point);
    }


    explicit Plane(const Vector4& plane) noexcept
    {
        Define(plane);
    }


    Plane& operator =(const Plane& rhs) noexcept = default;


    void Define(const Vector3& v0, const Vector3& v1, const Vector3& v2)
    {
        Vector3 dist1 = v1 - v0;
        Vector3 dist2 = v2 - v0;

        Define(dist1.CrossProduct(dist2), v0);
    }


    void Define(const Vector3& normal, const Vector3& point)
    {
        normal_ = normal.Normalized();
        absNormal_ = normal_.Abs();
        d_ = -normal_.DotProduct(point);
    }


    void Define(const Vector4& plane)
    {
        normal_ = Vector3(plane.x_, plane.y_, plane.z_);
        absNormal_ = normal_.Abs();
        d_ = plane.w_;
    }


    void Transform(const Matrix3& transform);

    void Transform(const Matrix3x4& transform);

    void Transform(const Matrix4& transform);


    Vector3 Project(const Vector3& point) const { return point - normal_ * (normal_.DotProduct(point) + d_); }


    float Distance(const Vector3& point) const { return normal_.DotProduct(point) + d_; }


    Vector3 Reflect(const Vector3& direction) const { return direction - (2.0f * normal_.DotProduct(direction) * normal_); }


    Matrix3x4 ReflectionMatrix() const;

    Plane Transformed(const Matrix3& transform) const;

    Plane Transformed(const Matrix3x4& transform) const;

    Plane Transformed(const Matrix4& transform) const;


    Vector4 ToVector4() const { return Vector4(normal_, d_); }


    Vector3 normal_;

    Vector3 absNormal_;

    float d_{};


    static const Plane UP;
};

}


namespace Urho3D
{

class BoundingBox;
class Polyhedron;
class Frustum;


class __attribute__((visibility("default"))) Sphere
{
public:

    Sphere() noexcept :
        center_(Vector3::ZERO),
        radius_(-M_INFINITY)
    {
    }


    Sphere(const Sphere& sphere) noexcept = default;


    Sphere(const Vector3& center, float radius) noexcept :
        center_(center),
        radius_(radius)
    {
    }


    Sphere(const Vector3* vertices, unsigned count) noexcept
    {
        Define(vertices, count);
    }


    explicit Sphere(const BoundingBox& box) noexcept
    {
        Define(box);
    }


    explicit Sphere(const Frustum& frustum) noexcept
    {
        Define(frustum);
    }


    explicit Sphere(const Polyhedron& poly) noexcept
    {
        Define(poly);
    }


    Sphere& operator =(const Sphere& rhs) noexcept = default;


    bool operator ==(const Sphere& rhs) const { return center_ == rhs.center_ && radius_ == rhs.radius_; }


    bool operator !=(const Sphere& rhs) const { return center_ != rhs.center_ || radius_ != rhs.radius_; }


    void Define(const Sphere& sphere)
    {
        Define(sphere.center_, sphere.radius_);
    }


    void Define(const Vector3& center, float radius)
    {
        center_ = center;
        radius_ = radius;
    }


    void Define(const Vector3* vertices, unsigned count);

    void Define(const BoundingBox& box);

    void Define(const Frustum& frustum);

    void Define(const Polyhedron& poly);


    void Merge(const Vector3& point)
    {
        if (radius_ < 0.0f)
        {
            center_ = point;
            radius_ = 0.0f;
            return;
        }

        Vector3 offset = point - center_;
        float dist = offset.Length();

        if (dist > radius_)
        {
            float half = (dist - radius_) * 0.5f;
            radius_ += half;
            center_ += (half / dist) * offset;
        }
    }


    void Merge(const Vector3* vertices, unsigned count);

    void Merge(const BoundingBox& box);

    void Merge(const Frustum& frustum);

    void Merge(const Polyhedron& poly);

    void Merge(const Sphere& sphere);


    void Clear()
    {
        center_ = Vector3::ZERO;
        radius_ = -M_INFINITY;
    }


    bool Defined() const
    {
        return radius_ >= 0.0f;
    }


    Intersection IsInside(const Vector3& point) const
    {
        float distSquared = (point - center_).LengthSquared();
        if (distSquared < radius_ * radius_)
            return INSIDE;
        else
            return OUTSIDE;
    }


    Intersection IsInside(const Sphere& sphere) const
    {
        float dist = (sphere.center_ - center_).Length();
        if (dist >= sphere.radius_ + radius_)
            return OUTSIDE;
        else if (dist + sphere.radius_ < radius_)
            return INSIDE;
        else
            return INTERSECTS;
    }


    Intersection IsInsideFast(const Sphere& sphere) const
    {
        float distSquared = (sphere.center_ - center_).LengthSquared();
        float combined = sphere.radius_ + radius_;

        if (distSquared >= combined * combined)
            return OUTSIDE;
        else
            return INSIDE;
    }


    Intersection IsInside(const BoundingBox& box) const;

    Intersection IsInsideFast(const BoundingBox& box) const;


    float Distance(const Vector3& point) const { return Max((point - center_).Length() - radius_, 0.0f); }

    Vector3 GetLocalPoint(float theta, float phi) const;

    Vector3 GetPoint(float theta, float phi) const { return center_ + GetLocalPoint(theta, phi); }


    Vector3 center_;

    float radius_{};
};

}


namespace Urho3D
{


enum FrustumPlane
{
    PLANE_NEAR = 0,
    PLANE_LEFT,
    PLANE_RIGHT,
    PLANE_UP,
    PLANE_DOWN,
    PLANE_FAR,
};

static const unsigned NUM_FRUSTUM_PLANES = 6;
static const unsigned NUM_FRUSTUM_VERTICES = 8;


class __attribute__((visibility("default"))) Frustum
{
public:

    Frustum() noexcept = default;


    Frustum(const Frustum& frustum) noexcept;


    Frustum& operator =(const Frustum& rhs) noexcept;


    void
        Define(float fov, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform = Matrix3x4::IDENTITY);

    void Define(const Vector3& near, const Vector3& far, const Matrix3x4& transform = Matrix3x4::IDENTITY);

    void Define(const BoundingBox& box, const Matrix3x4& transform = Matrix3x4::IDENTITY);

    void Define(const Matrix4& projection);

    void DefineOrtho
        (float orthoSize, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform = Matrix3x4::IDENTITY);

    void DefineSplit(const Matrix4& projection, float near, float far);

    void Transform(const Matrix3& transform);

    void Transform(const Matrix3x4& transform);


    Intersection IsInside(const Vector3& point) const
    {
        for (const auto& plane : planes_)
        {
            if (plane.Distance(point) < 0.0f)
                return OUTSIDE;
        }

        return INSIDE;
    }


    Intersection IsInside(const Sphere& sphere) const
    {
        bool allInside = true;
        for (const auto& plane : planes_)
        {
            float dist = plane.Distance(sphere.center_);
            if (dist < -sphere.radius_)
                return OUTSIDE;
            else if (dist < sphere.radius_)
                allInside = false;
        }

        return allInside ? INSIDE : INTERSECTS;
    }


    Intersection IsInsideFast(const Sphere& sphere) const
    {
        for (const auto& plane : planes_)
        {
            if (plane.Distance(sphere.center_) < -sphere.radius_)
                return OUTSIDE;
        }

        return INSIDE;
    }


    Intersection IsInside(const BoundingBox& box) const
    {
        Vector3 center = box.Center();
        Vector3 edge = center - box.min_;
        bool allInside = true;

        for (const auto& plane : planes_)
        {
            float dist = plane.normal_.DotProduct(center) + plane.d_;
            float absDist = plane.absNormal_.DotProduct(edge);

            if (dist < -absDist)
                return OUTSIDE;
            else if (dist < absDist)
                allInside = false;
        }

        return allInside ? INSIDE : INTERSECTS;
    }


    Intersection IsInsideFast(const BoundingBox& box) const
    {
        Vector3 center = box.Center();
        Vector3 edge = center - box.min_;

        for (const auto& plane : planes_)
        {
            float dist = plane.normal_.DotProduct(center) + plane.d_;
            float absDist = plane.absNormal_.DotProduct(edge);

            if (dist < -absDist)
                return OUTSIDE;
        }

        return INSIDE;
    }


    float Distance(const Vector3& point) const
    {
        float distance = 0.0f;
        for (const auto& plane : planes_)
            distance = Max(-plane.Distance(point), distance);

        return distance;
    }


    Frustum Transformed(const Matrix3& transform) const;

    Frustum Transformed(const Matrix3x4& transform) const;

    Rect Projected(const Matrix4& projection) const;


    void UpdatePlanes();


    Plane planes_[NUM_FRUSTUM_PLANES];

    Vector3 vertices_[NUM_FRUSTUM_VERTICES];
};

}



namespace Urho3D
{

class Camera;
struct LightBatchQueue;


enum LightType
{
    LIGHT_DIRECTIONAL = 0,
    LIGHT_SPOT,
    LIGHT_POINT
};

static const float SHADOW_MIN_QUANTIZE = 0.1f;
static const float SHADOW_MIN_VIEW = 1.0f;
static const int MAX_LIGHT_SPLITS = 6;

static const unsigned MAX_CASCADE_SPLITS = 4;





struct __attribute__((visibility("default"))) BiasParameters
{

    BiasParameters() = default;


    BiasParameters(float constantBias, float slopeScaledBias, float normalOffset = 0.0f) :
        constantBias_(constantBias),
        slopeScaledBias_(slopeScaledBias),
        normalOffset_(normalOffset)
    {
    }


    void Validate();


    float constantBias_;

    float slopeScaledBias_;

    float normalOffset_;
};


struct __attribute__((visibility("default"))) CascadeParameters
{

    CascadeParameters() = default;


    CascadeParameters(float split1, float split2, float split3, float split4, float fadeStart, float biasAutoAdjust = 1.0f) :
        fadeStart_(fadeStart),
        biasAutoAdjust_(biasAutoAdjust)
    {
        splits_[0] = split1;
        splits_[1] = split2;
        splits_[2] = split3;
        splits_[3] = split4;
    }


    void Validate();


    float GetShadowRange() const
    {
        float ret = 0.0f;
        for (unsigned i = 0; i < MAX_CASCADE_SPLITS; ++i)
            ret = Max(ret, splits_[i]);

        return ret;
    }


    Vector4 splits_;

    float fadeStart_{};

    float biasAutoAdjust_{};
};


struct __attribute__((visibility("default"))) FocusParameters
{

    FocusParameters() = default;


    FocusParameters(bool focus, bool nonUniform, bool autoSize, float quantize, float minView) :
        focus_(focus),
        nonUniform_(nonUniform),
        autoSize_(autoSize),
        quantize_(quantize),
        minView_(minView)
    {
    }


    void Validate();


    bool focus_;

    bool nonUniform_;

    bool autoSize_;

    float quantize_;

    float minView_;
};


class __attribute__((visibility("default"))) Light : public Drawable
{
    public: using ClassName = Light; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Light", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Light(Context* context);

    ~Light() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetLightType(LightType type);

    void SetPerVertex(bool enable);

    void SetColor(const Color& color);

    void SetTemperature(float temperature);

    void SetRadius(float radius);

    void SetLength(float length);

    void SetUsePhysicalValues(bool enable);

    void SetSpecularIntensity(float intensity);

    void SetBrightness(float brightness);

    void SetRange(float range);

    void SetFov(float fov);

    void SetAspectRatio(float aspectRatio);

    void SetFadeDistance(float distance);

    void SetShadowFadeDistance(float distance);

    void SetShadowBias(const BiasParameters& parameters);

    void SetShadowCascade(const CascadeParameters& parameters);

    void SetShadowFocus(const FocusParameters& parameters);

    void SetShadowIntensity(float intensity);

    void SetShadowResolution(float resolution);

    void SetShadowNearFarRatio(float nearFarRatio);

    void SetShadowMaxExtrusion(float extrusion);

    void SetRampTexture(Texture* texture);

    void SetShapeTexture(Texture* texture);


    LightType GetLightType() const { return lightType_; }


    bool GetPerVertex() const { return perVertex_; }


    const Color& GetColor() const { return color_; }


    float GetTemperature() const { return temperature_; }


    float GetRadius() const { return lightRad_; }


    float GetLength() const { return lightLength_; }


    bool GetUsePhysicalValues() const { return usePhysicalValues_; }


    Color GetColorFromTemperature() const;


    float GetSpecularIntensity() const { return specularIntensity_; }


    float GetBrightness() const { return brightness_; }


    Color GetEffectiveColor() const;


    float GetEffectiveSpecularIntensity() const { return specularIntensity_ * Abs(brightness_); }


    float GetRange() const { return range_; }


    float GetFov() const { return fov_; }


    float GetAspectRatio() const { return aspectRatio_; }


    float GetFadeDistance() const { return fadeDistance_; }


    float GetShadowFadeDistance() const { return shadowFadeDistance_; }


    const BiasParameters& GetShadowBias() const { return shadowBias_; }


    const CascadeParameters& GetShadowCascade() const { return shadowCascade_; }


    const FocusParameters& GetShadowFocus() const { return shadowFocus_; }


    float GetShadowIntensity() const { return shadowIntensity_; }


    float GetShadowResolution() const { return shadowResolution_; }


    float GetShadowNearFarRatio() const { return shadowNearFarRatio_; }


    float GetShadowMaxExtrusion() const { return shadowMaxExtrusion_; }


    Texture* GetRampTexture() const { return rampTexture_; }


    Texture* GetShapeTexture() const { return shapeTexture_; }


    Frustum GetFrustum() const;

    Frustum GetViewSpaceFrustum(const Matrix3x4& view) const;


    int GetNumShadowSplits() const;


    bool IsNegative() const { return GetEffectiveColor().SumRGB() < 0.0f; }


    void SetIntensitySortValue(float distance);

    void SetIntensitySortValue(const BoundingBox& box);

    void SetLightQueue(LightBatchQueue* queue);

    const Matrix3x4& GetVolumeTransform(Camera* camera);


    LightBatchQueue* GetLightQueue() const { return lightQueue_; }


    float GetIntensityDivisor(float attenuation = 1.0f) const
    {
        return Max(GetEffectiveColor().SumRGB(), 0.0f) * attenuation + M_EPSILON;
    }


    void SetRampTextureAttr(const ResourceRef& value);

    void SetShapeTextureAttr(const ResourceRef& value);

    ResourceRef GetRampTextureAttr() const;

    ResourceRef GetShapeTextureAttr() const;


    static Matrix3x4 GetFullscreenQuadTransform(Camera* camera);

protected:

    void OnWorldBoundingBoxUpdate() override;

private:

    void ValidateShadowFocus() { shadowFocus_.Validate(); }

    void ValidateShadowCascade() { shadowCascade_.Validate(); }

    void ValidateShadowBias() { shadowBias_.Validate(); }

    LightType lightType_;

    Color color_;

    float temperature_;

    float lightRad_;

    float lightLength_;

    BiasParameters shadowBias_;

    CascadeParameters shadowCascade_;

    FocusParameters shadowFocus_;

    Matrix3x4 volumeTransform_;

    SharedPtr<Texture> rampTexture_;

    SharedPtr<Texture> shapeTexture_;

    LightBatchQueue* lightQueue_;

    float specularIntensity_;

    float brightness_;

    float range_;

    float fov_;

    float aspectRatio_;

    float fadeDistance_;

    float shadowFadeDistance_;

    float shadowIntensity_;

    float shadowResolution_;

    float shadowNearFarRatio_;

    float shadowMaxExtrusion_;

    bool perVertex_;

    bool usePhysicalValues_;
};

inline bool CompareLights(Light* lhs, Light* rhs)
{

    if (lhs->GetPerVertex() != rhs->GetPerVertex())
        return lhs->GetPerVertex();
    else
        return lhs->GetSortValue() < rhs->GetSortValue();
}

}





namespace Urho3D
{

class Material;
class Pass;
class Scene;
class Technique;
class Texture;
class Texture2D;
class TextureCube;
class ValueAnimationInfo;
class JSONFile;

static const unsigned char DEFAULT_RENDER_ORDER = 128;


struct MaterialShaderParameter
{

    String name_;

    Variant value_;
};


struct TechniqueEntry
{

    TechniqueEntry() noexcept;

    TechniqueEntry(Technique* tech, MaterialQuality qualityLevel, float lodDistance) noexcept;

    ~TechniqueEntry() noexcept = default;


    SharedPtr<Technique> technique_;

    SharedPtr<Technique> original_;

    MaterialQuality qualityLevel_;

    float lodDistance_;
};


class ShaderParameterAnimationInfo : public ValueAnimationInfo
{
public:

    ShaderParameterAnimationInfo
        (Material* material, const String& name, ValueAnimation* attributeAnimation, WrapMode wrapMode, float speed);

    ShaderParameterAnimationInfo(const ShaderParameterAnimationInfo& other);

    ~ShaderParameterAnimationInfo() override;


    const String& GetName() const { return name_; }

protected:

    void ApplyValue(const Variant& newValue) override;

private:

    String name_;
};


template <> inline unsigned MakeHash(const TextureUnit& value)
{
    return (unsigned)value;
}


class __attribute__((visibility("default"))) Material : public Resource
{
    public: using ClassName = Material; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Material", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Material(Context* context);

    ~Material() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    bool Save(Serializer& dest) const override;


    bool Load(const XMLElement& source);

    bool Save(XMLElement& dest) const;


    bool Load(const JSONValue& source);

    bool Save(JSONValue& dest) const;


    void SetNumTechniques(unsigned num);

    void SetTechnique(unsigned index, Technique* tech, MaterialQuality qualityLevel = QUALITY_LOW, float lodDistance = 0.0f);

    void SetVertexShaderDefines(const String& defines);

    void SetPixelShaderDefines(const String& defines);

    void SetShaderParameter(const String& name, const Variant& value);

    void
        SetShaderParameterAnimation(const String& name, ValueAnimation* animation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f);

    void SetShaderParameterAnimationWrapMode(const String& name, WrapMode wrapMode);

    void SetShaderParameterAnimationSpeed(const String& name, float speed);

    void SetTexture(TextureUnit unit, Texture* texture);

    void SetUVTransform(const Vector2& offset, float rotation, const Vector2& repeat);

    void SetUVTransform(const Vector2& offset, float rotation, float repeat);

    void SetCullMode(CullMode mode);

    void SetShadowCullMode(CullMode mode);

    void SetFillMode(FillMode mode);

    void SetDepthBias(const BiasParameters& parameters);

    void SetAlphaToCoverage(bool enable);

    void SetLineAntiAlias(bool enable);

    void SetRenderOrder(unsigned char order);

    void SetOcclusion(bool enable);

    void SetScene(Scene* scene);

    void RemoveShaderParameter(const String& name);

    void ReleaseShaders();

    SharedPtr<Material> Clone(const String& cloneName = String::EMPTY) const;

    void SortTechniques();

    void MarkForAuxView(unsigned frameNumber);


    unsigned GetNumTechniques() const { return techniques_.Size(); }


    const Vector<TechniqueEntry>& GetTechniques() const { return techniques_; }


    const TechniqueEntry& GetTechniqueEntry(unsigned index) const;

    Technique* GetTechnique(unsigned index) const;

    Pass* GetPass(unsigned index, const String& passName) const;

    Texture* GetTexture(TextureUnit unit) const;


    const HashMap<TextureUnit, SharedPtr<Texture> >& GetTextures() const { return textures_; }


    const String& GetVertexShaderDefines() const { return vertexShaderDefines_; }

    const String& GetPixelShaderDefines() const { return pixelShaderDefines_; }


    const Variant& GetShaderParameter(const String& name) const;

    ValueAnimation* GetShaderParameterAnimation(const String& name) const;

    WrapMode GetShaderParameterAnimationWrapMode(const String& name) const;

    float GetShaderParameterAnimationSpeed(const String& name) const;


    const HashMap<StringHash, MaterialShaderParameter>& GetShaderParameters() const { return shaderParameters_; }


    CullMode GetCullMode() const { return cullMode_; }


    CullMode GetShadowCullMode() const { return shadowCullMode_; }


    FillMode GetFillMode() const { return fillMode_; }


    const BiasParameters& GetDepthBias() const { return depthBias_; }


    bool GetAlphaToCoverage() const { return alphaToCoverage_; }


    bool GetLineAntiAlias() const { return lineAntiAlias_; }


    unsigned char GetRenderOrder() const { return renderOrder_; }


    unsigned GetAuxViewFrameNumber() const { return auxViewFrameNumber_; }


    bool GetOcclusion() const { return occlusion_; }


    bool GetSpecular() const { return specular_; }


    Scene* GetScene() const;


    unsigned GetShaderParameterHash() const { return shaderParameterHash_; }


    static String GetTextureUnitName(TextureUnit unit);

    static Variant ParseShaderParameterValue(const String& value);

private:

    bool BeginLoadJSON(Deserializer& source);

    bool BeginLoadXML(Deserializer& source);


    void ResetToDefaults();

    void RefreshShaderParameterHash();

    void RefreshMemoryUse();

    void ApplyShaderDefines(unsigned index = M_MAX_UNSIGNED);

    ShaderParameterAnimationInfo* GetShaderParameterAnimationInfo(const String& name) const;

    void UpdateEventSubscription();

    void HandleAttributeAnimationUpdate(StringHash eventType, VariantMap& eventData);


    Vector<TechniqueEntry> techniques_;

    HashMap<TextureUnit, SharedPtr<Texture> > textures_;

    HashMap<StringHash, MaterialShaderParameter> shaderParameters_;

    HashMap<StringHash, SharedPtr<ShaderParameterAnimationInfo> > shaderParameterAnimationInfos_;

    String vertexShaderDefines_;

    String pixelShaderDefines_;

    CullMode cullMode_{};

    CullMode shadowCullMode_{};

    FillMode fillMode_{};

    BiasParameters depthBias_{};

    unsigned char renderOrder_{};

    unsigned auxViewFrameNumber_{};

    unsigned shaderParameterHash_{};

    bool alphaToCoverage_{};

    bool lineAntiAlias_{};

    bool occlusion_{true};

    bool specular_{};

    bool subscribed_{};

    bool batchedParameterUpdate_{};

    SharedPtr<XMLFile> loadXMLFile_;

    SharedPtr<JSONFile> loadJSONFile_;

    WeakPtr<Scene> scene_;
};

}


namespace Urho3D
{

class PixelShader;
class Graphics;
class Matrix3x4;
class Texture;
class UIElement;

static const unsigned UI_VERTEX_SIZE = 6;


class __attribute__((visibility("default"))) UIBatch
{
public:

    UIBatch();

    UIBatch(UIElement* element, BlendMode blendMode, const IntRect& scissor, Texture* texture, PODVector<float>* vertexData);


    void SetColor(const Color& color, bool overrideAlpha = false);

    void SetDefaultColor();

    void AddQuad(float x, float y, float width, float height, int texOffsetX, int texOffsetY, int texWidth = 0, int texHeight = 0);

    void AddQuad(const Matrix3x4& transform, int x, int y, int width, int height, int texOffsetX, int texOffsetY, int texWidth = 0,
        int texHeight = 0);

    void AddQuad(int x, int y, int width, int height, int texOffsetX, int texOffsetY, int texWidth, int texHeight, bool tiled);

    void AddQuad(const Matrix3x4& transform, const IntVector2& a, const IntVector2& b, const IntVector2& c, const IntVector2& d,
        const IntVector2& texA, const IntVector2& texB, const IntVector2& texC, const IntVector2& texD);

    void AddQuad(const Matrix3x4& transform, const IntVector2& a, const IntVector2& b, const IntVector2& c, const IntVector2& d,
        const IntVector2& texA, const IntVector2& texB, const IntVector2& texC, const IntVector2& texD, const Color& colA,
        const Color& colB, const Color& colC, const Color& colD);

    bool Merge(const UIBatch& batch);

    unsigned GetInterpolatedColor(float x, float y);


    static void AddOrMerge(const UIBatch& batch, PODVector<UIBatch>& batches);


    UIElement* element_{};

    BlendMode blendMode_{BLEND_REPLACE};

    IntRect scissor_;

    Texture* texture_{};

    Vector2 invTextureSize_{Vector2::ONE};

    PODVector<float>* vertexData_{};

    unsigned vertexStart_{};

    unsigned vertexEnd_{};

    unsigned color_{};

    bool useGradient_{};

    Material* custom_material_{};


    static Vector3 posAdjust;
};

}


namespace Urho3D
{


enum HorizontalAlignment
{
    HA_LEFT = 0,
    HA_CENTER,
    HA_RIGHT,
    HA_CUSTOM
};


enum VerticalAlignment
{
    VA_TOP = 0,
    VA_CENTER,
    VA_BOTTOM,
    VA_CUSTOM
};


enum Corner
{
    C_TOPLEFT = 0,
    C_TOPRIGHT,
    C_BOTTOMLEFT,
    C_BOTTOMRIGHT,
    MAX_UIELEMENT_CORNERS
};


enum Orientation
{
    O_HORIZONTAL = 0,
    O_VERTICAL
};


enum FocusMode
{

    FM_NOTFOCUSABLE = 0,

    FM_RESETFOCUS,

    FM_FOCUSABLE,

    FM_FOCUSABLE_DEFOCUSABLE
};


enum LayoutMode
{

    LM_FREE = 0,

    LM_HORIZONTAL,

    LM_VERTICAL
};


enum TraversalMode
{

    TM_BREADTH_FIRST = 0,

    TM_DEPTH_FIRST
};

enum DragAndDropMode : unsigned
{

    DD_DISABLED = 0x0,

    DD_SOURCE = 0x1,

    DD_TARGET = 0x2,

    DD_SOURCE_AND_TARGET = 0x3,
};
template<> struct IsFlagSet<DragAndDropMode> { constexpr static bool value_ = true; }; using DragAndDropModeFlags = FlagSet<DragAndDropMode>;

class Cursor;
class ResourceCache;
class Texture2D;


class __attribute__((visibility("default"))) UIElement : public Animatable
{
    public: using ClassName = UIElement; using BaseClassName = Animatable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("UIElement", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit UIElement(Context* context);

    ~UIElement() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    bool LoadXML(const XMLElement& source) override;

    virtual bool LoadXML(const XMLElement& source, XMLFile* styleFile);

    virtual UIElement* LoadChildXML(const XMLElement& childElem, XMLFile* styleFile);

    bool SaveXML(XMLElement& dest) const override;


    virtual void Update(float timeStep);

    virtual bool IsWithinScissor(const IntRect& currentScissor);

    virtual const IntVector2& GetScreenPosition() const;

    virtual void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor);

    virtual void GetDebugDrawBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor);

    virtual void OnHover(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor);

    virtual void OnClickBegin
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) { }

    virtual void OnClickEnd
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor,
            UIElement* beginElement) { }

    virtual void OnDoubleClick
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) { }

    virtual void
        OnDragBegin(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor);

    virtual void OnDragMove
        (const IntVector2& position, const IntVector2& screenPosition, const IntVector2& deltaPos, int buttons, int qualifiers,
            Cursor* cursor);

    virtual void
        OnDragEnd(const IntVector2& position, const IntVector2& screenPosition, int dragButtons, int releaseButton, Cursor* cursor);

    virtual void OnDragCancel
        (const IntVector2& position, const IntVector2& screenPosition, int dragButtons, int cancelButton, Cursor* cursor);

    virtual bool OnDragDropTest(UIElement* source);

    virtual bool OnDragDropFinish(UIElement* source);

    virtual void OnWheel(int delta, MouseButtonFlags buttons, QualifierFlags qualifiers) { }

    virtual void OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers) { }

    virtual void OnTextInput(const String& text) { }


    virtual void OnResize(const IntVector2& newSize, const IntVector2& delta) { }


    virtual void OnPositionSet(const IntVector2& newPosition) { }


    virtual void OnSetEditable() { }


    virtual void OnIndentSet() { }


    virtual IntVector2 ScreenToElement(const IntVector2& screenPosition);

    virtual IntVector2 ElementToScreen(const IntVector2& position);


    virtual bool IsWheelHandler() const { return false; }


    bool LoadXML(Deserializer& source);

    bool SaveXML(Serializer& dest, const String& indentation = "\t") const;

    bool FilterAttributes(XMLElement& dest) const;


    void SetName(const String& name);

    void SetPosition(const IntVector2& position);

    void SetPosition(int x, int y);

    void SetSize(const IntVector2& size);

    void SetSize(int width, int height);

    void SetWidth(int width);

    void SetHeight(int height);

    void SetMinSize(const IntVector2& minSize);

    void SetMinSize(int width, int height);

    void SetMinWidth(int width);

    void SetMinHeight(int height);

    void SetMaxSize(const IntVector2& maxSize);

    void SetMaxSize(int width, int height);

    void SetMaxWidth(int width);

    void SetMaxHeight(int height);

    void SetFixedSize(const IntVector2& size);

    void SetFixedSize(int width, int height);

    void SetFixedWidth(int width);

    void SetFixedHeight(int height);

    void SetAlignment(HorizontalAlignment hAlign, VerticalAlignment vAlign);

    void SetHorizontalAlignment(HorizontalAlignment align);

    void SetVerticalAlignment(VerticalAlignment align);

    void SetEnableAnchor(bool enable);

    void SetMinAnchor(const Vector2& anchor);

    void SetMinAnchor(float x, float y);

    void SetMaxAnchor(const Vector2& anchor);

    void SetMaxAnchor(float x, float y);

    void SetMinOffset(const IntVector2& offset);

    void SetMaxOffset(const IntVector2& offset);

    void SetPivot(const Vector2& pivot);

    void SetPivot(float x, float y);

    void SetClipBorder(const IntRect& rect);

    void SetColor(const Color& color);

    void SetColor(Corner corner, const Color& color);

    void SetPriority(int priority);

    void SetOpacity(float opacity);

    void SetBringToFront(bool enable);

    void SetBringToBack(bool enable);

    void SetClipChildren(bool enable);

    void SetSortChildren(bool enable);

    void SetUseDerivedOpacity(bool enable);

    void SetEnabled(bool enable);

    void SetDeepEnabled(bool enable);

    void ResetDeepEnabled();

    void SetEnabledRecursive(bool enable);

    void SetEditable(bool enable);

    void SetFocus(bool enable);

    void SetSelected(bool enable);

    void SetVisible(bool enable);

    void SetFocusMode(FocusMode mode);

    void SetDragDropMode(DragAndDropModeFlags mode);

    bool SetStyle(const String& styleName, XMLFile* file = nullptr);

    bool SetStyle(const XMLElement& element);

    bool SetStyleAuto(XMLFile* file = nullptr);

    void SetDefaultStyle(XMLFile* style);

    void SetLayout(LayoutMode mode, int spacing = 0, const IntRect& border = IntRect::ZERO);

    void SetLayoutMode(LayoutMode mode);

    void SetLayoutSpacing(int spacing);

    void SetLayoutBorder(const IntRect& border);

    void SetLayoutFlexScale(const Vector2& scale);

    void SetIndent(int indent);

    void SetIndentSpacing(int indentSpacing);

    void UpdateLayout();

    void DisableLayoutUpdate();

    void EnableLayoutUpdate();

    void BringToFront();

    UIElement* CreateChild(StringHash type, const String& name = String::EMPTY, unsigned index = M_MAX_UNSIGNED);

    void AddChild(UIElement* element);

    void InsertChild(unsigned index, UIElement* element);

    void RemoveChild(UIElement* element, unsigned index = 0);

    void RemoveChildAtIndex(unsigned index);

    void RemoveAllChildren();

    void Remove();

    unsigned FindChild(UIElement* element) const;

    void SetParent(UIElement* parent, unsigned index = M_MAX_UNSIGNED);

    void SetVar(StringHash key, const Variant& value);

    void SetInternal(bool enable);

    void SetTraversalMode(TraversalMode traversalMode);

    void SetElementEventSender(bool flag);


    virtual void SetBasePath(const String& basePath);


    void SetTags(const StringVector& tags);

    void AddTag(const String& tag);

    void AddTags(const String& tags, char separator = ';');

    void AddTags(const StringVector& tags);

    bool RemoveTag(const String& tag);

    void RemoveAllTags();


    template <class T> T* CreateChild(const String& name = String::EMPTY, unsigned index = M_MAX_UNSIGNED);

    template <class T> T* GetChildStaticCast(unsigned index) const;

    template <class T> T* GetChildStaticCast(const String& name, bool recursive = false) const;

    template <class T> T* GetChildStaticCast(const StringHash& key, const Variant& value = Variant::EMPTY, bool recursive = false) const;

    template <class T> T* GetChildDynamicCast(unsigned index) const;

    template <class T> T* GetChildDynamicCast(const String& name, bool recursive = false) const;

    template <class T> T* GetChildDynamicCast(const StringHash& key, const Variant& value = Variant::EMPTY, bool recursive = false) const;


    const String& GetName() const { return name_; }


    const IntVector2& GetPosition() const { return position_; }


    const IntVector2& GetSize() const { return size_; }


    int GetWidth() const { return size_.x_; }


    int GetHeight() const { return size_.y_; }


    const IntVector2& GetMinSize() const { return minSize_; }


    int GetMinWidth() const { return minSize_.x_; }


    int GetMinHeight() const { return minSize_.y_; }


    const IntVector2& GetMaxSize() const { return maxSize_; }


    int GetMaxWidth() const { return maxSize_.x_; }


    int GetMaxHeight() const { return maxSize_.y_; }


    bool IsFixedSize() const { return minSize_ == maxSize_; }


    bool IsFixedWidth() const { return minSize_.x_ == maxSize_.x_; }


    bool IsFixedHeight() const { return minSize_.y_ == maxSize_.y_; }


    const IntVector2& GetChildOffset() const { return childOffset_; }


    HorizontalAlignment GetHorizontalAlignment() const;


    VerticalAlignment GetVerticalAlignment() const;


    bool GetEnableAnchor() const { return enableAnchor_; }


    const Vector2& GetMinAnchor() const { return anchorMin_; }


    const Vector2& GetMaxAnchor() const { return anchorMax_; }


    const IntVector2& GetMinOffset() const { return minOffset_; }


    const IntVector2& GetMaxOffset() const { return maxOffset_; }


    const Vector2& GetPivot() const { return pivot_; }


    const IntRect& GetClipBorder() const { return clipBorder_; }


    const Color& GetColor(Corner corner) const { return colors_[corner]; }


    int GetPriority() const { return priority_; }


    float GetOpacity() const { return opacity_; }


    float GetDerivedOpacity() const;


    bool GetBringToFront() const { return bringToFront_; }


    bool GetBringToBack() const { return bringToBack_; }


    bool GetClipChildren() const { return clipChildren_; }


    bool GetSortChildren() const { return sortChildren_; }


    bool GetUseDerivedOpacity() const { return useDerivedOpacity_; }


    bool HasFocus() const;


    bool IsChildOf(UIElement* element) const;


    bool IsEnabled() const { return enabled_; }


    bool IsEnabledSelf() const { return enabledPrev_; }


    bool IsEditable() const { return editable_; }


    bool IsSelected() const { return selected_; }


    bool IsVisible() const { return visible_; }


    bool IsVisibleEffective() const;


    bool IsHovering() const { return hovering_; }


    bool IsInternal() const { return internal_; }


    bool HasColorGradient() const { return colorGradient_; }


    FocusMode GetFocusMode() const { return focusMode_; }


    DragAndDropModeFlags GetDragDropMode() const { return dragDropMode_; }


    const String& GetAppliedStyle() const;

    XMLFile* GetDefaultStyle(bool recursiveUp = true) const;


    LayoutMode GetLayoutMode() const { return layoutMode_; }


    int GetLayoutSpacing() const { return layoutSpacing_; }


    const IntRect& GetLayoutBorder() const { return layoutBorder_; }


    const Vector2& GetLayoutFlexScale() const { return layoutFlexScale_; }


    unsigned GetNumChildren(bool recursive = false) const;

    UIElement* GetChild(unsigned index) const;

    UIElement* GetChild(const String& name, bool recursive = false) const;

    UIElement* GetChild(const StringHash& key, const Variant& value = Variant::EMPTY, bool recursive = false) const;


    const Vector<SharedPtr<UIElement> >& GetChildren() const { return children_; }


    void GetChildren(PODVector<UIElement*>& dest, bool recursive = false) const;


    UIElement* GetParent() const { return parent_; }


    UIElement* GetRoot() const;

    const Color& GetDerivedColor() const;

    const Variant& GetVar(const StringHash& key) const;


    const VariantMap& GetVars() const { return vars_; }


    virtual const String& GetBasePath() const { return basePath_; }


    bool HasTag(const String& tag) const;


    const StringVector& GetTags() const { return tags_; }


    void GetChildrenWithTag(PODVector<UIElement*>& dest, const String& tag, bool recursive = false) const;


    PODVector<UIElement*> GetChildrenWithTag(const String& tag, bool recursive = false) const;


    int GetDragButtonCombo() const { return dragButtonCombo_; }


    unsigned GetDragButtonCount() const { return dragButtonCount_; }


    bool IsInside(IntVector2 position, bool isScreen);

    bool IsInsideCombined(IntVector2 position, bool isScreen);

    IntRect GetCombinedScreenRect();

    void SortChildren();


    int GetLayoutElementMaxSize() const { return layoutElementMaxSize_; }


    int GetIndent() const { return indent_; }


    int GetIndentSpacing() const { return indentSpacing_; }


    int GetIndentWidth() const { return indent_ * indentSpacing_; }


    void SetChildOffset(const IntVector2& offset);

    void SetHovering(bool enable);

    void AdjustScissor(IntRect& currentScissor);

    void GetBatchesWithOffset(IntVector2& offset, PODVector<UIBatch>& batches, PODVector<float>& vertexData, IntRect currentScissor);


    const Color& GetColorAttr() const { return colors_[0]; }


    TraversalMode GetTraversalMode() const { return traversalMode_; }


    bool IsElementEventSender() const { return elementEventSender_; }


    UIElement* GetElementEventSender() const;


    IntVector2 GetEffectiveMinSize() const;


    void SetRenderTexture(Texture2D* texture);

protected:

    void OnAttributeAnimationAdded() override;

    void OnAttributeAnimationRemoved() override;

    Animatable* FindAttributeAnimationTarget(const String& name, String& outName) override;

    void MarkDirty();

    bool RemoveChildXML(XMLElement& parent, const String& name) const;

    bool RemoveChildXML(XMLElement& parent, const String& name, const String& value) const;

    bool FilterUIStyleAttributes(XMLElement& dest, const XMLElement& styleElem) const;

    virtual bool FilterImplicitAttributes(XMLElement& dest) const;

    void UpdateAnchoring();


    String name_;

    Vector<SharedPtr<UIElement> > children_;

    UIElement* parent_{};

    IntRect clipBorder_;

    Color colors_[MAX_UIELEMENT_CORNERS];

    VariantMap vars_;


    String basePath_;


    int priority_{};

    bool bringToFront_{};

    bool bringToBack_{true};

    bool clipChildren_{};

    bool sortChildren_{true};

    bool useDerivedOpacity_{true};

    bool enabled_{};

    bool enabledPrev_{};

    bool editable_{true};

    bool selected_{};

    bool visible_{true};

    bool hovering_{};

    bool internal_{};

    FocusMode focusMode_{FM_NOTFOCUSABLE};

    DragAndDropModeFlags dragDropMode_{DD_DISABLED};

    LayoutMode layoutMode_{LM_FREE};

    int layoutSpacing_{};

    IntRect layoutBorder_{};

    Vector2 layoutFlexScale_{Vector2::ONE};

    unsigned resizeNestingLevel_{};

    unsigned layoutNestingLevel_{};

    int layoutElementMaxSize_{};

    int indent_{};

    int indentSpacing_{16};

    IntVector2 position_{};

    mutable IntVector2 screenPosition_;

    mutable bool positionDirty_{true};

    String appliedStyle_;

    int dragButtonCombo_{};

    unsigned dragButtonCount_{};

private:

    void GetChildrenRecursive(PODVector<UIElement*>& dest) const;

    void GetChildrenWithTagRecursive(PODVector<UIElement*>& dest, const String& tag) const;

    void ApplyStyleRecursive(UIElement* element);

    int CalculateLayoutParentSize(const PODVector<int>& sizes, int begin, int end, int spacing);

    void CalculateLayout
        (PODVector<int>& positions, PODVector<int>& sizes, const PODVector<int>& minSizes, const PODVector<int>& maxSizes,
            const PODVector<float>& flexScales, int targetSize, int begin, int end, int spacing);

    IntVector2 GetLayoutChildPosition(UIElement* child);

    void Detach();

    void VerifyChildAlignment();

    void HandlePostUpdate(StringHash eventType, VariantMap& eventData);


    IntVector2 size_;

    IntVector2 minSize_;

    IntVector2 maxSize_{M_MAX_INT, M_MAX_INT};

    IntVector2 childOffset_;

    IntVector2 layoutMinSize_;

    IntVector2 minOffset_;

    IntVector2 maxOffset_;

    bool enableAnchor_{};

    bool pivotSet_{};

    Vector2 anchorMin_;

    Vector2 anchorMax_;

    Vector2 pivot_;

    float opacity_{1.0f};

    mutable float derivedOpacity_{};

    mutable Color derivedColor_;

    mutable bool opacityDirty_{true};

    mutable bool derivedColorDirty_{true};

    bool sortOrderDirty_{};

    bool colorGradient_{};

    SharedPtr<XMLFile> defaultStyle_;

    WeakPtr<XMLFile> appliedStyleFile_;

    TraversalMode traversalMode_{TM_BREADTH_FIRST};

    bool elementEventSender_{};

    static XPathQuery styleXPathQuery_;

    StringVector tags_;
};

template <class T> T* UIElement::CreateChild(const String& name, unsigned index)
{
    return static_cast<T*>(CreateChild(T::GetTypeStatic(), name, index));
}

template <class T> T* UIElement::GetChildStaticCast(unsigned index) const
{
    return static_cast<T*>(GetChild(index));
}

template <class T> T* UIElement::GetChildStaticCast(const String& name, bool recursive) const
{
    return static_cast<T*>(GetChild(name, recursive));
}

template <class T> T* UIElement::GetChildStaticCast(const StringHash& key, const Variant& value, bool recursive) const
{
    return static_cast<T*>(GetChild(key, value, recursive));
}

template <class T> T* UIElement::GetChildDynamicCast(unsigned index) const
{
    return dynamic_cast<T*>(GetChild(index));
}

template <class T> T* UIElement::GetChildDynamicCast(const String& name, bool recursive) const
{
    return dynamic_cast<T*>(GetChild(name, recursive));
}

template <class T> T* UIElement::GetChildDynamicCast(const StringHash& key, const Variant& value, bool recursive) const
{
    return dynamic_cast<T*>(GetChild(key, value, recursive));
}

}


namespace Urho3D
{

class Texture;
class Texture2D;


class __attribute__((visibility("default"))) BorderImage : public UIElement
{
    public: using ClassName = BorderImage; using BaseClassName = UIElement; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("BorderImage", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit BorderImage(Context* context);

    ~BorderImage() override;

    static void RegisterObject(Context* context);


    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;


    void SetTexture(Texture* texture);

    void SetImageRect(const IntRect& rect);

    void SetFullImageRect();

    void SetBorder(const IntRect& rect);

    void SetImageBorder(const IntRect& rect);

    void SetHoverOffset(const IntVector2& offset);

    void SetHoverOffset(int x, int y);

    void SetBlendMode(BlendMode mode);

    void SetTiled(bool enable);

    void SetMaterial(Material* material);


    Texture* GetTexture() const { return texture_; }


    const IntRect& GetImageRect() const { return imageRect_; }


    const IntRect& GetBorder() const { return border_; }


    const IntRect& GetImageBorder() const { return imageBorder_; }


    const IntVector2& GetHoverOffset() const { return hoverOffset_; }


    BlendMode GetBlendMode() const { return blendMode_; }


    bool IsTiled() const { return tiled_; }


    Material* GetMaterial() const;


    void SetTextureAttr(const ResourceRef& value);

    ResourceRef GetTextureAttr() const;


    void SetMaterialAttr(const ResourceRef& value);

    ResourceRef GetMaterialAttr() const;
protected:

    void GetBatches
        (PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor, const IntVector2& offset);


    SharedPtr<Texture> texture_;

    IntRect imageRect_;

    IntRect border_;

    IntRect imageBorder_;

    IntVector2 hoverOffset_;

    BlendMode blendMode_;

    bool tiled_;

    SharedPtr<Material> material_;
};

}










namespace Urho3D
{

class Camera;


template <class T, class U> U* RefCast(T* t)
{
    if (!t)
        return nullptr;

    return dynamic_cast<U*>(t);
}


template <class T> CScriptArray* VectorToArray(const Vector<T>& vector, const char* arrayName)
{
    Context* context = GetScriptContext();
    if (context)
    {
        asITypeInfo* type = context->GetSubsystem<Script>()->GetObjectType(arrayName);
        CScriptArray* arr = CScriptArray::Create(type, vector.Size());

        for (unsigned i = 0; i < arr->GetSize(); ++i)
            *(static_cast<T*>(arr->At(i))) = vector[i];

        return arr;
    }
    else
        return nullptr;
}


template <class T> CScriptArray* VectorToArray(const PODVector<T>& vector, const char* arrayName)
{
    Context* context = GetScriptContext();
    if (context)
    {
        asITypeInfo* type = context->GetSubsystem<Script>()->GetObjectType(arrayName);
        CScriptArray* arr = CScriptArray::Create(type, vector.Size());

        for (unsigned i = 0; i < arr->GetSize(); ++i)
            *(static_cast<T*>(arr->At(i))) = vector[i];

        return arr;
    }
    else
        return nullptr;
}


template <class T> CScriptArray* BufferToArray(const T* buffer, unsigned size, const char* arrayName)
{
    Context* context = GetScriptContext();
    if (context)
    {
        asITypeInfo* type = context->GetSubsystem<Script>()->GetObjectType(arrayName);
        CScriptArray* arr = CScriptArray::Create(type, size);

        for (unsigned i = 0; i < arr->GetSize(); ++i)
            *(static_cast<T*>(arr->At(i))) = buffer[i];

        return arr;
    }
    else
        return nullptr;
}


template <class T> CScriptArray* VectorToHandleArray(const Vector<T*>& vector, const char* arrayName)
{
    Context* context = GetScriptContext();
    if (context)
    {
        asITypeInfo* type = context->GetSubsystem<Script>()->GetObjectType(arrayName);
        CScriptArray* arr = CScriptArray::Create(type, vector.Size());

        for (unsigned i = 0; i < arr->GetSize(); ++i)
        {

            T* ptr = vector[i];
            if (ptr)
                ptr->AddRef();
            *(static_cast<T**>(arr->At(i))) = ptr;
        }

        return arr;
    }
    else
        return nullptr;
}


template <class T> CScriptArray* VectorToHandleArray(const PODVector<T*>& vector, const char* arrayName)
{
    Context* context = GetScriptContext();
    if (context)
    {
        asITypeInfo* type = context->GetSubsystem<Script>()->GetObjectType(arrayName);
        CScriptArray* arr = CScriptArray::Create(type, vector.Size());

        for (unsigned i = 0; i < arr->GetSize(); ++i)
        {

            T* ptr = vector[i];
            if (ptr)
                ptr->AddRef();
            *(static_cast<T**>(arr->At(i))) = ptr;
        }

        return arr;
    }
    else
        return nullptr;
}


template <class T> CScriptArray* VectorToHandleArray(const Vector<SharedPtr<T> >& vector, const char* arrayName)
{
    Context* context = GetScriptContext();
    if (context)
    {
        asITypeInfo* type = context->GetSubsystem<Script>()->GetObjectType(arrayName);
        CScriptArray* arr = CScriptArray::Create(type, vector.Size());

        for (unsigned i = 0; i < arr->GetSize(); ++i)
        {

            T* ptr = vector[i];
            if (ptr)
                ptr->AddRef();
            *(static_cast<T**>(arr->At(i))) = ptr;
        }

        return arr;
    }
    else
        return nullptr;
}


template <class T> Vector<T> ArrayToVector(CScriptArray* arr)
{
    Vector<T> dest(arr ? arr->GetSize() : 0);
    if (arr)
    {
        for (unsigned i = 0; i < arr->GetSize(); ++i)
            dest[i] = *static_cast<T*>(arr->At(i));
    }
    return dest;
}


template <class T> PODVector<T> ArrayToPODVector(CScriptArray* arr)
{
    PODVector<T> dest(arr ? arr->GetSize() : 0);
    if (arr)
    {
        for (unsigned i = 0; i < arr->GetSize(); ++i)
            dest[i] = *static_cast<T*>(arr->At(i));
    }
    return dest;
}


template <class T, class U> void RegisterSubclass(asIScriptEngine* engine, const char* classNameT, const char* classNameU)
{
    if (!strcmp(classNameT, classNameU))
        return;

    String declReturnT(String(classNameT) + "@+ opImplCast()");
    String declReturnU(String(classNameU) + "@+ opImplCast()");

    engine->RegisterObjectMethod(classNameT, declReturnU.CString(), asFunctionPtr((RefCast<T, U>)), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(classNameU, declReturnT.CString(), asFunctionPtr((RefCast<U, T>)), asCALL_CDECL_OBJLAST);
}


template <class T> unsigned SerializerWrite(CScriptArray* arr, T* ptr)
{
    unsigned bytesToWrite = arr->GetSize();
    return bytesToWrite ? ptr->Write(arr->At(0), bytesToWrite) : 0;
}


template <class T> bool SerializerWriteVectorBuffer(VectorBuffer* src, T* ptr)
{
    return ptr->Write(src->GetData(), src->GetSize()) == src->GetSize();
}


template <class T> void RegisterSerializer(asIScriptEngine* engine, const char* className)
{
    engine->RegisterObjectMethod(className, "uint Write(Array<uint8>@+)", asFunctionPtr(SerializerWrite<T>), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool WriteInt(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(int) >(&T::WriteInt)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteInt64(int64)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(long long) >(&T::WriteInt64)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteShort(int16)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(short) >(&T::WriteShort)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteByte(int8)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(signed char) >(&T::WriteByte)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteUInt(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned) >(&T::WriteUInt)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteUInt64(uint64)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned long long) >(&T::WriteUInt64)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteUShort(uint16)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned short) >(&T::WriteUShort)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteUByte(uint8)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned char) >(&T::WriteUByte)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteBool(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(bool) >(&T::WriteBool)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteFloat(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(float) >(&T::WriteFloat)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteDouble(double)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(double) >(&T::WriteDouble)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteIntRect(const IntRect&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const IntRect&) >(&T::WriteIntRect)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteIntVector2(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const IntVector2&) >(&T::WriteIntVector2)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteVector2(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Vector2&) >(&T::WriteVector2)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteVector3(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Vector3&) >(&T::WriteVector3)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WritePackedVector3(const Vector3&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Vector3&, float) >(&T::WritePackedVector3)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteVector4(const Vector4&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Vector4&) >(&T::WriteVector4)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteQuaternion(const Quaternion&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Quaternion&) >(&T::WriteQuaternion)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WritePackedQuaternion(const Quaternion&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Quaternion&) >(&T::WritePackedQuaternion)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteMatrix3(const Matrix3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Matrix3&) >(&T::WriteMatrix3)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteMatrix3x4(const Matrix3x4&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Matrix3x4&) >(&T::WriteMatrix3x4)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteMatrix4(const Matrix4&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Matrix4&) >(&T::WriteMatrix4)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteColor(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Color&) >(&T::WriteColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteBoundingBox(const BoundingBox&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const BoundingBox&) >(&T::WriteBoundingBox)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteString(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const String&) >(&T::WriteString)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteFileID(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const String&) >(&T::WriteFileID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteStringHash(const StringHash&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const StringHash&) >(&T::WriteStringHash)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteVariant(const Variant&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const Variant&) >(&T::WriteVariant)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteVariantMap(const VariantMap&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const VariantMap&) >(&T::WriteVariantMap)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteVectorBuffer(const VectorBuffer&in)", asFunctionPtr(SerializerWriteVectorBuffer<T>), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool WriteVLE(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned) >(&T::WriteVLE)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteNetID(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned) >(&T::WriteNetID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool WriteLine(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const String&) >(&T::WriteLine)), asCALL_THISCALL);
}


template <class T> CScriptArray* DeserializerRead(unsigned size, T* ptr)
{
    PODVector<unsigned char> vector(size);
    unsigned bytesRead = size ? ptr->Read(&vector[0], size) : 0;
    vector.Resize(bytesRead);
    return VectorToArray(vector, "Array<uint8>");
}


template <class T> VectorBuffer DeserializerReadVectorBuffer(unsigned size, T* ptr)
{
    return VectorBuffer(*ptr, size);
}


template <class T> void RegisterDeserializer(asIScriptEngine* engine, const char* className)
{
    engine->RegisterObjectMethod(className, "Array<uint8>@ Read(uint)", asFunctionPtr(DeserializerRead<T>), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "int ReadInt()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<int (T::*)() >(&T::ReadInt)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int64 ReadInt64()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<long long (T::*)() >(&T::ReadInt64)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int16 ReadShort()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<short (T::*)() >(&T::ReadShort)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int8 ReadByte()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<signed char (T::*)() >(&T::ReadByte)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint ReadUInt()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() >(&T::ReadUInt)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint64 ReadUInt64()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned long long (T::*)() >(&T::ReadUInt64)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint16 ReadUShort()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned short (T::*)() >(&T::ReadUShort)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint8 ReadUByte()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned char (T::*)() >(&T::ReadUByte)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool ReadBool()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() >(&T::ReadBool)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float ReadFloat()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<float (T::*)() >(&T::ReadFloat)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "double ReadDouble()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<double (T::*)() >(&T::ReadDouble)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntRect ReadIntRect()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<IntRect (T::*)() >(&T::ReadIntRect)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 ReadIntVector2()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<IntVector2 (T::*)() >(&T::ReadIntVector2)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 ReadVector2()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector2 (T::*)() >(&T::ReadVector2)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 ReadVector3()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector3 (T::*)() >(&T::ReadVector3)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 ReadPackedVector3(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector3 (T::*)(float) >(&T::ReadPackedVector3)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector4 ReadVector4()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector4 (T::*)() >(&T::ReadVector4)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Quaternion ReadQuaternion()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Quaternion (T::*)() >(&T::ReadQuaternion)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Quaternion ReadPackedQuaternion()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Quaternion (T::*)() >(&T::ReadPackedQuaternion)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3 ReadMatrix3()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Matrix3 (T::*)() >(&T::ReadMatrix3)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3x4 ReadMatrix3x4()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Matrix3x4 (T::*)() >(&T::ReadMatrix3x4)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix4 ReadMatrix4()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Matrix4 (T::*)() >(&T::ReadMatrix4)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Color ReadColor()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Color (T::*)() >(&T::ReadColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "BoundingBox ReadBoundingBox()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<BoundingBox (T::*)() >(&T::ReadBoundingBox)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "String ReadString()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<String (T::*)() >(&T::ReadString)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "String ReadFileID()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<String (T::*)() >(&T::ReadFileID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "StringHash ReadStringHash()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<StringHash (T::*)() >(&T::ReadStringHash)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant ReadVariant()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Variant (T::*)() >(&T::ReadVariant)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "VariantMap ReadVariantMap()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<VariantMap (T::*)() >(&T::ReadVariantMap)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "VectorBuffer ReadVectorBuffer(uint)", asFunctionPtr(DeserializerReadVectorBuffer<T>), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "uint ReadVLE()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() >(&T::ReadVLE)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint ReadNetID()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() >(&T::ReadNetID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "String ReadLine()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<String (T::*)() >(&T::ReadLine)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint Seek(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)(unsigned) >(&T::Seek)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint SeekRelative(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)(int) >(&T::SeekRelative)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint Tell() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() const >(&T::Tell)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<const String& (T::*)() const >(&T::GetName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_checksum()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() >(&T::GetChecksum)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_position() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() const >(&T::GetPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_size() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() const >(&T::GetSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_eof() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::IsEof)), asCALL_THISCALL);
}


template <class T> void RegisterRefCounted(asIScriptEngine* engine, const char* className)
{
    engine->RegisterObjectType(className, 0, asOBJ_REF);
    engine->RegisterObjectBehaviour(className, asBEHAVE_ADDREF, "void f()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::AddRef)), asCALL_THISCALL);
    engine->RegisterObjectBehaviour(className, asBEHAVE_RELEASE, "void f()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::ReleaseRef)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_refs() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<int (T::*)() const >(&T::Refs)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_weakRefs() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<int (T::*)() const >(&T::WeakRefs)), asCALL_THISCALL);
    RegisterSubclass<RefCounted, T>(engine, "RefCounted", className);
}

template <class T> void ObjectSendEvent(const String& eventType, VariantMap& eventData, T* ptr)
{
    ptr->SendEvent(StringHash(eventType), eventData);
}

template <class T> bool ObjectHasSubscribedToEvent(const String& eventType, T* ptr)
{
    return ptr->HasSubscribedToEvent(StringHash(eventType));
}

template <class T> bool ObjectHasSubscribedToSenderEvent(Object* sender, const String& eventType, T* ptr)
{
    return ptr->HasSubscribedToEvent(sender, StringHash(eventType));
}


template <class T> void RegisterObject(asIScriptEngine* engine, const char* className)
{
    RegisterRefCounted<T>(engine, className);
    engine->RegisterObjectMethod(className, "StringHash get_type() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<StringHash (T::*)() const >(&T::GetType)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_typeName() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<const String& (T::*)() const >(&T::GetTypeName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_category() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<const String& (T::*)() const >(&T::GetCategory)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SendEvent(const String&in, VariantMap& eventData = VariantMap())", asFunctionPtr(ObjectSendEvent<T>), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool HasSubscribedToEvent(const String&in)", asFunctionPtr(ObjectHasSubscribedToEvent<T>), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool HasSubscribedToEvent(Object@+, const String&in)", asFunctionPtr(ObjectHasSubscribedToSenderEvent<T>), asCALL_CDECL_OBJLAST);
    RegisterSubclass<Object, T>(engine, "Object", className);
}

template <class T> T* ConstructObject()
{
    auto* object = new T(GetScriptContext());
    object->AddRef();
    return object;
}

template <class T> T* ConstructNamedObject(const String& name)
{
    auto* object = new T(GetScriptContext());
    object->AddRef();
    object->SetName(name);
    return object;
}


template <class T> void RegisterObjectConstructor(asIScriptEngine* engine, const char* className)
{
    String declFactory(String(className) + "@ f()");
    engine->RegisterObjectBehaviour(className, asBEHAVE_FACTORY, declFactory.CString(), asFunctionPtr(ConstructObject<T>), asCALL_CDECL);
}


template <class T> void RegisterNamedObjectConstructor(asIScriptEngine* engine, const char* className)
{
    String declFactoryWithName(String(className) + "@ f(const String&in)");
    engine->RegisterObjectBehaviour(className, asBEHAVE_FACTORY, declFactoryWithName.CString(), asFunctionPtr(ConstructNamedObject<T>), asCALL_CDECL);
}

static const AttributeInfo noAttributeInfo{};



#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"


static const AttributeInfo& SerializableGetAttributeInfo(unsigned index, Serializable* ptr)
{
    const Vector<AttributeInfo>* attributes = ptr->GetAttributes();
    if (!attributes || index >= attributes->Size())
    {
        GetActiveASContext()->SetException("Index out of bounds");
        return noAttributeInfo;
    }
    else
        return attributes->At(index);
}

static bool SerializableLoad(File* file, Serializable* ptr)
{
    return file && ptr->Load(*file);
}

static bool SerializableLoadVectorBuffer(VectorBuffer& buffer, Serializable* ptr)
{
    return ptr->Load(buffer);
}

static bool SerializableSave(File* file, Serializable* ptr)
{
    return file && ptr->Save(*file);
}

static bool SerializableSaveVectorBuffer(VectorBuffer& buffer, Serializable* ptr)
{
    return ptr->Save(buffer);
}


template <class T> void RegisterSerializable(asIScriptEngine* engine, const char* className)
{
    RegisterObject<T>(engine, className);
    engine->RegisterObjectMethod(className, "bool Load(File@+)", asFunctionPtr(SerializableLoad), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Load(VectorBuffer&)", asFunctionPtr(SerializableLoadVectorBuffer), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Save(File@+) const", asFunctionPtr(SerializableSave), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Save(VectorBuffer&) const", asFunctionPtr(SerializableSaveVectorBuffer), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool LoadXML(const XMLElement&)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const XMLElement&) >(&T::LoadXML)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool SaveXML(XMLElement&) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(XMLElement&) const >(&T::SaveXML)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool LoadJSON(const JSONValue&)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const JSONValue&) >(&T::LoadJSON)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool SaveJSON(JSONValue&) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(JSONValue&) const >(&T::SaveJSON)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void MarkNetworkUpdate() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::MarkNetworkUpdate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void ApplyAttributes()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::ApplyAttributes)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool SetAttribute(const String&in, const Variant&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const String&, const Variant&) >(&T::SetAttribute)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void ResetToDefault()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::ResetToDefault)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveInstanceDefault()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveInstanceDefault)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant GetAttribute(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Variant (T::*)(const String&) const >(&T::GetAttribute)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant GetAttributeDefault(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Variant (T::*)(const String&) const >(&T::GetAttributeDefault)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetInterceptNetworkUpdate(const String&in, bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, bool) >(&T::SetInterceptNetworkUpdate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool GetInterceptNetworkUpdate(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const String&) const >(&T::GetInterceptNetworkUpdate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAttributes() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() const >(&T::GetNumAttributes)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_attributes(uint, const Variant&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned, const Variant&) >(&T::SetAttribute)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant get_attributes(uint) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Variant (T::*)(unsigned) const >(&T::GetAttribute)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant get_attributeDefaults(uint) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Variant (T::*)(unsigned) const >(&T::GetAttributeDefault)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const AttributeInfo& get_attributeInfos(uint) const", asFunctionPtr(SerializableGetAttributeInfo), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void set_temporary(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(bool) >(&T::SetTemporary)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_temporary() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::IsTemporary)), asCALL_THISCALL);
    RegisterSubclass<Object, T>(engine, "Serializable", className);
}


template <class T> void RegisterAnimatable(asIScriptEngine* engine, const char* className)
{
    RegisterSerializable<T>(engine, className);
    RegisterSubclass<Animatable, T>(engine, "Animatable", className);

    engine->RegisterObjectMethod(className, "void set_animationEnabled(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(bool) >(&T::SetAnimationEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_animationEnabled() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::GetAnimationEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_objectAnimation(ObjectAnimation@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(ObjectAnimation*) >(&T::SetObjectAnimation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "ObjectAnimation@+ get_objectAnimation() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<ObjectAnimation* (T::*)() const >(&T::GetObjectAnimation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetAttributeAnimation(const String&in, ValueAnimation@+, WrapMode wrapMode=WM_LOOP, float speed=1.0f)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, ValueAnimation*, WrapMode, float) >(&T::SetAttributeAnimation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "ValueAnimation@+ GetAttributeAnimation(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<ValueAnimation* (T::*)(const String&) const >(&T::GetAttributeAnimation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetAttributeAnimationWrapMode(const String&in, WrapMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, WrapMode) >(&T::SetAttributeAnimationWrapMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "WrapMode GetAttributeAnimationWrapMode(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<WrapMode (T::*)(const String&) const >(&T::GetAttributeAnimationWrapMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetAttributeAnimationSpeed(const String&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, float) >(&T::SetAttributeAnimationSpeed)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float GetAttributeAnimationSpeed(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<float (T::*)(const String&) const >(&T::GetAttributeAnimationSpeed)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveObjectAnimation()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::RemoveObjectAnimation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveAttributeAnimation(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&) >(&T::RemoveAttributeAnimation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetAnimationTime(float time)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float) >(&T::SetAnimationTime)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetAttributeAnimationTime(const String&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, float) >(&T::SetAttributeAnimationTime)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float GetAttributeAnimationTime(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<float (T::*)(const String&) const >(&T::GetAttributeAnimationTime)), asCALL_THISCALL);
}


template <class T> void RegisterComponent(asIScriptEngine* engine, const char* className, bool nodeRegistered = true, bool debugRendererRegistered = true)
{

    RegisterAnimatable<T>(engine, className);
    RegisterSubclass<Component, T>(engine, "Component", className);
    engine->RegisterObjectMethod(className, "void Remove()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::Remove)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enabled(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(bool) >(&T::SetEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::IsEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabledEffective() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::IsEnabledEffective)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_id()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() const >(&T::GetID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_replicated()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::IsReplicated)), asCALL_THISCALL);
    if (nodeRegistered)
        engine->RegisterObjectMethod(className, "Node@+ get_node() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Node* (T::*)() const >(&T::GetNode)), asCALL_THISCALL);
    if (debugRendererRegistered)
        engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(DebugRenderer*, bool) >(&T::DrawDebugGeometry)), asCALL_THISCALL);
}

static Component* NodeCreateComponent(const String& typeName, CreateMode mode, unsigned id, Node* ptr)
{
    return ptr->CreateComponent(typeName, mode, id);
}

static Component* NodeGetOrCreateComponent(const String& typeName, CreateMode mode, unsigned id, Node* ptr)
{
    return ptr->GetOrCreateComponent(typeName, mode, id);
}

static void NodeRemoveComponent(const String& typeName, Node* ptr)
{
    ptr->RemoveComponent(typeName);
}

static void NodeRemoveComponents(const String& typeName, Node* ptr)
{
    ptr->RemoveComponents(typeName);
}

static Component* NodeGetComponent(unsigned index, Node* ptr)
{
    const Vector<SharedPtr<Component> >& components = ptr->GetComponents();
    if (index >= components.Size())
    {
        GetActiveASContext()->SetException("Index out of bounds");
        return nullptr;
    }
    else
        return components[index];
}

static Component* NodeGetComponentWithType(const String& typeName, bool recursive, Node* ptr)
{
    return ptr->GetComponent(typeName, recursive);
}

static Component* NodeGetParentComponentWithType(const String& typeName, bool fullTraversal, Node* ptr)
{
    return ptr->GetParentComponent(typeName, fullTraversal);
}

static CScriptArray* NodeGetComponents(Node* ptr)
{
    return VectorToHandleArray<Component>(ptr->GetComponents(), "Array<Component@>");
}

static CScriptArray* NodeGetComponentsWithType(const String& typeName, bool recursive, Node* ptr)
{
    PODVector<Component*> components;
    ptr->GetComponents(components, typeName, recursive);
    return VectorToHandleArray<Component>(components, "Array<Component@>");
}

static bool NodeHasComponent(const String& typeName, Node* ptr)
{
    return ptr->HasComponent(typeName);
}

static CScriptArray* NodeGetChildren(bool recursive, Node* ptr)
{
    PODVector<Node*> nodes;
    ptr->GetChildren(nodes, recursive);
    return VectorToHandleArray<Node>(nodes, "Array<Node@>");
}

static CScriptArray* NodeGetChildrenWithComponent(const String& typeName, bool recursive, Node* ptr)
{
    PODVector<Node*> nodes;
    ptr->GetChildrenWithComponent(nodes, typeName, recursive);
    return VectorToHandleArray<Node>(nodes, "Array<Node@>");
}

static CScriptArray* NodeGetChildrenWithTag(const String& typeName, bool recursive, Node* ptr)
{
    PODVector<Node*> nodes;
    ptr->GetChildrenWithTag(nodes, typeName, recursive);
    return VectorToHandleArray<Node>(nodes, "Array<Node@>");
}

static CScriptArray* NodeGetTags(Node* ptr)
{
    return VectorToArray<String>(ptr->GetTags(), "Array<String>");
}

static unsigned NodeGetNumChildrenNonRecursive(Node* ptr)
{
    return ptr->GetNumChildren(false);
}

static unsigned NodeGetNumChildrenRecursive(Node* ptr)
{
    return ptr->GetNumChildren(true);
}

static Node* NodeGetChild(unsigned index, Node* ptr)
{
    const Vector<SharedPtr<Node> >& children = ptr->GetChildren();
    if (index >= children.Size())
    {
        GetActiveASContext()->SetException("Index out of bounds");
        return nullptr;
    }
    else
        return children[index].Get();
}

static Node* NodeGetChildByName(const String& name, Node* ptr)
{
    return ptr->GetChild(name);
}

static Node* NodeGetChildByNameRecursive(const String& name, Node* ptr)
{
    return ptr->GetChild(name, true);
}

static CScriptArray* NodeGetChildrenWithScript(bool recursive, Node* ptr)
{
    PODVector<Node*> nodes;
    ptr->GetChildrenWithComponent<ScriptInstance>(nodes, recursive);
    return VectorToHandleArray<Node>(nodes, "Array<Node@>");
}

static CScriptArray* NodeGetChildrenWithClassName(const String& className, bool recursive, Node* ptr)
{
    PODVector<Node*> nodes;
    PODVector<Node*> result;

    ptr->GetChildrenWithComponent<ScriptInstance>(nodes, recursive);
    for (PODVector<Node*>::Iterator i = nodes.Begin(); i != nodes.End(); ++i)
    {
        Node* node = *i;
        const Vector<SharedPtr<Component> >& components = node->GetComponents();
        for (Vector<SharedPtr<Component> >::ConstIterator j = components.Begin(); j != components.End(); ++j)
        {
            if (auto* instance = (*j)->Cast<ScriptInstance>())
            {
                if (instance->IsA(className))
                    result.Push(node);
            }
        }
    }

    return VectorToHandleArray<Node>(result, "Array<Node@>");
}

static VariantMap& NodeGetVars(Node* ptr)
{

    ptr->MarkNetworkUpdate();
    return const_cast<VariantMap&>(ptr->GetVars());
}


template <class T> void RegisterNode(asIScriptEngine* engine, const char* className)
{
    RegisterAnimatable<T>(engine, className);
    RegisterSubclass<Node, T>(engine, "Node", className);
    engine->RegisterObjectMethod(className, "void SetPosition2D(float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float, float) >(&T::SetPosition2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetScale(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float) >(&T::SetScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetScale2D(float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float, float) >(&T::SetScale2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&) >(&T::SetTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in, const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&, const Vector3&) >(&T::SetTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&, float) >(&T::SetTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform(const Matrix3x4&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Matrix3x4&) >(&T::SetTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform2D(const Vector2&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float) >(&T::SetTransform2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform2D(const Vector2&in, float, const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float, const Vector2&) >(&T::SetTransform2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetTransform2D(const Vector2&in, float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float, float) >(&T::SetTransform2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Vector3&in, const Quaternion&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&) >(&T::SetWorldTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Vector3&in, const Quaternion&in, const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&, const Vector3&) >(&T::SetWorldTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Vector3&in, const Quaternion&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&, float) >(&T::SetWorldTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetWorldTransform2D(const Vector2&in, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float) >(&T::SetWorldTransform2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetWorldTransform2D(const Vector2&in, float, const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float, const Vector2&) >(&T::SetWorldTransform2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetWorldTransform2D(const Vector2&in, float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float, float) >(&T::SetWorldTransform2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Translate(const Vector3&in, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, TransformSpace) >(&T::Translate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Translate2D(const Vector2&in, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, TransformSpace) >(&T::Translate2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Rotate(const Quaternion&in, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Quaternion&, TransformSpace) >(&T::Rotate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Rotate2D(float, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float, TransformSpace) >(&T::Rotate2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RotateAround(const Vector3&in, const Quaternion&in, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&, const Quaternion&, TransformSpace) >(&T::RotateAround)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RotateAround2D(const Vector2&in, float, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&, float, TransformSpace) >(&T::RotateAround2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Pitch(float, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::Pitch)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Yaw(float, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::Yaw)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Roll(float, TransformSpace space = TS_LOCAL)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::Roll)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool LookAt(const Vector3&in, const Vector3&in up = Vector3(0, 1, 0), TransformSpace space = TS_WORLD)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::LookAt)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Scale(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float) >(&T::Scale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Scale(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&) >(&T::Scale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Scale2D(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::Scale2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ CreateChild(const String&in name = String(), CreateMode mode = REPLICATED, uint id = 0, bool temporary = false)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Node* (T::*)(const String&, CreateMode, unsigned, bool) >(&T::CreateChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ CreateTemporaryChild(const String&in name = String(), CreateMode mode = REPLICATED, uint id = 0)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Node* (T::*)(const String&, CreateMode, unsigned) >(&T::CreateTemporaryChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void AddChild(Node@+, uint index = M_MAX_UNSIGNED)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::AddChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveChild(Node@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Node*) >(&T::RemoveChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveAllChildren()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveAllChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveChildren(bool, bool, bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Remove()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::Remove)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Component@+ CreateComponent(const String&in, CreateMode mode = REPLICATED, uint id = 0)", asFunctionPtr(NodeCreateComponent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Component@+ GetOrCreateComponent(const String&in, CreateMode mode = REPLICATED, uint id = 0)", asFunctionPtr(NodeGetOrCreateComponent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Component@+ CloneComponent(Component@+, uint id = 0)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Component* (T::*)(Component*, unsigned) >(&T::CloneComponent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Component@+ CloneComponent(Component@+, CreateMode, uint id = 0)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Component* (T::*)(Component*, CreateMode, unsigned) >(&T::CloneComponent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveComponent(Component@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Component*) >(&T::RemoveComponent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveComponent(const String&in)", asFunctionPtr(NodeRemoveComponent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void RemoveComponents(bool, bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(bool, bool) >(&T::RemoveComponents)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveComponents(const String&in)", asFunctionPtr(NodeRemoveComponents), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void RemoveAllComponents()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveAllComponents)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void ReorderComponent(Component@+, uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::ReorderComponent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void AddTag(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::AddTag)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void AddTags(const String&in, int8 separator = ';')", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, char) >(&T::AddTags)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool RemoveTag(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveTag)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveAllTags()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveAllTags)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildren(bool recursive = false) const", asFunctionPtr(NodeGetChildren), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildrenWithComponent(const String&in, bool recursive = false) const", asFunctionPtr(NodeGetChildrenWithComponent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildrenWithTag(const String&in, bool recursive = false) const", asFunctionPtr(NodeGetChildrenWithTag), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildrenWithScript(bool recursive = false) const", asFunctionPtr(NodeGetChildrenWithScript), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildrenWithScript(const String&in, bool recursive = false) const", asFunctionPtr(NodeGetChildrenWithClassName), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Node@+ GetChild(const String&in, bool recursive = false) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Node* (T::*)(const String&, bool) const >(&T::GetChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Array<Component@>@ GetComponents() const", asFunctionPtr(NodeGetComponents), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Array<Component@>@ GetComponents(const String&in, bool recursive = false) const", asFunctionPtr(NodeGetComponentsWithType), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Component@+ GetComponent(const String&in, bool recursive = false) const", asFunctionPtr(NodeGetComponentWithType), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Component@+ GetParentComponent(const String&in, bool fullTraversal = false) const", asFunctionPtr(NodeGetParentComponentWithType), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool IsChildOf(Node@+) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsChildOf)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool HasComponent(const String&in) const", asFunctionPtr(NodeHasComponent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool HasTag(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::HasTag)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Array<String>@ get_tags()", asFunctionPtr(NodeGetTags), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Vector3 LocalToWorld(const Vector3&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector3 (T::*)(const Vector3&) const >(&T::LocalToWorld)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 LocalToWorld(const Vector4&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector3 (T::*)(const Vector4&) const >(&T::LocalToWorld)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 LocalToWorld2D(const Vector2&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector2 (T::*)(const Vector2&) const >(&T::LocalToWorld2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 WorldToLocal(const Vector3&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector3 (T::*)(const Vector3&) const >(&T::WorldToLocal)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 WorldToLocal(const Vector4&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector3 (T::*)(const Vector4&) const >(&T::WorldToLocal)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 WorldToLocal2D(const Vector2&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Vector2 (T::*)(const Vector2&) const >(&T::WorldToLocal2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&) >(&T::SetPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_position() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position2D(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetPosition2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_position2D() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPosition2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(const Quaternion&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Quaternion&) >(&T::SetRotation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_rotation() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetRotation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation2D(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float) >(&T::SetRotation2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rotation2D() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetRotation2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_direction(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetDirection)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_direction() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDirection)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_up() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetUp)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_right() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetRight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scale(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&) >(&T::SetScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_scale() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scale2D(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetScale2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_scale2D() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetScale2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldPosition(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&) >(&T::SetWorldPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldPosition()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldPosition2D(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetWorldPosition2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_worldPosition2D()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldPosition2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldRotation(const Quaternion&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Quaternion&) >(&T::SetWorldRotation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Quaternion get_worldRotation()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldRotation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldRotation2D(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float) >(&T::SetWorldRotation2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_worldRotation2D()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldRotation2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldDirection(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetWorldDirection)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldDirection()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldDirection)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldUp()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldUp)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldRight()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldRight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldScale(const Vector3&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector3&) >(&T::SetWorldScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldScale()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_signedWorldScale()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSignedWorldScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldScale2D(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetWorldScale2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_worldScale2D()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldScale2D)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3x4 get_transform() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Matrix3x4& get_worldTransform() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldTransform)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_id(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_id()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetID)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_replicated()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsReplicated)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numChildren() const", asFunctionPtr(NodeGetNumChildrenNonRecursive), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "uint get_numAllChildren() const", asFunctionPtr(NodeGetNumChildrenRecursive), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Node@+ get_children(uint) const", asFunctionPtr(NodeGetChild), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Node@+ get_childrenByName(const String&in) const", asFunctionPtr(NodeGetChildByName), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Node@+ get_allChildrenByName(const String&in) const", asFunctionPtr(NodeGetChildByNameRecursive), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "uint get_numComponents() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetNumComponents)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Component@+ get_components(uint) const", asFunctionPtr(NodeGetComponent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void set_name(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_parent(Node@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetParent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_parent() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetParent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "VariantMap& get_vars()", asFunctionPtr(NodeGetVars), asCALL_CDECL_OBJLAST);
}

static bool ResourceLoad(File* file, Resource* ptr)
{
    return file && ptr->Load(*file);
}

static bool ResourceLoadVectorBuffer(VectorBuffer& buffer, Resource* ptr)
{
    return ptr->Load(buffer);
}

static bool ResourceLoadByName(const String& fileName, Resource* ptr)
{
    return ptr->LoadFile(fileName);
}

static bool ResourceSave(File* file, Resource* ptr)
{
    return file && ptr->Save(*file);
}

static bool ResourceSaveVectorBuffer(VectorBuffer& buffer, Resource* ptr)
{
    return ptr->Save(buffer);
}

static bool ResourceSaveByName(const String& fileName, Resource* ptr)
{
    return ptr->SaveFile(fileName);
}


template <class T> void RegisterResource(asIScriptEngine* engine, const char* className)
{
    RegisterObject<T>(engine, className);
    RegisterSubclass<Resource, T>(engine, "Resource", className);

    if (strcmp("Resource", className) != 0)
    {
        RegisterObjectConstructor<T>(engine, className);
        RegisterNamedObjectConstructor<T>(engine, className);
    }
    engine->RegisterObjectMethod(className, "bool Load(File@+)", asFunctionPtr(ResourceLoad), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Load(VectorBuffer&)", asFunctionPtr(ResourceLoadVectorBuffer), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Load(const String&in)", asFunctionPtr(ResourceLoadByName), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Save(File@+) const", asFunctionPtr(ResourceSave), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Save(VectorBuffer&) const", asFunctionPtr(ResourceSaveVectorBuffer), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool Save(const String&in) const", asFunctionPtr(ResourceSaveByName), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void set_name(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&) >(&T::SetName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<const String& (T::*)() const >(&T::GetName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_memoryUse() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() const >(&T::GetMemoryUse)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_useTimer()" ,asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<unsigned (T::*)() >(&T::GetUseTimer)), asCALL_THISCALL);
}

static void ResourceAddMetadata(const String& name, const Variant& value, ResourceWithMetadata* ptr)
{
    ptr->AddMetadata(name, value);
}

static const Variant& ResourceGetMetadata(const String& name, ResourceWithMetadata* ptr)
{
    return ptr->GetMetadata(name);
}

static bool ResourceHasMetadata(ResourceWithMetadata* ptr)
{
    return ptr->HasMetadata();
}


template <class T> void RegisterResourceWithMetadata(asIScriptEngine* engine, const char* className)
{
    RegisterResource<T>(engine, className);
    engine->RegisterObjectMethod(className, "void AddMetadata(const String&in, const Variant&in)", asFunctionPtr(ResourceAddMetadata), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void RemoveMetadata(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&) >(&T::RemoveMetadata)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveAllMetadata()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveAllMetadata)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_metadata(const String&in, const Variant&in)", asFunctionPtr(ResourceAddMetadata), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "const Variant& get_metadata(const String&in) const", asFunctionPtr(ResourceGetMetadata), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool get_hasMetadata() const", asFunctionPtr(ResourceHasMetadata), asCALL_CDECL_OBJLAST);
}


template <class T> void RegisterDrawable(asIScriptEngine* engine, const char* className)
{
    RegisterComponent<T>(engine, className);
    RegisterSubclass<Drawable, T>(engine, "Drawable", className);
    engine->RegisterObjectMethod(className, "bool IsInView(Camera@+) const", asSMethodPtr<sizeof(void (Drawable::*)())>::Convert(static_cast<bool (Drawable::*)(Camera*) const >(&Drawable::IsInView)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_inView() const", asSMethodPtr<sizeof(void (Drawable::*)())>::Convert(static_cast<bool (Drawable::*)() const >(&Drawable::IsInView)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_castShadows(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetCastShadows)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_castShadows() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetCastShadows)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occluder(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetOccluder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occluder() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsOccluder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occludee(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetOccludee)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occludee() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsOccludee)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawDistance(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetDrawDistance)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_drawDistance() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDrawDistance)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowDistance(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetShadowDistance)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowDistance() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetShadowDistance)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lodBias(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLodBias)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lodBias() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLodBias)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewMask(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetViewMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_viewMask() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetViewMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lightMask(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLightMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_lightMask() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLightMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowMask(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetShadowMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_shadowMask() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetShadowMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_zoneMask(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetZoneMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_zoneMask() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetZoneMask)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLights(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMaxLights)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxLights() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaxLights)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_boundingBox() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetBoundingBox)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_worldBoundingBox()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWorldBoundingBox)), asCALL_THISCALL);
}


template <class T> void RegisterSoundSource(asIScriptEngine* engine, const char* className)
{
    RegisterComponent<T>(engine, className);
    RegisterSubclass<SoundSource, T>(engine, "SoundSource", className);
    engine->RegisterObjectMethod(className, "void Play(Sound@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Sound*) >(&T::Play)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Play(Sound@+, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Sound*, float) >(&T::Play)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Play(Sound@+, float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Sound*, float, float) >(&T::Play)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Play(Sound@+, float, float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Sound*, float, float, float) >(&T::Play)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Stop()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::Stop)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Seek(float)", asSMethodPtr<sizeof(void (SoundSource::*)())>::Convert((void (SoundSource::*)())(&SoundSource::Seek)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_soundType(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetSoundType)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_soundType() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSoundType)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_frequency(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFrequency)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequency() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetFrequency)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_gain(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetGain)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_gain() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetGain)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_panning(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetPanning)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_panning() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPanning)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Sound@+ get_sound() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSound)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_timePosition() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetTimePosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_attenuation() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetAttenuation)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoRemoveMode(AutoRemoveMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetAutoRemoveMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "AutoRemoveMode get_autoRemoveMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetAutoRemoveMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_playing() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsPlaying)), asCALL_THISCALL);
}


template <class T> void RegisterTexture(asIScriptEngine* engine, const char* className)
{
    RegisterResourceWithMetadata<T>(engine, className);
    RegisterSubclass<Texture, T>(engine, "Texture", className);
    engine->RegisterObjectMethod(className, "void SetNumLevels(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetNumLevels)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void ClearDataLost()", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)() >(&T::ClearDataLost)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureUsage get_usage() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetUsage)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_format() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetFormat)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_compressed() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsCompressed)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_levels() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLevels)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_levelWidth(uint) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLevelWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_levelHeight(uint) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLevelHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_filterMode(TextureFilterMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFilterMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureFilterMode get_filterMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetFilterMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_addressMode(TextureCoordinate, TextureAddressMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetAddressMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureAddressMode get_addressMode(TextureCoordinate) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetAddressMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anisotropy(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetAnisotropy)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_anisotropy() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetAnisotropy)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_borderColor(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetBorderColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_borderColor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetBorderColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sRGB(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetSRGB)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sRGB() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSRGB)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_multiSample() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMultiSample)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoResolve() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetAutoResolve)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resolveDirty() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsResolveDirty)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_levelsDirty() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLevelsDirty)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_backupTexture(Texture@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetBackupTexture)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_backupTexture() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetBackupTexture)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mipsToSkip(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMipsToSkip)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_mipsToSkip(int) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMipsToSkip)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dataLost() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)() const >(&T::IsDataLost)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_components() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetComponents)), asCALL_THISCALL);
}


template <class T> void RegisterStaticModel(asIScriptEngine* engine, const char* className, bool registerSetModel)
{
    RegisterDrawable<T>(engine, className);
    RegisterSubclass<StaticModel, T>(engine, "StaticModel", className);
    engine->RegisterObjectMethod(className, "void ApplyMaterialList(const String&in fileName = String())", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::ApplyMaterialList)), asCALL_THISCALL);
    if (registerSetModel)
        engine->RegisterObjectMethod(className, "void set_model(Model@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetModel)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Model@+ get_model() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetModel)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Material*) >(&T::SetMaterial)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_materials(uint, Material@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(unsigned, Material*) >(&T::SetMaterial)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Material* (T::*)() const >(&T::GetMaterial)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_materials(uint) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<Material* (T::*)(unsigned) const >(&T::GetMaterial)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numGeometries() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetNumGeometries)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Zone@+ get_zone() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetZone)), asCALL_THISCALL);
}

static bool UIElementLoadXML(File* file, UIElement* ptr)
{
    return file && ptr->LoadXML(*file);
}

static bool UIElementLoadXMLVectorBuffer(VectorBuffer& buffer, UIElement* ptr)
{
    return ptr->LoadXML(buffer);
}

static bool UIElementLoadXML(XMLFile* file, XMLFile* styleFile, UIElement* ptr)
{
    if (file)
    {
        XMLElement rootElem = file->GetRoot("element");
        return rootElem && ptr->LoadXML(rootElem, styleFile);
    }
    else
        return false;
}

static UIElement* UIElementLoadChildXML(XMLFile* file, XMLFile* styleFile, UIElement* ptr)
{
    if (!file)
        return nullptr;

    XMLElement rootElem = file->GetRoot("element");
    if (rootElem)
        return ptr->LoadChildXML(rootElem, styleFile);
    else
        return nullptr;
}

static bool UIElementSaveXML(File* file, const String& indentation, UIElement* ptr)
{
    return file && ptr->SaveXML(*file);
}

static bool UIElementSaveXMLVectorBuffer(VectorBuffer& buffer, const String& indentation, UIElement* ptr)
{
    return ptr->SaveXML(buffer);
}

static UIElement* UIElementCreateChild(const String& typeName, const String& name, unsigned index, UIElement* ptr)
{
    return ptr->CreateChild(typeName, name, index);
}

static void UIElementRemoveChild(UIElement* child, unsigned index, UIElement* ptr)
{
    ptr->RemoveChild(child, index);
}

static void UIElementRemoveChild(unsigned index, UIElement* ptr)
{
    ptr->RemoveChildAtIndex(index);
}

static CScriptArray* UIElementGetChildren(bool recursive, UIElement* ptr)
{
    PODVector<UIElement*> elements;
    ptr->GetChildren(elements, recursive);
    return VectorToHandleArray<UIElement>(elements, "Array<UIElement@>");
}

static CScriptArray* UIElementGetChildrenWithTag(const String& tag, bool recursive, UIElement* ptr)
{
    PODVector<UIElement*> elements;
    ptr->GetChildrenWithTag(elements, tag, recursive);
    return VectorToHandleArray<UIElement>(elements, "Array<UIElement@>");
}

static CScriptArray* UIElementGetTags(UIElement* ptr)
{
    return VectorToArray<String>(ptr->GetTags(), "Array<String>");
}

static unsigned UIElementGetNumChildrenNonRecursive(UIElement* ptr)
{
    return ptr->GetNumChildren(false);
}

static unsigned UIElementGetNumChildrenRecursive(UIElement* ptr)
{
    return ptr->GetNumChildren(true);
}

static void UIElementSetParent(UIElement* parent, UIElement* ptr)
{
    ptr->SetParent(parent);
}

static VariantMap& UIElementGetVars(UIElement* ptr)
{
    return const_cast<VariantMap&>(ptr->GetVars());
}

static void UIElementSetStyle(const String& styleName, UIElement* ptr)
{
    if (styleName.Empty())
        ptr->SetStyleAuto();
    else
        ptr->SetStyle(styleName);
}

static XMLFile* UIElementGetDefaultStyle(UIElement* ptr)
{
    return ptr->GetDefaultStyle();
}


#pragma clang diagnostic pop



template <class T> void RegisterUIElement(asIScriptEngine* engine, const char* className, bool isSprite = false)
{
    RegisterAnimatable<T>(engine, className);
    RegisterObjectConstructor<T>(engine, className);
    RegisterNamedObjectConstructor<T>(engine, className);
    RegisterSubclass<UIElement, T>(engine, "UIElement", className);
    engine->RegisterObjectMethod(className, "bool LoadXML(const XMLElement&in, XMLFile@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const XMLElement&, XMLFile*) >(&T::LoadXML)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool LoadXML(File@+)", asFunctionPtr(reinterpret_cast<void (*)()>(static_cast<bool (*)(File*, UIElement*)>(UIElementLoadXML))), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool LoadXML(VectorBuffer&)", asFunctionPtr(reinterpret_cast<void (*)()>(static_cast<bool (*)(VectorBuffer&, UIElement*)>(UIElementLoadXMLVectorBuffer))), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool LoadXML(XMLFile@+, XMLFile@+)", asFunctionPtr(reinterpret_cast<void (*)()>(static_cast<bool (*)(XMLFile*, XMLFile*, UIElement*)>(UIElementLoadXML))), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "UIElement@+ LoadChildXML(const XMLElement&in, XMLFile@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::LoadChildXML)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ LoadChildXML(XMLFile@+, XMLFile@+)", asFunctionPtr(UIElementLoadChildXML), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool SaveXML(File@+, const String&in indentation = \"\t\")", asFunctionPtr(UIElementSaveXML), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool SaveXML(VectorBuffer&, const String&in indentation = \"\t\")", asFunctionPtr(UIElementSaveXMLVectorBuffer), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "bool SetStyle(const XMLElement&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const XMLElement&) >(&T::SetStyle)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool SetStyle(const String&in, XMLFile@+ arg1 = null)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<bool (T::*)(const String&, XMLFile*) >(&T::SetStyle)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool SetStyleAuto(XMLFile@+ arg0 = null)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetStyleAuto)), asCALL_THISCALL);
    if (!isSprite)
        engine->RegisterObjectMethod(className, "void SetPosition(int, int)", asSMethodPtr<sizeof(void (UIElement::*)())>::Convert(static_cast<void (UIElement::*)(int, int) >(&UIElement::SetPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetSize(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetMinSize(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetMinSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetMaxSize(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetMaxSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetFixedSize(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetFixedSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetFixedWidth(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFixedWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetFixedHeight(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFixedHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetAlignment(HorizontalAlignment, VerticalAlignment)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetAlignment)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetMinAnchor(float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float, float) >(&T::SetMinAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetMaxAnchor(float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float, float) >(&T::SetMaxAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetPivot(float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(float, float) >(&T::SetPivot)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetLayout(LayoutMode, int spacing = 0, const IntRect& border = IntRect(0, 0, 0, 0))", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLayout)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void UpdateLayout()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::UpdateLayout)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void DisableLayoutUpdate()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::DisableLayoutUpdate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void EnableLayoutUpdate()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::EnableLayoutUpdate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void BringToFront()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::BringToFront)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ CreateChild(const String&in, const String&in name = String(), uint index = M_MAX_UNSIGNED)", asFunctionPtr(UIElementCreateChild), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void AddChild(UIElement@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::AddChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void InsertChild(uint, UIElement@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::InsertChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveChild(UIElement@+, uint arg1 = 0)", asFunctionPtr(reinterpret_cast<void (*)()>(static_cast<void (*)(UIElement*, unsigned, UIElement*)>(UIElementRemoveChild))), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void RemoveChild(uint)", asFunctionPtr(reinterpret_cast<void (*)()>(static_cast<void (*)(unsigned, UIElement*)>(UIElementRemoveChild))), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void RemoveAllChildren()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveAllChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void Remove()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::Remove)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint FindChild(UIElement@+) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::FindChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetParent(UIElement@+, uint index = M_MAX_UNSIGNED)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetParent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void AddTag(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::AddTag)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void AddTags(const String&in, int8 separator = ';')", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const String&, char) >(&T::AddTags)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void RemoveAllTags()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveAllTags)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool RemoveTag(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::RemoveTag)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ GetChild(const String&in, bool recursive = false) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<UIElement* (T::*)(const String&, bool) const >(&T::GetChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ GetChild(const StringHash&in, const Variant&in value = Variant(), bool recursive = false) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<UIElement* (T::*)(const StringHash&, const Variant&, bool) const >(&T::GetChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool IsChildOf(UIElement@+) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsChildOf)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetChildren(bool recursive = false) const", asFunctionPtr(UIElementGetChildren), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "UIElement@+ GetElementEventSender() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetElementEventSender)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Variant& GetVar(const StringHash&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetVar)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool HasTag(const String&in) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::HasTag)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetChildrenWithTag(const String&in, bool recursive = false) const", asFunctionPtr(UIElementGetChildrenWithTag), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "IntVector2 ScreenToElement(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::ScreenToElement)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 ElementToScreen(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::ElementToScreen)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool IsInside(IntVector2, bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsInside)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool IsInsideCombined(IntVector2, bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsInsideCombined)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_style(const String&in)", asFunctionPtr(UIElementSetStyle), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "const String& get_style() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetAppliedStyle)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_name(const String&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetName)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetName)), asCALL_THISCALL);
    if (!isSprite)
    {
        engine->RegisterObjectMethod(className, "void set_position(const IntVector2&in)", asSMethodPtr<sizeof(void (UIElement::*)())>::Convert(static_cast<void (UIElement::*)(const IntVector2&) >(&UIElement::SetPosition)), asCALL_THISCALL);
        engine->RegisterObjectMethod(className, "const IntVector2& get_position() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPosition)), asCALL_THISCALL);
    }
    engine->RegisterObjectMethod(className, "void set_size(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_size() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_width(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_height(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minSize(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetMinSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_minSize() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMinSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minWidth(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMinWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_minWidth() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMinWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minHeight(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMinHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_minHeight() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMinHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxSize(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetMaxSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_maxSize() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaxSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxWidth(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMaxWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxWidth() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaxWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxHeight(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMaxHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxHeight() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaxHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedSize() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsFixedSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedWidth() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsFixedWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedHeight() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsFixedHeight)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_horizontalAlignment(HorizontalAlignment)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetHorizontalAlignment)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "HorizontalAlignment get_horizontalAlignment() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetHorizontalAlignment)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_verticalAlignment(VerticalAlignment)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetVerticalAlignment)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "VerticalAlignment get_verticalAlignment() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetVerticalAlignment)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableAnchor(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetEnableAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableAnchor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetEnableAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minAnchor(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetMinAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_minAnchor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMinAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxAnchor(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetMaxAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_maxAnchor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaxAnchor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minOffset(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetMinOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_minOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMinOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxOffset(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetMaxOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_maxOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaxOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pivot(const Vector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Vector2&) >(&T::SetPivot)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_pivot() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPivot)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clipBorder(const IntRect&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntRect&) >(&T::SetClipBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_clipBorder() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetClipBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_color(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const Color&) >(&T::SetColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_colors(Corner, const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(Corner, const Color&) >(&T::SetColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_colors(Corner) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_priority(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetPriority)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_priority() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPriority)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_opacity(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetOpacity)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_opacity() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetOpacity)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bringToFront(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetBringToFront)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_bringToFront() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetBringToFront)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bringToBack(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetBringToBack)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_bringToBack() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetBringToBack)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clipChildren(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetClipChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_clipChildren() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetClipChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sortChildren(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetSortChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sortChildren() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSortChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useDerivedOpacity(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetUseDerivedOpacity)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useDerivedOpacity() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetUseDerivedOpacity)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetDeepEnabled(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetDeepEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void ResetDeepEnabled()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::ResetDeepEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetEnabledRecursive(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetEnabledRecursive)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enabled(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsEnabled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabledSelf() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsEnabledSelf)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_editable(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetEditable)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_editable() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsEditable)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_focus(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFocus)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_focus() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::HasFocus)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_selected(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetSelected)), asCALL_THISCALL);

    engine->RegisterObjectMethod(className, "bool get_selected() const", asSMethodPtr<sizeof(void (UIElement::*)())>::Convert((void (UIElement::*)())(&UIElement::IsSelected)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_visible(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetVisible)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_visible() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsVisible)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_visibleEffective() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsVisibleEffective)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hovering() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsHovering)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_internal(bool) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetInternal)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_internal() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsInternal)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_colorGradient() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::HasColorGradient)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_focusMode(FocusMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFocusMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "FocusMode get_focusMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetFocusMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dragDropMode(uint)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetDragDropMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_dragDropMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDragDropMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_traversalMode(TraversalMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetTraversalMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "TraversalMode get_traversalMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetTraversalMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultStyle(XMLFile@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetDefaultStyle)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLFile@+ get_defaultStyle() const", asFunctionPtr(UIElementGetDefaultStyle), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "void set_layoutMode(LayoutMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLayoutMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "LayoutMode get_layoutMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLayoutMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutSpacing(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLayoutSpacing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_layoutSpacing() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLayoutSpacing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutBorder(const IntRect&)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLayoutBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_layoutBorder() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLayoutBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutFlexScale(const Vector2&)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetLayoutFlexScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_layoutFlexScale() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetLayoutFlexScale)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_indent(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetIndent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_indent() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetIndent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_indentSpacing(int)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetIndentSpacing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_indentSpacing() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetIndentSpacing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_indentWidth() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetIndentWidth)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_childOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetChildOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_elementEventSender(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetElementEventSender)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_elementEventSender() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsElementEventSender)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numChildren() const", asFunctionPtr(UIElementGetNumChildrenNonRecursive), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "uint get_numAllChildren() const", asFunctionPtr(UIElementGetNumChildrenRecursive), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "uint GetNumChildren(bool) const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetNumChildren)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_children(uint) const", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<UIElement* (T::*)(unsigned) const >(&T::GetChild)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_parent(UIElement@+)", asFunctionPtr(UIElementSetParent), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "UIElement@+ get_parent() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetParent)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_root() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetRoot)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_dragButtonCount() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDragButtonCount)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_dragButtonCombo() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDragButtonCombo)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_screenPosition()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetScreenPosition)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntRect get_combinedScreenRect()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetCombinedScreenRect)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_derivedOpacity()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDerivedOpacity)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "VariantMap& get_vars()", asFunctionPtr(UIElementGetVars), asCALL_CDECL_OBJLAST);
    engine->RegisterObjectMethod(className, "Array<String>@ get_tags() const", asFunctionPtr(UIElementGetTags), asCALL_CDECL_OBJLAST);
}


template <class T> void RegisterUISelectable(asIScriptEngine* engine, const char* className)
{
    RegisterUIElement<T>(engine, className);
    engine->RegisterObjectMethod(className, "void set_selectionColor(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetSelectionColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_selectionColor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetSelectionColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hoverColor(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetHoverColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_hoverColor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetHoverColor)), asCALL_THISCALL);
}


template <class T> void RegisterBorderImage(asIScriptEngine* engine, const char* className)
{
    RegisterUIElement<T>(engine, className);
    engine->RegisterObjectMethod(className, "void SetFullImageRect()", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFullImageRect)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetHoverOffset(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetHoverOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_texture(Texture@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetTexture)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_texture() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetTexture)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMaterial)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetMaterial)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_imageRect(const IntRect&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntRect&) >(&T::SetImageRect)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_imageRect() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetImageRect)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_border(const IntRect&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntRect&) >(&T::SetBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_border() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_imageBorder(const IntRect&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntRect&) >(&T::SetImageBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_imageBorder() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetImageBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hoverOffset(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetHoverOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_hoverOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetHoverOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(BlendMode)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetBlendMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "BlendMode get_blendMode() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetBlendMode)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_tiled(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetTiled)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_tiled() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsTiled)), asCALL_THISCALL);
}


template <class T> void RegisterWindow(asIScriptEngine* engine, const char* className)
{
    RegisterBorderImage<T>(engine, className);
    engine->RegisterObjectMethod(className, "void set_movable(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetMovable)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_movable() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsMovable)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_resizable(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetResizable)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resizable() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsResizable)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_resizeBorder(const IntRect&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntRect&) >(&T::SetResizeBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_resizeBorder() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetResizeBorder)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modal(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetModal)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_modal() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsModal)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalShadeColor(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetModalShadeColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_modalShadeColor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetModalShadeColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalFrameColor(const Color&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetModalFrameColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_modalFrameColor() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetModalFrameColor)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalFrameSize(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetModalFrameSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_modalFrameSize() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetModalFrameSize)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalAutoDismiss(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetModalAutoDismiss)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_modalAutoDismiss() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetModalAutoDismiss)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedWidthResizing(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFixedWidthResizing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedWidthResizing() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetFixedWidthResizing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedHeightResizing(bool)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetFixedHeightResizing)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedHeightResizing() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetFixedHeightResizing)), asCALL_THISCALL);
}


template <class T> void RegisterButton(asIScriptEngine* engine, const char* className)
{
    RegisterBorderImage<T>(engine, className);
    engine->RegisterObjectMethod(className, "void SetPressedOffset(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetPressedOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetDisabledOffset(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetDisabledOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetPressedChildOffset(int, int)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(int, int) >(&T::SetPressedChildOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void SetRepeat(float, float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetRepeat)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pressedOffset(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetPressedOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_pressedOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPressedOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_disabledOffset(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetDisabledOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_disabledOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetDisabledOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pressedChildOffset(const IntVector2&in)", asSMethodPtr<sizeof(void (T::*)())>::Convert(static_cast<void (T::*)(const IntVector2&) >(&T::SetPressedChildOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_pressedChildOffset() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetPressedChildOffset)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_repeatDelay(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetRepeatDelay)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_repeatDelay() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetRepeatDelay)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_repeatRate(float)", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::SetRepeatRate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_repeatRate() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::GetRepeatRate)), asCALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_pressed() const", asSMethodPtr<sizeof(void (T::*)())>::Convert((void (T::*)())(&T::IsPressed)), asCALL_THISCALL);
}

}


class asIScriptEngine;

namespace Urho3D
{

class Context;


void RegisterMathAPI(asIScriptEngine* engine);

void RegisterCoreAPI(asIScriptEngine* engine);

void RegisterIOAPI(asIScriptEngine* engine);

void RegisterResourceAPI(asIScriptEngine* engine);

void RegisterSceneAPI(asIScriptEngine* engine);

void RegisterGraphicsAPI(asIScriptEngine* engine);

void RegisterInputAPI(asIScriptEngine* engine);

void RegisterAudioAPI(asIScriptEngine* engine);

void RegisterUIAPI(asIScriptEngine* engine);


void RegisterNetworkAPI(asIScriptEngine* engine);







void RegisterIKAPI(asIScriptEngine* engine);



void RegisterPhysicsAPI(asIScriptEngine* engine);

void RegisterRaycastVehicleAPI(asIScriptEngine* engine);



void RegisterNavigationAPI(asIScriptEngine* engine);



void RegisterUrho2DAPI(asIScriptEngine* engine);


void RegisterScriptInterfaceAPI(asIScriptEngine* engine);

void RegisterScriptAPI(asIScriptEngine* engine);

void RegisterEngineAPI(asIScriptEngine* engine);

}

class asIScriptContext;
class asIScriptEngine;
class asIScriptFunction;
class asIScriptModule;
class asIScriptObject;
class asITypeInfo;

namespace Urho3D
{

class Script;
class ScriptEventInvoker;
class ScriptInstance;
class Variant;


class __attribute__((visibility("default"))) ScriptFile : public Resource, public ScriptEventListener
{
    public: using ClassName = ScriptFile; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ScriptFile", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ScriptFile(Context* context);

    ~ScriptFile() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;


    void AddEventHandler(StringHash eventType, const String& handlerName) override;

    void AddEventHandler(Object* sender, StringHash eventType, const String& handlerName) override;

    void RemoveEventHandler(StringHash eventType) override;

    void RemoveEventHandler(Object* sender, StringHash eventType) override;

    void RemoveEventHandlers(Object* sender) override;

    void RemoveEventHandlers() override;

    void RemoveEventHandlersExcept(const PODVector<StringHash>& exceptions) override;

    bool HasEventHandler(StringHash eventType) const override;

    bool HasEventHandler(Object* sender, StringHash eventType) const override;


    bool Execute(const String& declaration, const VariantVector& parameters = Variant::emptyVariantVector,
        Variant* functionReturn = nullptr, bool unprepare = true);

    bool Execute(asIScriptFunction* function, const VariantVector& parameters = Variant::emptyVariantVector,
        Variant* functionReturn = nullptr, bool unprepare = true);

    bool Execute(asIScriptObject* object, const String& declaration, const VariantVector& parameters = Variant::emptyVariantVector,
        Variant* functionReturn = nullptr, bool unprepare = true);

    bool Execute(asIScriptObject* object, asIScriptFunction* method, const VariantVector& parameters = Variant::emptyVariantVector,
        Variant* functionReturn = nullptr, bool unprepare = true);


    void DelayedExecute
        (float delay, bool repeat, const String& declaration, const VariantVector& parameters = Variant::emptyVariantVector);

    void ClearDelayedExecute(const String& declaration = String::EMPTY);

    asIScriptObject* CreateObject(const String& className, bool useInterface = false);

    bool SaveByteCode(Serializer& dest);


    asIScriptModule* GetScriptModule() const { return scriptModule_; }


    asIScriptFunction* GetFunction(const String& declaration);

    asIScriptFunction* GetMethod(asIScriptObject* object, const String& declaration);


    bool IsCompiled() const { return compiled_; }


    void CleanupEventInvoker(asIScriptObject* object);

private:

    void AddEventHandlerInternal(Object* sender, StringHash eventType, const String& handlerName);

    bool AddScriptSection(asIScriptEngine* engine, Deserializer& source);

    void SetParameters(asIScriptContext* context, asIScriptFunction* function, const VariantVector& parameters);

    void ReleaseModule();

    void HandleUpdate(StringHash eventType, VariantMap& eventData);


    SharedPtr<Script> script_;

    asIScriptModule* scriptModule_{};

    bool compiled_{};

    bool subscribed_{};

    HashSet<String> includeFiles_;

    HashMap<asITypeInfo*, bool> validClasses_;

    HashMap<String, asIScriptFunction*> functions_;

    HashMap<asITypeInfo*, HashMap<String, asIScriptFunction*> > methods_;

    Vector<DelayedCall> delayedCalls_;

    HashMap<asIScriptObject*, SharedPtr<ScriptEventInvoker> > eventInvokers_;

    SharedArrayPtr<unsigned char> loadByteCode_;

    unsigned loadByteCodeSize_{};
};


class __attribute__((visibility("default"))) ScriptEventInvoker : public Object
{
    public: using ClassName = ScriptEventInvoker; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ScriptEventInvoker", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ScriptEventInvoker(ScriptFile* file, asIScriptObject* object = nullptr);

    ~ScriptEventInvoker() override;


    asIScriptObject* GetObject() const { return object_; }


    bool IsObjectAlive() const;

    void HandleScriptEvent(StringHash eventType, VariantMap& eventData);

private:

    ScriptFile* file_;

    asILockableSharedBool* sharedBool_;

    asIScriptObject* object_;
};


__attribute__((visibility("default"))) ScriptFile* GetScriptContextFile();

}


namespace Urho3D
{

class AudioImpl;
class Sound;
class SoundListener;
class SoundSource;


class __attribute__((visibility("default"))) Audio : public Object
{
    public: using ClassName = Audio; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Audio", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Audio(Context* context);

    ~Audio() override;


    bool SetMode(int bufferLengthMSec, int mixRate, bool stereo, bool interpolation = true);

    void Update(float timeStep);

    bool Play();

    void Stop();

    void SetMasterGain(const String& type, float gain);

    void PauseSoundType(const String& type);

    void ResumeSoundType(const String& type);

    void ResumeAll();

    void SetListener(SoundListener* listener);

    void StopSound(Sound* sound);


    unsigned GetSampleSize() const { return sampleSize_; }


    int GetMixRate() const { return mixRate_; }


    bool GetInterpolation() const { return interpolation_; }


    bool IsStereo() const { return stereo_; }


    bool IsPlaying() const { return playing_; }


    bool IsInitialized() const { return deviceID_ != 0; }


    float GetMasterGain(const String& type) const;


    bool IsSoundTypePaused(const String& type) const;


    SoundListener* GetListener() const;


    const PODVector<SoundSource*>& GetSoundSources() const { return soundSources_; }


    bool HasMasterGain(const String& type) const { return masterGain_.Contains(type); }


    void AddSoundSource(SoundSource* soundSource);

    void RemoveSoundSource(SoundSource* soundSource);


    Mutex& GetMutex() { return audioMutex_; }


    float GetSoundSourceMasterGain(StringHash typeHash) const;


    void MixOutput(void* dest, unsigned samples);

private:

    void HandleRenderUpdate(StringHash eventType, VariantMap& eventData);

    void Release();

    void UpdateInternal(float timeStep);


    SharedArrayPtr<int> clipBuffer_;

    Mutex audioMutex_;

    unsigned deviceID_{};

    unsigned sampleSize_{};

    unsigned fragmentSize_{};

    int mixRate_{};

    bool interpolation_{};

    bool stereo_{};

    bool playing_{};

    HashMap<StringHash, Variant> masterGain_;

    HashSet<StringHash> pausedSoundTypes_;

    PODVector<SoundSource*> soundSources_;

    WeakPtr<SoundListener> listener_;
};


void __attribute__((visibility("default"))) RegisterAudioLibrary(Context* context);

}

namespace Urho3D
{


static const Urho3D::StringHash E_SOUNDFINISHED(Urho3D::GetEventNameRegister().RegisterString("SoundFinished")); namespace SoundFinished
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_SOUNDSOURCE("SoundSource");
    static const Urho3D::StringHash P_SOUND("Sound");
}

}
namespace Urho3D
{


class __attribute__((visibility("default"))) SoundStream : public RefCounted
{
public:

    SoundStream();

    ~SoundStream() override;


    virtual bool Seek(unsigned sample_number);


    virtual unsigned GetData(signed char* dest, unsigned numBytes) = 0;


    void SetFormat(unsigned frequency, bool sixteenBit, bool stereo);

    void SetStopAtEnd(bool enable);


    unsigned GetSampleSize() const;


    float GetFrequency() const { return (float)frequency_; }


    unsigned GetIntFrequency() const { return frequency_; }


    bool GetStopAtEnd() const { return stopAtEnd_; }


    bool IsSixteenBit() const { return sixteenBit_; }


    bool IsStereo() const { return stereo_; }

protected:

    unsigned frequency_;

    bool stopAtEnd_;

    bool sixteenBit_;

    bool stereo_;
};

}





namespace Urho3D
{


class __attribute__((visibility("default"))) BufferedSoundStream : public SoundStream
{
public:

    BufferedSoundStream();

    ~BufferedSoundStream() override;


    unsigned GetData(signed char* dest, unsigned numBytes) override;


    void AddData(void* data, unsigned numBytes);

    void AddData(const SharedArrayPtr<signed char>& data, unsigned numBytes);

    void AddData(const SharedArrayPtr<signed short>& data, unsigned numBytes);

    void Clear();


    unsigned GetBufferNumBytes() const;

    float GetBufferLength() const;

private:

    List<Pair<SharedArrayPtr<signed char>, unsigned> > buffers_;

    unsigned position_;

    mutable Mutex bufferMutex_;
};

}
namespace Urho3D
{

class Sound;


class __attribute__((visibility("default"))) OggVorbisSoundStream : public SoundStream
{
public:

    explicit OggVorbisSoundStream(const Sound* sound);

    ~OggVorbisSoundStream() override;


    bool Seek(unsigned sample_number) override;


    unsigned GetData(signed char* dest, unsigned numBytes) override;

protected:

    void* decoder_;

    SharedArrayPtr<signed char> data_;

    unsigned dataSize_;
};

}
namespace Urho3D
{

class SoundStream;


class __attribute__((visibility("default"))) Sound : public ResourceWithMetadata
{
    public: using ClassName = Sound; using BaseClassName = ResourceWithMetadata; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Sound", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Sound(Context* context);

    ~Sound() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;


    bool LoadRaw(Deserializer& source);

    bool LoadWav(Deserializer& source);

    bool LoadOggVorbis(Deserializer& source);

    void SetSize(unsigned dataSize);

    void SetData(const void* data, unsigned dataSize);

    void SetFormat(unsigned frequency, bool sixteenBit, bool stereo);

    void SetLooped(bool enable);

    void SetLoop(unsigned repeatOffset, unsigned endOffset);


    SharedPtr<SoundStream> GetDecoderStream() const;


    SharedArrayPtr<signed char> GetData() const { return data_; }


    signed char* GetStart() const { return data_.Get(); }


    signed char* GetRepeat() const { return repeat_; }


    signed char* GetEnd() const { return end_; }


    float GetLength() const;


    unsigned GetDataSize() const { return dataSize_; }


    unsigned GetSampleSize() const;


    float GetFrequency() const { return (float)frequency_; }


    unsigned GetIntFrequency() const { return frequency_; }


    bool IsLooped() const { return looped_; }


    bool IsSixteenBit() const { return sixteenBit_; }


    bool IsStereo() const { return stereo_; }


    bool IsCompressed() const { return compressed_; }


    void FixInterpolation();

private:

    void LoadParameters();


    SharedArrayPtr<signed char> data_;

    signed char* repeat_;

    signed char* end_;

    unsigned dataSize_;

    unsigned frequency_;

    bool looped_;

    bool sixteenBit_;

    bool stereo_;

    bool compressed_;

    float compressedLength_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) SoundListener : public Component
{
    public: using ClassName = SoundListener; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SoundListener", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit SoundListener(Context* context);

    ~SoundListener() override;

    static void RegisterObject(Context* context);
};

}

namespace Urho3D
{

class Audio;


class __attribute__((visibility("default"))) SoundSource3D : public SoundSource
{
    public: using ClassName = SoundSource3D; using BaseClassName = SoundSource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SoundSource3D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit SoundSource3D(Context* context);

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;

    void Update(float timeStep) override;


    void SetDistanceAttenuation(float nearDistance, float farDistance, float rolloffFactor);

    void SetAngleAttenuation(float innerAngle, float outerAngle);

    void SetNearDistance(float distance);

    void SetFarDistance(float distance);

    void SetInnerAngle(float angle);

    void SetOuterAngle(float angle);

    void SetRolloffFactor(float factor);

    void CalculateAttenuation();


    float GetNearDistance() const { return nearDistance_; }


    float GetFarDistance() const { return farDistance_; }


    float GetInnerAngle() const { return innerAngle_; }


    float GetOuterAngle() const { return outerAngle_; }


    float RollAngleoffFactor() const { return rolloffFactor_; }

protected:

    float nearDistance_;

    float farDistance_;

    float innerAngle_;

    float outerAngle_;

    float rolloffFactor_;
};

}




namespace Urho3D
{


class __attribute__((visibility("default"))) Condition
{
public:

    Condition();


    ~Condition();


    void Set();


    void Wait();

private:


    void* mutex_;


    void* event_;
};

}

namespace Urho3D
{


static const Urho3D::StringHash E_BEGINFRAME(Urho3D::GetEventNameRegister().RegisterString("BeginFrame")); namespace BeginFrame
{
    static const Urho3D::StringHash P_FRAMENUMBER("FrameNumber");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_UPDATE(Urho3D::GetEventNameRegister().RegisterString("Update")); namespace Update
{
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_POSTUPDATE(Urho3D::GetEventNameRegister().RegisterString("PostUpdate")); namespace PostUpdate
{
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_RENDERUPDATE(Urho3D::GetEventNameRegister().RegisterString("RenderUpdate")); namespace RenderUpdate
{
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_POSTRENDERUPDATE(Urho3D::GetEventNameRegister().RegisterString("PostRenderUpdate")); namespace PostRenderUpdate
{
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_ENDFRAME(Urho3D::GetEventNameRegister().RegisterString("EndFrame")); namespace EndFrame
{
}

}
using ThreadID = pthread_t;




namespace Urho3D
{


class __attribute__((visibility("default"))) Thread
{
public:

    Thread();

    virtual ~Thread();


    virtual void ThreadFunction() = 0;


    bool Run();

    void Stop();

    void SetPriority(int priority);


    bool IsStarted() const { return handle_ != nullptr; }


    static void SetMainThread();

    static ThreadID GetCurrentThreadID();

    static bool IsMainThread();

protected:

    void* handle_;

    volatile bool shouldRun_;


    static ThreadID mainThreadID;
};

}



namespace Urho3D
{


class __attribute__((visibility("default"))) ProfilerBlock
{
public:

    ProfilerBlock(ProfilerBlock* parent, const char* name) :
        name_(nullptr),
        time_(0),
        maxTime_(0),
        count_(0),
        parent_(parent),
        frameTime_(0),
        frameMaxTime_(0),
        frameCount_(0),
        intervalTime_(0),
        intervalMaxTime_(0),
        intervalCount_(0),
        totalTime_(0),
        totalMaxTime_(0),
        totalCount_(0)
    {
        if (name)
        {
            unsigned nameLength = String::CStringLength(name);
            name_ = new char[nameLength + 1];
            memcpy(name_, name, nameLength + 1);
        }
    }


    virtual ~ProfilerBlock()
    {
        for (PODVector<ProfilerBlock*>::Iterator i = children_.Begin(); i != children_.End(); ++i)
        {
            delete *i;
            *i = nullptr;
        }

        delete [] name_;
    }


    void Begin()
    {
        timer_.Reset();
        ++count_;
    }


    void End()
    {
        long long time = timer_.GetUSec(false);
        if (time > maxTime_)
            maxTime_ = time;
        time_ += time;
    }


    void EndFrame()
    {
        frameTime_ = time_;
        frameMaxTime_ = maxTime_;
        frameCount_ = count_;
        intervalTime_ += time_;
        if (maxTime_ > intervalMaxTime_)
            intervalMaxTime_ = maxTime_;
        intervalCount_ += count_;
        totalTime_ += time_;
        if (maxTime_ > totalMaxTime_)
            totalMaxTime_ = maxTime_;
        totalCount_ += count_;
        time_ = 0;
        maxTime_ = 0;
        count_ = 0;

        for (PODVector<ProfilerBlock*>::Iterator i = children_.Begin(); i != children_.End(); ++i)
            (*i)->EndFrame();
    }


    void BeginInterval()
    {
        intervalTime_ = 0;
        intervalMaxTime_ = 0;
        intervalCount_ = 0;

        for (PODVector<ProfilerBlock*>::Iterator i = children_.Begin(); i != children_.End(); ++i)
            (*i)->BeginInterval();
    }


    ProfilerBlock* GetChild(const char* name)
    {
        for (PODVector<ProfilerBlock*>::Iterator i = children_.Begin(); i != children_.End(); ++i)
        {
            if (!String::Compare((*i)->name_, name, true))
                return *i;
        }

        auto* newBlock = new ProfilerBlock(this, name);
        children_.Push(newBlock);

        return newBlock;
    }


    char* name_;

    HiresTimer timer_;

    long long time_;

    long long maxTime_;

    unsigned count_;

    ProfilerBlock* parent_;

    PODVector<ProfilerBlock*> children_;

    long long frameTime_;

    long long frameMaxTime_;

    unsigned frameCount_;

    long long intervalTime_;

    long long intervalMaxTime_;

    unsigned intervalCount_;

    long long totalTime_;

    long long totalMaxTime_;

    unsigned totalCount_;
};


class __attribute__((visibility("default"))) Profiler : public Object
{
    public: using ClassName = Profiler; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Profiler", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Profiler(Context* context);

    ~Profiler() override;


    void BeginBlock(const char* name)
    {

        if (!Thread::IsMainThread())
            return;

        current_ = current_->GetChild(name);
        current_->Begin();
    }


    void EndBlock()
    {
        if (!Thread::IsMainThread())
            return;

        current_->End();
        if (current_->parent_)
            current_ = current_->parent_;
    }


    void BeginFrame();

    void EndFrame();

    void BeginInterval();


    const String& PrintData(bool showUnused = false, bool showTotal = false, unsigned maxDepth = M_MAX_UNSIGNED) const;

    const ProfilerBlock* GetCurrentBlock() { return current_; }

    const ProfilerBlock* GetRootBlock() { return root_; }

protected:

    void PrintData(ProfilerBlock* block, String& output, unsigned depth, unsigned maxDepth, bool showUnused, bool showTotal) const;


    ProfilerBlock* current_;

    ProfilerBlock* root_;

    unsigned intervalFrames_;
};


class __attribute__((visibility("default"))) AutoProfileBlock
{
public:

    AutoProfileBlock(Profiler* profiler, const char* name) :
        profiler_(profiler)
    {
        if (profiler_)
            profiler_->BeginBlock(name);
    }


    ~AutoProfileBlock()
    {
        if (profiler_)
            profiler_->EndBlock();
    }

private:

    Profiler* profiler_;
};







}

namespace Urho3D
{


class __attribute__((visibility("default"))) EventProfilerBlock : public ProfilerBlock
{
public:

    EventProfilerBlock(EventProfilerBlock* parent, StringHash eventID) :
        ProfilerBlock(parent, GetEventNameRegister().GetString(eventID).CString()),
        eventID_(eventID)
    {
    }


    EventProfilerBlock* GetChild(StringHash eventID)
    {
        for (PODVector<ProfilerBlock*>::Iterator i = children_.Begin(); i != children_.End(); ++i)
        {
            auto* eventProfilerBlock = static_cast<EventProfilerBlock*>(*i);
            if (eventProfilerBlock->eventID_ == eventID)
                return eventProfilerBlock;
        }

        auto* newBlock = new EventProfilerBlock(this, eventID);
        children_.Push(newBlock);

        return newBlock;
    }


    StringHash eventID_;
};


class __attribute__((visibility("default"))) EventProfiler : public Profiler
{
    public: using ClassName = EventProfiler; using BaseClassName = Profiler; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("EventProfiler", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit EventProfiler(Context* context);


    static void SetActive(bool newActive) { active = newActive; }

    static bool IsActive() { return active; }


    void BeginBlock(StringHash eventID)
    {

        if (!Thread::IsMainThread())
            return;

        current_ = static_cast<EventProfilerBlock*>(current_)->GetChild(eventID);
        current_->Begin();
    }

private:

    static bool active;
};

}


namespace Urho3D
{

class Mutex;


__attribute__((visibility("default"))) void InitFPU();

__attribute__((visibility("default"))) void ErrorDialog(const String& title, const String& message);

__attribute__((visibility("default"))) void ErrorExit(const String& message = String::EMPTY, int exitCode = 1);

__attribute__((visibility("default"))) void OpenConsoleWindow();

__attribute__((visibility("default"))) void PrintUnicode(const String& str, bool error = false);

__attribute__((visibility("default"))) void PrintUnicodeLine(const String& str, bool error = false);

__attribute__((visibility("default"))) void PrintLine(const String& str, bool error = false);

__attribute__((visibility("default"))) void PrintLine(const char* str, bool error = false);

__attribute__((visibility("default"))) const Vector<String>& ParseArguments(const String& cmdLine, bool skipFirstArgument = true);

__attribute__((visibility("default"))) const Vector<String>& ParseArguments(const char* cmdLine);

__attribute__((visibility("default"))) const Vector<String>& ParseArguments(const WString& cmdLine);

__attribute__((visibility("default"))) const Vector<String>& ParseArguments(const wchar_t* cmdLine);

__attribute__((visibility("default"))) const Vector<String>& ParseArguments(int argc, char** argv);

__attribute__((visibility("default"))) const Vector<String>& GetArguments();

__attribute__((visibility("default"))) String GetConsoleInput();

__attribute__((visibility("default"))) String GetPlatform();

__attribute__((visibility("default"))) unsigned GetNumPhysicalCPUs();

__attribute__((visibility("default"))) unsigned GetNumLogicalCPUs();

__attribute__((visibility("default"))) void SetMiniDumpDir(const String& pathName);

__attribute__((visibility("default"))) String GetMiniDumpDir();

__attribute__((visibility("default"))) unsigned long long GetTotalMemory();

__attribute__((visibility("default"))) String GetLoginName();

__attribute__((visibility("default"))) String GetHostName();

__attribute__((visibility("default"))) String GetOSVersion();
}
namespace Urho3D
{






}




namespace Urho3D
{

enum InterpolationMode
{

    BEZIER_CURVE = 0,

    CATMULL_ROM_CURVE,

    LINEAR_CURVE,

    CATMULL_ROM_FULL_CURVE
};


class __attribute__((visibility("default"))) Spline
{
public:

    Spline();

    explicit Spline(InterpolationMode mode);

    explicit Spline(const Vector<Variant>& knots, InterpolationMode mode = BEZIER_CURVE);

    Spline(const Spline& rhs) = default;


    Spline& operator =(const Spline& rhs) = default;


    bool operator ==(const Spline& rhs) const
    {
        return (knots_ == rhs.knots_ && interpolationMode_ == rhs.interpolationMode_);
    }


    bool operator !=(const Spline& rhs) const
    {
        return !(*this == rhs);
    }


    InterpolationMode GetInterpolationMode() const { return interpolationMode_; }


    const VariantVector& GetKnots() const { return knots_; }


    Variant GetKnot(unsigned index) const { return knots_[index]; }


    Variant GetPoint(float f) const;


    void SetInterpolationMode(InterpolationMode interpolationMode) { interpolationMode_ = interpolationMode; }


    void SetKnots(const Vector<Variant>& knots) { knots_ = knots; }


    void SetKnot(const Variant& knot, unsigned index);

    void AddKnot(const Variant& knot);

    void AddKnot(const Variant& knot, unsigned index);


    void RemoveKnot() { knots_.Pop(); }


    void RemoveKnot(unsigned index) { knots_.Erase(index); }


    void Clear() { knots_.Clear(); }

private:

    Variant BezierInterpolation(const Vector<Variant>& knots, float t) const;

    Variant CatmullRomInterpolation(const Vector<Variant>& knots, float t) const;

    Variant LinearInterpolation(const Vector<Variant>& knots, float t) const;

    Variant LinearInterpolation(const Variant& lhs, const Variant& rhs, float t) const;


    InterpolationMode interpolationMode_;

    VariantVector knots_;
};

}





namespace Urho3D
{


static const Urho3D::StringHash E_WORKITEMCOMPLETED(Urho3D::GetEventNameRegister().RegisterString("WorkItemCompleted")); namespace WorkItemCompleted
{
    static const Urho3D::StringHash P_ITEM("Item");
}

class WorkerThread;


struct WorkItem : public RefCounted
{
    friend class WorkQueue;

public:

    void (* workFunction_)(const WorkItem*, unsigned){};

    void* start_{};

    void* end_{};

    void* aux_{};

    unsigned priority_{};

    bool sendEvent_{};

    volatile bool completed_{};

private:
    bool pooled_{};
};


class __attribute__((visibility("default"))) WorkQueue : public Object
{
    public: using ClassName = WorkQueue; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("WorkQueue", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class WorkerThread;

public:

    explicit WorkQueue(Context* context);

    ~WorkQueue() override;


    void CreateThreads(unsigned numThreads);

    SharedPtr<WorkItem> GetFreeItem();

    void AddWorkItem(const SharedPtr<WorkItem>& item);

    bool RemoveWorkItem(SharedPtr<WorkItem> item);

    unsigned RemoveWorkItems(const Vector<SharedPtr<WorkItem> >& items);

    void Pause();

    void Resume();

    void Complete(unsigned priority);


    void SetTolerance(int tolerance) { tolerance_ = tolerance; }


    void SetNonThreadedWorkMs(int ms) { maxNonThreadedWorkMs_ = Max(ms, 1); }


    unsigned GetNumThreads() const { return threads_.Size(); }


    bool IsCompleted(unsigned priority) const;

    bool IsCompleting() const { return completing_; }


    int GetTolerance() const { return tolerance_; }


    int GetNonThreadedWorkMs() const { return maxNonThreadedWorkMs_; }

private:

    void ProcessItems(unsigned threadIndex);

    void PurgeCompleted(unsigned priority);

    void PurgePool();

    void ReturnToPool(SharedPtr<WorkItem>& item);

    void HandleBeginFrame(StringHash eventType, VariantMap& eventData);


    Vector<SharedPtr<WorkerThread> > threads_;

    List<SharedPtr<WorkItem> > poolItems_;

    List<SharedPtr<WorkItem> > workItems_;

    List<WorkItem*> queue_;

    Mutex queueMutex_;

    volatile bool shutDown_;

    volatile bool pausing_;

    bool paused_;

    bool completing_;

    int tolerance_;

    unsigned lastSize_;

    int maxNonThreadedWorkMs_;
};

}






namespace Urho3D
{

class Console;
class DebugHud;


class __attribute__((visibility("default"))) Engine : public Object
{
    public: using ClassName = Engine; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Engine", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Engine(Context* context);

    ~Engine() override;


    bool Initialize(const VariantMap& parameters);

    bool InitializeResourceCache(const VariantMap& parameters, bool removeOld = true);

    void RunFrame();

    Console* CreateConsole();

    DebugHud* CreateDebugHud();

    void SetMinFps(int fps);

    void SetMaxFps(int fps);

    void SetMaxInactiveFps(int fps);

    void SetTimeStepSmoothing(int frames);

    void SetPauseMinimized(bool enable);

    void SetAutoExit(bool enable);

    void SetNextTimeStep(float seconds);

    void Exit();

    void DumpProfiler();

    void DumpResources(bool dumpFileName = false);

    void DumpMemory();


    float GetNextTimeStep() const { return timeStep_; }


    int GetMinFps() const { return minFps_; }


    int GetMaxFps() const { return maxFps_; }


    int GetMaxInactiveFps() const { return maxInactiveFps_; }


    int GetTimeStepSmoothing() const { return timeStepSmoothing_; }


    bool GetPauseMinimized() const { return pauseMinimized_; }


    bool GetAutoExit() const { return autoExit_; }


    bool IsInitialized() const { return initialized_; }


    bool IsExiting() const { return exiting_; }


    bool IsHeadless() const { return headless_; }


    void Update();

    void Render();

    void ApplyFrameLimit();


    static VariantMap ParseParameters(const Vector<String>& arguments);

    static bool HasParameter(const VariantMap& parameters, const String& parameter);

    static const Variant
        & GetParameter(const VariantMap& parameters, const String& parameter, const Variant& defaultValue = Variant::EMPTY);

private:

    void HandleExitRequested(StringHash eventType, VariantMap& eventData);

    void DoExit();


    HiresTimer frameTimer_;

    PODVector<float> lastTimeSteps_;

    float timeStep_;

    unsigned timeStepSmoothing_;

    unsigned minFps_;

    unsigned maxFps_;

    unsigned maxInactiveFps_;

    bool pauseMinimized_;





    bool autoExit_;

    bool initialized_;

    bool exiting_;

    bool headless_;

    bool audioPaused_;
};

}


namespace Urho3D
{

class Engine;


class __attribute__((visibility("default"))) Application : public Object
{
    public: using ClassName = Application; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Application", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Application(Context* context);


    virtual void Setup() { }


    virtual void Start() { }


    virtual void Stop() { }


    int Run();

    void ErrorExit(const String& message = String::EMPTY);

protected:

    void HandleLogMessage(StringHash eventType, VariantMap& eventData);


    SharedPtr<Engine> engine_;

    VariantMap engineParameters_;

    String startupErrors_;

    int exitCode_;
};
}
namespace Urho3D
{

class Button;
class BorderImage;
class DropDownList;
class Engine;
class Font;
class LineEdit;
class ListView;
class Text;
class UIElement;
class XMLFile;


class __attribute__((visibility("default"))) Console : public Object
{
    public: using ClassName = Console; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Console", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Console(Context* context);

    ~Console() override;


    void SetDefaultStyle(XMLFile* style);

    void SetVisible(bool enable);

    void Toggle();


    void SetAutoVisibleOnError(bool enable) { autoVisibleOnError_ = enable; }


    void SetCommandInterpreter(const String& interpreter) { commandInterpreter_ = interpreter; }


    void SetNumBufferedRows(unsigned rows);

    void SetNumRows(unsigned rows);

    void SetNumHistoryRows(unsigned rows);

    void SetFocusOnShow(bool enable);

    void AddAutoComplete(const String& option);

    void RemoveAutoComplete(const String& option);

    void UpdateElements();


    XMLFile* GetDefaultStyle() const;


    BorderImage* GetBackground() const { return background_; }


    LineEdit* GetLineEdit() const { return lineEdit_; }


    Button* GetCloseButton() const { return closeButton_; }


    bool IsVisible() const;


    bool IsAutoVisibleOnError() const { return autoVisibleOnError_; }


    const String& GetCommandInterpreter() const { return commandInterpreter_; }


    unsigned GetNumBufferedRows() const;


    unsigned GetNumRows() const { return displayedRows_; }


    void CopySelectedRows() const;


    unsigned GetNumHistoryRows() const { return historyRows_; }


    unsigned GetHistoryPosition() const { return historyPosition_; }


    const String& GetHistoryRow(unsigned index) const;


    bool GetFocusOnShow() const { return focusOnShow_; }

private:

    bool PopulateInterpreter();

    void HandleInterpreterSelected(StringHash eventType, VariantMap& eventData);

    void HandleTextChanged(StringHash eventType, VariantMap& eventData);

    void HandleTextFinished(StringHash eventType, VariantMap& eventData);

    void HandleLineEditKey(StringHash eventType, VariantMap& eventData);

    void HandleCloseButtonPressed(StringHash eventType, VariantMap& eventData);

    void HandleRootElementResized(StringHash eventType, VariantMap& eventData);

    void HandleLogMessage(StringHash eventType, VariantMap& eventData);

    void HandlePostUpdate(StringHash eventType, VariantMap& eventData);


    bool autoVisibleOnError_;

    SharedPtr<BorderImage> background_;

    ListView* rowContainer_;

    UIElement* commandLine_;

    DropDownList* interpreters_;

    LineEdit* lineEdit_;

    SharedPtr<Button> closeButton_;

    String commandInterpreter_;


    Vector<String> history_;

    Vector<Pair<int, String> > pendingRows_;

    String currentRow_;

    unsigned displayedRows_{};

    unsigned historyRows_;

    unsigned historyPosition_;
    Vector<String> autoComplete_;

    unsigned autoCompletePosition_;

    String autoCompleteLine_;


    bool printing_;

    bool focusOnShow_;

    bool historyOrAutoCompleteChange_;
};

}
namespace Urho3D
{

class Engine;
class Font;
class Text;
class XMLFile;

static const unsigned DEBUGHUD_SHOW_NONE = 0x0;
static const unsigned DEBUGHUD_SHOW_STATS = 0x1;
static const unsigned DEBUGHUD_SHOW_MODE = 0x2;
static const unsigned DEBUGHUD_SHOW_PROFILER = 0x4;
static const unsigned DEBUGHUD_SHOW_MEMORY = 0x8;
static const unsigned DEBUGHUD_SHOW_EVENTPROFILER = 0x10;
static const unsigned DEBUGHUD_SHOW_ALL = DEBUGHUD_SHOW_STATS | DEBUGHUD_SHOW_MODE | DEBUGHUD_SHOW_PROFILER | DEBUGHUD_SHOW_MEMORY;


class __attribute__((visibility("default"))) DebugHud : public Object
{
    public: using ClassName = DebugHud; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("DebugHud", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit DebugHud(Context* context);

    ~DebugHud() override;


    void Update();

    void SetDefaultStyle(XMLFile* style);

    void SetMode(unsigned mode);

    void SetProfilerMaxDepth(unsigned depth);

    void SetProfilerInterval(float interval);

    void SetUseRendererStats(bool enable);

    void Toggle(unsigned mode);

    void ToggleAll();


    XMLFile* GetDefaultStyle() const;


    Text* GetStatsText() const { return statsText_; }


    Text* GetModeText() const { return modeText_; }


    Text* GetProfilerText() const { return profilerText_; }


    Text* GetMemoryText() const { return memoryText_; }


    unsigned GetMode() const { return mode_; }


    unsigned GetProfilerMaxDepth() const { return profilerMaxDepth_; }


    float GetProfilerInterval() const;


    bool GetUseRendererStats() const { return useRendererStats_; }


    void SetAppStats(const String& label, const Variant& stats);

    void SetAppStats(const String& label, const String& stats);

    bool ResetAppStats(const String& label);

    void ClearAppStats();

private:

    void HandlePostUpdate(StringHash eventType, VariantMap& eventData);


    SharedPtr<Text> statsText_;

    SharedPtr<Text> modeText_;

    SharedPtr<Text> profilerText_;

    SharedPtr<Text> eventProfilerText_;

    SharedPtr<Text> memoryText_;

    HashMap<String, String> appStats_;

    Timer profilerTimer_;

    unsigned profilerMaxDepth_;

    unsigned profilerInterval_;

    bool useRendererStats_;

    unsigned mode_;
};

}

namespace Urho3D
{


static const String EP_AUTOLOAD_PATHS = "AutoloadPaths";
static const String EP_BORDERLESS = "Borderless";
static const String EP_DUMP_SHADERS = "DumpShaders";
static const String EP_EVENT_PROFILER = "EventProfiler";
static const String EP_EXTERNAL_WINDOW = "ExternalWindow";
static const String EP_FLUSH_GPU = "FlushGPU";
static const String EP_FORCE_GL2 = "ForceGL2";
static const String EP_FRAME_LIMITER = "FrameLimiter";
static const String EP_FULL_SCREEN = "FullScreen";
static const String EP_HEADLESS = "Headless";
static const String EP_HIGH_DPI = "HighDPI";
static const String EP_LOG_LEVEL = "LogLevel";
static const String EP_LOG_NAME = "LogName";
static const String EP_LOG_QUIET = "LogQuiet";
static const String EP_LOW_QUALITY_SHADOWS = "LowQualityShadows";
static const String EP_MATERIAL_QUALITY = "MaterialQuality";
static const String EP_MONITOR = "Monitor";
static const String EP_MULTI_SAMPLE = "MultiSample";
static const String EP_ORIENTATIONS = "Orientations";
static const String EP_PACKAGE_CACHE_DIR = "PackageCacheDir";
static const String EP_RENDER_PATH = "RenderPath";
static const String EP_REFRESH_RATE = "RefreshRate";
static const String EP_RESOURCE_PACKAGES = "ResourcePackages";
static const String EP_RESOURCE_PATHS = "ResourcePaths";
static const String EP_RESOURCE_PREFIX_PATHS = "ResourcePrefixPaths";
static const String EP_SHADER_CACHE_DIR = "ShaderCacheDir";
static const String EP_SHADOWS = "Shadows";
static const String EP_SOUND = "Sound";
static const String EP_SOUND_BUFFER = "SoundBuffer";
static const String EP_SOUND_INTERPOLATION = "SoundInterpolation";
static const String EP_SOUND_MIX_RATE = "SoundMixRate";
static const String EP_SOUND_STEREO = "SoundStereo";
static const String EP_TEXTURE_ANISOTROPY = "TextureAnisotropy";
static const String EP_TEXTURE_FILTER_MODE = "TextureFilterMode";
static const String EP_TEXTURE_QUALITY = "TextureQuality";
static const String EP_TIME_OUT = "TimeOut";
static const String EP_TOUCH_EMULATION = "TouchEmulation";
static const String EP_TRIPLE_BUFFER = "TripleBuffer";
static const String EP_VSYNC = "VSync";
static const String EP_WINDOW_HEIGHT = "WindowHeight";
static const String EP_WINDOW_ICON = "WindowIcon";
static const String EP_WINDOW_POSITION_X = "WindowPositionX";
static const String EP_WINDOW_POSITION_Y = "WindowPositionY";
static const String EP_WINDOW_RESIZABLE = "WindowResizable";
static const String EP_WINDOW_TITLE = "WindowTitle";
static const String EP_WINDOW_WIDTH = "WindowWidth";
static const String EP_WORKER_THREADS = "WorkerThreads";

}
namespace Urho3D
{


static const Urho3D::StringHash E_CONSOLECOMMAND(Urho3D::GetEventNameRegister().RegisterString("ConsoleCommand")); namespace ConsoleCommand
{
    static const Urho3D::StringHash P_COMMAND("Command");
    static const Urho3D::StringHash P_ID("Id");
}

}
namespace Urho3D
{

enum BoneCollisionShape : unsigned char
{
    BONECOLLISION_NONE = 0x0,
    BONECOLLISION_SPHERE = 0x1,
    BONECOLLISION_BOX = 0x2,
};
template<> struct IsFlagSet<BoneCollisionShape> { constexpr static bool value_ = true; }; using BoneCollisionShapeFlags = FlagSet<BoneCollisionShape>;

class Deserializer;
class ResourceCache;
class Serializer;


struct Bone
{

    Bone() :
        parentIndex_(0),
        initialPosition_(Vector3::ZERO),
        initialRotation_(Quaternion::IDENTITY),
        initialScale_(Vector3::ONE),
        animated_(true),
        radius_(0.0f)
    {
    }


    String name_;

    StringHash nameHash_;

    unsigned parentIndex_;

    Vector3 initialPosition_;

    Quaternion initialRotation_;

    Vector3 initialScale_;

    Matrix3x4 offsetMatrix_;

    bool animated_;

    BoneCollisionShapeFlags collisionMask_ = BONECOLLISION_NONE;

    float radius_;

    BoundingBox boundingBox_;

    WeakPtr<Node> node_;
};


class __attribute__((visibility("default"))) Skeleton
{
public:

    Skeleton();

    ~Skeleton();


    bool Load(Deserializer& source);

    bool Save(Serializer& dest) const;

    void Define(const Skeleton& src);

    void SetRootBoneIndex(unsigned index);

    void ClearBones();

    void Reset();


    const Vector<Bone>& GetBones() const { return bones_; }


    Vector<Bone>& GetModifiableBones() { return bones_; }


    unsigned GetNumBones() const { return bones_.Size(); }


    Bone* GetRootBone();

    unsigned GetBoneIndex(const String& boneName) const;

    unsigned GetBoneIndex(const StringHash& boneNameHash) const;

    unsigned GetBoneIndex(const Bone* bone) const;

    Bone* GetBoneParent(const Bone* bone);

    Bone* GetBone(unsigned index);

    Bone* GetBone(const String& name);

    Bone* GetBone(const char* name);

    Bone* GetBone(const StringHash& boneNameHash);


    void ResetSilent();

private:

    Vector<Bone> bones_;

    unsigned rootBoneIndex_;
};

}




namespace Urho3D
{

class Geometry;
class IndexBuffer;
class Graphics;
class VertexBuffer;


struct VertexBufferMorph
{

    VertexMaskFlags elementMask_;

    unsigned vertexCount_;

    unsigned dataSize_;

    SharedArrayPtr<unsigned char> morphData_;
};


struct ModelMorph
{

    String name_;

    StringHash nameHash_;

    float weight_;

    HashMap<unsigned, VertexBufferMorph> buffers_;
};


struct VertexBufferDesc
{

    unsigned vertexCount_;

    PODVector<VertexElement> vertexElements_;

    unsigned dataSize_;

    SharedArrayPtr<unsigned char> data_;
};


struct IndexBufferDesc
{

    unsigned indexCount_;

    unsigned indexSize_;

    unsigned dataSize_;

    SharedArrayPtr<unsigned char> data_;
};


struct GeometryDesc
{

    PrimitiveType type_;

    unsigned vbRef_;

    unsigned ibRef_;

    unsigned indexStart_;

    unsigned indexCount_;
};


class __attribute__((visibility("default"))) Model : public ResourceWithMetadata
{
    public: using ClassName = Model; using BaseClassName = ResourceWithMetadata; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Model", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Model(Context* context);

    ~Model() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    bool Save(Serializer& dest) const override;


    void SetBoundingBox(const BoundingBox& box);

    bool SetVertexBuffers(const Vector<SharedPtr<VertexBuffer> >& buffers, const PODVector<unsigned>& morphRangeStarts,
        const PODVector<unsigned>& morphRangeCounts);

    bool SetIndexBuffers(const Vector<SharedPtr<IndexBuffer> >& buffers);

    void SetNumGeometries(unsigned num);

    bool SetNumGeometryLodLevels(unsigned index, unsigned num);

    bool SetGeometry(unsigned index, unsigned lodLevel, Geometry* geometry);

    bool SetGeometryCenter(unsigned index, const Vector3& center);

    void SetSkeleton(const Skeleton& skeleton);

    void SetGeometryBoneMappings(const Vector<PODVector<unsigned> >& geometryBoneMappings);

    void SetMorphs(const Vector<ModelMorph>& morphs);

    SharedPtr<Model> Clone(const String& cloneName = String::EMPTY) const;


    const BoundingBox& GetBoundingBox() const { return boundingBox_; }


    Skeleton& GetSkeleton() { return skeleton_; }


    const Vector<SharedPtr<VertexBuffer> >& GetVertexBuffers() const { return vertexBuffers_; }


    const Vector<SharedPtr<IndexBuffer> >& GetIndexBuffers() const { return indexBuffers_; }


    unsigned GetNumGeometries() const { return geometries_.Size(); }


    unsigned GetNumGeometryLodLevels(unsigned index) const;


    const Vector<Vector<SharedPtr<Geometry> > >& GetGeometries() const { return geometries_; }


    const PODVector<Vector3>& GetGeometryCenters() const { return geometryCenters_; }


    Geometry* GetGeometry(unsigned index, unsigned lodLevel) const;


    const Vector3& GetGeometryCenter(unsigned index) const
    {
        return index < geometryCenters_.Size() ? geometryCenters_[index] : Vector3::ZERO;
    }


    const Vector<PODVector<unsigned> >& GetGeometryBoneMappings() const { return geometryBoneMappings_; }


    const Vector<ModelMorph>& GetMorphs() const { return morphs_; }


    unsigned GetNumMorphs() const { return morphs_.Size(); }


    const ModelMorph* GetMorph(unsigned index) const;

    const ModelMorph* GetMorph(const String& name) const;

    const ModelMorph* GetMorph(StringHash nameHash) const;

    unsigned GetMorphRangeStart(unsigned bufferIndex) const;

    unsigned GetMorphRangeCount(unsigned bufferIndex) const;

private:

    BoundingBox boundingBox_;

    Skeleton skeleton_;

    Vector<SharedPtr<VertexBuffer> > vertexBuffers_;

    Vector<SharedPtr<IndexBuffer> > indexBuffers_;

    Vector<Vector<SharedPtr<Geometry> > > geometries_;

    Vector<PODVector<unsigned> > geometryBoneMappings_;

    PODVector<Vector3> geometryCenters_;

    Vector<ModelMorph> morphs_;

    PODVector<unsigned> morphRangeStarts_;

    PODVector<unsigned> morphRangeCounts_;

    Vector<VertexBufferDesc> loadVBData_;

    Vector<IndexBufferDesc> loadIBData_;

    Vector<PODVector<GeometryDesc> > loadGeometries_;
};

}




namespace Urho3D
{

class Animation;
class AnimationState;


class __attribute__((visibility("default"))) AnimatedModel : public StaticModel
{
    public: using ClassName = AnimatedModel; using BaseClassName = StaticModel; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("AnimatedModel", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class AnimationState;

public:

    explicit AnimatedModel(Context* context);

    ~AnimatedModel() override;

    static void RegisterObject(Context* context);


    bool Load(Deserializer& source) override;

    bool LoadXML(const XMLElement& source) override;

    bool LoadJSON(const JSONValue& source) override;

    void ApplyAttributes() override;

    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void Update(const FrameInfo& frame) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetModel(Model* model, bool createBones = true);

    AnimationState* AddAnimationState(Animation* animation);

    void RemoveAnimationState(Animation* animation);

    void RemoveAnimationState(const String& animationName);

    void RemoveAnimationState(StringHash animationNameHash);

    void RemoveAnimationState(AnimationState* state);

    void RemoveAnimationState(unsigned index);

    void RemoveAllAnimationStates();

    void SetAnimationLodBias(float bias);

    void SetUpdateInvisible(bool enable);

    void SetMorphWeight(unsigned index, float weight);

    void SetMorphWeight(const String& name, float weight);

    void SetMorphWeight(StringHash nameHash, float weight);

    void ResetMorphWeights();

    void ApplyAnimation();


    Skeleton& GetSkeleton() { return skeleton_; }


    const Vector<SharedPtr<AnimationState> >& GetAnimationStates() const { return animationStates_; }


    unsigned GetNumAnimationStates() const { return animationStates_.Size(); }


    AnimationState* GetAnimationState(Animation* animation) const;

    AnimationState* GetAnimationState(const String& animationName) const;

    AnimationState* GetAnimationState(StringHash animationNameHash) const;

    AnimationState* GetAnimationState(unsigned index) const;


    float GetAnimationLodBias() const { return animationLodBias_; }


    bool GetUpdateInvisible() const { return updateInvisible_; }


    const Vector<ModelMorph>& GetMorphs() const { return morphs_; }


    const Vector<SharedPtr<VertexBuffer> >& GetMorphVertexBuffers() const { return morphVertexBuffers_; }


    unsigned GetNumMorphs() const { return morphs_.Size(); }


    float GetMorphWeight(unsigned index) const;

    float GetMorphWeight(const String& name) const;

    float GetMorphWeight(StringHash nameHash) const;


    bool IsMaster() const { return isMaster_; }


    void SetModelAttr(const ResourceRef& value);

    void SetBonesEnabledAttr(const VariantVector& value);

    void SetAnimationStatesAttr(const VariantVector& value);

    void SetMorphsAttr(const PODVector<unsigned char>& value);

    ResourceRef GetModelAttr() const;

    VariantVector GetBonesEnabledAttr() const;

    VariantVector GetAnimationStatesAttr() const;

    const PODVector<unsigned char>& GetMorphsAttr() const;


    const Vector<PODVector<unsigned> >& GetGeometryBoneMappings() const { return geometryBoneMappings_; }


    const Vector<PODVector<Matrix3x4> >& GetGeometrySkinMatrices() const { return geometrySkinMatrices_; }


    void UpdateBoneBoundingBox();

protected:

    void OnNodeSet(Node* node) override;

    void OnMarkedDirty(Node* node) override;

    void OnWorldBoundingBoxUpdate() override;

private:

    void AssignBoneNodes();

    void FinalizeBoneBoundingBoxes();

    void RemoveRootBone();

    void MarkAnimationDirty();

    void MarkAnimationOrderDirty();

    void MarkMorphsDirty();

    void SetSkeleton(const Skeleton& skeleton, bool createBones);

    void SetGeometryBoneMappings();

    void CloneGeometries();

    void CopyMorphVertices(void* destVertexData, void* srcVertexData, unsigned vertexCount, VertexBuffer* destBuffer, VertexBuffer* srcBuffer);

    void UpdateAnimation(const FrameInfo& frame);

    void UpdateSkinning();

    void UpdateMorphs();

    void ApplyMorph
        (VertexBuffer* buffer, void* destVertexData, unsigned morphRangeStart, const VertexBufferMorph& morph, float weight);

    void HandleModelReloadFinished(StringHash eventType, VariantMap& eventData);


    Skeleton skeleton_;

    Vector<SharedPtr<VertexBuffer> > morphVertexBuffers_;

    Vector<ModelMorph> morphs_;

    Vector<SharedPtr<AnimationState> > animationStates_;

    PODVector<Matrix3x4> skinMatrices_;

    Vector<PODVector<unsigned> > geometryBoneMappings_;

    Vector<PODVector<Matrix3x4> > geometrySkinMatrices_;

    Vector<PODVector<Matrix3x4*> > geometrySkinMatrixPtrs_;

    BoundingBox boneBoundingBox_;

    mutable VectorBuffer attrBuffer_;

    unsigned animationLodFrameNumber_;

    VertexMaskFlags morphElementMask_;

    float animationLodBias_;

    float animationLodTimer_;

    float animationLodDistance_;

    bool updateInvisible_;

    bool animationDirty_;

    bool animationOrderDirty_;

    bool morphsDirty_;

    bool skinningDirty_;

    bool boneBoundingBoxDirty_;

    bool isMaster_;

    bool loading_;

    bool assignBonesPending_;

    bool forceAnimationUpdate_;
};

}
namespace Urho3D
{

enum AnimationChannel : unsigned char
{
    CHANNEL_NONE = 0x0,
    CHANNEL_POSITION = 0x1,
    CHANNEL_ROTATION = 0x2,
    CHANNEL_SCALE = 0x4,
};
template<> struct IsFlagSet<AnimationChannel> { constexpr static bool value_ = true; }; using AnimationChannelFlags = FlagSet<AnimationChannel>;


struct AnimationKeyFrame
{

    AnimationKeyFrame() :
        time_(0.0f),
        scale_(Vector3::ONE)
    {
    }


    float time_;

    Vector3 position_;

    Quaternion rotation_;

    Vector3 scale_;
};


struct __attribute__((visibility("default"))) AnimationTrack
{

    AnimationTrack()
    {
    }


    void SetKeyFrame(unsigned index, const AnimationKeyFrame& keyFrame);

    void AddKeyFrame(const AnimationKeyFrame& keyFrame);

    void InsertKeyFrame(unsigned index, const AnimationKeyFrame& keyFrame);

    void RemoveKeyFrame(unsigned index);

    void RemoveAllKeyFrames();


    AnimationKeyFrame* GetKeyFrame(unsigned index);

    unsigned GetNumKeyFrames() const { return keyFrames_.Size(); }

    void GetKeyFrameIndex(float time, unsigned& index) const;


    String name_;

    StringHash nameHash_;

    AnimationChannelFlags channelMask_{};

    Vector<AnimationKeyFrame> keyFrames_;
};


struct AnimationTriggerPoint
{

    AnimationTriggerPoint() :
        time_(0.0f)
    {
    }


    float time_;

    Variant data_;
};


class __attribute__((visibility("default"))) Animation : public ResourceWithMetadata
{
    public: using ClassName = Animation; using BaseClassName = ResourceWithMetadata; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Animation", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Animation(Context* context);

    ~Animation() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;


    void SetAnimationName(const String& name);

    void SetLength(float length);

    AnimationTrack* CreateTrack(const String& name);

    bool RemoveTrack(const String& name);

    void RemoveAllTracks();

    void SetTrigger(unsigned index, const AnimationTriggerPoint& trigger);

    void AddTrigger(const AnimationTriggerPoint& trigger);

    void AddTrigger(float time, bool timeIsNormalized, const Variant& data);

    void RemoveTrigger(unsigned index);

    void RemoveAllTriggers();

    void SetNumTriggers(unsigned num);

    SharedPtr<Animation> Clone(const String& cloneName = String::EMPTY) const;


    const String& GetAnimationName() const { return animationName_; }


    StringHash GetAnimationNameHash() const { return animationNameHash_; }


    float GetLength() const { return length_; }


    const HashMap<StringHash, AnimationTrack>& GetTracks() const { return tracks_; }


    unsigned GetNumTracks() const { return tracks_.Size(); }


    AnimationTrack *GetTrack(unsigned index);


    AnimationTrack* GetTrack(const String& name);

    AnimationTrack* GetTrack(StringHash nameHash);


    const Vector<AnimationTriggerPoint>& GetTriggers() const { return triggers_; }


    unsigned GetNumTriggers() const { return triggers_.Size(); }


    AnimationTriggerPoint* GetTrigger(unsigned index);

private:

    String animationName_;

    StringHash animationNameHash_;

    float length_;

    HashMap<StringHash, AnimationTrack> tracks_;

    Vector<AnimationTriggerPoint> triggers_;
};

}
namespace Urho3D
{

class Animation;
class AnimatedModel;
class Deserializer;
class Serializer;
class Skeleton;
struct AnimationTrack;
struct Bone;


enum AnimationBlendMode
{

    ABM_LERP = 0,

    ABM_ADDITIVE
};


struct AnimationStateTrack
{

    AnimationStateTrack();

    ~AnimationStateTrack();


    const AnimationTrack* track_;

    Bone* bone_;

    WeakPtr<Node> node_;

    float weight_;

    unsigned keyFrame_;
};


class __attribute__((visibility("default"))) AnimationState : public RefCounted
{
public:

    AnimationState(AnimatedModel* model, Animation* animation);

    AnimationState(Node* node, Animation* animation);

    ~AnimationState() override;


    void SetStartBone(Bone* startBone);

    void SetLooped(bool looped);

    void SetWeight(float weight);

    void SetBlendMode(AnimationBlendMode mode);

    void SetTime(float time);

    void SetBoneWeight(unsigned index, float weight, bool recursive = false);

    void SetBoneWeight(const String& name, float weight, bool recursive = false);

    void SetBoneWeight(StringHash nameHash, float weight, bool recursive = false);

    void AddWeight(float delta);

    void AddTime(float delta);

    void SetLayer(unsigned char layer);


    Animation* GetAnimation() const { return animation_; }


    AnimatedModel* GetModel() const;

    Node* GetNode() const;

    Bone* GetStartBone() const;

    float GetBoneWeight(unsigned index) const;

    float GetBoneWeight(const String& name) const;

    float GetBoneWeight(StringHash nameHash) const;

    unsigned GetTrackIndex(Node* node) const;

    unsigned GetTrackIndex(const String& name) const;

    unsigned GetTrackIndex(StringHash nameHash) const;


    bool IsEnabled() const { return weight_ > 0.0f; }


    bool IsLooped() const { return looped_; }


    float GetWeight() const { return weight_; }


    AnimationBlendMode GetBlendMode() const { return blendingMode_; }


    float GetTime() const { return time_; }


    float GetLength() const;


    unsigned char GetLayer() const { return layer_; }


    void Apply();

private:

    void ApplyToModel();

    void ApplyToNodes();

    void ApplyTrack(AnimationStateTrack& stateTrack, float weight, bool silent);


    WeakPtr<AnimatedModel> model_;

    WeakPtr<Node> node_;

    SharedPtr<Animation> animation_;

    Bone* startBone_;

    Vector<AnimationStateTrack> stateTracks_;

    bool looped_;

    float weight_;

    float time_;

    unsigned char layer_;

    AnimationBlendMode blendingMode_;
};

}


namespace Urho3D
{

class AnimatedModel;
class Animation;
struct Bone;


struct __attribute__((visibility("default"))) AnimationControl
{

    AnimationControl() :
        speed_(1.0f),
        targetWeight_(0.0f),
        fadeTime_(0.0f),
        autoFadeTime_(0.0f),
        setTimeTtl_(0.0f),
        setWeightTtl_(0.0f),
        setTime_(0),
        setWeight_(0),
        setTimeRev_(0),
        setWeightRev_(0),
        removeOnCompletion_(true)
    {
    }


    String name_;

    StringHash hash_;

    float speed_;

    float targetWeight_;

    float fadeTime_;

    float autoFadeTime_;

    float setTimeTtl_;

    float setWeightTtl_;

    unsigned short setTime_;

    unsigned char setWeight_;

    unsigned char setTimeRev_;

    unsigned char setWeightRev_;

    bool removeOnCompletion_;
};


class __attribute__((visibility("default"))) AnimationController : public Component
{
    public: using ClassName = AnimationController; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("AnimationController", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit AnimationController(Context* context);

    ~AnimationController() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    virtual void Update(float timeStep);

    bool Play(const String& name, unsigned char layer, bool looped, float fadeInTime = 0.0f);

    bool PlayExclusive(const String& name, unsigned char layer, bool looped, float fadeTime = 0.0f);

    bool Stop(const String& name, float fadeOutTime = 0.0f);

    void StopLayer(unsigned char layer, float fadeOutTime = 0.0f);

    void StopAll(float fadeOutTime = 0.0f);

    bool Fade(const String& name, float targetWeight, float fadeTime);

    bool FadeOthers(const String& name, float targetWeight, float fadeTime);


    bool SetLayer(const String& name, unsigned char layer);

    bool SetStartBone(const String& name, const String& startBoneName);

    bool SetTime(const String& name, float time);

    bool SetWeight(const String& name, float weight);

    bool SetLooped(const String& name, bool enable);

    bool SetSpeed(const String& name, float speed);

    bool SetAutoFade(const String& name, float fadeOutTime);

    bool SetRemoveOnCompletion(const String& name, bool removeOnCompletion);

    bool SetBlendMode(const String& name, AnimationBlendMode mode);


    bool IsPlaying(const String& name) const;

    bool IsPlaying(unsigned char layer) const;

    bool IsFadingIn(const String& name) const;

    bool IsFadingOut(const String& name) const;

    bool IsAtEnd(const String& name) const;

    unsigned char GetLayer(const String& name) const;

    Bone* GetStartBone(const String& name) const;

    const String& GetStartBoneName(const String& name) const;

    float GetTime(const String& name) const;

    float GetWeight(const String& name) const;

    bool IsLooped(const String& name) const;

    AnimationBlendMode GetBlendMode(const String& name) const;

    float GetLength(const String& name) const;

    float GetSpeed(const String& name) const;

    float GetFadeTarget(const String& name) const;

    float GetFadeTime(const String& name) const;

    float GetAutoFade(const String& name) const;

    bool GetRemoveOnCompletion(const String& name) const;

    AnimationState* GetAnimationState(const String& name) const;

    AnimationState* GetAnimationState(StringHash nameHash) const;

    const Vector<AnimationControl>& GetAnimations() const { return animations_; }


    void SetAnimationsAttr(const VariantVector& value);

    void SetNetAnimationsAttr(const PODVector<unsigned char>& value);

    void SetNodeAnimationStatesAttr(const VariantVector& value);

    VariantVector GetAnimationsAttr() const;

    const PODVector<unsigned char>& GetNetAnimationsAttr() const;

    VariantVector GetNodeAnimationStatesAttr() const;

protected:

    void OnSceneSet(Scene* scene) override;

private:

    AnimationState* AddAnimationState(Animation* animation);

    void RemoveAnimationState(AnimationState* state);

    void FindAnimation(const String& name, unsigned& index, AnimationState*& state) const;

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);


    Vector<AnimationControl> animations_;

    Vector<SharedPtr<AnimationState> > nodeAnimationStates_;

    mutable VectorBuffer attrBuffer_;
};

}

namespace Urho3D
{

class Camera;
class Drawable;
class Geometry;
class Light;
class Material;
class Matrix3x4;
class Pass;
class ShaderVariation;
class Texture2D;
class VertexBuffer;
class View;
class Zone;
struct LightBatchQueue;


struct Batch
{

    Batch() = default;


    explicit Batch(const SourceBatch& rhs) :
        distance_(rhs.distance_),
        renderOrder_(rhs.material_ ? rhs.material_->GetRenderOrder() : DEFAULT_RENDER_ORDER),
        isBase_(false),
        geometry_(rhs.geometry_),
        material_(rhs.material_),
        worldTransform_(rhs.worldTransform_),
        numWorldTransforms_(rhs.numWorldTransforms_),
        instancingData_(rhs.instancingData_),
        lightQueue_(nullptr),
        geometryType_(rhs.geometryType_)
    {
    }


    void CalculateSortKey();

    void Prepare(View* view, Camera* camera, bool setModelTransform, bool allowDepthWrite) const;

    void Draw(View* view, Camera* camera, bool allowDepthWrite) const;


    unsigned long long sortKey_{};

    float distance_{};

    unsigned char renderOrder_{};

    unsigned char lightMask_{};

    bool isBase_{};

    Geometry* geometry_{};

    Material* material_{};

    const Matrix3x4* worldTransform_{};

    unsigned numWorldTransforms_{};

    void* instancingData_{};

    Zone* zone_{};

    LightBatchQueue* lightQueue_{};

    Pass* pass_{};

    ShaderVariation* vertexShader_{};

    ShaderVariation* pixelShader_{};

    GeometryType geometryType_{};
};


struct InstanceData
{

    InstanceData() = default;


    InstanceData(const Matrix3x4* worldTransform, const void* instancingData, float distance) :
        worldTransform_(worldTransform),
        instancingData_(instancingData),
        distance_(distance)
    {
    }


    const Matrix3x4* worldTransform_{};

    const void* instancingData_{};

    float distance_{};
};


struct BatchGroup : public Batch
{

    BatchGroup() :
        startIndex_(M_MAX_UNSIGNED)
    {
    }


    explicit BatchGroup(const Batch& batch) :
        Batch(batch),
        startIndex_(M_MAX_UNSIGNED)
    {
    }


    ~BatchGroup() = default;


    void AddTransforms(const Batch& batch)
    {
        InstanceData newInstance;
        newInstance.distance_ = batch.distance_;
        newInstance.instancingData_ = batch.instancingData_;

        for (unsigned i = 0; i < batch.numWorldTransforms_; ++i)
        {
            newInstance.worldTransform_ = &batch.worldTransform_[i];
            instances_.Push(newInstance);
        }
    }


    void SetInstancingData(void* lockedData, unsigned stride, unsigned& freeIndex);

    void Draw(View* view, Camera* camera, bool allowDepthWrite) const;


    PODVector<InstanceData> instances_;

    unsigned startIndex_;
};


struct BatchGroupKey
{

    BatchGroupKey() = default;


    explicit BatchGroupKey(const Batch& batch) :
        zone_(batch.zone_),
        lightQueue_(batch.lightQueue_),
        pass_(batch.pass_),
        material_(batch.material_),
        geometry_(batch.geometry_),
        renderOrder_(batch.renderOrder_)
    {
    }


    Zone* zone_;

    LightBatchQueue* lightQueue_;

    Pass* pass_;

    Material* material_;

    Geometry* geometry_;

    unsigned char renderOrder_;


    bool operator ==(const BatchGroupKey& rhs) const
    {
        return zone_ == rhs.zone_ && lightQueue_ == rhs.lightQueue_ && pass_ == rhs.pass_ && material_ == rhs.material_ &&
               geometry_ == rhs.geometry_ && renderOrder_ == rhs.renderOrder_;
    }


    bool operator !=(const BatchGroupKey& rhs) const
    {
        return zone_ != rhs.zone_ || lightQueue_ != rhs.lightQueue_ || pass_ != rhs.pass_ || material_ != rhs.material_ ||
               geometry_ != rhs.geometry_ || renderOrder_ != rhs.renderOrder_;
    }


    unsigned ToHash() const;
};


struct BatchQueue
{
public:

    void Clear(int maxSortedInstances);

    void SortBackToFront();

    void SortFrontToBack();

    void SortFrontToBack2Pass(PODVector<Batch*>& batches);

    void SetInstancingData(void* lockedData, unsigned stride, unsigned& freeIndex);

    void Draw(View* view, Camera* camera, bool markToStencil, bool usingLightOptimization, bool allowDepthWrite) const;

    unsigned GetNumInstances() const;


    bool IsEmpty() const { return batches_.Empty() && batchGroups_.Empty(); }


    HashMap<BatchGroupKey, BatchGroup> batchGroups_;

    HashMap<unsigned, unsigned> shaderRemapping_;

    HashMap<unsigned short, unsigned short> materialRemapping_;

    HashMap<unsigned short, unsigned short> geometryRemapping_;


    PODVector<Batch> batches_;

    PODVector<Batch*> sortedBatches_;

    PODVector<BatchGroup*> sortedBatchGroups_;

    unsigned maxSortedInstances_;

    bool hasExtraDefines_;

    String vsExtraDefines_;

    String psExtraDefines_;

    StringHash vsExtraDefinesHash_;

    StringHash psExtraDefinesHash_;
};


struct ShadowBatchQueue
{

    Camera* shadowCamera_{};

    IntRect shadowViewport_;

    BatchQueue shadowBatches_;

    float nearSplit_{};

    float farSplit_{};
};


struct LightBatchQueue
{

    Light* light_;

    bool negative_;

    Texture2D* shadowMap_;

    BatchQueue litBaseBatches_;

    BatchQueue litBatches_;

    Vector<ShadowBatchQueue> shadowSplits_;

    PODVector<Light*> vertexLights_;

    PODVector<Batch> volumeBatches_;
};

}
namespace Urho3D
{

class IndexBuffer;
class VertexBuffer;


struct __attribute__((visibility("default"))) Billboard
{

    Vector3 position_;

    Vector2 size_;

    Rect uv_;

    Color color_;

    float rotation_;

    Vector3 direction_;

    bool enabled_;

    float sortDistance_;

    float screenScaleFactor_;
};


class __attribute__((visibility("default"))) BillboardSet : public Drawable
{
    public: using ClassName = BillboardSet; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("BillboardSet", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit BillboardSet(Context* context);

    ~BillboardSet() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;


    void SetMaterial(Material* material);

    void SetNumBillboards(unsigned num);

    void SetRelative(bool enable);

    void SetScaled(bool enable);

    void SetSorted(bool enable);

    void SetFixedScreenSize(bool enable);

    void SetFaceCameraMode(FaceCameraMode mode);

    void SetMinAngle(float angle);

    void SetAnimationLodBias(float bias);

    void Commit();


    Material* GetMaterial() const;


    unsigned GetNumBillboards() const { return billboards_.Size(); }


    PODVector<Billboard>& GetBillboards() { return billboards_; }


    Billboard* GetBillboard(unsigned index);


    bool IsRelative() const { return relative_; }


    bool IsScaled() const { return scaled_; }


    bool IsSorted() const { return sorted_; }


    bool IsFixedScreenSize() const { return fixedScreenSize_; }


    FaceCameraMode GetFaceCameraMode() const { return faceCameraMode_; }


    float GetMinAngle() const { return minAngle_; }


    float GetAnimationLodBias() const { return animationLodBias_; }


    void SetMaterialAttr(const ResourceRef& value);

    void SetBillboardsAttr(const VariantVector& value);

    void SetNetBillboardsAttr(const PODVector<unsigned char>& value);

    ResourceRef GetMaterialAttr() const;

    VariantVector GetBillboardsAttr() const;

    const PODVector<unsigned char>& GetNetBillboardsAttr() const;

protected:

    void OnWorldBoundingBoxUpdate() override;

    void MarkPositionsDirty();


    PODVector<Billboard> billboards_;

    float animationLodBias_;

    float animationLodTimer_;

    bool relative_;

    bool scaled_;

    bool sorted_;

    bool fixedScreenSize_;

    FaceCameraMode faceCameraMode_;

    float minAngle_;

private:

    void UpdateBufferSize();

    void UpdateVertexBuffer(const FrameInfo& frame);

    void CalculateFixedScreenSize(const FrameInfo& frame);


    SharedPtr<Geometry> geometry_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    SharedPtr<IndexBuffer> indexBuffer_;

    Matrix3x4 transforms_[2];

    bool bufferSizeDirty_;

    bool bufferDirty_;

    bool forceUpdate_;

    bool geometryTypeUpdate_;

    bool sortThisFrame_;

    bool hasOrthoCamera_;

    unsigned sortFrameNumber_;

    Vector3 previousOffset_;

    Vector<Billboard*> sortedBillboards_;

    mutable VectorBuffer attrBuffer_;
};

}
namespace Urho3D
{

class BoundingBox;
class Frustum;
class Plane;
class Sphere;


class __attribute__((visibility("default"))) Ray
{
public:

    Ray() noexcept = default;


    Ray(const Vector3& origin, const Vector3& direction) noexcept
    {
        Define(origin, direction);
    }


    Ray(const Ray& ray) noexcept = default;


    Ray& operator =(const Ray& rhs) noexcept = default;


    bool operator ==(const Ray& rhs) const { return origin_ == rhs.origin_ && direction_ == rhs.direction_; }


    bool operator !=(const Ray& rhs) const { return origin_ != rhs.origin_ || direction_ != rhs.direction_; }


    void Define(const Vector3& origin, const Vector3& direction)
    {
        origin_ = origin;
        direction_ = direction.Normalized();
    }


    Vector3 Project(const Vector3& point) const
    {
        Vector3 offset = point - origin_;
        return origin_ + offset.DotProduct(direction_) * direction_;
    }


    float Distance(const Vector3& point) const
    {
        Vector3 projected = Project(point);
        return (point - projected).Length();
    }


    Vector3 ClosestPoint(const Ray& ray) const;

    float HitDistance(const Plane& plane) const;

    float HitDistance(const BoundingBox& box) const;

    float HitDistance(const Frustum& frustum, bool solidInside = true) const;

    float HitDistance(const Sphere& sphere) const;

    float HitDistance(const Vector3& v0, const Vector3& v1, const Vector3& v2, Vector3* outNormal = nullptr, Vector3* outBary = nullptr) const;

    float HitDistance
        (const void* vertexData, unsigned vertexStride, unsigned vertexStart, unsigned vertexCount, Vector3* outNormal = nullptr,
            Vector2* outUV = nullptr, unsigned uvOffset = 0) const;

    float HitDistance(const void* vertexData, unsigned vertexStride, const void* indexData, unsigned indexSize, unsigned indexStart,
        unsigned indexCount, Vector3* outNormal = nullptr, Vector2* outUV = nullptr, unsigned uvOffset = 0) const;

    bool InsideGeometry(const void* vertexData, unsigned vertexSize, unsigned vertexStart, unsigned vertexCount) const;

    bool InsideGeometry(const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart,
        unsigned indexCount) const;

    Ray Transformed(const Matrix3x4& transform) const;


    Vector3 origin_;

    Vector3 direction_;
};

}



namespace Urho3D
{

static const float DEFAULT_NEARCLIP = 0.1f;
static const float DEFAULT_FARCLIP = 1000.0f;
static const float DEFAULT_CAMERA_FOV = 45.0f;
static const float DEFAULT_ORTHOSIZE = 20.0f;

enum ViewOverride : unsigned
{
    VO_NONE = 0x0,
    VO_LOW_MATERIAL_QUALITY = 0x1,
    VO_DISABLE_SHADOWS = 0x2,
    VO_DISABLE_OCCLUSION = 0x4,
};
template<> struct IsFlagSet<ViewOverride> { constexpr static bool value_ = true; }; using ViewOverrideFlags = FlagSet<ViewOverride>;


class __attribute__((visibility("default"))) Camera : public Component
{
    public: using ClassName = Camera; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Camera", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Camera(Context* context);

    ~Camera() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetNearClip(float nearClip);

    void SetFarClip(float farClip);

    void SetFov(float fov);

    void SetOrthoSize(float orthoSize);

    void SetOrthoSize(const Vector2& orthoSize);

    void SetAspectRatio(float aspectRatio);

    void SetFillMode(FillMode mode);

    void SetZoom(float zoom);

    void SetLodBias(float bias);

    void SetViewMask(unsigned mask);

    void SetViewOverrideFlags(ViewOverrideFlags flags);

    void SetOrthographic(bool enable);

    void SetAutoAspectRatio(bool enable);

    void SetProjectionOffset(const Vector2& offset);

    void SetUseReflection(bool enable);

    void SetReflectionPlane(const Plane& plane);

    void SetUseClipping(bool enable);

    void SetClipPlane(const Plane& plane);

    void SetFlipVertical(bool enable);




    void SetProjection(const Matrix4& projection);


    float GetFarClip() const;


    float GetNearClip() const;


    float GetFov() const { return fov_; }


    float GetOrthoSize() const { return orthoSize_; }


    float GetAspectRatio() const { return aspectRatio_; }


    float GetZoom() const { return zoom_; }


    float GetLodBias() const { return lodBias_; }


    unsigned GetViewMask() const { return viewMask_; }


    ViewOverrideFlags GetViewOverrideFlags() const { return viewOverrideFlags_; }


    FillMode GetFillMode() const { return fillMode_; }


    bool IsOrthographic() const { return orthographic_; }


    bool GetAutoAspectRatio() const { return autoAspectRatio_; }


    const Frustum& GetFrustum() const;

    Matrix4 GetProjection() const;

    Matrix4 GetGPUProjection() const;

    const Matrix3x4& GetView() const;

    void GetFrustumSize(Vector3& near, Vector3& far) const;

    float GetHalfViewSize() const;

    Frustum GetSplitFrustum(float nearClip, float farClip) const;

    Frustum GetViewSpaceFrustum() const;

    Frustum GetViewSpaceSplitFrustum(float nearClip, float farClip) const;

    Ray GetScreenRay(float x, float y) const;

    Vector2 WorldToScreenPoint(const Vector3& worldPos) const;



    Vector3 ScreenToWorldPoint(const Vector3& screenPos) const;


    const Vector2& GetProjectionOffset() const { return projectionOffset_; }


    bool GetUseReflection() const { return useReflection_; }


    const Plane& GetReflectionPlane() const { return reflectionPlane_; }


    bool GetUseClipping() const { return useClipping_; }


    const Plane& GetClipPlane() const { return clipPlane_; }


    bool GetFlipVertical() const { return flipVertical_; }


    bool GetReverseCulling() const { return flipVertical_ ^ useReflection_; }


    float GetDistance(const Vector3& worldPos) const;

    float GetDistanceSquared(const Vector3& worldPos) const;

    float GetLodDistance(float distance, float scale, float bias) const;

    Quaternion GetFaceCameraRotation(const Vector3& position, const Quaternion& rotation, FaceCameraMode mode, float minAngle = 0.0f);

    Matrix3x4 GetEffectiveWorldTransform() const;

    bool IsProjectionValid() const;


    void SetAspectRatioInternal(float aspectRatio);

    void SetOrthoSizeAttr(float orthoSize);

    void SetReflectionPlaneAttr(const Vector4& value);

    Vector4 GetReflectionPlaneAttr() const;

    void SetClipPlaneAttr(const Vector4& value);

    Vector4 GetClipPlaneAttr() const;

protected:

    void OnNodeSet(Node* node) override;

    void OnMarkedDirty(Node* node) override;

private:

    void UpdateProjection() const;


    mutable Matrix3x4 view_;

    mutable Matrix4 projection_;

    mutable Frustum frustum_;

    mutable bool viewDirty_;

    mutable bool projectionDirty_;

    mutable bool frustumDirty_;

    bool orthographic_;

    mutable float projNearClip_{};

    mutable float projFarClip_{};

    float nearClip_;

    float farClip_;

    float fov_;

    float orthoSize_;

    float aspectRatio_;

    float zoom_;

    float lodBias_;

    unsigned viewMask_;

    ViewOverrideFlags viewOverrideFlags_;

    FillMode fillMode_;

    Vector2 projectionOffset_;

    Plane reflectionPlane_;

    Plane clipPlane_;

    Matrix3x4 reflectionMatrix_;

    bool autoAspectRatio_;

    bool flipVertical_;

    bool useReflection_;

    bool useClipping_;

    mutable bool customProjection_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstantBuffer : public Object, public GPUObject
{
    public: using ClassName = ConstantBuffer; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstantBuffer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstantBuffer(Context* context);

    ~ConstantBuffer() override;


    void OnDeviceReset() override;

    void Release() override;


    bool SetSize(unsigned size);

    void SetParameter(unsigned offset, unsigned size, const void* data);

    void SetVector3ArrayParameter(unsigned offset, unsigned rows, const void* data);

    void Apply();


    unsigned GetSize() const { return size_; }


    bool IsDirty() const { return dirty_; }

private:

    SharedArrayPtr<unsigned char> shadowData_;

    unsigned size_{};

    bool dirty_{};
};

}
namespace Urho3D
{


struct CustomGeometryVertex
{

    Vector3 position_;

    Vector3 normal_;

    unsigned color_;

    Vector2 texCoord_;

    Vector4 tangent_;
};

class VertexBuffer;


class __attribute__((visibility("default"))) CustomGeometry : public Drawable
{
    public: using ClassName = CustomGeometry; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CustomGeometry", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CustomGeometry(Context* context);

    ~CustomGeometry() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    Geometry* GetLodGeometry(unsigned batchIndex, unsigned level) override;

    unsigned GetNumOccluderTriangles() override;

    bool DrawOcclusion(OcclusionBuffer* buffer) override;


    void Clear();

    void SetNumGeometries(unsigned num);

    void SetDynamic(bool enable);

    void BeginGeometry(unsigned index, PrimitiveType type);

    void DefineVertex(const Vector3& position);

    void DefineNormal(const Vector3& normal);

    void DefineColor(const Color& color);

    void DefineTexCoord(const Vector2& texCoord);

    void DefineTangent(const Vector4& tangent);

    void DefineGeometry
        (unsigned index, PrimitiveType type, unsigned numVertices, bool hasNormals, bool hasColors, bool hasTexCoords,
            bool hasTangents);

    void Commit();

    void SetMaterial(Material* material);

    bool SetMaterial(unsigned index, Material* material);


    unsigned GetNumGeometries() const { return geometries_.Size(); }


    unsigned GetNumVertices(unsigned index) const;


    bool IsDynamic() const { return dynamic_; }


    Material* GetMaterial(unsigned index = 0) const;


    Vector<PODVector<CustomGeometryVertex> >& GetVertices() { return vertices_; }


    CustomGeometryVertex* GetVertex(unsigned geometryIndex, unsigned vertexNum);


    void SetGeometryDataAttr(const PODVector<unsigned char>& value);

    void SetMaterialsAttr(const ResourceRefList& value);

    PODVector<unsigned char> GetGeometryDataAttr() const;

    const ResourceRefList& GetMaterialsAttr() const;

protected:

    void OnWorldBoundingBoxUpdate() override;

private:

    PODVector<PrimitiveType> primitiveTypes_;

    Vector<PODVector<CustomGeometryVertex> > vertices_;

    Vector<SharedPtr<Geometry> > geometries_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    VertexMaskFlags elementMask_;

    unsigned geometryIndex_;

    mutable ResourceRefList materialsAttr_;

    bool dynamic_;
};

}
namespace Urho3D
{

class BoundingBox;
class Camera;
class Polyhedron;
class Drawable;
class Light;
class Matrix3x4;
class Renderer;
class Skeleton;
class Sphere;
class VertexBuffer;


struct DebugLine
{

    DebugLine() = default;


    DebugLine(const Vector3& start, const Vector3& end, unsigned color) :
        start_(start),
        end_(end),
        color_(color)
    {
    }


    Vector3 start_;

    Vector3 end_;

    unsigned color_{};
};


struct DebugTriangle
{

    DebugTriangle() = default;


    DebugTriangle(const Vector3& v1, const Vector3& v2, const Vector3& v3, unsigned color) :
        v1_(v1),
        v2_(v2),
        v3_(v3),
        color_(color)
    {
    }


    Vector3 v1_;

    Vector3 v2_;

    Vector3 v3_;

    unsigned color_{};
};


class __attribute__((visibility("default"))) DebugRenderer : public Component
{
    public: using ClassName = DebugRenderer; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("DebugRenderer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit DebugRenderer(Context* context);

    ~DebugRenderer() override;

    static void RegisterObject(Context* context);


    void SetLineAntiAlias(bool enable);

    void SetView(Camera* camera);

    void AddLine(const Vector3& start, const Vector3& end, const Color& color, bool depthTest = true);

    void AddLine(const Vector3& start, const Vector3& end, unsigned color, bool depthTest = true);

    void AddTriangle(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Color& color, bool depthTest = true);

    void AddTriangle(const Vector3& v1, const Vector3& v2, const Vector3& v3, unsigned color, bool depthTest = true);

    void AddPolygon(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, const Color& color, bool depthTest = true);

    void AddPolygon(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, unsigned color, bool depthTest = true);

    void AddNode(Node* node, float scale = 1.0f, bool depthTest = true);

    void AddBoundingBox(const BoundingBox& box, const Color& color, bool depthTest = true, bool solid = false);

    void AddBoundingBox(const BoundingBox& box, const Matrix3x4& transform, const Color& color, bool depthTest = true, bool solid = false);

    void AddFrustum(const Frustum& frustum, const Color& color, bool depthTest = true);

    void AddPolyhedron(const Polyhedron& poly, const Color& color, bool depthTest = true);

    void AddSphere(const Sphere& sphere, const Color& color, bool depthTest = true);

    void AddSphereSector(const Sphere& sphere, const Quaternion& rotation, float angle,
        bool drawLines, const Color& color, bool depthTest = true);

    void AddCylinder(const Vector3& position, float radius, float height, const Color& color, bool depthTest = true);

    void AddSkeleton(const Skeleton& skeleton, const Color& color, bool depthTest = true);

    void AddTriangleMesh(const void* vertexData, unsigned vertexSize, const void* indexData,
        unsigned indexSize, unsigned indexStart, unsigned indexCount, const Matrix3x4& transform, const Color& color, bool depthTest = true);

    void AddTriangleMesh(const void* vertexData, unsigned vertexSize, unsigned vertexStart, const void* indexData,
        unsigned indexSize, unsigned indexStart, unsigned indexCount, const Matrix3x4& transform, const Color& color, bool depthTest = true);

    void AddCircle(const Vector3& center, const Vector3& normal, float radius, const Color& color, int steps = 64, bool depthTest = true);

    void AddCross(const Vector3& center, float size, const Color& color, bool depthTest = true);

    void AddQuad(const Vector3& center, float width, float height, const Color& color, bool depthTest = true);


    void Render();


    bool GetLineAntiAlias() const { return lineAntiAlias_; }


    const Matrix3x4& GetView() const { return view_; }


    const Matrix4& GetProjection() const { return projection_; }


    const Frustum& GetFrustum() const { return frustum_; }


    bool IsInside(const BoundingBox& box) const;

    bool HasContent() const;

private:

    void HandleEndFrame(StringHash eventType, VariantMap& eventData);


    PODVector<DebugLine> lines_;

    PODVector<DebugLine> noDepthLines_;

    PODVector<DebugTriangle> triangles_;

    PODVector<DebugTriangle> noDepthTriangles_;

    Matrix3x4 view_;

    Matrix4 projection_;

    Matrix4 gpuProjection_;

    Frustum frustum_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    bool lineAntiAlias_;
};

}
namespace Urho3D
{

class IndexBuffer;
class VertexBuffer;


struct DecalVertex
{

    DecalVertex() = default;


    DecalVertex(const Vector3& position, const Vector3& normal) :
        position_(position),
        normal_(normal)
    {
    }


    DecalVertex(const Vector3& position, const Vector3& normal, const float* blendWeights, const unsigned char* blendIndices) :
        position_(position),
        normal_(normal)
    {
        for (unsigned i = 0; i < 4; ++i)
        {
            blendWeights_[i] = blendWeights[i];
            blendIndices_[i] = blendIndices[i];
        }
    }


    Vector3 position_;

    Vector3 normal_;

    Vector2 texCoord_;

    Vector4 tangent_;

    float blendWeights_[4]{};

    unsigned char blendIndices_[4]{};
};


struct Decal
{

    Decal() :
        timer_(0.0f),
        timeToLive_(0.0f)
    {
    }


    void AddVertex(const DecalVertex& vertex);

    void CalculateBoundingBox();


    float timer_;

    float timeToLive_;

    BoundingBox boundingBox_;

    PODVector<DecalVertex> vertices_;

    PODVector<unsigned short> indices_;
};


class __attribute__((visibility("default"))) DecalSet : public Drawable
{
    public: using ClassName = DecalSet; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("DecalSet", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit DecalSet(Context* context);

    ~DecalSet() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnSetEnabled() override;

    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;


    void SetMaterial(Material* material);

    void SetMaxVertices(unsigned num);

    void SetMaxIndices(unsigned num);

    void SetOptimizeBufferSize(bool enable);

    bool AddDecal(Drawable* target, const Vector3& worldPosition, const Quaternion& worldRotation, float size, float aspectRatio,
        float depth, const Vector2& topLeftUV, const Vector2& bottomRightUV, float timeToLive = 0.0f, float normalCutoff = 0.1f,
        unsigned subGeometry = M_MAX_UNSIGNED);

    void RemoveDecals(unsigned num);

    void RemoveAllDecals();


    Material* GetMaterial() const;


    unsigned GetNumDecals() const { return decals_.Size(); }


    unsigned GetNumVertices() const { return numVertices_; }


    unsigned GetNumIndices() const { return numIndices_; }


    unsigned GetMaxVertices() const { return maxVertices_; }


    unsigned GetMaxIndices() const { return maxIndices_; }


    bool GetOptimizeBufferSize() const { return optimizeBufferSize_; }


    void SetMaterialAttr(const ResourceRef& value);

    void SetDecalsAttr(const PODVector<unsigned char>& value);

    ResourceRef GetMaterialAttr() const;

    PODVector<unsigned char> GetDecalsAttr() const;

protected:

    void OnWorldBoundingBoxUpdate() override;

    void OnMarkedDirty(Node* node) override;

private:

    void GetFaces(Vector<PODVector<DecalVertex> >& faces, Drawable* target, unsigned batchIndex, const Frustum& frustum,
        const Vector3& decalNormal, float normalCutoff);

    void GetFace
        (Vector<PODVector<DecalVertex> >& faces, Drawable* target, unsigned batchIndex, unsigned i0, unsigned i1, unsigned i2,
            const unsigned char* positionData, const unsigned char* normalData, const unsigned char* skinningData,
            unsigned positionStride, unsigned normalStride, unsigned skinningStride, const Frustum& frustum,
            const Vector3& decalNormal, float normalCutoff);

    bool GetBones(Drawable* target, unsigned batchIndex, const float* blendWeights, const unsigned char* blendIndices,
        unsigned char* newBlendIndices);

    void CalculateUVs
        (Decal& decal, const Matrix3x4& view, const Matrix4& projection, const Vector2& topLeftUV, const Vector2& bottomRightUV);

    void TransformVertices(Decal& decal, const Matrix3x4& transform);

    List<Decal>::Iterator RemoveDecal(List<Decal>::Iterator i);

    void MarkDecalsDirty();

    void CalculateBoundingBox();

    void UpdateBuffers();

    void UpdateSkinning();

    void UpdateBatch();

    void AssignBoneNodes();

    void UpdateEventSubscription(bool checkAllDecals);

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);


    SharedPtr<Geometry> geometry_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    SharedPtr<IndexBuffer> indexBuffer_;

    List<Decal> decals_;

    Vector<Bone> bones_;

    PODVector<Matrix3x4> skinMatrices_;

    unsigned numVertices_;

    unsigned numIndices_;

    unsigned maxVertices_;

    unsigned maxIndices_;

    bool optimizeBufferSize_;

    bool skinned_;

    bool bufferDirty_;

    bool boundingBoxDirty_;

    bool skinningDirty_;

    bool assignBonesPending_;

    bool subscribed_;
};

}

namespace Urho3D
{


static const Urho3D::StringHash E_BONEHIERARCHYCREATED(Urho3D::GetEventNameRegister().RegisterString("BoneHierarchyCreated")); namespace BoneHierarchyCreated
{
    static const Urho3D::StringHash P_NODE("Node");
}


static const Urho3D::StringHash E_ANIMATIONTRIGGER(Urho3D::GetEventNameRegister().RegisterString("AnimationTrigger")); namespace AnimationTrigger
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_ANIMATION("Animation");
    static const Urho3D::StringHash P_NAME("Name");
    static const Urho3D::StringHash P_TIME("Time");
    static const Urho3D::StringHash P_DATA("Data");
}


static const Urho3D::StringHash E_ANIMATIONFINISHED(Urho3D::GetEventNameRegister().RegisterString("AnimationFinished")); namespace AnimationFinished
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_ANIMATION("Animation");
    static const Urho3D::StringHash P_NAME("Name");
    static const Urho3D::StringHash P_LOOPED("Looped");
}


static const Urho3D::StringHash E_PARTICLEEFFECTFINISHED(Urho3D::GetEventNameRegister().RegisterString("ParticleEffectFinished")); namespace ParticleEffectFinished
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_EFFECT("Effect");
}


static const Urho3D::StringHash E_TERRAINCREATED(Urho3D::GetEventNameRegister().RegisterString("TerrainCreated")); namespace TerrainCreated
{
    static const Urho3D::StringHash P_NODE("Node");
}

}

namespace Urho3D
{

class IndexBuffer;
class Ray;
class Graphics;
class VertexBuffer;


class __attribute__((visibility("default"))) Geometry : public Object
{
    public: using ClassName = Geometry; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Geometry", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Geometry(Context* context);

    ~Geometry() override;


    bool SetNumVertexBuffers(unsigned num);

    bool SetVertexBuffer(unsigned index, VertexBuffer* buffer);

    void SetIndexBuffer(IndexBuffer* buffer);

    bool SetDrawRange(PrimitiveType type, unsigned indexStart, unsigned indexCount, bool getUsedVertexRange = true);

    bool SetDrawRange(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned vertexStart, unsigned vertexCount,
        bool checkIllegal = true);

    void SetLodDistance(float distance);

    void SetRawVertexData(const SharedArrayPtr<unsigned char>& data, const PODVector<VertexElement>& elements);

    void SetRawVertexData(const SharedArrayPtr<unsigned char>& data, unsigned elementMask);

    void SetRawIndexData(const SharedArrayPtr<unsigned char>& data, unsigned indexSize);

    void Draw(Graphics* graphics);


    const Vector<SharedPtr<VertexBuffer> >& GetVertexBuffers() const { return vertexBuffers_; }


    unsigned GetNumVertexBuffers() const { return vertexBuffers_.Size(); }


    VertexBuffer* GetVertexBuffer(unsigned index) const;


    IndexBuffer* GetIndexBuffer() const { return indexBuffer_; }


    PrimitiveType GetPrimitiveType() const { return primitiveType_; }


    unsigned GetIndexStart() const { return indexStart_; }


    unsigned GetIndexCount() const { return indexCount_; }


    unsigned GetVertexStart() const { return vertexStart_; }


    unsigned GetVertexCount() const { return vertexCount_; }


    float GetLodDistance() const { return lodDistance_; }


    unsigned short GetBufferHash() const;

    void GetRawData(const unsigned char*& vertexData, unsigned& vertexSize, const unsigned char*& indexData, unsigned& indexSize, const PODVector<VertexElement>*& elements) const;

    void GetRawDataShared(SharedArrayPtr<unsigned char>& vertexData, unsigned& vertexSize, SharedArrayPtr<unsigned char>& indexData,
        unsigned& indexSize, const PODVector<VertexElement>*& elements) const;

    float GetHitDistance(const Ray& ray, Vector3* outNormal = nullptr, Vector2* outUV = nullptr) const;

    bool IsInside(const Ray& ray) const;


    bool IsEmpty() const { return indexCount_ == 0 && vertexCount_ == 0; }

private:

    Vector<SharedPtr<VertexBuffer> > vertexBuffers_;

    SharedPtr<IndexBuffer> indexBuffer_;

    PrimitiveType primitiveType_;

    unsigned indexStart_;

    unsigned indexCount_;

    unsigned vertexStart_;

    unsigned vertexCount_;

    float lodDistance_;

    PODVector<VertexElement> rawElements_;

    SharedArrayPtr<unsigned char> rawVertexData_;

    SharedArrayPtr<unsigned char> rawIndexData_;

    unsigned rawVertexSize_;

    unsigned rawIndexSize_;
};

}
namespace Urho3D
{

class ConstantBuffer;
class Shader;


struct ShaderParameter
{

    ShaderParameter() = default;

    ShaderParameter(const String& name, unsigned glType, int location);

    ShaderParameter(ShaderType type, const String& name, unsigned offset, unsigned size, unsigned buffer);

    ShaderParameter(ShaderType type, const String& name, unsigned reg, unsigned regCount);


    ShaderType type_{};

    String name_{};

    union
    {

        unsigned offset_;

        int location_;

        unsigned register_;
    };

    union
    {

        unsigned size_;

        unsigned glType_;

        unsigned regCount_;
    };


    unsigned buffer_{};

    ConstantBuffer* bufferPtr_{};
};


class __attribute__((visibility("default"))) ShaderVariation : public RefCounted, public GPUObject
{
public:

    ShaderVariation(Shader* owner, ShaderType type);

    ~ShaderVariation() override;


    void OnDeviceLost() override;

    void Release() override;


    bool Create();

    void SetName(const String& name);

    void SetDefines(const String& defines);


    Shader* GetOwner() const;


    ShaderType GetShaderType() const { return type_; }


    const String& GetName() const { return name_; }


    String GetFullName() const { return name_ + "(" + defines_ + ")"; }


    bool HasParameter(StringHash param) const { return parameters_.Contains(param); }


    bool HasTextureUnit(TextureUnit unit) const { return useTextureUnits_[unit]; }


    const HashMap<StringHash, ShaderParameter>& GetParameters() const { return parameters_; }


    unsigned long long GetElementHash() const { return elementHash_; }


    const PODVector<unsigned char>& GetByteCode() const { return byteCode_; }


    const String& GetDefines() const { return defines_; }


    const String& GetCompilerOutput() const { return compilerOutput_; }


    const unsigned* GetConstantBufferSizes() const { return &constantBufferSizes_[0]; }


    const String& GetDefinesClipPlane() { return definesClipPlane_; }


    static const char* elementSemanticNames[];

private:

    bool LoadByteCode(const String& binaryShaderName);

    bool Compile();

    void ParseParameters(unsigned char* bufData, unsigned bufSize);

    void SaveByteCode(const String& binaryShaderName);

    void CalculateConstantBufferSizes();


    WeakPtr<Shader> owner_;

    ShaderType type_;

    unsigned long long elementHash_{};

    HashMap<StringHash, ShaderParameter> parameters_;

    bool useTextureUnits_[MAX_TEXTURE_UNITS]{};

    unsigned constantBufferSizes_[MAX_SHADER_PARAMETER_GROUPS]{};

    PODVector<unsigned char> byteCode_;

    String name_;

    String defines_;

    String definesClipPlane_;

    String compilerOutput_;
};

}




struct SDL_Surface;

namespace Urho3D
{

static const int COLOR_LUT_SIZE = 16;


enum CompressedFormat
{
    CF_NONE = 0,
    CF_RGBA,
    CF_DXT1,
    CF_DXT3,
    CF_DXT5,
    CF_ETC1,
    CF_PVRTC_RGB_2BPP,
    CF_PVRTC_RGBA_2BPP,
    CF_PVRTC_RGB_4BPP,
    CF_PVRTC_RGBA_4BPP,
};


struct CompressedLevel
{

    bool Decompress(unsigned char* dest);


    unsigned char* data_{};

    CompressedFormat format_{CF_NONE};

    int width_{};

    int height_{};

    int depth_{};

    unsigned blockSize_{};

    unsigned dataSize_{};

    unsigned rowSize_{};

    unsigned rows_{};
};


class __attribute__((visibility("default"))) Image : public Resource
{
    public: using ClassName = Image; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Image", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Image(Context* context);

    ~Image() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;

    bool SaveFile(const String& fileName) const override;


    bool SetSize(int width, int height, unsigned components);

    bool SetSize(int width, int height, int depth, unsigned components);

    void SetData(const unsigned char* pixelData);

    void SetPixel(int x, int y, const Color& color);

    void SetPixel(int x, int y, int z, const Color& color);

    void SetPixelInt(int x, int y, unsigned uintColor);

    void SetPixelInt(int x, int y, int z, unsigned uintColor);

    bool LoadColorLUT(Deserializer& source);

    bool FlipHorizontal();

    bool FlipVertical();

    bool Resize(int width, int height);

    void Clear(const Color& color);

    void ClearInt(unsigned uintColor);

    bool SaveBMP(const String& fileName) const;

    bool SavePNG(const String& fileName) const;

    bool SaveTGA(const String& fileName) const;

    bool SaveJPG(const String& fileName, int quality) const;

    bool SaveDDS(const String& fileName) const;

    bool SaveWEBP(const String& fileName, float compression = 0.0f) const;

    bool IsCubemap() const { return cubemap_; }

    bool IsArray() const { return array_; }

    bool IsSRGB() const { return sRGB_; }


    Color GetPixel(int x, int y) const;

    Color GetPixel(int x, int y, int z) const;

    unsigned GetPixelInt(int x, int y) const;

    unsigned GetPixelInt(int x, int y, int z) const;

    Color GetPixelBilinear(float x, float y) const;

    Color GetPixelTrilinear(float x, float y, float z) const;


    int GetWidth() const { return width_; }


    int GetHeight() const { return height_; }


    int GetDepth() const { return depth_; }


    unsigned GetComponents() const { return components_; }


    unsigned char* GetData() const { return data_; }


    bool IsCompressed() const { return compressedFormat_ != CF_NONE; }


    CompressedFormat GetCompressedFormat() const { return compressedFormat_; }


    unsigned GetNumCompressedLevels() const { return numCompressedLevels_; }


    SharedPtr<Image> GetNextLevel() const;

    SharedPtr<Image> GetNextSibling() const { return nextSibling_; }

    SharedPtr<Image> ConvertToRGBA() const;

    CompressedLevel GetCompressedLevel(unsigned index) const;

    Image* GetSubimage(const IntRect& rect) const;

    SDL_Surface* GetSDLSurface(const IntRect& rect = IntRect::ZERO) const;

    void PrecalculateLevels();

    bool HasAlphaChannel() const;

    bool SetSubimage(const Image* image, const IntRect& rect);

    void CleanupLevels();

    void GetLevels(PODVector<Image*>& levels);

    void GetLevels(PODVector<const Image*>& levels) const;

private:

    static unsigned char* GetImageData(Deserializer& source, int& width, int& height, unsigned& components);

    static void FreeImageData(unsigned char* pixelData);


    int width_{};

    int height_{};

    int depth_{};

    unsigned components_{};

    unsigned numCompressedLevels_{};

    bool cubemap_{};

    bool array_{};

    bool sRGB_{};

    CompressedFormat compressedFormat_{CF_NONE};

    SharedArrayPtr<unsigned char> data_;

    SharedPtr<Image> nextLevel_;

    SharedPtr<Image> nextSibling_;
};

}


struct SDL_Window;

namespace Urho3D
{

class ConstantBuffer;
class File;
class Image;
class IndexBuffer;
class GPUObject;
class GraphicsImpl;
class RenderSurface;
class Shader;
class ShaderPrecache;
class ShaderProgram;
class ShaderVariation;
class Texture;
class Texture2D;
class Texture2DArray;
class TextureCube;
class Vector3;
class Vector4;
class VertexBuffer;
class VertexDeclaration;

struct ShaderParameter;


struct ScratchBuffer
{
    ScratchBuffer() :
        size_(0),
        reserved_(false)
    {
    }


    SharedArrayPtr<unsigned char> data_;

    unsigned size_;

    bool reserved_;
};


class __attribute__((visibility("default"))) Graphics : public Object
{
    public: using ClassName = Graphics; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Graphics", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Graphics(Context* context);

    ~Graphics() override;


    void SetExternalWindow(void* window);

    void SetWindowTitle(const String& windowTitle);

    void SetWindowIcon(Image* windowIcon);

    void SetWindowPosition(const IntVector2& position);

    void SetWindowPosition(int x, int y);

    bool SetMode
        (int width, int height, bool fullscreen, bool borderless, bool resizable, bool highDPI, bool vsync, bool tripleBuffer,
            int multiSample, int monitor, int refreshRate);

    bool SetMode(int width, int height);

    void SetSRGB(bool enable);

    void SetDither(bool enable);

    void SetFlushGPU(bool enable);

    void SetForceGL2(bool enable);

    void SetOrientations(const String& orientations);

    bool ToggleFullscreen();

    void Close();

    bool TakeScreenShot(Image& destImage);

    bool BeginFrame();

    void EndFrame();

    void Clear(ClearTargetFlags flags, const Color& color = Color(0.0f, 0.0f, 0.0f, 0.0f), float depth = 1.0f, unsigned stencil = 0);

    bool ResolveToTexture(Texture2D* destination, const IntRect& viewport);

    bool ResolveToTexture(Texture2D* texture);

    bool ResolveToTexture(TextureCube* texture);

    void Draw(PrimitiveType type, unsigned vertexStart, unsigned vertexCount);

    void Draw(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned minVertex, unsigned vertexCount);

    void Draw(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned baseVertexIndex, unsigned minVertex, unsigned vertexCount);

    void DrawInstanced(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned minVertex, unsigned vertexCount,
        unsigned instanceCount);

    void DrawInstanced(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned baseVertexIndex, unsigned minVertex,
        unsigned vertexCount, unsigned instanceCount);

    void SetVertexBuffer(VertexBuffer* buffer);

    bool SetVertexBuffers(const PODVector<VertexBuffer*>& buffers, unsigned instanceOffset = 0);

    bool SetVertexBuffers(const Vector<SharedPtr<VertexBuffer> >& buffers, unsigned instanceOffset = 0);

    void SetIndexBuffer(IndexBuffer* buffer);

    void SetShaders(ShaderVariation* vs, ShaderVariation* ps);

    void SetShaderParameter(StringHash param, const float* data, unsigned count);

    void SetShaderParameter(StringHash param, float value);

    void SetShaderParameter(StringHash param, int value);

    void SetShaderParameter(StringHash param, bool value);

    void SetShaderParameter(StringHash param, const Color& color);

    void SetShaderParameter(StringHash param, const Vector2& vector);

    void SetShaderParameter(StringHash param, const Matrix3& matrix);

    void SetShaderParameter(StringHash param, const Vector3& vector);

    void SetShaderParameter(StringHash param, const Matrix4& matrix);

    void SetShaderParameter(StringHash param, const Vector4& vector);

    void SetShaderParameter(StringHash param, const Matrix3x4& matrix);

    void SetShaderParameter(StringHash param, const Variant& value);

    bool NeedParameterUpdate(ShaderParameterGroup group, const void* source);

    bool HasShaderParameter(StringHash param);

    bool HasTextureUnit(TextureUnit unit);

    void ClearParameterSource(ShaderParameterGroup group);

    void ClearParameterSources();

    void ClearTransformSources();

    void SetTexture(unsigned index, Texture* texture);

    void SetTextureForUpdate(Texture* texture);

    void SetTextureParametersDirty();

    void SetDefaultTextureFilterMode(TextureFilterMode mode);

    void SetDefaultTextureAnisotropy(unsigned level);

    void ResetRenderTargets();

    void ResetRenderTarget(unsigned index);

    void ResetDepthStencil();

    void SetRenderTarget(unsigned index, RenderSurface* renderTarget);

    void SetRenderTarget(unsigned index, Texture2D* texture);

    void SetDepthStencil(RenderSurface* depthStencil);

    void SetDepthStencil(Texture2D* texture);

    void SetViewport(const IntRect& rect);

    void SetBlendMode(BlendMode mode, bool alphaToCoverage = false);

    void SetColorWrite(bool enable);

    void SetCullMode(CullMode mode);

    void SetDepthBias(float constantBias, float slopeScaledBias);

    void SetDepthTest(CompareMode mode);

    void SetDepthWrite(bool enable);

    void SetFillMode(FillMode mode);

    void SetLineAntiAlias(bool enable);

    void SetScissorTest(bool enable, const Rect& rect = Rect::FULL, bool borderInclusive = true);

    void SetScissorTest(bool enable, const IntRect& rect);

    void SetStencilTest
        (bool enable, CompareMode mode = CMP_ALWAYS, StencilOp pass = OP_KEEP, StencilOp fail = OP_KEEP, StencilOp zFail = OP_KEEP,
            unsigned stencilRef = 0, unsigned compareMask = M_MAX_UNSIGNED, unsigned writeMask = M_MAX_UNSIGNED);

    void SetClipPlane(bool enable, const Plane& clipPlane = Plane::UP, const Matrix3x4& view = Matrix3x4::IDENTITY,
        const Matrix4& projection = Matrix4::IDENTITY);

    void BeginDumpShaders(const String& fileName);

    void EndDumpShaders();

    void PrecacheShaders(Deserializer& source);

    void SetShaderCacheDir(const String& path);


    bool IsInitialized() const;


    GraphicsImpl* GetImpl() const { return impl_; }


    void* GetExternalWindow() const { return externalWindow_; }


    SDL_Window* GetWindow() const { return window_; }


    const String& GetWindowTitle() const { return windowTitle_; }


    const String& GetApiName() const { return apiName_; }


    IntVector2 GetWindowPosition() const;


    int GetWidth() const { return width_; }


    int GetHeight() const { return height_; }


    int GetMultiSample() const { return multiSample_; }


    IntVector2 GetSize() const { return IntVector2(width_, height_); }


    bool GetFullscreen() const { return fullscreen_; }


    bool GetBorderless() const { return borderless_; }


    bool GetResizable() const { return resizable_; }


    bool GetHighDPI() const { return highDPI_; }


    bool GetVSync() const { return vsync_; }


    int GetRefreshRate() const { return refreshRate_; }


    int GetMonitor() const { return monitor_; }


    bool GetTripleBuffer() const { return tripleBuffer_; }


    bool GetSRGB() const { return sRGB_; }


    bool GetDither() const;


    bool GetFlushGPU() const { return flushGPU_; }


    bool GetForceGL2() const { return forceGL2_; }


    const String& GetOrientations() const { return orientations_; }


    bool IsDeviceLost() const;


    unsigned GetNumPrimitives() const { return numPrimitives_; }


    unsigned GetNumBatches() const { return numBatches_; }


    unsigned GetDummyColorFormat() const { return dummyColorFormat_; }


    unsigned GetShadowMapFormat() const { return shadowMapFormat_; }


    unsigned GetHiresShadowMapFormat() const { return hiresShadowMapFormat_; }


    bool GetInstancingSupport() const { return instancingSupport_; }


    bool GetLightPrepassSupport() const { return lightPrepassSupport_; }


    bool GetDeferredSupport() const { return deferredSupport_; }


    bool GetAnisotropySupport() const { return anisotropySupport_; }


    bool GetHardwareShadowSupport() const { return hardwareShadowSupport_; }


    bool GetReadableDepthSupport() const { return GetReadableDepthFormat() != 0; }


    bool GetSRGBSupport() const { return sRGBSupport_; }


    bool GetSRGBWriteSupport() const { return sRGBWriteSupport_; }


    PODVector<IntVector3> GetResolutions(int monitor) const;

    PODVector<int> GetMultiSampleLevels() const;

    IntVector2 GetDesktopResolution(int monitor) const;

    int GetMonitorCount() const;

    int GetCurrentMonitor() const;

    bool GetMaximized() const;

    Vector3 GetDisplayDPI(int monitor=0) const;


    unsigned GetFormat(CompressedFormat format) const;

    ShaderVariation* GetShader(ShaderType type, const String& name, const String& defines = String::EMPTY) const;

    ShaderVariation* GetShader(ShaderType type, const char* name, const char* defines) const;

    VertexBuffer* GetVertexBuffer(unsigned index) const;


    IndexBuffer* GetIndexBuffer() const { return indexBuffer_; }


    ShaderVariation* GetVertexShader() const { return vertexShader_; }


    ShaderVariation* GetPixelShader() const { return pixelShader_; }


    ShaderProgram* GetShaderProgram() const;


    TextureUnit GetTextureUnit(const String& name);

    const String& GetTextureUnitName(TextureUnit unit);

    Texture* GetTexture(unsigned index) const;


    TextureFilterMode GetDefaultTextureFilterMode() const { return defaultTextureFilterMode_; }


    unsigned GetDefaultTextureAnisotropy() const { return defaultTextureAnisotropy_; }


    RenderSurface* GetRenderTarget(unsigned index) const;


    RenderSurface* GetDepthStencil() const { return depthStencil_; }


    IntRect GetViewport() const { return viewport_; }


    BlendMode GetBlendMode() const { return blendMode_; }


    bool GetAlphaToCoverage() const { return alphaToCoverage_; }


    bool GetColorWrite() const { return colorWrite_; }


    CullMode GetCullMode() const { return cullMode_; }


    float GetDepthConstantBias() const { return constantDepthBias_; }


    float GetDepthSlopeScaledBias() const { return slopeScaledDepthBias_; }


    CompareMode GetDepthTest() const { return depthTestMode_; }


    bool GetDepthWrite() const { return depthWrite_; }


    FillMode GetFillMode() const { return fillMode_; }


    bool GetLineAntiAlias() const { return lineAntiAlias_; }


    bool GetStencilTest() const { return stencilTest_; }


    bool GetScissorTest() const { return scissorTest_; }


    const IntRect& GetScissorRect() const { return scissorRect_; }


    CompareMode GetStencilTestMode() const { return stencilTestMode_; }


    StencilOp GetStencilPass() const { return stencilPass_; }


    StencilOp GetStencilFail() const { return stencilFail_; }


    StencilOp GetStencilZFail() const { return stencilZFail_; }


    unsigned GetStencilRef() const { return stencilRef_; }


    unsigned GetStencilCompareMask() const { return stencilCompareMask_; }


    unsigned GetStencilWriteMask() const { return stencilWriteMask_; }


    bool GetUseClipPlane() const { return useClipPlane_; }


    const String& GetShaderCacheDir() const { return shaderCacheDir_; }


    IntVector2 GetRenderTargetDimensions() const;


    void OnWindowResized();

    void OnWindowMoved();

    void Restore();

    void Maximize();

    void Minimize();

    void Raise() const;

    void AddGPUObject(GPUObject* object);

    void RemoveGPUObject(GPUObject* object);

    void* ReserveScratchBuffer(unsigned size);

    void FreeScratchBuffer(void* buffer);

    void CleanupScratchBuffers();

    void CleanupShaderPrograms(ShaderVariation* variation);

    void CleanupRenderSurface(RenderSurface* surface);

    ConstantBuffer* GetOrCreateConstantBuffer(ShaderType type, unsigned index, unsigned size);

    void MarkFBODirty();

    void SetVBO(unsigned object);

    void SetUBO(unsigned object);


    static unsigned GetAlphaFormat();

    static unsigned GetLuminanceFormat();

    static unsigned GetLuminanceAlphaFormat();

    static unsigned GetRGBFormat();

    static unsigned GetRGBAFormat();

    static unsigned GetRGBA16Format();

    static unsigned GetRGBAFloat16Format();

    static unsigned GetRGBAFloat32Format();

    static unsigned GetRG16Format();

    static unsigned GetRGFloat16Format();

    static unsigned GetRGFloat32Format();

    static unsigned GetFloat16Format();

    static unsigned GetFloat32Format();

    static unsigned GetLinearDepthFormat();

    static unsigned GetDepthStencilFormat();

    static unsigned GetReadableDepthFormat();

    static unsigned GetFormat(const String& formatName);


    static const Vector2& GetPixelUVOffset() { return pixelUVOffset; }


    static unsigned GetMaxBones();

    static bool GetGL3Support();

private:

    bool OpenWindow(int width, int height, bool resizable, bool borderless);

    void CreateWindowIcon();

    void AdjustWindow(int& newWidth, int& newHeight, bool& newFullscreen, bool& newBorderless, int& monitor);

    bool CreateDevice(int width, int height, int multiSample);

    bool UpdateSwapChain(int width, int height);

    bool CreateInterface();

    bool CreateDevice(unsigned adapter, unsigned deviceType);

    void ResetDevice();

    void OnDeviceLost();

    void OnDeviceReset();

    void SetStreamFrequency(unsigned index, unsigned frequency);

    void ResetStreamFrequencies();

    void CheckFeatureSupport();

    void ResetCachedState();

    void SetTextureUnitMappings();

    void PrepareDraw();

    void CreateResolveTexture();

    void CleanupFramebuffers();

    unsigned CreateFramebuffer();

    void DeleteFramebuffer(unsigned fbo);

    void BindFramebuffer(unsigned fbo);

    void BindColorAttachment(unsigned index, unsigned target, unsigned object, bool isRenderBuffer);

    void BindDepthAttachment(unsigned object, bool isRenderBuffer);

    void BindStencilAttachment(unsigned object, bool isRenderBuffer);

    bool CheckFramebuffer();

    void SetVertexAttribDivisor(unsigned location, unsigned divisor);

    void Release(bool clearGPUObjects, bool closeWindow);


    Mutex gpuObjectMutex_;

    GraphicsImpl* impl_;

    SDL_Window* window_{};

    String windowTitle_;

    WeakPtr<Image> windowIcon_;

    void* externalWindow_{};

    int width_{};

    int height_{};

    IntVector2 position_;

    int multiSample_{1};

    bool fullscreen_{};

    bool borderless_{};

    bool resizable_{};

    bool highDPI_{};

    bool vsync_{};

    int refreshRate_{};

    int monitor_{};

    bool tripleBuffer_{};

    bool flushGPU_{};

    bool forceGL2_{};

    bool sRGB_{};

    bool lightPrepassSupport_{};

    bool deferredSupport_{};

    bool anisotropySupport_{};

    bool dxtTextureSupport_{};

    bool etcTextureSupport_{};

    bool pvrtcTextureSupport_{};

    bool hardwareShadowSupport_{};

    bool instancingSupport_{};

    bool sRGBSupport_{};

    bool sRGBWriteSupport_{};

    unsigned numPrimitives_{};

    unsigned numBatches_{};

    unsigned maxScratchBufferRequest_{};

    PODVector<GPUObject*> gpuObjects_;

    Vector<ScratchBuffer> scratchBuffers_;

    unsigned dummyColorFormat_{};

    unsigned shadowMapFormat_{};

    unsigned hiresShadowMapFormat_{};

    VertexBuffer* vertexBuffers_[MAX_VERTEX_STREAMS]{};

    IndexBuffer* indexBuffer_{};

    unsigned long long vertexDeclarationHash_{};

    unsigned primitiveType_{};

    ShaderVariation* vertexShader_{};

    ShaderVariation* pixelShader_{};

    Texture* textures_[MAX_TEXTURE_UNITS]{};

    HashMap<String, TextureUnit> textureUnits_;

    RenderSurface* renderTargets_[MAX_RENDERTARGETS]{};

    RenderSurface* depthStencil_{};

    IntRect viewport_;

    TextureFilterMode defaultTextureFilterMode_{FILTER_TRILINEAR};

    unsigned defaultTextureAnisotropy_{4};

    BlendMode blendMode_{};

    bool alphaToCoverage_{};

    bool colorWrite_{};

    CullMode cullMode_{};

    float constantDepthBias_{};

    float slopeScaledDepthBias_{};

    CompareMode depthTestMode_{};

    bool depthWrite_{};

    bool lineAntiAlias_{};

    FillMode fillMode_{};

    bool scissorTest_{};

    IntRect scissorRect_;

    CompareMode stencilTestMode_{};

    StencilOp stencilPass_{};

    StencilOp stencilFail_{};

    StencilOp stencilZFail_{};

    unsigned stencilRef_{};

    unsigned stencilCompareMask_{};

    unsigned stencilWriteMask_{};

    Vector4 clipPlane_;

    bool stencilTest_{};

    bool useClipPlane_{};

    const void* shaderParameterSources_[MAX_SHADER_PARAMETER_GROUPS]{};

    String shaderPath_;

    String shaderCacheDir_;

    String shaderExtension_;

    mutable WeakPtr<Shader> lastShader_;

    mutable String lastShaderName_;

    SharedPtr<ShaderPrecache> shaderPrecache_;

    String orientations_;

    String apiName_;


    static const Vector2 pixelUVOffset;

    static bool gl3Support;
};


void __attribute__((visibility("default"))) RegisterGraphicsLibrary(Context* context);

}

namespace Urho3D
{


static const Urho3D::StringHash E_SCREENMODE(Urho3D::GetEventNameRegister().RegisterString("ScreenMode")); namespace ScreenMode
{
    static const Urho3D::StringHash P_WIDTH("Width");
    static const Urho3D::StringHash P_HEIGHT("Height");
    static const Urho3D::StringHash P_FULLSCREEN("Fullscreen");
    static const Urho3D::StringHash P_BORDERLESS("Borderless");
    static const Urho3D::StringHash P_RESIZABLE("Resizable");
    static const Urho3D::StringHash P_HIGHDPI("HighDPI");
    static const Urho3D::StringHash P_MONITOR("Monitor");
    static const Urho3D::StringHash P_REFRESHRATE("RefreshRate");
}


static const Urho3D::StringHash E_WINDOWPOS(Urho3D::GetEventNameRegister().RegisterString("WindowPos")); namespace WindowPos
{
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
}


static const Urho3D::StringHash E_RENDERSURFACEUPDATE(Urho3D::GetEventNameRegister().RegisterString("RenderSurfaceUpdate")); namespace RenderSurfaceUpdate
{
}


static const Urho3D::StringHash E_BEGINRENDERING(Urho3D::GetEventNameRegister().RegisterString("BeginRendering")); namespace BeginRendering
{
}


static const Urho3D::StringHash E_ENDRENDERING(Urho3D::GetEventNameRegister().RegisterString("EndRendering")); namespace EndRendering
{
}


static const Urho3D::StringHash E_BEGINVIEWUPDATE(Urho3D::GetEventNameRegister().RegisterString("BeginViewUpdate")); namespace BeginViewUpdate
{
    static const Urho3D::StringHash P_VIEW("View");
    static const Urho3D::StringHash P_TEXTURE("Texture");
    static const Urho3D::StringHash P_SURFACE("Surface");
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_CAMERA("Camera");
}


static const Urho3D::StringHash E_ENDVIEWUPDATE(Urho3D::GetEventNameRegister().RegisterString("EndViewUpdate")); namespace EndViewUpdate
{
    static const Urho3D::StringHash P_VIEW("View");
    static const Urho3D::StringHash P_TEXTURE("Texture");
    static const Urho3D::StringHash P_SURFACE("Surface");
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_CAMERA("Camera");
}


static const Urho3D::StringHash E_BEGINVIEWRENDER(Urho3D::GetEventNameRegister().RegisterString("BeginViewRender")); namespace BeginViewRender
{
    static const Urho3D::StringHash P_VIEW("View");
    static const Urho3D::StringHash P_TEXTURE("Texture");
    static const Urho3D::StringHash P_SURFACE("Surface");
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_CAMERA("Camera");
}


static const Urho3D::StringHash E_VIEWBUFFERSREADY(Urho3D::GetEventNameRegister().RegisterString("ViewBuffersReady")); namespace ViewBuffersReady
{
    static const Urho3D::StringHash P_VIEW("View");
    static const Urho3D::StringHash P_TEXTURE("Texture");
    static const Urho3D::StringHash P_SURFACE("Surface");
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_CAMERA("Camera");
}


static const Urho3D::StringHash E_VIEWGLOBALSHADERPARAMETERS(Urho3D::GetEventNameRegister().RegisterString("ViewGlobalShaderParameters")); namespace ViewGlobalShaderParameters
{
    static const Urho3D::StringHash P_VIEW("View");
    static const Urho3D::StringHash P_TEXTURE("Texture");
    static const Urho3D::StringHash P_SURFACE("Surface");
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_CAMERA("Camera");
}


static const Urho3D::StringHash E_ENDVIEWRENDER(Urho3D::GetEventNameRegister().RegisterString("EndViewRender")); namespace EndViewRender
{
    static const Urho3D::StringHash P_VIEW("View");
    static const Urho3D::StringHash P_TEXTURE("Texture");
    static const Urho3D::StringHash P_SURFACE("Surface");
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_CAMERA("Camera");
}


static const Urho3D::StringHash E_ENDALLVIEWSRENDER(Urho3D::GetEventNameRegister().RegisterString("EndAllViewsRender")); namespace EndAllViewsRender
{
}


static const Urho3D::StringHash E_RENDERPATHEVENT(Urho3D::GetEventNameRegister().RegisterString("RenderPathEvent")); namespace RenderPathEvent
{
    static const Urho3D::StringHash P_NAME("Name");
}


static const Urho3D::StringHash E_DEVICELOST(Urho3D::GetEventNameRegister().RegisterString("DeviceLost")); namespace DeviceLost
{
}


static const Urho3D::StringHash E_DEVICERESET(Urho3D::GetEventNameRegister().RegisterString("DeviceReset")); namespace DeviceReset
{
}

}
namespace Urho3D
{


class __attribute__((visibility("default"))) IndexBuffer : public Object, public GPUObject
{
    public: using ClassName = IndexBuffer; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("IndexBuffer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit IndexBuffer(Context* context, bool forceHeadless = false);

    ~IndexBuffer() override;


    void OnDeviceLost() override;

    void OnDeviceReset() override;

    void Release() override;


    void SetShadowed(bool enable);

    bool SetSize(unsigned indexCount, bool largeIndices, bool dynamic = false);

    bool SetData(const void* data);

    bool SetDataRange(const void* data, unsigned start, unsigned count, bool discard = false);

    void* Lock(unsigned start, unsigned count, bool discard = false);

    void Unlock();


    bool IsShadowed() const { return shadowed_; }


    bool IsDynamic() const { return dynamic_; }


    bool IsLocked() const { return lockState_ != LOCK_NONE; }


    unsigned GetIndexCount() const { return indexCount_; }


    unsigned GetIndexSize() const { return indexSize_; }


    bool GetUsedVertexRange(unsigned start, unsigned count, unsigned& minVertex, unsigned& vertexCount);


    unsigned char* GetShadowData() const { return shadowData_.Get(); }


    SharedArrayPtr<unsigned char> GetShadowDataShared() const { return shadowData_; }

private:

    bool Create();

    bool UpdateToGPU();

    void* MapBuffer(unsigned start, unsigned count, bool discard);

    void UnmapBuffer();


    SharedArrayPtr<unsigned char> shadowData_;

    unsigned indexCount_;

    unsigned indexSize_;

    LockState lockState_;

    unsigned lockStart_;

    unsigned lockCount_;

    void* lockScratchData_;

    bool dynamic_;

    bool shadowed_;

    bool discardLock_;
};

}



namespace Urho3D
{

class BoundingBox;
class Camera;
class IndexBuffer;
class IntRect;
class VertexBuffer;
struct Edge;
struct Gradients;


struct DepthValue
{

    int min_;

    int max_;
};


struct OcclusionBufferData
{

    SharedArrayPtr<int> dataWithSafety_;

    int* data_;

    bool used_;
};


struct OcclusionBatch
{

    Matrix3x4 model_;

    const void* vertexData_;

    unsigned vertexSize_;

    const void* indexData_;

    unsigned indexSize_;

    unsigned drawStart_;

    unsigned drawCount_;
};

static const int OCCLUSION_MIN_SIZE = 8;
static const int OCCLUSION_DEFAULT_MAX_TRIANGLES = 5000;
static const float OCCLUSION_RELATIVE_BIAS = 0.00001f;
static const int OCCLUSION_FIXED_BIAS = 16;
static const float OCCLUSION_X_SCALE = 65536.0f;
static const float OCCLUSION_Z_SCALE = 16777216.0f;


class __attribute__((visibility("default"))) OcclusionBuffer : public Object
{
    public: using ClassName = OcclusionBuffer; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("OcclusionBuffer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit OcclusionBuffer(Context* context);

    ~OcclusionBuffer() override;


    bool SetSize(int width, int height, bool threaded);

    void SetView(Camera* camera);

    void SetMaxTriangles(unsigned triangles);

    void SetCullMode(CullMode mode);

    void Reset();

    void Clear();

    bool AddTriangles(const Matrix3x4& model, const void* vertexData, unsigned vertexSize, unsigned vertexStart, unsigned vertexCount);

    bool AddTriangles(const Matrix3x4& model, const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize,
        unsigned indexStart, unsigned indexCount);

    void DrawTriangles();

    void BuildDepthHierarchy();

    void ResetUseTimer();


    int* GetBuffer() const { return buffers_.Size() ? buffers_[0].data_ : nullptr; }


    const Matrix3x4& GetView() const { return view_; }


    const Matrix4& GetProjection() const { return projection_; }


    int GetWidth() const { return width_; }


    int GetHeight() const { return height_; }


    unsigned GetNumTriangles() const { return numTriangles_; }


    unsigned GetMaxTriangles() const { return maxTriangles_; }


    CullMode GetCullMode() const { return cullMode_; }


    bool IsThreaded() const { return buffers_.Size() > 1; }


    bool IsVisible(const BoundingBox& worldSpaceBox) const;

    unsigned GetUseTimer();


    void DrawBatch(const OcclusionBatch& batch, unsigned threadIndex);

private:

    inline Vector4 ModelTransform(const Matrix4& transform, const Vector3& vertex) const;

    inline Vector3 ViewportTransform(const Vector4& vertex) const;

    inline Vector4 ClipEdge(const Vector4& v0, const Vector4& v1, float d0, float d1) const;

    inline float SignedArea(const Vector3& v0, const Vector3& v1, const Vector3& v2) const;

    void CalculateViewport();

    void DrawTriangle(Vector4* vertices, unsigned threadIndex);

    void ClipVertices(const Vector4& plane, Vector4* vertices, bool* triangles, unsigned& numTriangles);

    void DrawTriangle2D(const Vector3* vertices, bool clockwise, unsigned threadIndex);

    void ClearBuffer(unsigned threadIndex);

    void MergeBuffers();


    Vector<OcclusionBufferData> buffers_;

    Vector<SharedArrayPtr<DepthValue> > mipBuffers_;

    PODVector<OcclusionBatch> batches_;

    int width_{};

    int height_{};

    unsigned numTriangles_{};

    unsigned maxTriangles_{OCCLUSION_DEFAULT_MAX_TRIANGLES};

    CullMode cullMode_{CULL_CCW};

    bool depthHierarchyDirty_{true};

    bool reverseCulling_{};

    Matrix3x4 view_;

    Matrix4 projection_;

    Matrix4 viewProj_;

    Timer useTimer_;

    float nearClip_{};

    float farClip_{};

    float scaleX_{};

    float scaleY_{};

    float offsetX_{};

    float offsetY_{};

    float projOffsetScaleX_{};

    float projOffsetScaleY_{};
};

}
namespace Urho3D
{

class Drawable;
class Node;


class __attribute__((visibility("default"))) OctreeQuery
{
public:

    OctreeQuery(PODVector<Drawable*>& result, unsigned char drawableFlags, unsigned viewMask) :
        result_(result),
        drawableFlags_(drawableFlags),
        viewMask_(viewMask)
    {
    }


    virtual ~OctreeQuery() = default;


    OctreeQuery(const OctreeQuery& rhs) = delete;

    OctreeQuery& operator =(const OctreeQuery& rhs) = delete;


    virtual Intersection TestOctant(const BoundingBox& box, bool inside) = 0;

    virtual void TestDrawables(Drawable** start, Drawable** end, bool inside) = 0;


    PODVector<Drawable*>& result_;

    unsigned char drawableFlags_;

    unsigned viewMask_;
};


class __attribute__((visibility("default"))) PointOctreeQuery : public OctreeQuery
{
public:

    PointOctreeQuery(PODVector<Drawable*>& result, const Vector3& point, unsigned char drawableFlags = DRAWABLE_ANY,
        unsigned viewMask = DEFAULT_VIEWMASK) :
        OctreeQuery(result, drawableFlags, viewMask),
        point_(point)
    {
    }


    Intersection TestOctant(const BoundingBox& box, bool inside) override;

    void TestDrawables(Drawable** start, Drawable** end, bool inside) override;


    Vector3 point_;
};


class __attribute__((visibility("default"))) SphereOctreeQuery : public OctreeQuery
{
public:

    SphereOctreeQuery(PODVector<Drawable*>& result, const Sphere& sphere, unsigned char drawableFlags = DRAWABLE_ANY,
        unsigned viewMask = DEFAULT_VIEWMASK) :
        OctreeQuery(result, drawableFlags, viewMask),
        sphere_(sphere)
    {
    }


    Intersection TestOctant(const BoundingBox& box, bool inside) override;

    void TestDrawables(Drawable** start, Drawable** end, bool inside) override;


    Sphere sphere_;
};


class __attribute__((visibility("default"))) BoxOctreeQuery : public OctreeQuery
{
public:

    BoxOctreeQuery(PODVector<Drawable*>& result, const BoundingBox& box, unsigned char drawableFlags = DRAWABLE_ANY,
        unsigned viewMask = DEFAULT_VIEWMASK) :
        OctreeQuery(result, drawableFlags, viewMask),
        box_(box)
    {
    }


    Intersection TestOctant(const BoundingBox& box, bool inside) override;

    void TestDrawables(Drawable** start, Drawable** end, bool inside) override;


    BoundingBox box_;
};


class __attribute__((visibility("default"))) FrustumOctreeQuery : public OctreeQuery
{
public:

    FrustumOctreeQuery(PODVector<Drawable*>& result, const Frustum& frustum, unsigned char drawableFlags = DRAWABLE_ANY,
        unsigned viewMask = DEFAULT_VIEWMASK) :
        OctreeQuery(result, drawableFlags, viewMask),
        frustum_(frustum)
    {
    }


    Intersection TestOctant(const BoundingBox& box, bool inside) override;

    void TestDrawables(Drawable** start, Drawable** end, bool inside) override;


    Frustum frustum_;
};


struct __attribute__((visibility("default"))) OctreeQueryResult
{

    OctreeQueryResult() :
        drawable_(nullptr),
        node_(nullptr)
    {
    }


    bool operator !=(const OctreeQueryResult& rhs) const { return drawable_ != rhs.drawable_ || node_ != rhs.node_; }


    Drawable* drawable_;

    Node* node_;
};


enum RayQueryLevel
{
    RAY_AABB = 0,
    RAY_OBB,
    RAY_TRIANGLE,
    RAY_TRIANGLE_UV
};


struct __attribute__((visibility("default"))) RayQueryResult
{

    RayQueryResult() :
        drawable_(nullptr),
        node_(nullptr)
    {
    }


    bool operator !=(const RayQueryResult& rhs) const
    {
        return position_ != rhs.position_ ||
               normal_ != rhs.normal_ ||
               textureUV_ != rhs.textureUV_ ||
               distance_ != rhs.distance_ ||
               drawable_ != rhs.drawable_ ||
               node_ != rhs.node_ ||
               subObject_ != rhs.subObject_;
    }


    Vector3 position_;

    Vector3 normal_;

    Vector2 textureUV_;

    float distance_{};

    Drawable* drawable_;

    Node* node_;

    unsigned subObject_{};
};


class __attribute__((visibility("default"))) RayOctreeQuery
{
public:

    RayOctreeQuery(PODVector<RayQueryResult>& result, const Ray& ray, RayQueryLevel level = RAY_TRIANGLE,
        float maxDistance = M_INFINITY, unsigned char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK) :
        result_(result),
        ray_(ray),
        drawableFlags_(drawableFlags),
        viewMask_(viewMask),
        maxDistance_(maxDistance),
        level_(level)
    {
    }


    RayOctreeQuery(const RayOctreeQuery& rhs) = delete;

    RayOctreeQuery& operator =(const RayOctreeQuery& rhs) = delete;


    PODVector<RayQueryResult>& result_;

    Ray ray_;

    unsigned char drawableFlags_;

    unsigned viewMask_;

    float maxDistance_;

    RayQueryLevel level_;
};

class __attribute__((visibility("default"))) AllContentOctreeQuery : public OctreeQuery
{
public:

    AllContentOctreeQuery(PODVector<Drawable*>& result, unsigned char drawableFlags, unsigned viewMask) :
        OctreeQuery(result, drawableFlags, viewMask)
    {
    }


    Intersection TestOctant(const BoundingBox& box, bool inside) override;

    void TestDrawables(Drawable** start, Drawable** end, bool inside) override;
};

}


namespace Urho3D
{

class Octree;

static const int NUM_OCTANTS = 8;
static const unsigned ROOT_INDEX = M_MAX_UNSIGNED;


class __attribute__((visibility("default"))) Octant
{
public:

    Octant(const BoundingBox& box, unsigned level, Octant* parent, Octree* root, unsigned index = ROOT_INDEX);

    virtual ~Octant();


    Octant* GetOrCreateChild(unsigned index);

    void DeleteChild(unsigned index);

    void InsertDrawable(Drawable* drawable);

    bool CheckDrawableFit(const BoundingBox& box) const;


    void AddDrawable(Drawable* drawable)
    {
        drawable->SetOctant(this);
        drawables_.Push(drawable);
        IncDrawableCount();
    }


    void RemoveDrawable(Drawable* drawable, bool resetOctant = true)
    {
        if (drawables_.Remove(drawable))
        {
            if (resetOctant)
                drawable->SetOctant(nullptr);
            DecDrawableCount();
        }
    }


    const BoundingBox& GetWorldBoundingBox() const { return worldBoundingBox_; }


    const BoundingBox& GetCullingBox() const { return cullingBox_; }


    unsigned GetLevel() const { return level_; }


    Octant* GetParent() const { return parent_; }


    Octree* GetRoot() const { return root_; }


    unsigned GetNumDrawables() const { return numDrawables_; }


    bool IsEmpty() { return numDrawables_ == 0; }


    void ResetRoot();

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest);

protected:

    void Initialize(const BoundingBox& box);

    void GetDrawablesInternal(OctreeQuery& query, bool inside) const;

    void GetDrawablesInternal(RayOctreeQuery& query) const;

    void GetDrawablesOnlyInternal(RayOctreeQuery& query, PODVector<Drawable*>& drawables) const;


    void IncDrawableCount()
    {
        ++numDrawables_;
        if (parent_)
            parent_->IncDrawableCount();
    }


    void DecDrawableCount()
    {
        Octant* parent = parent_;

        --numDrawables_;
        if (!numDrawables_)
        {
            if (parent)
                parent->DeleteChild(index_);
        }

        if (parent)
            parent->DecDrawableCount();
    }


    BoundingBox worldBoundingBox_;

    BoundingBox cullingBox_;

    PODVector<Drawable*> drawables_;

    Octant* children_[NUM_OCTANTS]{};

    Vector3 center_;

    Vector3 halfSize_;

    unsigned level_;

    unsigned numDrawables_{};

    Octant* parent_;

    Octree* root_;

    unsigned index_;
};


class __attribute__((visibility("default"))) Octree : public Component, public Octant
{
    public: using ClassName = Octree; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Octree", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Octree(Context* context);

    ~Octree() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetSize(const BoundingBox& box, unsigned numLevels);

    void Update(const FrameInfo& frame);

    void AddManualDrawable(Drawable* drawable);

    void RemoveManualDrawable(Drawable* drawable);


    void GetDrawables(OctreeQuery& query) const;

    void Raycast(RayOctreeQuery& query) const;

    void RaycastSingle(RayOctreeQuery& query) const;


    unsigned GetNumLevels() const { return numLevels_; }


    void QueueUpdate(Drawable* drawable);

    void CancelUpdate(Drawable* drawable);

    void DrawDebugGeometry(bool depthTest);

private:

    void HandleRenderUpdate(StringHash eventType, VariantMap& eventData);

    void UpdateOctreeSize() { SetSize(worldBoundingBox_, numLevels_); }


    PODVector<Drawable*> drawableUpdates_;

    PODVector<Drawable*> threadedDrawableUpdates_;

    Mutex octreeMutex_;

    mutable PODVector<Drawable*> rayQueryDrawables_;

    unsigned numLevels_;
};

}

namespace Urho3D
{


enum EmitterType
{
    EMITTER_SPHERE = 0,
    EMITTER_BOX,
    EMITTER_SPHEREVOLUME,
    EMITTER_CYLINDER,
    EMITTER_RING
};


struct ColorFrame
{

    ColorFrame() :
        time_(0.0f)
    {
    }


    explicit ColorFrame(const Color& color) :
        color_(color),
        time_(0.0f)
    {
    }


    ColorFrame(const Color& color, float time) :
        color_(color),
        time_(time)
    {
    }


    Color Interpolate(const ColorFrame& next, float time) const
    {
        float timeInterval = next.time_ - time_;
        if (timeInterval > 0.0f)
        {
            float t = (time - time_) / timeInterval;
            return color_.Lerp(next.color_, t);
        }
        else
            return next.color_;
    }


    Color color_;

    float time_;
};


struct TextureFrame
{

    TextureFrame() :
        uv_(0.0f, 0.0f, 1.0f, 1.0f),
        time_(0.0f)
    {
    }


    Rect uv_;

    float time_;
};

static const unsigned DEFAULT_NUM_PARTICLES = 10;

class Material;
class XMLFile;
class XMLElement;


class __attribute__((visibility("default"))) ParticleEffect : public Resource
{
    public: using ClassName = ParticleEffect; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ParticleEffect", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ParticleEffect(Context* context);

    ~ParticleEffect() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    bool Save(Serializer& dest) const override;


    bool Save(XMLElement& dest) const;

    bool Load(const XMLElement& source);

    void SetMaterial(Material* material);

    void SetNumParticles(unsigned num);

    void SetUpdateInvisible(bool enable);

    void SetRelative(bool enable);

    void SetScaled(bool enable);

    void SetSorted(bool enable);

    void SetFixedScreenSize(bool enable);

    void SetAnimationLodBias(float lodBias);

    void SetEmitterType(EmitterType type);

    void SetEmitterSize(const Vector3& size);

    void SetMinDirection(const Vector3& direction);

    void SetMaxDirection(const Vector3& direction);

    void SetConstantForce(const Vector3& force);

    void SetDampingForce(float force);

    void SetActiveTime(float time);

    void SetInactiveTime(float time);

    void SetMinEmissionRate(float rate);

    void SetMaxEmissionRate(float rate);

    void SetMinParticleSize(const Vector2& size);

    void SetMaxParticleSize(const Vector2& size);

    void SetMinTimeToLive(float time);

    void SetMaxTimeToLive(float time);

    void SetMinVelocity(float velocity);

    void SetMaxVelocity(float velocity);

    void SetMinRotation(float rotation);

    void SetMaxRotation(float rotation);

    void SetMinRotationSpeed(float speed);

    void SetMaxRotationSpeed(float speed);

    void SetSizeAdd(float sizeAdd);

    void SetSizeMul(float sizeMul);

    void SetFaceCameraMode(FaceCameraMode mode);


    void AddColorTime(const Color& color, float time);

    void AddColorFrame(const ColorFrame& colorFrame);

    void RemoveColorFrame(unsigned index);

    void SetColorFrames(const Vector<ColorFrame>& colorFrames);

    void SetColorFrame(unsigned index, const ColorFrame& colorFrame);

    void SetNumColorFrames(unsigned number);

    void SortColorFrames();


    void AddTextureTime(const Rect& uv, float time);

    void AddTextureFrame(const TextureFrame& textureFrame);

    void RemoveTextureFrame(unsigned index);

    void SetTextureFrames(const Vector<TextureFrame>& textureFrames);

    void SetTextureFrame(unsigned index, const TextureFrame& textureFrame);

    void SetNumTextureFrames(unsigned number);

    void SortTextureFrames();

    SharedPtr<ParticleEffect> Clone(const String& cloneName = String::EMPTY) const;


    Material* GetMaterial() const { return material_; }


    unsigned GetNumParticles() const { return numParticles_; }


    bool GetUpdateInvisible() const { return updateInvisible_; }


    bool IsRelative() const { return relative_; }


    bool IsScaled() const { return scaled_; }


    bool IsSorted() const { return sorted_; }


    bool IsFixedScreenSize() const { return fixedScreenSize_; }


    float GetAnimationLodBias() const { return animationLodBias_; }


    EmitterType GetEmitterType() const { return emitterType_; }


    const Vector3& GetEmitterSize() const { return emitterSize_; }


    const Vector3& GetMinDirection() const { return directionMin_; }


    const Vector3& GetMaxDirection() const { return directionMax_; }


    const Vector3& GetConstantForce() const { return constantForce_; }


    float GetDampingForce() const { return dampingForce_; }


    float GetActiveTime() const { return activeTime_; }


    float GetInactiveTime() const { return inactiveTime_; }


    float GetMinEmissionRate() const { return emissionRateMin_; }


    float GetMaxEmissionRate() const { return emissionRateMax_; }


    const Vector2& GetMinParticleSize() const { return sizeMin_; }


    const Vector2& GetMaxParticleSize() const { return sizeMax_; }


    float GetMinTimeToLive() const { return timeToLiveMin_; }


    float GetMaxTimeToLive() const { return timeToLiveMax_; }


    float GetMinVelocity() const { return velocityMin_; }


    float GetMaxVelocity() const { return velocityMax_; }


    float GetMinRotation() const { return rotationMin_; }


    float GetMaxRotation() const { return rotationMax_; }


    float GetMinRotationSpeed() const { return rotationSpeedMin_; }


    float GetMaxRotationSpeed() const { return rotationSpeedMax_; }


    float GetSizeAdd() const { return sizeAdd_; }


    float GetSizeMul() const { return sizeMul_; }


    const Vector<ColorFrame>& GetColorFrames() const { return colorFrames_; }


    unsigned GetNumColorFrames() const { return colorFrames_.Size(); }


    const ColorFrame* GetColorFrame(unsigned index) const;


    const Vector<TextureFrame>& GetTextureFrames() const { return textureFrames_; }


    unsigned GetNumTextureFrames() const { return textureFrames_.Size(); }


    const TextureFrame* GetTextureFrame(unsigned index) const;


    FaceCameraMode GetFaceCameraMode() const { return faceCameraMode_; }


    Vector3 GetRandomDirection() const;

    Vector2 GetRandomSize() const;

    float GetRandomVelocity() const;

    float GetRandomTimeToLive() const;

    float GetRandomRotationSpeed() const;

    float GetRandomRotation() const;

private:

    void GetFloatMinMax(const XMLElement& element, float& minValue, float& maxValue);

    void GetVector2MinMax(const XMLElement& element, Vector2& minValue, Vector2& maxValue);

    void GetVector3MinMax(const XMLElement& element, Vector3& minValue, Vector3& maxValue);


    SharedPtr<Material> material_;

    unsigned numParticles_;

    bool updateInvisible_;

    bool relative_;

    bool scaled_;

    bool sorted_;

    bool fixedScreenSize_;

    float animationLodBias_;

    EmitterType emitterType_;

    Vector3 emitterSize_;

    Vector3 directionMin_;

    Vector3 directionMax_;

    Vector3 constantForce_;

    float dampingForce_;

    float activeTime_;

    float inactiveTime_;

    float emissionRateMin_;

    float emissionRateMax_;

    Vector2 sizeMin_;

    Vector2 sizeMax_;

    float timeToLiveMin_;

    float timeToLiveMax_;

    float velocityMin_;

    float velocityMax_;

    float rotationMin_;

    float rotationMax_;

    float rotationSpeedMin_;

    float rotationSpeedMax_;

    float sizeAdd_;

    float sizeMul_;

    Vector<ColorFrame> colorFrames_;

    Vector<TextureFrame> textureFrames_;

    String loadMaterialName_;

    FaceCameraMode faceCameraMode_;
};

}
namespace Urho3D
{

class ParticleEffect;


struct Particle
{

    Vector3 velocity_;

    Vector2 size_;

    float timer_;

    float timeToLive_;

    float scale_;

    float rotationSpeed_;

    unsigned colorIndex_;

    unsigned texIndex_;
};


class __attribute__((visibility("default"))) ParticleEmitter : public BillboardSet
{
    public: using ClassName = ParticleEmitter; using BaseClassName = BillboardSet; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ParticleEmitter", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ParticleEmitter(Context* context);

    ~ParticleEmitter() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;

    void Update(const FrameInfo& frame) override;


    void SetEffect(ParticleEffect* effect);

    void SetNumParticles(unsigned num);

    void SetEmitting(bool enable);

    void SetSerializeParticles(bool enable);

    void SetAutoRemoveMode(AutoRemoveMode mode);

    void ResetEmissionTimer();

    void RemoveAllParticles();

    void Reset();

    void ApplyEffect();


    ParticleEffect* GetEffect() const;


    unsigned GetNumParticles() const { return particles_.Size(); }


    bool IsEmitting() const { return emitting_; }


    bool GetSerializeParticles() const { return serializeParticles_; }


    AutoRemoveMode GetAutoRemoveMode() const { return autoRemove_; }


    void SetEffectAttr(const ResourceRef& value);

    ResourceRef GetEffectAttr() const;

    void SetParticlesAttr(const VariantVector& value);

    VariantVector GetParticlesAttr() const;

    VariantVector GetParticleBillboardsAttr() const;

protected:

    void OnSceneSet(Scene* scene) override;


    bool EmitNewParticle();

    unsigned GetFreeParticle() const;

    bool CheckActiveParticles() const;

private:

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);

    void HandleEffectReloadFinished(StringHash eventType, VariantMap& eventData);


    SharedPtr<ParticleEffect> effect_;

    PODVector<Particle> particles_;

    float periodTimer_;

    float emissionTimer_;

    float lastTimeStep_;

    unsigned lastUpdateFrameNumber_;

    bool emitting_;

    bool needUpdate_;

    bool serializeParticles_;

    bool sendFinishedEvent_;

    AutoRemoveMode autoRemove_;
};

}
namespace Urho3D
{

class XMLElement;
class XMLFile;


enum RenderCommandType
{
    CMD_NONE = 0,
    CMD_CLEAR,
    CMD_SCENEPASS,
    CMD_QUAD,
    CMD_FORWARDLIGHTS,
    CMD_LIGHTVOLUMES,
    CMD_RENDERUI,
    CMD_SENDEVENT
};


enum RenderCommandSortMode
{
    SORT_FRONTTOBACK = 0,
    SORT_BACKTOFRONT
};


enum RenderTargetSizeMode
{
    SIZE_ABSOLUTE = 0,
    SIZE_VIEWPORTDIVISOR,
    SIZE_VIEWPORTMULTIPLIER
};


struct __attribute__((visibility("default"))) RenderTargetInfo
{

    void Load(const XMLElement& element);


    String name_;

    String tag_;

    unsigned format_{};

    Vector2 size_;

    RenderTargetSizeMode sizeMode_{SIZE_ABSOLUTE};

    int multiSample_{1};

    bool autoResolve_{true};

    bool enabled_{true};

    bool cubemap_{};

    bool filtered_{};

    bool sRGB_{};

    bool persistent_{};
};


struct __attribute__((visibility("default"))) RenderPathCommand
{

    void Load(const XMLElement& element);

    void SetTextureName(TextureUnit unit, const String& name);

    void SetShaderParameter(const String& name, const Variant& value);

    void RemoveShaderParameter(const String& name);

    void SetNumOutputs(unsigned num);

    void SetOutput(unsigned index, const String& name, CubeMapFace face = FACE_POSITIVE_X);

    void SetOutputName(unsigned index, const String& name);

    void SetOutputFace(unsigned index, CubeMapFace face);

    void SetDepthStencilName(const String& name);


    const String& GetTextureName(TextureUnit unit) const;

    const Variant& GetShaderParameter(const String& name) const;


    unsigned GetNumOutputs() const { return outputs_.Size(); }


    const String& GetOutputName(unsigned index) const;

    CubeMapFace GetOutputFace(unsigned index) const;


    const String& GetDepthStencilName() const { return depthStencilName_; }


    String tag_;

    RenderCommandType type_{};

    RenderCommandSortMode sortMode_{};

    String pass_;

    unsigned passIndex_{};

    String basePath_;

    String metadata_;

    String vertexShaderName_;

    String pixelShaderName_;

    String vertexShaderDefines_;

    String pixelShaderDefines_;

    String textureNames_[MAX_TEXTURE_UNITS];

    HashMap<StringHash, Variant> shaderParameters_;

    Vector<Pair<String, CubeMapFace> > outputs_;

    String depthStencilName_;

    ClearTargetFlags clearFlags_{};

    Color clearColor_;

    float clearDepth_{};

    unsigned clearStencil_{};

    BlendMode blendMode_{BLEND_REPLACE};

    bool enabled_{true};

    bool useFogColor_{};

    bool markToStencil_{};

    bool useLitBase_{true};

    bool vertexLights_{};

    String eventName_;
};


class __attribute__((visibility("default"))) RenderPath : public RefCounted
{
public:

    RenderPath();

    ~RenderPath() override;


    SharedPtr<RenderPath> Clone();

    bool Load(XMLFile* file);

    bool Append(XMLFile* file);

    void SetEnabled(const String& tag, bool active);

    bool IsEnabled(const String& tag) const;

    bool IsAdded(const String& tag) const;

    void ToggleEnabled(const String& tag);

    void SetRenderTarget(unsigned index, const RenderTargetInfo& info);

    void AddRenderTarget(const RenderTargetInfo& info);

    void RemoveRenderTarget(unsigned index);

    void RemoveRenderTarget(const String& name);

    void RemoveRenderTargets(const String& tag);

    void SetCommand(unsigned index, const RenderPathCommand& command);

    void AddCommand(const RenderPathCommand& command);

    void InsertCommand(unsigned index, const RenderPathCommand& command);

    void RemoveCommand(unsigned index);

    void RemoveCommands(const String& tag);

    void SetShaderParameter(const String& name, const Variant& value);


    unsigned GetNumRenderTargets() const { return renderTargets_.Size(); }


    unsigned GetNumCommands() const { return commands_.Size(); }


    RenderPathCommand* GetCommand(unsigned index) { return index < commands_.Size() ? &commands_[index] : nullptr; }


    const Variant& GetShaderParameter(const String& name) const;


    Vector<RenderTargetInfo> renderTargets_;

    Vector<RenderPathCommand> commands_;
};

}
namespace Urho3D
{

class Camera;
class RenderPath;
class Scene;
class XMLFile;
class View;


class __attribute__((visibility("default"))) Viewport : public Object
{
    public: using ClassName = Viewport; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Viewport", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Viewport(Context* context);

    Viewport(Context* context, Scene* scene, Camera* camera, RenderPath* renderPath = nullptr);

    Viewport(Context* context, Scene* scene, Camera* camera, const IntRect& rect, RenderPath* renderPath = nullptr);

    ~Viewport() override;


    void SetScene(Scene* scene);

    void SetCamera(Camera* camera);

    void SetRect(const IntRect& rect);

    void SetRenderPath(RenderPath* renderPath);

    void SetRenderPath(XMLFile* file);

    void SetDrawDebug(bool enable);

    void SetCullCamera(Camera* camera);


    Scene* GetScene() const;

    Camera* GetCamera() const;

    View* GetView() const;


    const IntRect& GetRect() const { return rect_; }


    RenderPath* GetRenderPath() const;


    bool GetDrawDebug() const { return drawDebug_; }


    Camera* GetCullCamera() const;


    Ray GetScreenRay(int x, int y) const;

    IntVector2 WorldToScreenPoint(const Vector3& worldPos) const;

    Vector3 ScreenToWorldPoint(int x, int y, float depth) const;


    void AllocateView();

private:

    WeakPtr<Scene> scene_;

    WeakPtr<Camera> camera_;

    WeakPtr<Camera> cullCamera_;

    IntRect rect_;

    SharedPtr<RenderPath> renderPath_;

    SharedPtr<View> view_;

    bool drawDebug_;
};

}


namespace Urho3D
{

class Texture;


class __attribute__((visibility("default"))) RenderSurface : public RefCounted
{
    friend class Texture2D;
    friend class Texture2DArray;
    friend class TextureCube;

public:

    explicit RenderSurface(Texture* parentTexture);

    ~RenderSurface() override;


    void SetNumViewports(unsigned num);

    void SetViewport(unsigned index, Viewport* viewport);

    void SetUpdateMode(RenderSurfaceUpdateMode mode);

    void SetLinkedRenderTarget(RenderSurface* renderTarget);

    void SetLinkedDepthStencil(RenderSurface* depthStencil);

    void QueueUpdate();

    void Release();

    void OnDeviceLost();

    bool CreateRenderBuffer(unsigned width, unsigned height, unsigned format, int multiSample);


    int GetWidth() const;


    int GetHeight() const;


    TextureUsage GetUsage() const;


    int GetMultiSample() const;


    bool GetAutoResolve() const;


    unsigned GetNumViewports() const { return viewports_.Size(); }


    Viewport* GetViewport(unsigned index) const;


    RenderSurfaceUpdateMode GetUpdateMode() const { return updateMode_; }


    RenderSurface* GetLinkedRenderTarget() const { return linkedRenderTarget_; }


    RenderSurface* GetLinkedDepthStencil() const { return linkedDepthStencil_; }


    bool IsUpdateQueued() const { return updateQueued_; }


    void ResetUpdateQueued();


    Texture* GetParentTexture() const { return parentTexture_; }


    void* GetSurface() const { return surface_; }


    void* GetRenderTargetView() const { return renderTargetView_; }


    void* GetReadOnlyView() const { return readOnlyView_; }


    unsigned GetTarget() const { return target_; }


    unsigned GetRenderBuffer() const { return renderBuffer_; }


    bool IsResolveDirty() const { return resolveDirty_; }


    void SetResolveDirty(bool enable) { resolveDirty_ = enable; }

private:

    Texture* parentTexture_;

    union
    {

        void* surface_;

        void* renderTargetView_;

        unsigned renderBuffer_;
    };

    union
    {

        void* readOnlyView_;

        unsigned target_;
    };


    Vector<SharedPtr<Viewport> > viewports_;

    WeakPtr<RenderSurface> linkedRenderTarget_;

    WeakPtr<RenderSurface> linkedDepthStencil_;

    RenderSurfaceUpdateMode updateMode_{SURFACE_UPDATEVISIBLE};

    bool updateQueued_{};

    bool resolveDirty_{};
};

}
namespace Urho3D
{

class Geometry;
class Drawable;
class Light;
class Material;
class Pass;
class Technique;
class Octree;
class Graphics;
class RenderPath;
class RenderSurface;
class ResourceCache;
class Scene;
class Skeleton;
class OcclusionBuffer;
class Technique;
class Texture;
class Texture2D;
class TextureCube;
class View;
class Zone;
struct BatchQueue;

static const int SHADOW_MIN_PIXELS = 64;
static const int INSTANCING_BUFFER_DEFAULT_SIZE = 1024;


enum LightVSVariation
{
    LVS_DIR = 0,
    LVS_SPOT,
    LVS_POINT,
    LVS_SHADOW,
    LVS_SPOTSHADOW,
    LVS_POINTSHADOW,
    LVS_SHADOWNORMALOFFSET,
    LVS_SPOTSHADOWNORMALOFFSET,
    LVS_POINTSHADOWNORMALOFFSET,
    MAX_LIGHT_VS_VARIATIONS
};


enum VertexLightVSVariation
{
    VLVS_NOLIGHTS = 0,
    VLVS_1LIGHT,
    VLVS_2LIGHTS,
    VLVS_3LIGHTS,
    VLVS_4LIGHTS,
    MAX_VERTEXLIGHT_VS_VARIATIONS
};


enum LightPSVariation
{
    LPS_NONE = 0,
    LPS_SPOT,
    LPS_POINT,
    LPS_POINTMASK,
    LPS_SPEC,
    LPS_SPOTSPEC,
    LPS_POINTSPEC,
    LPS_POINTMASKSPEC,
    LPS_SHADOW,
    LPS_SPOTSHADOW,
    LPS_POINTSHADOW,
    LPS_POINTMASKSHADOW,
    LPS_SHADOWSPEC,
    LPS_SPOTSHADOWSPEC,
    LPS_POINTSHADOWSPEC,
    LPS_POINTMASKSHADOWSPEC,
    MAX_LIGHT_PS_VARIATIONS
};


enum DeferredLightVSVariation
{
    DLVS_NONE = 0,
    DLVS_DIR,
    DLVS_ORTHO,
    DLVS_ORTHODIR,
    MAX_DEFERRED_LIGHT_VS_VARIATIONS
};


enum DeferredLightPSVariation
{
    DLPS_NONE = 0,
    DLPS_SPOT,
    DLPS_POINT,
    DLPS_POINTMASK,
    DLPS_SPEC,
    DLPS_SPOTSPEC,
    DLPS_POINTSPEC,
    DLPS_POINTMASKSPEC,
    DLPS_SHADOW,
    DLPS_SPOTSHADOW,
    DLPS_POINTSHADOW,
    DLPS_POINTMASKSHADOW,
    DLPS_SHADOWSPEC,
    DLPS_SPOTSHADOWSPEC,
    DLPS_POINTSHADOWSPEC,
    DLPS_POINTMASKSHADOWSPEC,
    DLPS_SHADOWNORMALOFFSET,
    DLPS_SPOTSHADOWNORMALOFFSET,
    DLPS_POINTSHADOWNORMALOFFSET,
    DLPS_POINTMASKSHADOWNORMALOFFSET,
    DLPS_SHADOWSPECNORMALOFFSET,
    DLPS_SPOTSHADOWSPECNORMALOFFSET,
    DLPS_POINTSHADOWSPECNORMALOFFSET,
    DLPS_POINTMASKSHADOWSPECNORMALOFFSET,
    DLPS_ORTHO,
    DLPS_ORTHOSPOT,
    DLPS_ORTHOPOINT,
    DLPS_ORTHOPOINTMASK,
    DLPS_ORTHOSPEC,
    DLPS_ORTHOSPOTSPEC,
    DLPS_ORTHOPOINTSPEC,
    DLPS_ORTHOPOINTMASKSPEC,
    DLPS_ORTHOSHADOW,
    DLPS_ORTHOSPOTSHADOW,
    DLPS_ORTHOPOINTSHADOW,
    DLPS_ORTHOPOINTMASKSHADOW,
    DLPS_ORTHOSHADOWSPEC,
    DLPS_ORTHOSPOTSHADOWSPEC,
    DLPS_ORTHOPOINTSHADOWSPEC,
    DLPS_ORTHOPOINTMASKSHADOWSPEC,
    DLPS_ORTHOSHADOWNORMALOFFSET,
    DLPS_ORTHOSPOTSHADOWNORMALOFFSET,
    DLPS_ORTHOPOINTSHADOWNORMALOFFSET,
    DLPS_ORTHOPOINTMASKSHADOWNORMALOFFSET,
    DLPS_ORTHOSHADOWSPECNORMALOFFSET,
    DLPS_ORTHOSPOTSHADOWSPECNORMALOFFSET,
    DLPS_ORTHOPOINTSHADOWSPECNORMALOFFSET,
    DLPS_ORTHOPOINTMASKSHADOWSPECNORMALOFFSET,
    MAX_DEFERRED_LIGHT_PS_VARIATIONS
};


class __attribute__((visibility("default"))) Renderer : public Object
{
    public: using ClassName = Renderer; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Renderer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:
    using ShadowMapFilter = void(Object::*)(View* view, Texture2D* shadowMap, float blurScale);


    explicit Renderer(Context* context);

    ~Renderer() override;


    void SetNumViewports(unsigned num);

    void SetViewport(unsigned index, Viewport* viewport);

    void SetDefaultRenderPath(RenderPath* renderPath);

    void SetDefaultRenderPath(XMLFile* xmlFile);

    void SetDefaultTechnique(Technique* technique);

    void SetHDRRendering(bool enable);

    void SetSpecularLighting(bool enable);

    void SetTextureAnisotropy(int level);

    void SetTextureFilterMode(TextureFilterMode mode);

    void SetTextureQuality(MaterialQuality quality);

    void SetMaterialQuality(MaterialQuality quality);

    void SetDrawShadows(bool enable);

    void SetShadowMapSize(int size);

    void SetShadowQuality(ShadowQuality quality);

    void SetShadowSoftness(float shadowSoftness);

    void SetVSMShadowParameters(float minVariance, float lightBleedingReduction);

    void SetVSMMultiSample(int multiSample);

    void SetShadowMapFilter(Object* instance, ShadowMapFilter functionPtr);

    void SetReuseShadowMaps(bool enable);

    void SetMaxShadowMaps(int shadowMaps);

    void SetDynamicInstancing(bool enable);

    void SetNumExtraInstancingBufferElements(int elements);

    void SetMinInstances(int instances);

    void SetMaxSortedInstances(int instances);

    void SetMaxOccluderTriangles(int triangles);

    void SetOcclusionBufferSize(int size);

    void SetOccluderSizeThreshold(float screenSize);

    void SetThreadedOcclusion(bool enable);

    void SetMobileShadowBiasMul(float mul);

    void SetMobileShadowBiasAdd(float add);

    void SetMobileNormalOffsetMul(float mul);

    void ReloadShaders();


    void ApplyShadowMapFilter(View* view, Texture2D* shadowMap, float blurScale);


    unsigned GetNumViewports() const { return viewports_.Size(); }


    Viewport* GetViewport(unsigned index) const;

    Viewport* GetViewportForScene(Scene* scene, unsigned index) const;

    RenderPath* GetDefaultRenderPath() const;

    Technique* GetDefaultTechnique() const;


    bool GetHDRRendering() const { return hdrRendering_; }


    bool GetSpecularLighting() const { return specularLighting_; }


    bool GetDrawShadows() const { return drawShadows_; }


    int GetTextureAnisotropy() const { return textureAnisotropy_; }


    TextureFilterMode GetTextureFilterMode() const { return textureFilterMode_; }


    MaterialQuality GetTextureQuality() const { return textureQuality_; }


    MaterialQuality GetMaterialQuality() const { return materialQuality_; }


    int GetShadowMapSize() const { return shadowMapSize_; }


    ShadowQuality GetShadowQuality() const { return shadowQuality_; }


    float GetShadowSoftness() const { return shadowSoftness_; }


    Vector2 GetVSMShadowParameters() const { return vsmShadowParams_; };


    int GetVSMMultiSample() const { return vsmMultiSample_; }


    bool GetReuseShadowMaps() const { return reuseShadowMaps_; }


    int GetMaxShadowMaps() const { return maxShadowMaps_; }


    bool GetDynamicInstancing() const { return dynamicInstancing_; }


    int GetNumExtraInstancingBufferElements() const { return numExtraInstancingBufferElements_; };


    int GetMinInstances() const { return minInstances_; }


    int GetMaxSortedInstances() const { return maxSortedInstances_; }


    int GetMaxOccluderTriangles() const { return maxOccluderTriangles_; }


    int GetOcclusionBufferSize() const { return occlusionBufferSize_; }


    float GetOccluderSizeThreshold() const { return occluderSizeThreshold_; }


    bool GetThreadedOcclusion() const { return threadedOcclusion_; }


    float GetMobileShadowBiasMul() const { return mobileShadowBiasMul_; }


    float GetMobileShadowBiasAdd() const { return mobileShadowBiasAdd_; }


    float GetMobileNormalOffsetMul() const { return mobileNormalOffsetMul_; }


    unsigned GetNumViews() const { return views_.Size(); }


    unsigned GetNumPrimitives() const { return numPrimitives_; }


    unsigned GetNumBatches() const { return numBatches_; }


    unsigned GetNumGeometries(bool allViews = false) const;

    unsigned GetNumLights(bool allViews = false) const;

    unsigned GetNumShadowMaps(bool allViews = false) const;

    unsigned GetNumOccluders(bool allViews = false) const;


    Zone* GetDefaultZone() const { return defaultZone_; }


    Material* GetDefaultMaterial() const { return defaultMaterial_; }


    Texture2D* GetDefaultLightRamp() const { return defaultLightRamp_; }


    Texture2D* GetDefaultLightSpot() const { return defaultLightSpot_; }


    TextureCube* GetFaceSelectCubeMap() const { return faceSelectCubeMap_; }


    TextureCube* GetIndirectionCubeMap() const { return indirectionCubeMap_; }


    VertexBuffer* GetInstancingBuffer() const { return dynamicInstancing_ ? instancingBuffer_.Get() : nullptr; }


    const FrameInfo& GetFrameInfo() const { return frame_; }


    void Update(float timeStep);

    void Render();

    void DrawDebugGeometry(bool depthTest);

    void QueueRenderSurface(RenderSurface* renderTarget);

    void QueueViewport(RenderSurface* renderTarget, Viewport* viewport);


    Geometry* GetLightGeometry(Light* light);

    Geometry* GetQuadGeometry();

    Texture2D* GetShadowMap(Light* light, Camera* camera, unsigned viewWidth, unsigned viewHeight);

    Texture* GetScreenBuffer
        (int width, int height, unsigned format, int multiSample, bool autoResolve, bool cubemap, bool filtered, bool srgb, unsigned persistentKey = 0);

    RenderSurface* GetDepthStencil(int width, int height, int multiSample, bool autoResolve);

    OcclusionBuffer* GetOcclusionBuffer(Camera* camera);

    Camera* GetShadowCamera();

    void StorePreparedView(View* view, Camera* camera);

    View* GetPreparedView(Camera* camera);

    void SetBatchShaders(Batch& batch, Technique* tech, bool allowShadows, const BatchQueue& queue);

    void SetLightVolumeBatchShaders
        (Batch& batch, Camera* camera, const String& vsName, const String& psName, const String& vsDefines, const String& psDefines);

    void SetCullMode(CullMode mode, Camera* camera);

    bool ResizeInstancingBuffer(unsigned numInstances);

    void OptimizeLightByScissor(Light* light, Camera* camera);

    void OptimizeLightByStencil(Light* light, Camera* camera);

    const Rect& GetLightScissor(Light* light, Camera* camera);


    static View* GetActualView(View* view);

private:

    void Initialize();

    void LoadShaders();

    void LoadPassShaders(Pass* pass, Vector<SharedPtr<ShaderVariation> >& vertexShaders, Vector<SharedPtr<ShaderVariation> >& pixelShaders, const BatchQueue& queue);

    void ReleaseMaterialShaders();

    void ReloadTextures();

    void CreateGeometries();

    void CreateInstancingBuffer();

    void SetIndirectionTextureData();

    void UpdateQueuedViewport(unsigned index);

    void PrepareViewRender();

    void RemoveUnusedBuffers();

    void ResetShadowMapAllocations();

    void ResetScreenBufferAllocations();

    void ResetShadowMaps();

    void ResetBuffers();

    String GetShadowVariations() const;

    void HandleScreenMode(StringHash eventType, VariantMap& eventData);

    void HandleRenderUpdate(StringHash eventType, VariantMap& eventData);

    void BlurShadowMap(View* view, Texture2D* shadowMap, float blurScale);


    WeakPtr<Graphics> graphics_;

    SharedPtr<RenderPath> defaultRenderPath_;

    SharedPtr<Technique> defaultTechnique_;

    SharedPtr<Zone> defaultZone_;

    SharedPtr<Geometry> dirLightGeometry_;

    SharedPtr<Geometry> spotLightGeometry_;

    SharedPtr<Geometry> pointLightGeometry_;

    SharedPtr<VertexBuffer> instancingBuffer_;

    SharedPtr<Material> defaultMaterial_;

    SharedPtr<Texture2D> defaultLightRamp_;

    SharedPtr<Texture2D> defaultLightSpot_;

    SharedPtr<TextureCube> faceSelectCubeMap_;

    SharedPtr<TextureCube> indirectionCubeMap_;

    Vector<SharedPtr<Node> > shadowCameraNodes_;

    Vector<SharedPtr<OcclusionBuffer> > occlusionBuffers_;

    HashMap<int, Vector<SharedPtr<Texture2D> > > shadowMaps_;

    HashMap<int, SharedPtr<Texture2D> > colorShadowMaps_;

    HashMap<int, PODVector<Light*> > shadowMapAllocations_;

    Object* shadowMapFilterInstance_{};

    ShadowMapFilter shadowMapFilter_{};

    HashMap<unsigned long long, Vector<SharedPtr<Texture> > > screenBuffers_;

    HashMap<unsigned long long, unsigned> screenBufferAllocations_;

    HashMap<Pair<Light*, Camera*>, Rect> lightScissorCache_;

    Vector<SharedPtr<Viewport> > viewports_;

    Vector<Pair<WeakPtr<RenderSurface>, WeakPtr<Viewport> > > queuedViewports_;

    Vector<WeakPtr<View> > views_;

    HashMap<Camera*, WeakPtr<View> > preparedViews_;

    HashSet<Octree*> updatedOctrees_;

    HashSet<Technique*> shaderErrorDisplayed_;

    Mutex rendererMutex_;

    Vector<String> deferredLightPSVariations_;

    FrameInfo frame_;

    int textureAnisotropy_{4};

    TextureFilterMode textureFilterMode_{FILTER_TRILINEAR};

    MaterialQuality textureQuality_{QUALITY_HIGH};

    MaterialQuality materialQuality_{QUALITY_HIGH};

    int shadowMapSize_{1024};

    ShadowQuality shadowQuality_{SHADOWQUALITY_PCF_16BIT};

    float shadowSoftness_{1.0f};

    Vector2 vsmShadowParams_{0.0000001f, 0.9f};

    int vsmMultiSample_{1};

    int maxShadowMaps_{1};

    int minInstances_{2};

    int maxSortedInstances_{1000};

    int maxOccluderTriangles_{5000};

    int occlusionBufferSize_{256};

    float occluderSizeThreshold_{0.025f};

    float mobileShadowBiasMul_{1.0f};

    float mobileShadowBiasAdd_{};

    float mobileNormalOffsetMul_{1.0f};

    unsigned numOcclusionBuffers_{};

    unsigned numShadowCameras_{};

    unsigned numPrimitives_{};

    unsigned numBatches_{};

    unsigned shadersChangedFrameNumber_{M_MAX_UNSIGNED};

    unsigned char lightStencilValue_{};

    bool hdrRendering_{};

    bool specularLighting_{true};

    bool drawShadows_{true};

    bool reuseShadowMaps_{true};

    bool dynamicInstancing_{true};

    int numExtraInstancingBufferElements_{};

    bool threadedOcclusion_{};

    bool shadersDirty_{true};

    bool initialized_{};

    bool resetViews_{};
};

}
namespace Urho3D
{

enum TrailType
{
    TT_FACE_CAMERA = 0,
    TT_BONE
};

class IndexBuffer;
class VertexBuffer;


struct __attribute__((visibility("default"))) TrailPoint
{

    TrailPoint() = default;

    TrailPoint(const Vector3& position, const Vector3& forward);

    Vector3 position_;

    Vector3 forward_;

    Vector3 parentPos_;

    float elapsedLength_{};

    TrailPoint* next_{};

    float lifetime_{};

    float sortDistance_{};
};


class __attribute__((visibility("default"))) RibbonTrail : public Drawable
{
    public: using ClassName = RibbonTrail; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RibbonTrail", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit RibbonTrail(Context* context);

    ~RibbonTrail() override;

    static void RegisterObject(Context* context);

    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void OnSetEnabled() override;

    void Update(const FrameInfo &frame) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;


    void SetMaterial(Material* material);

    void SetMaterialAttr(const ResourceRef& value);

    void SetVertexDistance(float length);

    void SetWidth(float width);

    void SetStartColor(const Color& color);

    void SetEndColor(const Color& color);

    void SetStartScale(float startScale);

    void SetEndScale(float endScale);

    void SetTrailType(TrailType type);

    void SetBaseVelocity(const Vector3& baseVelocity);

    void SetSorted(bool enable);

    void SetLifetime(float time);

    void SetEmitting(bool emitting);

    void SetUpdateInvisible(bool enable);

    void SetTailColumn(unsigned tailColumn);

    void SetAnimationLodBias(float bias);

    void Commit();


    Material* GetMaterial() const;


    ResourceRef GetMaterialAttr() const;


    float GetVertexDistance() const { return vertexDistance_; }


    float GetWidth() const { return width_; }


    const Color& GetStartColor() const { return startColor_; }


    const Color& GetEndColor() const { return endColor_; }


    float GetStartScale() const { return startScale_; }


    float GetEndScale() const { return endScale_; }


    bool IsSorted() const { return sorted_; }


    float GetLifetime() const {return lifetime_;}


    float GetAnimationLodBias() const { return animationLodBias_; }


    TrailType GetTrailType() const { return trailType_; }


    const Vector3& GetBaseVelocity() const { return baseVelocity_; }


    unsigned GetTailColumn() const { return tailColumn_; }


    bool IsEmitting() const { return emitting_ ; }


    bool GetUpdateInvisible() const { return updateInvisible_; }

protected:

    void OnSceneSet(Scene* scene) override;

    void OnWorldBoundingBoxUpdate() override;

    void MarkPositionsDirty();

    PODVector<TrailPoint> points_;

    bool sorted_;

    float animationLodBias_;

    float animationLodTimer_;

    TrailType trailType_;

    Vector3 baseVelocity_;

private:

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);


    void UpdateBufferSize();

    void UpdateVertexBuffer(const FrameInfo& frame);

    void UpdateTail(float timeStep);

    SharedPtr<Geometry> geometry_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    SharedPtr<IndexBuffer> indexBuffer_;

    Matrix3x4 transforms_;

    bool bufferSizeDirty_;

    bool bufferDirty_;

    Vector3 previousPosition_;

    float vertexDistance_;

    float width_;

    unsigned numPoints_;

    Color startColor_;

    Color endColor_;

    float startScale_;

    float endScale_;

    float lastTimeStep_;

    float lifetime_;

    unsigned tailColumn_;

    unsigned lastUpdateFrameNumber_;

    bool needUpdate_;

    Vector3 previousOffset_;

    Vector<TrailPoint*> sortedPoints_;

    bool forceUpdate_;

    bool emitting_;

    bool updateInvisible_;


    TrailPoint endTail_;

    float startEndTailTime_;
};

}
namespace Urho3D
{

class ShaderVariation;


class __attribute__((visibility("default"))) Shader : public Resource
{
    public: using ClassName = Shader; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Shader", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Shader(Context* context);

    ~Shader() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;


    ShaderVariation* GetVariation(ShaderType type, const String& defines);

    ShaderVariation* GetVariation(ShaderType type, const char* defines);


    const String& GetSourceCode(ShaderType type) const { return type == VS ? vsSourceCode_ : psSourceCode_; }


    unsigned GetTimeStamp() const { return timeStamp_; }

private:

    bool ProcessSource(String& code, Deserializer& source);

    String NormalizeDefines(const String& defines);

    void RefreshMemoryUse();


    String vsSourceCode_;

    String psSourceCode_;

    HashMap<StringHash, SharedPtr<ShaderVariation> > vsVariations_;

    HashMap<StringHash, SharedPtr<ShaderVariation> > psVariations_;

    unsigned timeStamp_;

    unsigned numVariations_;
};

}
namespace Urho3D
{

class Graphics;
class ShaderVariation;


class __attribute__((visibility("default"))) ShaderPrecache : public Object
{
    public: using ClassName = ShaderPrecache; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ShaderPrecache", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    ShaderPrecache(Context* context, const String& fileName);

    ~ShaderPrecache() override;


    void StoreShaders(ShaderVariation* vs, ShaderVariation* ps);


    static void LoadShaders(Graphics* graphics, Deserializer& source);

private:

    String fileName_;

    XMLFile xmlFile_;

    HashSet<Pair<ShaderVariation*, ShaderVariation*> > usedPtrCombinations_;

    HashSet<String> usedCombinations_;
};

}
namespace Urho3D
{

class ConstantBuffer;
class Graphics;


class __attribute__((visibility("default"))) ShaderProgram : public RefCounted, public GPUObject
{
public:

    ShaderProgram(Graphics* graphics, ShaderVariation* vertexShader, ShaderVariation* pixelShader);

    ~ShaderProgram() override;


    void OnDeviceLost() override;

    void Release() override;


    bool Link();


    ShaderVariation* GetVertexShader() const;

    ShaderVariation* GetPixelShader() const;

    bool HasParameter(StringHash param) const;


    bool HasTextureUnit(TextureUnit unit) const { return useTextureUnits_[unit]; }


    const ShaderParameter* GetParameter(StringHash param) const;


    const String& GetLinkerOutput() const { return linkerOutput_; }


    const HashMap<Pair<unsigned char, unsigned char>, unsigned>& GetVertexAttributes() const { return vertexAttributes_; }


    unsigned GetUsedVertexAttributes() const { return usedVertexAttributes_; }


    const SharedPtr<ConstantBuffer>* GetConstantBuffers() const { return &constantBuffers_[0]; }


    bool NeedParameterUpdate(ShaderParameterGroup group, const void* source);

    void ClearParameterSource(ShaderParameterGroup group);


    static void ClearParameterSources();

    static void ClearGlobalParameterSource(ShaderParameterGroup group);

private:

    WeakPtr<ShaderVariation> vertexShader_;

    WeakPtr<ShaderVariation> pixelShader_;

    HashMap<StringHash, ShaderParameter> shaderParameters_;

    bool useTextureUnits_[MAX_TEXTURE_UNITS]{};

    HashMap<Pair<unsigned char, unsigned char>, unsigned> vertexAttributes_;

    unsigned usedVertexAttributes_{};

    SharedPtr<ConstantBuffer> constantBuffers_[MAX_SHADER_PARAMETER_GROUPS * 2];

    const void* parameterSources_[MAX_SHADER_PARAMETER_GROUPS]{};

    String linkerOutput_;

    unsigned frameNumber_{};


    static unsigned globalFrameNumber;

    static const void* globalParameterSources[MAX_SHADER_PARAMETER_GROUPS];
};

}


namespace Urho3D
{


class __attribute__((visibility("default"))) Skybox : public StaticModel
{
    public: using ClassName = Skybox; using BaseClassName = StaticModel; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Skybox", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Skybox(Context* context);

    ~Skybox() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

protected:

    void OnWorldBoundingBoxUpdate() override;


    HashMap<Camera*, Matrix3x4> customWorldTransforms_;

    unsigned lastFrame_;
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) StaticModelGroup : public StaticModel
{
    public: using ClassName = StaticModelGroup; using BaseClassName = StaticModel; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("StaticModelGroup", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit StaticModelGroup(Context* context);

    ~StaticModelGroup() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    unsigned GetNumOccluderTriangles() override;

    bool DrawOcclusion(OcclusionBuffer* buffer) override;


    void AddInstanceNode(Node* node);

    void RemoveInstanceNode(Node* node);

    void RemoveAllInstanceNodes();


    unsigned GetNumInstanceNodes() const { return instanceNodes_.Size(); }


    Node* GetInstanceNode(unsigned index) const;


    void SetNodeIDsAttr(const VariantVector& value);


    const VariantVector& GetNodeIDsAttr() const;

protected:

    void OnNodeSetEnabled(Node* node) override;

    void OnWorldBoundingBoxUpdate() override;

private:

    void UpdateNumTransforms();

    void UpdateNodeIDs() const;


    Vector<WeakPtr<Node> > instanceNodes_;

    PODVector<Matrix3x4> worldTransforms_;

    mutable VariantVector nodeIDsAttr_;

    unsigned numWorldTransforms_{};

    mutable bool nodesDirty_{};

    mutable bool nodeIDsDirty_{};
};

}
namespace Urho3D
{


__attribute__((visibility("default"))) void GenerateTangents
    (void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount,
        unsigned normalOffset, unsigned texCoordOffset, unsigned tangentOffset);

}
namespace Urho3D
{

class ShaderVariation;


enum PassLightingMode
{
    LIGHTING_UNLIT = 0,
    LIGHTING_PERVERTEX,
    LIGHTING_PERPIXEL
};


class __attribute__((visibility("default"))) Pass : public RefCounted
{
public:

    explicit Pass(const String& name);

    ~Pass() override;


    void SetBlendMode(BlendMode mode);

    void SetCullMode(CullMode mode);

    void SetDepthTestMode(CompareMode mode);

    void SetLightingMode(PassLightingMode mode);

    void SetDepthWrite(bool enable);

    void SetAlphaToCoverage(bool enable);

    void SetIsDesktop(bool enable);

    void SetVertexShader(const String& name);

    void SetPixelShader(const String& name);

    void SetVertexShaderDefines(const String& defines);

    void SetPixelShaderDefines(const String& defines);

    void SetVertexShaderDefineExcludes(const String& excludes);

    void SetPixelShaderDefineExcludes(const String& excludes);

    void ReleaseShaders();

    void MarkShadersLoaded(unsigned frameNumber);


    const String& GetName() const { return name_; }


    unsigned GetIndex() const { return index_; }


    BlendMode GetBlendMode() const { return blendMode_; }


    CullMode GetCullMode() const { return cullMode_; }


    CompareMode GetDepthTestMode() const { return depthTestMode_; }


    PassLightingMode GetLightingMode() const { return lightingMode_; }


    unsigned GetShadersLoadedFrameNumber() const { return shadersLoadedFrameNumber_; }


    bool GetDepthWrite() const { return depthWrite_; }


    bool GetAlphaToCoverage() const { return alphaToCoverage_; }


    bool IsDesktop() const { return isDesktop_; }


    const String& GetVertexShader() const { return vertexShaderName_; }


    const String& GetPixelShader() const { return pixelShaderName_; }


    const String& GetVertexShaderDefines() const { return vertexShaderDefines_; }


    const String& GetPixelShaderDefines() const { return pixelShaderDefines_; }


    const String& GetVertexShaderDefineExcludes() const { return vertexShaderDefineExcludes_; }


    const String& GetPixelShaderDefineExcludes() const { return pixelShaderDefineExcludes_; }


    Vector<SharedPtr<ShaderVariation> >& GetVertexShaders() { return vertexShaders_; }


    Vector<SharedPtr<ShaderVariation> >& GetPixelShaders() { return pixelShaders_; }


    Vector<SharedPtr<ShaderVariation> >& GetVertexShaders(const StringHash& extraDefinesHash);

    Vector<SharedPtr<ShaderVariation> >& GetPixelShaders(const StringHash& extraDefinesHash);

    String GetEffectiveVertexShaderDefines() const;

    String GetEffectivePixelShaderDefines() const;

private:

    unsigned index_;

    BlendMode blendMode_;

    CullMode cullMode_;

    CompareMode depthTestMode_;

    PassLightingMode lightingMode_;

    unsigned shadersLoadedFrameNumber_;

    bool depthWrite_;

    bool alphaToCoverage_;

    bool isDesktop_;

    String vertexShaderName_;

    String pixelShaderName_;

    String vertexShaderDefines_;

    String pixelShaderDefines_;

    String vertexShaderDefineExcludes_;

    String pixelShaderDefineExcludes_;

    Vector<SharedPtr<ShaderVariation> > vertexShaders_;

    Vector<SharedPtr<ShaderVariation> > pixelShaders_;

    HashMap<StringHash, Vector<SharedPtr<ShaderVariation> > > extraVertexShaders_;

    HashMap<StringHash, Vector<SharedPtr<ShaderVariation> > > extraPixelShaders_;

    String name_;
};


class __attribute__((visibility("default"))) Technique : public Resource
{
    public: using ClassName = Technique; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Technique", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class Renderer;

public:

    explicit Technique(Context* context);

    ~Technique() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;


    void SetIsDesktop(bool enable);

    Pass* CreatePass(const String& name);

    void RemovePass(const String& name);

    void ReleaseShaders();

    SharedPtr<Technique> Clone(const String& cloneName = String::EMPTY) const;


    bool IsDesktop() const { return isDesktop_; }


    bool IsSupported() const { return !isDesktop_ || desktopSupport_; }


    bool HasPass(unsigned passIndex) const { return passIndex < passes_.Size() && passes_[passIndex].Get() != nullptr; }


    bool HasPass(const String& name) const;


    Pass* GetPass(unsigned passIndex) const { return passIndex < passes_.Size() ? passes_[passIndex].Get() : nullptr; }


    Pass* GetPass(const String& name) const;


    Pass* GetSupportedPass(unsigned passIndex) const
    {
        Pass* pass = passIndex < passes_.Size() ? passes_[passIndex].Get() : nullptr;
        return pass && (!pass->IsDesktop() || desktopSupport_) ? pass : nullptr;
    }


    Pass* GetSupportedPass(const String& name) const;


    unsigned GetNumPasses() const;

    Vector<String> GetPassNames() const;

    PODVector<Pass*> GetPasses() const;


    SharedPtr<Technique> CloneWithDefines(const String& vsDefines, const String& psDefines);


    static unsigned GetPassIndex(const String& passName);


    static unsigned basePassIndex;

    static unsigned alphaPassIndex;

    static unsigned materialPassIndex;

    static unsigned deferredPassIndex;

    static unsigned lightPassIndex;

    static unsigned litBasePassIndex;

    static unsigned litAlphaPassIndex;

    static unsigned shadowPassIndex;

private:

    bool isDesktop_;

    bool desktopSupport_;

    Vector<SharedPtr<Pass> > passes_;

    HashMap<Pair<StringHash, StringHash>, SharedPtr<Technique> > cloneTechniques_;


    static HashMap<String, unsigned> passIndices;
};

}
namespace Urho3D
{

class Image;
class IndexBuffer;
class Material;
class Node;
class TerrainPatch;


class __attribute__((visibility("default"))) Terrain : public Component
{
    public: using ClassName = Terrain; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Terrain", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Terrain(Context* context);

    ~Terrain() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnSetEnabled() override;


    void SetPatchSize(int size);

    void SetSpacing(const Vector3& spacing);

    void SetMaxLodLevels(unsigned levels);

    void SetOcclusionLodLevel(unsigned level);

    void SetSmoothing(bool enable);

    bool SetHeightMap(Image* image);

    void SetMaterial(Material* material);

    void SetNorthNeighbor(Terrain* north);

    void SetSouthNeighbor(Terrain* south);

    void SetWestNeighbor(Terrain* west);

    void SetEastNeighbor(Terrain* east);

    void SetNeighbors(Terrain* north, Terrain* south, Terrain* west, Terrain* east);

    void SetDrawDistance(float distance);

    void SetShadowDistance(float distance);

    void SetLodBias(float bias);

    void SetViewMask(unsigned mask);

    void SetLightMask(unsigned mask);

    void SetShadowMask(unsigned mask);

    void SetZoneMask(unsigned mask);

    void SetMaxLights(unsigned num);

    void SetCastShadows(bool enable);

    void SetOccluder(bool enable);

    void SetOccludee(bool enable);

    void ApplyHeightMap();


    int GetPatchSize() const { return patchSize_; }


    const Vector3& GetSpacing() const { return spacing_; }


    const IntVector2& GetNumVertices() const { return numVertices_; }


    const IntVector2& GetNumPatches() const { return numPatches_; }


    unsigned GetMaxLodLevels() const { return maxLodLevels_; }


    unsigned GetOcclusionLodLevel() const { return occlusionLodLevel_; }


    bool GetSmoothing() const { return smoothing_; }


    Image* GetHeightMap() const;

    Material* GetMaterial() const;

    TerrainPatch* GetPatch(unsigned index) const;

    TerrainPatch* GetPatch(int x, int z) const;

    TerrainPatch* GetNeighborPatch(int x, int z) const;

    float GetHeight(const Vector3& worldPosition) const;

    Vector3 GetNormal(const Vector3& worldPosition) const;

    IntVector2 WorldToHeightMap(const Vector3& worldPosition) const;

    Vector3 HeightMapToWorld(const IntVector2& pixelPosition) const;


    Terrain* GetNorthNeighbor() const { return north_; }


    Terrain* GetSouthNeighbor() const { return south_; }


    Terrain* GetWestNeighbor() const { return west_; }


    Terrain* GetEastNeighbor() const { return east_; }


    SharedArrayPtr<float> GetHeightData() const { return heightData_; }


    float GetDrawDistance() const { return drawDistance_; }


    float GetShadowDistance() const { return shadowDistance_; }


    float GetLodBias() const { return lodBias_; }


    unsigned GetViewMask() const { return viewMask_; }


    unsigned GetLightMask() const { return lightMask_; }


    unsigned GetShadowMask() const { return shadowMask_; }


    unsigned GetZoneMask() const { return zoneMask_; }


    unsigned GetMaxLights() const { return maxLights_; }


    bool IsVisible() const { return visible_; }


    bool GetCastShadows() const { return castShadows_; }


    bool IsOccluder() const { return occluder_; }


    bool IsOccludee() const { return occludee_; }


    void CreatePatchGeometry(TerrainPatch* patch);

    void UpdatePatchLod(TerrainPatch* patch);

    void SetHeightMapAttr(const ResourceRef& value);

    void SetMaterialAttr(const ResourceRef& value);

    void SetPatchSizeAttr(int value);

    void SetMaxLodLevelsAttr(unsigned value);

    void SetOcclusionLodLevelAttr(unsigned value);

    ResourceRef GetHeightMapAttr() const;

    ResourceRef GetMaterialAttr() const;

private:

    void CreateGeometry();

    void CreateIndexData();

    float GetRawHeight(int x, int z) const;

    float GetSourceHeight(int x, int z) const;

    float GetLodHeight(int x, int z, unsigned lodLevel) const;

    Vector3 GetRawNormal(int x, int z) const;

    void CalculateLodErrors(TerrainPatch* patch);

    void SetPatchNeighbors(TerrainPatch* patch);

    bool SetHeightMapInternal(Image* image, bool recreateNow);

    void HandleHeightMapReloadFinished(StringHash eventType, VariantMap& eventData);

    void HandleNeighborTerrainCreated(StringHash eventType, VariantMap& eventData);

    void UpdateEdgePatchNeighbors();

    void MarkNeighborsDirty() { neighborsDirty_ = true; }

    void MarkTerrainDirty() { recreateTerrain_ = true; }


    SharedPtr<IndexBuffer> indexBuffer_;

    SharedPtr<Image> heightMap_;

    SharedArrayPtr<float> heightData_;

    SharedArrayPtr<float> sourceHeightData_;

    SharedPtr<Material> material_;

    Vector<WeakPtr<TerrainPatch> > patches_;

    PODVector<Pair<unsigned, unsigned> > drawRanges_;

    WeakPtr<Terrain> north_;

    WeakPtr<Terrain> south_;

    WeakPtr<Terrain> west_;

    WeakPtr<Terrain> east_;

    Vector3 spacing_;

    Vector3 lastSpacing_;

    Vector2 patchWorldOrigin_;

    Vector2 patchWorldSize_;

    IntVector2 numVertices_;

    IntVector2 lastNumVertices_;

    IntVector2 numPatches_;

    int patchSize_;

    int lastPatchSize_;

    unsigned numLodLevels_;

    unsigned maxLodLevels_;

    unsigned occlusionLodLevel_;

    bool smoothing_;

    bool visible_;

    bool castShadows_;

    bool occluder_;

    bool occludee_;

    unsigned viewMask_;

    unsigned lightMask_;

    unsigned shadowMask_;

    unsigned zoneMask_;

    float drawDistance_;

    float shadowDistance_;

    float lodBias_;

    unsigned maxLights_;

    unsigned northID_;

    unsigned southID_;

    unsigned westID_;

    unsigned eastID_;

    bool recreateTerrain_;

    bool neighborsDirty_;
};

}
namespace Urho3D
{

class Geometry;
class Terrain;
class VertexBuffer;


class __attribute__((visibility("default"))) TerrainPatch : public Drawable
{
    public: using ClassName = TerrainPatch; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("TerrainPatch", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit TerrainPatch(Context* context);

    ~TerrainPatch() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;

    Geometry* GetLodGeometry(unsigned batchIndex, unsigned level) override;

    unsigned GetNumOccluderTriangles() override;

    bool DrawOcclusion(OcclusionBuffer* buffer) override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetOwner(Terrain* terrain);

    void SetNeighbors(TerrainPatch* north, TerrainPatch* south, TerrainPatch* west, TerrainPatch* east);

    void SetMaterial(Material* material);

    void SetBoundingBox(const BoundingBox& box);

    void SetCoordinates(const IntVector2& coordinates);

    void ResetLod();


    Geometry* GetGeometry() const;

    Geometry* GetMaxLodGeometry() const;

    Geometry* GetOcclusionGeometry() const;

    VertexBuffer* GetVertexBuffer() const;

    Terrain* GetOwner() const;


    TerrainPatch* GetNorthPatch() const { return north_; }


    TerrainPatch* GetSouthPatch() const { return south_; }


    TerrainPatch* GetWestPatch() const { return west_; }


    TerrainPatch* GetEastPatch() const { return east_; }


    PODVector<float>& GetLodErrors() { return lodErrors_; }


    const IntVector2& GetCoordinates() const { return coordinates_; }


    unsigned GetLodLevel() const { return lodLevel_; }

protected:

    void OnWorldBoundingBoxUpdate() override;

private:

    unsigned GetCorrectedLodLevel(unsigned lodLevel);


    SharedPtr<Geometry> geometry_;

    SharedPtr<Geometry> maxLodGeometry_;

    SharedPtr<Geometry> occlusionGeometry_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    WeakPtr<Terrain> owner_;

    WeakPtr<TerrainPatch> north_;

    WeakPtr<TerrainPatch> south_;

    WeakPtr<TerrainPatch> west_;

    WeakPtr<TerrainPatch> east_;

    PODVector<float> lodErrors_;

    IntVector2 coordinates_;

    unsigned lodLevel_;
};

}

namespace Urho3D
{

class Image;
class XMLFile;


class __attribute__((visibility("default"))) Texture2D : public Texture
{
    public: using ClassName = Texture2D; using BaseClassName = Texture; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Texture2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Texture2D(Context* context);

    ~Texture2D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    void OnDeviceLost() override;

    void OnDeviceReset() override;

    void Release() override;





    bool SetSize(int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC, int multiSample = 1, bool autoResolve = true);

    bool SetData(unsigned level, int x, int y, int width, int height, const void* data);

    bool SetData(Image* image, bool useAlpha = false);


    bool GetData(unsigned level, void* dest) const;

    bool GetImage(Image& image) const;

    SharedPtr<Image> GetImage() const;


    RenderSurface* GetRenderSurface() const { return renderSurface_; }

protected:

    bool Create() override;

private:

    void HandleRenderSurfaceUpdate(StringHash eventType, VariantMap& eventData);


    SharedPtr<RenderSurface> renderSurface_;

    SharedPtr<Image> loadImage_;

    SharedPtr<XMLFile> loadParameters_;
};

}
namespace Urho3D
{

class Deserializer;
class Image;


class __attribute__((visibility("default"))) Texture2DArray : public Texture
{
    public: using ClassName = Texture2DArray; using BaseClassName = Texture; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Texture2DArray", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    explicit Texture2DArray(Context* context);

    ~Texture2DArray() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    void OnDeviceLost() override;

    void OnDeviceReset() override;

    void Release() override;


    void SetLayers(unsigned layers);

    bool SetSize(unsigned layers, int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC);

    bool SetData(unsigned layer, unsigned level, int x, int y, int width, int height, const void* data);

    bool SetData(unsigned layer, Deserializer& source);

    bool SetData(unsigned layer, Image* image, bool useAlpha = false);


    unsigned GetLayers() const { return layers_; }

    bool GetData(unsigned layer, unsigned level, void* dest) const;

    RenderSurface* GetRenderSurface() const { return renderSurface_; }

protected:

    bool Create() override;

private:

    void HandleRenderSurfaceUpdate(StringHash eventType, VariantMap& eventData);


    unsigned layers_{};

    SharedPtr<RenderSurface> renderSurface_;

    PODVector<unsigned> layerMemoryUse_;

    Vector<SharedPtr<Image> > loadImages_;

    SharedPtr<XMLFile> loadParameters_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) Texture3D : public Texture
{
    public: using ClassName = Texture3D; using BaseClassName = Texture; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Texture3D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Texture3D(Context* context);

    ~Texture3D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    void OnDeviceLost() override;

    void OnDeviceReset() override;

    void Release() override;


    bool SetSize(int width, int height, int depth, unsigned format, TextureUsage usage = TEXTURE_STATIC);

    bool SetData(unsigned level, int x, int y, int z, int width, int height, int depth, const void* data);

    bool SetData(Image* image, bool useAlpha = false);


    bool GetData(unsigned level, void* dest) const;

protected:

    bool Create() override;

private:

    SharedPtr<Image> loadImage_;

    SharedPtr<XMLFile> loadParameters_;
};

}
namespace Urho3D
{

class Deserializer;
class Image;


class __attribute__((visibility("default"))) TextureCube : public Texture
{
    public: using ClassName = TextureCube; using BaseClassName = Texture; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("TextureCube", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit TextureCube(Context* context);

    ~TextureCube() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    void OnDeviceLost() override;

    void OnDeviceReset() override;

    void Release() override;


    bool SetSize(int size, unsigned format, TextureUsage usage = TEXTURE_STATIC, int multiSample = 1);

    bool SetData(CubeMapFace face, unsigned level, int x, int y, int width, int height, const void* data);

    bool SetData(CubeMapFace face, Deserializer& source);

    bool SetData(CubeMapFace face, Image* image, bool useAlpha = false);


    bool GetData(CubeMapFace face, unsigned level, void* dest) const;

    SharedPtr<Image> GetImage(CubeMapFace face) const;


    RenderSurface* GetRenderSurface(CubeMapFace face) const { return renderSurfaces_[face]; }

protected:

    bool Create() override;

private:

    void HandleRenderSurfaceUpdate(StringHash eventType, VariantMap& eventData);


    SharedPtr<RenderSurface> renderSurfaces_[MAX_CUBEMAP_FACES];

    unsigned faceMemoryUse_[MAX_CUBEMAP_FACES]{};

    Vector<SharedPtr<Image> > loadImages_;

    SharedPtr<XMLFile> loadParameters_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) VertexBuffer : public Object, public GPUObject
{
    public: using ClassName = VertexBuffer; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("VertexBuffer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit VertexBuffer(Context* context, bool forceHeadless = false);

    ~VertexBuffer() override;


    void OnDeviceLost() override;

    void OnDeviceReset() override;

    void Release() override;


    void SetShadowed(bool enable);

    bool SetSize(unsigned vertexCount, const PODVector<VertexElement>& elements, bool dynamic = false);

    bool SetSize(unsigned vertexCount, unsigned elementMask, bool dynamic = false);

    bool SetData(const void* data);

    bool SetDataRange(const void* data, unsigned start, unsigned count, bool discard = false);

    void* Lock(unsigned start, unsigned count, bool discard = false);

    void Unlock();


    bool IsShadowed() const { return shadowed_; }


    bool IsDynamic() const { return dynamic_; }


    bool IsLocked() const { return lockState_ != LOCK_NONE; }


    unsigned GetVertexCount() const { return vertexCount_; }


    unsigned GetVertexSize() const { return vertexSize_; }


    const PODVector<VertexElement>& GetElements() const { return elements_; }


    const VertexElement* GetElement(VertexElementSemantic semantic, unsigned char index = 0) const;


    const VertexElement* GetElement(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0) const;


    bool HasElement(VertexElementSemantic semantic, unsigned char index = 0) const { return GetElement(semantic, index) != nullptr; }


    bool HasElement(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0) const { return GetElement(type, semantic, index) != nullptr; }


    unsigned GetElementOffset(VertexElementSemantic semantic, unsigned char index = 0) const { const VertexElement* element = GetElement(semantic, index); return element ? element->offset_ : M_MAX_UNSIGNED; }


    unsigned GetElementOffset(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0) const { const VertexElement* element = GetElement(type, semantic, index); return element ? element->offset_ : M_MAX_UNSIGNED; }


    VertexMaskFlags GetElementMask() const { return elementMask_; }


    unsigned char* GetShadowData() const { return shadowData_.Get(); }


    SharedArrayPtr<unsigned char> GetShadowDataShared() const { return shadowData_; }


    unsigned long long GetBufferHash(unsigned streamIndex) { return elementHash_ << (streamIndex * 16); }


    static const VertexElement* GetElement(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0);


    static bool HasElement(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0);


    static unsigned GetElementOffset(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0);


    static PODVector<VertexElement> GetElements(unsigned elementMask);


    static unsigned GetVertexSize(const PODVector<VertexElement>& elements);


    static unsigned GetVertexSize(unsigned elementMask);


    static void UpdateOffsets(PODVector<VertexElement>& elements);

private:

    void UpdateOffsets();

    bool Create();

    bool UpdateToGPU();

    void* MapBuffer(unsigned start, unsigned count, bool discard);

    void UnmapBuffer();


    SharedArrayPtr<unsigned char> shadowData_;

    unsigned vertexCount_{};

    unsigned vertexSize_{};

    PODVector<VertexElement> elements_;

    unsigned long long elementHash_{};

    VertexMaskFlags elementMask_{};

    LockState lockState_{LOCK_NONE};

    unsigned lockStart_{};

    unsigned lockCount_{};

    void* lockScratchData_{};

    bool dynamic_{};

    bool shadowed_{};

    bool discardLock_{};
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) Zone : public Drawable
{
    public: using ClassName = Zone; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Zone", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Zone(Context* context);

    ~Zone() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetBoundingBox(const BoundingBox& box);

    void SetAmbientColor(const Color& color);

    void SetFogColor(const Color& color);

    void SetFogStart(float start);

    void SetFogEnd(float end);

    void SetFogHeight(float height);

    void SetFogHeightScale(float scale);

    void SetPriority(int priority);

    void SetHeightFog(bool enable);

    void SetOverride(bool enable);

    void SetAmbientGradient(bool enable);

    void SetZoneTexture(Texture* texture);


    const Matrix3x4& GetInverseWorldTransform() const;


    const Color& GetAmbientColor() const { return ambientColor_; }


    const Color& GetAmbientStartColor();

    const Color& GetAmbientEndColor();


    const Color& GetFogColor() const { return fogColor_; }


    float GetFogStart() const { return fogStart_; }


    float GetFogEnd() const { return fogEnd_; }


    float GetFogHeight() const { return fogHeight_; }


    float GetFogHeightScale() const { return fogHeightScale_; }


    int GetPriority() const { return priority_; }


    bool GetHeightFog() const { return heightFog_; }


    bool GetOverride() const { return override_; }


    bool GetAmbientGradient() const { return ambientGradient_; }


    Texture* GetZoneTexture() const { return zoneTexture_; }


    bool IsInside(const Vector3& point) const;

    void SetZoneTextureAttr(const ResourceRef& value);

    ResourceRef GetZoneTextureAttr() const;

protected:

    void OnMarkedDirty(Node* node) override;

    void OnWorldBoundingBoxUpdate() override;

    void OnRemoveFromOctree() override;

    void UpdateAmbientGradient();

    void ClearDrawablesZone();

    void MarkNodeDirty() { OnMarkedDirty(node_); }


    mutable Matrix3x4 inverseWorld_;

    mutable bool inverseWorldDirty_;

    bool heightFog_;

    bool override_;

    bool ambientGradient_;

    BoundingBox lastWorldBoundingBox_;

    Color ambientColor_;

    Color ambientStartColor_;

    Color ambientEndColor_;

    Color fogColor_;

    float fogStart_;

    float fogEnd_;

    float fogHeight_;

    float fogHeightScale_;

    int priority_;

    SharedPtr<Texture> zoneTexture_;

    WeakPtr<Zone> lastAmbientStartZone_;

    WeakPtr<Zone> lastAmbientEndZone_;
};

}

namespace Urho3D
{

class BoundingBox;
class Frustum;
class Matrix3;
class Matrix3x4;
class Plane;


class __attribute__((visibility("default"))) Polyhedron
{
public:

    Polyhedron() noexcept = default;

    ~Polyhedron() noexcept = default;


    Polyhedron(const Polyhedron& polyhedron) :
        faces_(polyhedron.faces_)
    {
    }


    explicit Polyhedron(const Vector<PODVector<Vector3> >& faces) :
        faces_(faces)
    {
    }


    explicit Polyhedron(const BoundingBox& box)
    {
        Define(box);
    }


    explicit Polyhedron(const Frustum& frustum)
    {
        Define(frustum);
    }


    Polyhedron& operator =(const Polyhedron& rhs)
    {
        faces_ = rhs.faces_;
        return *this;
    }


    void Define(const BoundingBox& box);

    void Define(const Frustum& frustum);

    void AddFace(const Vector3& v0, const Vector3& v1, const Vector3& v2);

    void AddFace(const Vector3& v0, const Vector3& v1, const Vector3& v2, const Vector3& v3);

    void AddFace(const PODVector<Vector3>& face);

    void Clip(const Plane& plane);

    void Clip(const BoundingBox& box);

    void Clip(const Frustum& frustum);

    void Clear();

    void Transform(const Matrix3& transform);

    void Transform(const Matrix3x4& transform);


    Polyhedron Transformed(const Matrix3& transform) const;

    Polyhedron Transformed(const Matrix3x4& transform) const;


    bool Empty() const { return faces_.Empty(); }


    Vector<PODVector<Vector3> > faces_;

private:

    void SetFace(unsigned index, const Vector3& v0, const Vector3& v1, const Vector3& v2);

    void SetFace(unsigned index, const Vector3& v0, const Vector3& v1, const Vector3& v2, const Vector3& v3);

    PODVector<Vector3> clippedVertices_;

    PODVector<Vector3> outFace_;
};

}


namespace Urho3D
{

class Camera;
class DebugRenderer;
class Light;
class Drawable;
class Graphics;
class OcclusionBuffer;
class Octree;
class Renderer;
class RenderPath;
class RenderSurface;
class Technique;
class Texture;
class Texture2D;
class Viewport;
class Zone;
struct RenderPathCommand;
struct WorkItem;


struct LightQueryResult
{

    Light* light_;

    PODVector<Drawable*> litGeometries_;

    PODVector<Drawable*> shadowCasters_;

    Camera* shadowCameras_[MAX_LIGHT_SPLITS];

    unsigned shadowCasterBegin_[MAX_LIGHT_SPLITS];

    unsigned shadowCasterEnd_[MAX_LIGHT_SPLITS];

    BoundingBox shadowCasterBox_[MAX_LIGHT_SPLITS];

    float shadowNearSplits_[MAX_LIGHT_SPLITS];

    float shadowFarSplits_[MAX_LIGHT_SPLITS];

    unsigned numSplits_;
};


struct ScenePassInfo
{

    unsigned passIndex_;

    bool allowInstancing_;

    bool markToStencil_;

    bool vertexLights_;

    BatchQueue* batchQueue_;
};


struct PerThreadSceneResult
{

    PODVector<Drawable*> geometries_;

    PODVector<Light*> lights_;

    float minZ_;

    float maxZ_;
};

static const unsigned MAX_VIEWPORT_TEXTURES = 2;


class __attribute__((visibility("default"))) View : public Object
{
    friend void CheckVisibilityWork(const WorkItem* item, unsigned threadIndex);
    friend void ProcessLightWork(const WorkItem* item, unsigned threadIndex);

    public: using ClassName = View; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("View", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit View(Context* context);

    ~View() override = default;


    bool Define(RenderSurface* renderTarget, Viewport* viewport);

    void Update(const FrameInfo& frame);

    void Render();


    Graphics* GetGraphics() const;

    Renderer* GetRenderer() const;


    Scene* GetScene() const { return scene_; }


    Octree* GetOctree() const { return octree_; }


    Camera* GetCamera() const { return camera_; }


    Camera* GetCullCamera() const { return cullCamera_; }


    const FrameInfo& GetFrameInfo() const { return frame_; }


    RenderSurface* GetRenderTarget() const { return renderTarget_; }


    bool GetDrawDebug() const { return drawDebug_; }


    const IntRect& GetViewRect() const { return viewRect_; }


    const IntVector2& GetViewSize() const { return viewSize_; }


    const PODVector<Drawable*>& GetGeometries() const { return geometries_; }


    const PODVector<Drawable*>& GetOccluders() const { return occluders_; }


    const PODVector<Light*>& GetLights() const { return lights_; }


    const Vector<LightBatchQueue>& GetLightQueues() const { return lightQueues_; }


    OcclusionBuffer* GetOcclusionBuffer() const { return occlusionBuffer_; }


    unsigned GetNumActiveOccluders() const { return activeOccluders_; }


    View* GetSourceView() const;


    void SetGlobalShaderParameters();

    void SetCameraShaderParameters(Camera* camera);

    void SetCommandShaderParameters(const RenderPathCommand& command);

    void SetGBufferShaderParameters(const IntVector2& texSize, const IntRect& viewRect);


    void DrawFullscreenQuad(bool setIdentityProjection = false);


    Texture* FindNamedTexture(const String& name, const String& basePath, bool isRenderTarget, bool isVolumeMap = false);

private:

    void GetDrawables();

    void GetBatches();

    void ProcessLights();

    void GetLightBatches();

    void GetBaseBatches();

    void UpdateGeometries();

    void GetLitBatches(Drawable* drawable, LightBatchQueue& lightQueue, BatchQueue* alphaQueue);

    void ExecuteRenderPathCommands();

    void SetRenderTargets(RenderPathCommand& command);

    bool SetTextures(RenderPathCommand& command);

    void RenderQuad(RenderPathCommand& command);

    bool IsNecessary(const RenderPathCommand& command);

    bool CheckViewportRead(const RenderPathCommand& command);

    bool CheckViewportWrite(const RenderPathCommand& command);

    bool CheckPingpong(unsigned index);

    void AllocateScreenBuffers();

    void BlitFramebuffer(Texture* source, RenderSurface* destination, bool depthWrite);

    void UpdateOccluders(PODVector<Drawable*>& occluders, Camera* camera);

    void DrawOccluders(OcclusionBuffer* buffer, const PODVector<Drawable*>& occluders);

    void ProcessLight(LightQueryResult& query, unsigned threadIndex);

    void ProcessShadowCasters(LightQueryResult& query, const PODVector<Drawable*>& drawables, unsigned splitIndex);

    void SetupShadowCameras(LightQueryResult& query);

    void SetupDirLightShadowCamera(Camera* shadowCamera, Light* light, float nearSplit, float farSplit);

    void
        FinalizeShadowCamera(Camera* shadowCamera, Light* light, const IntRect& shadowViewport, const BoundingBox& shadowCasterBox);

    void
        QuantizeDirLightShadowCamera(Camera* shadowCamera, Light* light, const IntRect& shadowViewport, const BoundingBox& viewBox);

    bool IsShadowCasterVisible(Drawable* drawable, BoundingBox lightViewBox, Camera* shadowCamera, const Matrix3x4& lightView,
        const Frustum& lightViewFrustum, const BoundingBox& lightViewFrustumBox);

    IntRect GetShadowMapViewport(Light* light, int splitIndex, Texture2D* shadowMap);

    void FindZone(Drawable* drawable);

    Technique* GetTechnique(Drawable* drawable, Material* material);

    void CheckMaterialForAuxView(Material* material);

    void SetQueueShaderDefines(BatchQueue& queue, const RenderPathCommand& command);

    void AddBatchToQueue(BatchQueue& queue, Batch& batch, Technique* tech, bool allowInstancing = true, bool allowShadows = true);

    void PrepareInstancingBuffer();

    void SetupLightVolumeBatch(Batch& batch);

    bool NeedRenderShadowMap(const LightBatchQueue& queue);

    void RenderShadowMap(const LightBatchQueue& queue);

    RenderSurface* GetDepthStencil(RenderSurface* renderTarget);

    RenderSurface* GetRenderSurfaceFromTexture(Texture* texture, CubeMapFace face = FACE_POSITIVE_X);

    void SendViewEvent(StringHash eventType);


    Zone* GetZone(Drawable* drawable)
    {
        if (cameraZoneOverride_)
            return cameraZone_;
        Zone* drawableZone = drawable->GetZone();
        return drawableZone ? drawableZone : cameraZone_;
    }


    unsigned GetLightMask(Drawable* drawable)
    {
        return drawable->GetLightMask() & GetZone(drawable)->GetLightMask();
    }


    unsigned GetShadowMask(Drawable* drawable)
    {
        return drawable->GetShadowMask() & GetZone(drawable)->GetShadowMask();
    }


    unsigned long long GetVertexLightQueueHash(const PODVector<Light*>& vertexLights)
    {
        unsigned long long hash = 0;
        for (PODVector<Light*>::ConstIterator i = vertexLights.Begin(); i != vertexLights.End(); ++i)
            hash += (unsigned long long)(*i);
        return hash;
    }


    WeakPtr<Graphics> graphics_;

    WeakPtr<Renderer> renderer_;

    Scene* scene_{};

    Octree* octree_{};

    Camera* camera_{};

    Camera* cullCamera_{};

    WeakPtr<View> sourceView_;

    Zone* cameraZone_{};

    Zone* farClipZone_{};

    OcclusionBuffer* occlusionBuffer_{};

    RenderSurface* renderTarget_{};

    RenderSurface* substituteRenderTarget_{};

    Texture* viewportTextures_[MAX_VIEWPORT_TEXTURES]{};

    RenderSurface* currentRenderTarget_{};

    RenderSurface* lastCustomDepthSurface_{};

    Texture* currentViewportTexture_{};

    Texture* depthOnlyDummyTexture_{};

    IntRect viewRect_;

    IntVector2 viewSize_;

    IntVector2 rtSize_;

    FrameInfo frame_{};

    float aspectRatio_{};

    float minZ_{};

    float maxZ_{};

    int materialQuality_{};

    int maxOccluderTriangles_{};

    int minInstances_{};

    int highestZonePriority_{};

    bool geometriesUpdated_{};

    bool cameraZoneOverride_{};

    bool drawShadows_{};

    bool deferred_{};

    bool deferredAmbient_{};

    bool useLitBase_{};

    bool hasScenePasses_{};

    bool noStencil_{};

    bool drawDebug_{};

    RenderPath* renderPath_{};

    Vector<PODVector<Drawable*> > tempDrawables_;

    Vector<PerThreadSceneResult> sceneResults_;

    PODVector<Zone*> zones_;

    PODVector<Drawable*> geometries_;

    PODVector<Drawable*> nonThreadedGeometries_;

    PODVector<Drawable*> threadedGeometries_;

    PODVector<Drawable*> occluders_;

    PODVector<Light*> lights_;

    unsigned activeOccluders_{};


    HashSet<Drawable*> maxLightsDrawables_;

    HashMap<StringHash, Texture*> renderTargets_;

    Vector<LightQueryResult> lightQueryResults_;

    PODVector<ScenePassInfo> scenePasses_;

    Vector<LightBatchQueue> lightQueues_;

    HashMap<unsigned long long, LightBatchQueue> vertexLightQueues_;

    HashMap<unsigned, BatchQueue> batchQueues_;

    unsigned gBufferPassIndex_{};

    unsigned basePassIndex_{};

    unsigned alphaPassIndex_{};

    unsigned lightPassIndex_{};

    unsigned litBasePassIndex_{};

    unsigned litAlphaPassIndex_{};

    const RenderPathCommand* lightVolumeCommand_{};

    const RenderPathCommand* forwardLightsCommand_{};

    const RenderPathCommand* passCommand_{};

    bool usedResolve_{};
};

}



namespace Urho3D
{

class Context;


void RegisterIKLibrary(Context* context);

}
struct ik_node_t;

namespace Urho3D
{

class Context;
class Node;

class __attribute__((visibility("default"))) IKConstraint : public Component
{
    public: using ClassName = IKConstraint; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("IKConstraint", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:


    explicit IKConstraint(Context* context);


    ~IKConstraint() override;


    static void RegisterObject(Context* context);

    float GetStiffness() const;
    void SetStiffness(float stiffness);

    float GetStretchiness() const;
    void SetStretchiness(float stretchiness);

    const Vector2& GetLengthConstraints() const;
    void SetLengthConstraints(const Vector2& lengthConstraints);

private:
    friend class IKSolver;


    void SetIKConstraintNode(ik_node_t* constraintNode);

    ik_node_t* ikConstraintNode_;

    float stiffness_;
    float stretchiness_;
    Vector2 lengthConstraints_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) JSONFile : public Resource
{
    public: using ClassName = JSONFile; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("JSONFile", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit JSONFile(Context* context);

    ~JSONFile() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;

    bool Save(Serializer& dest, const String& indendation) const;


    bool FromString(const String& source);

    String ToString(const String& indendation = "\t") const;


    JSONValue& GetRoot() { return root_; }

    const JSONValue& GetRoot() const { return root_; }

private:

    JSONValue root_;
};

}


namespace Urho3D
{

class Component;
class Node;


class __attribute__((visibility("default"))) SceneResolver
{
public:

    SceneResolver();

    ~SceneResolver();


    void Reset();

    void AddNode(unsigned oldID, Node* node);

    void AddComponent(unsigned oldID, Component* component);

    void Resolve();

private:

    HashMap<unsigned, WeakPtr<Node> > nodes_;

    HashMap<unsigned, WeakPtr<Component> > components_;
};

}


namespace Urho3D
{

class File;
class PackageFile;

static const unsigned FIRST_REPLICATED_ID = 0x1;
static const unsigned LAST_REPLICATED_ID = 0xffffff;
static const unsigned FIRST_LOCAL_ID = 0x01000000;
static const unsigned LAST_LOCAL_ID = 0xffffffff;


enum LoadMode
{

    LOAD_RESOURCES_ONLY = 0,

    LOAD_SCENE,

    LOAD_SCENE_AND_RESOURCES
};


struct AsyncProgress
{

    SharedPtr<File> file_;

    SharedPtr<XMLFile> xmlFile_;

    SharedPtr<JSONFile> jsonFile_;


    XMLElement xmlElement_;


    unsigned jsonIndex_;


    LoadMode mode_;

    HashSet<StringHash> resources_;

    unsigned loadedResources_;

    unsigned totalResources_;

    unsigned loadedNodes_;

    unsigned totalNodes_;
};


class __attribute__((visibility("default"))) Scene : public Node
{
    public: using ClassName = Scene; using BaseClassName = Node; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Scene", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    using Node::GetComponent;
    using Node::SaveXML;
    using Node::SaveJSON;

public:

    explicit Scene(Context* context);

    ~Scene() override;

    static void RegisterObject(Context* context);


    bool Load(Deserializer& source) override;

    bool Save(Serializer& dest) const override;

    bool LoadXML(const XMLElement& source) override;

    bool LoadJSON(const JSONValue& source) override;

    void MarkNetworkUpdate() override;

    void AddReplicationState(NodeReplicationState* state) override;


    bool LoadXML(Deserializer& source);

    bool LoadJSON(Deserializer& source);

    bool SaveXML(Serializer& dest, const String& indentation = "\t") const;

    bool SaveJSON(Serializer& dest, const String& indentation = "\t") const;

    bool LoadAsync(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES);

    bool LoadAsyncXML(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES);

    bool LoadAsyncJSON(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES);

    void StopAsyncLoading();

    Node* Instantiate(Deserializer& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED);

    Node* InstantiateXML
        (const XMLElement& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED);

    Node* InstantiateXML(Deserializer& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED);

    Node* InstantiateJSON
        (const JSONValue& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED);

    Node* InstantiateJSON(Deserializer& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED);


    void Clear(bool clearReplicated = true, bool clearLocal = true);

    void SetUpdateEnabled(bool enable);

    void SetTimeScale(float scale);

    void SetElapsedTime(float time);

    void SetSmoothingConstant(float constant);

    void SetSnapThreshold(float threshold);

    void SetAsyncLoadingMs(int ms);

    void AddRequiredPackageFile(PackageFile* package);

    void ClearRequiredPackageFiles();

    void RegisterVar(const String& name);

    void UnregisterVar(const String& name);

    void UnregisterAllVars();


    Node* GetNode(unsigned id) const;

    Component* GetComponent(unsigned id) const;

    bool GetNodesWithTag(PODVector<Node*>& dest, const String& tag) const;


    bool IsUpdateEnabled() const { return updateEnabled_; }


    bool IsAsyncLoading() const { return asyncLoading_; }


    float GetAsyncProgress() const;


    LoadMode GetAsyncLoadMode() const { return asyncProgress_.mode_; }


    const String& GetFileName() const { return fileName_; }


    unsigned GetChecksum() const { return checksum_; }


    float GetTimeScale() const { return timeScale_; }


    float GetElapsedTime() const { return elapsedTime_; }


    float GetSmoothingConstant() const { return smoothingConstant_; }


    float GetSnapThreshold() const { return snapThreshold_; }


    int GetAsyncLoadingMs() const { return asyncLoadingMs_; }


    const Vector<SharedPtr<PackageFile> >& GetRequiredPackageFiles() const { return requiredPackageFiles_; }


    const String& GetVarName(StringHash hash) const;


    void Update(float timeStep);

    void BeginThreadedUpdate();

    void EndThreadedUpdate();

    void DelayedMarkedDirty(Component* component);


    bool IsThreadedUpdate() const { return threadedUpdate_; }


    unsigned GetFreeNodeID(CreateMode mode);

    unsigned GetFreeComponentID(CreateMode mode);

    static bool IsReplicatedID(unsigned id) { return id < FIRST_LOCAL_ID; }


    void NodeTagAdded(Node* node, const String& tag);

    void NodeTagRemoved(Node* node, const String& tag);


    void NodeAdded(Node* node);

    void NodeRemoved(Node* node);

    void ComponentAdded(Component* component);

    void ComponentRemoved(Component* component);

    void SetVarNamesAttr(const String& value);

    String GetVarNamesAttr() const;

    void PrepareNetworkUpdate();

    void CleanupConnection(Connection* connection);

    void MarkNetworkUpdate(Node* node);

    void MarkNetworkUpdate(Component* component);

    void MarkReplicationDirty(Node* node);

private:

    void HandleUpdate(StringHash eventType, VariantMap& eventData);

    void HandleResourceBackgroundLoaded(StringHash eventType, VariantMap& eventData);

    void UpdateAsyncLoading();

    void FinishAsyncLoading();

    void FinishLoading(Deserializer* source);

    void FinishSaving(Serializer* dest) const;

    void PreloadResources(File* file, bool isSceneFile);

    void PreloadResourcesXML(const XMLElement& element);

    void PreloadResourcesJSON(const JSONValue& value);


    HashMap<unsigned, Node*> replicatedNodes_;

    HashMap<unsigned, Node*> localNodes_;

    HashMap<unsigned, Component*> replicatedComponents_;

    HashMap<unsigned, Component*> localComponents_;

    HashMap<StringHash, PODVector<Node*> > taggedNodes_;

    AsyncProgress asyncProgress_;

    SceneResolver resolver_;

    mutable String fileName_;

    Vector<SharedPtr<PackageFile> > requiredPackageFiles_;

    HashMap<StringHash, String> varNames_;

    HashSet<unsigned> networkUpdateNodes_;

    HashSet<unsigned> networkUpdateComponents_;

    PODVector<Component*> delayedDirtyComponents_;

    Mutex sceneMutex_;

    VariantMap smoothingData_;

    unsigned replicatedNodeID_;

    unsigned replicatedComponentID_;

    unsigned localNodeID_;

    unsigned localComponentID_;

    mutable unsigned checksum_;

    int asyncLoadingMs_;

    float timeScale_;

    float elapsedTime_;

    float smoothingConstant_;

    float snapThreshold_;

    bool updateEnabled_;

    bool asyncLoading_;

    bool threadedUpdate_;
};


void __attribute__((visibility("default"))) RegisterSceneLibrary(Context* context);

}

using ik_node_t = struct ik_node_t;

namespace Urho3D
{

class Context;
class IKSolver;

class __attribute__((visibility("default"))) IKEffector : public Component
{
    public: using ClassName = IKEffector; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("IKEffector", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    enum Feature
    {
        WEIGHT_NLERP = 0x01,






        INHERIT_PARENT_ROTATION = 0x02
    };


    explicit IKEffector(Context* context);


    ~IKEffector() override;


    static void RegisterObject(Context* context);


    bool GetFeature(Feature feature) const;

    void SetFeature(Feature feature, bool enable);


    Node* GetTargetNode() const;
    void SetTargetNode(Node* targetNode);





    const String& GetTargetName() const;







    void SetTargetName(const String& nodeName);


    const Vector3& GetTargetPosition() const;

    void SetTargetPosition(const Vector3& targetPosition);


    const Quaternion& GetTargetRotation() const;

    void SetTargetRotation(const Quaternion& targetRotation);


    Vector3 GetTargetRotationEuler() const;

    void SetTargetRotationEuler(const Vector3& targetRotation);


    unsigned GetChainLength() const;

    void SetChainLength(unsigned chainLength);


    float GetWeight() const;
    void SetWeight(float weight);


    float GetRotationWeight() const;
    void SetRotationWeight(float weight);


    float GetRotationDecay() const;
    void SetRotationDecay(float decay);

    void DrawDebugGeometry(bool depthTest);
    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;

private:
    friend class IKSolver;


    void SetIKSolver(IKSolver* solver);

    void SetIKEffectorNode(ik_node_t* effectorNode);

    void UpdateTargetNodePosition();

public:

    bool GetWEIGHT_NLERP() const;
    bool GetINHERIT_PARENT_ROTATION() const;
    void SetWEIGHT_NLERP(bool enable);
    void SetINHERIT_PARENT_ROTATION(bool enable);

private:
    WeakPtr<Node> targetNode_;
    WeakPtr<IKSolver> solver_;
    ik_node_t* ikEffectorNode_;

    String targetName_;
    Vector3 targetPosition_;
    Quaternion targetRotation_;
    unsigned chainLength_;
    float weight_;
    float rotationWeight_;
    float rotationDecay_;
    unsigned features_;
};

}
namespace Urho3D
{

static const Urho3D::StringHash E_IKEFFECTORTARGETCHANGED(Urho3D::GetEventNameRegister().RegisterString("IKEffectorTargetChanged")); namespace IKEffectorTargetChanged
{
    static const Urho3D::StringHash P_EFFECTORNODE("EffectorNode");
    static const Urho3D::StringHash P_TARGETNODE("TargetNode");
}

}
struct ik_solver_t;
struct ik_node_t;

namespace Urho3D
{
class AnimationState;
class IKConstraint;
class IKEffector;







class __attribute__((visibility("default"))) IKSolver : public Component
{
    public: using ClassName = IKSolver; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("IKSolver", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    enum Algorithm
    {
        ONE_BONE = 0,
        TWO_BONE,
        FABRIK




    };

    enum Feature
    {
        JOINT_ROTATIONS = 0x01,
        TARGET_ROTATIONS = 0x02,
        UPDATE_ORIGINAL_POSE = 0x04,
        UPDATE_ACTIVE_POSE = 0x08,
        USE_ORIGINAL_POSE = 0x10,
        CONSTRAINTS = 0x20,







        AUTO_SOLVE = 0x40
    };


    explicit IKSolver(Context* context);

    ~IKSolver() override;

    static void RegisterObject(Context* context);


    Algorithm GetAlgorithm() const;
    void SetAlgorithm(Algorithm algorithm);


    bool GetFeature(Feature feature) const;

    void SetFeature(Feature feature, bool enable);


    unsigned GetMaximumIterations() const;
    void SetMaximumIterations(unsigned iterations);


    float GetTolerance() const;
    void SetTolerance(float tolerance);







    void RebuildChainTrees();
    void RecalculateSegmentLengths();






    void CalculateJointRotations();
    void Solve();







    void ApplyOriginalPoseToScene();






    void ApplySceneToOriginalPose();







    void ApplyActivePoseToScene();






    void ApplySceneToActivePose();





    void ApplyOriginalPoseToActivePose();

    void DrawDebugGeometry(bool depthTest);
    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;

private:
    friend class IKEffector;


    void MarkChainsNeedUpdating();

    void MarkTreeNeedsRebuild();

    bool IsSolverTreeValid() const;


    void OnSceneSet(Scene* scene) override;

    void OnNodeSet(Node* node) override;


    ik_node_t* CreateIKNodeFromUrhoNode(const Node* node);


    void DestroyTree();

    void RebuildTree();

    bool BuildTreeToEffector(IKEffector* effector);







    bool ComponentIsInOurSubtree(Component* component) const;

    void HandleComponentAdded(StringHash eventType, VariantMap& eventData);
    void HandleComponentRemoved(StringHash eventType, VariantMap& eventData);
    void HandleNodeAdded(StringHash eventType, VariantMap& eventData);
    void HandleNodeRemoved(StringHash eventType, VariantMap& eventData);

    void HandleSceneDrawableUpdateFinished(StringHash eventType, VariantMap& eventData);


public:
    bool GetJOINT_ROTATIONS() const;
    bool GetTARGET_ROTATIONS() const;
    bool GetUPDATE_ORIGINAL_POSE() const;
    bool GetUPDATE_ACTIVE_POSE() const;
    bool GetUSE_ORIGINAL_POSE() const;
    bool GetCONSTRAINTS() const;
    bool GetAUTO_SOLVE() const;

    void SetJOINT_ROTATIONS(bool enable);
    void SetTARGET_ROTATIONS(bool enable);
    void SetUPDATE_ORIGINAL_POSE(bool enable);
    void SetUPDATE_ACTIVE_POSE(bool enable);
    void SetUSE_ORIGINAL_POSE(bool enable);
    void SetCONSTRAINTS(bool enable);
    void SetAUTO_SOLVE(bool enable);

private:
    PODVector<IKEffector*> effectorList_;
    PODVector<IKConstraint*> constraintList_;
    ik_solver_t* solver_;
    Algorithm algorithm_;
    unsigned features_;
    bool chainTreesNeedUpdating_;
    bool treeNeedsRebuild;
    bool solverTreeValid_;
};

}


namespace Urho3D
{

class Deserializer;
class Serializer;
class VectorBuffer;


__attribute__((visibility("default"))) unsigned EstimateCompressBound(unsigned srcSize);

__attribute__((visibility("default"))) unsigned CompressData(void* dest, const void* src, unsigned srcSize);

__attribute__((visibility("default"))) unsigned DecompressData(void* dest, const void* src, unsigned destSize);

__attribute__((visibility("default"))) bool CompressStream(Serializer& dest, Deserializer& src);

__attribute__((visibility("default"))) bool DecompressStream(Serializer& dest, Deserializer& src);

__attribute__((visibility("default"))) VectorBuffer CompressVectorBuffer(VectorBuffer& src);

__attribute__((visibility("default"))) VectorBuffer DecompressVectorBuffer(VectorBuffer& src);

}


namespace Urho3D
{

class AsyncExecRequest;


static const unsigned SCAN_FILES = 0x1;

static const unsigned SCAN_DIRS = 0x2;

static const unsigned SCAN_HIDDEN = 0x4;


class __attribute__((visibility("default"))) FileSystem : public Object
{
    public: using ClassName = FileSystem; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("FileSystem", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit FileSystem(Context* context);

    ~FileSystem() override;


    bool SetCurrentDir(const String& pathName);

    bool CreateDir(const String& pathName);

    void SetExecuteConsoleCommands(bool enable);

    int SystemCommand(const String& commandLine, bool redirectStdOutToLog = false);

    int SystemRun(const String& fileName, const Vector<String>& arguments);

    unsigned SystemCommandAsync(const String& commandLine);

    unsigned SystemRunAsync(const String& fileName, const Vector<String>& arguments);

    bool SystemOpen(const String& fileName, const String& mode = String::EMPTY);

    bool Copy(const String& srcFileName, const String& destFileName);

    bool Rename(const String& srcFileName, const String& destFileName);

    bool Delete(const String& fileName);

    void RegisterPath(const String& pathName);

    bool SetLastModifiedTime(const String& fileName, unsigned newTime);


    String GetCurrentDir() const;


    bool GetExecuteConsoleCommands() const { return executeConsoleCommands_; }


    bool HasRegisteredPaths() const { return allowedPaths_.Size() > 0; }


    bool CheckAccess(const String& pathName) const;

    unsigned GetLastModifiedTime(const String& fileName) const;

    bool FileExists(const String& fileName) const;

    bool DirExists(const String& pathName) const;

    void ScanDir(Vector<String>& result, const String& pathName, const String& filter, unsigned flags, bool recursive) const;

    String GetProgramDir() const;

    String GetUserDocumentsDir() const;

    String GetAppPreferencesDir(const String& org, const String& app) const;

    String GetTemporaryDir() const;

private:

    void ScanDirInternal
        (Vector<String>& result, String path, const String& startPath, const String& filter, unsigned flags, bool recursive) const;

    void HandleBeginFrame(StringHash eventType, VariantMap& eventData);

    void HandleConsoleCommand(StringHash eventType, VariantMap& eventData);


    HashSet<String> allowedPaths_;

    List<AsyncExecRequest*> asyncExecQueue_;

    unsigned nextAsyncExecID_{1};

    bool executeConsoleCommands_{};
};


__attribute__((visibility("default"))) void
    SplitPath(const String& fullPath, String& pathName, String& fileName, String& extension, bool lowercaseExtension = true);

__attribute__((visibility("default"))) String GetPath(const String& fullPath);

__attribute__((visibility("default"))) String GetFileName(const String& fullPath);

__attribute__((visibility("default"))) String GetExtension(const String& fullPath, bool lowercaseExtension = true);

__attribute__((visibility("default"))) String GetFileNameAndExtension(const String& fileName, bool lowercaseExtension = false);

__attribute__((visibility("default"))) String ReplaceExtension(const String& fullPath, const String& newExtension);

__attribute__((visibility("default"))) String AddTrailingSlash(const String& pathName);

__attribute__((visibility("default"))) String RemoveTrailingSlash(const String& pathName);

__attribute__((visibility("default"))) String GetParentPath(const String& path);

__attribute__((visibility("default"))) String GetInternalPath(const String& pathName);

__attribute__((visibility("default"))) String GetNativePath(const String& pathName);

__attribute__((visibility("default"))) WString GetWideNativePath(const String& pathName);

__attribute__((visibility("default"))) bool IsAbsolutePath(const String& pathName);

__attribute__((visibility("default"))) String CompressRelativePath(const String& path);

__attribute__((visibility("default"))) String ResolvePath(const String& relative, const String& absolute);


}
namespace Urho3D
{

class FileSystem;


class __attribute__((visibility("default"))) FileWatcher : public Object, public Thread
{
    public: using ClassName = FileWatcher; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("FileWatcher", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit FileWatcher(Context* context);

    ~FileWatcher() override;


    void ThreadFunction() override;


    bool StartWatching(const String& pathName, bool watchSubDirs);

    void StopWatching();

    void SetDelay(float interval);

    void AddChange(const String& fileName);

    bool GetNextChange(String& dest);


    const String& GetPath() const { return path_; }


    float GetDelay() const { return delay_; }

private:

    SharedPtr<FileSystem> fileSystem_;

    String path_;

    HashMap<String, Timer> changes_;

    Mutex changesMutex_;

    float delay_;

    bool watchSubDirs_;
    HashMap<int, String> dirHandle_;

    int watchHandle_;
};

}
namespace Urho3D
{


static const Urho3D::StringHash E_LOGMESSAGE(Urho3D::GetEventNameRegister().RegisterString("LogMessage")); namespace LogMessage
{
    static const Urho3D::StringHash P_MESSAGE("Message");
    static const Urho3D::StringHash P_LEVEL("Level");
}


static const Urho3D::StringHash E_ASYNCEXECFINISHED(Urho3D::GetEventNameRegister().RegisterString("AsyncExecFinished")); namespace AsyncExecFinished
{
    static const Urho3D::StringHash P_REQUESTID("RequestID");
    static const Urho3D::StringHash P_EXITCODE("ExitCode");
}

}

bool CheckMinimalVersion(int major, int minor);


bool IsFileWatcherSupported();


void* CreateFileWatcher(const char* pathname, bool watchSubDirs);


void CloseFileWatcher(void* watcher);


const char* ReadFileWatcher(void* watcher);
namespace Urho3D
{


class __attribute__((visibility("default"))) MemoryBuffer : public AbstractFile
{
public:

    MemoryBuffer(void* data, unsigned size);

    MemoryBuffer(const void* data, unsigned size);

    explicit MemoryBuffer(PODVector<unsigned char>& data);

    explicit MemoryBuffer(const PODVector<unsigned char>& data);


    unsigned Read(void* dest, unsigned size) override;

    unsigned Seek(unsigned position) override;

    unsigned Write(const void* data, unsigned size) override;


    unsigned char* GetData() { return buffer_; }


    bool IsReadOnly() { return readOnly_; }

private:

    unsigned char* buffer_;

    bool readOnly_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) NamedPipe : public Object, public AbstractFile
{
    public: using ClassName = NamedPipe; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("NamedPipe", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit NamedPipe(Context* context);

    NamedPipe(Context* context, const String& pipeName, bool isServer);

    ~NamedPipe() override;


    unsigned Read(void* dest, unsigned size) override;

    unsigned Seek(unsigned position) override;

    unsigned Write(const void* data, unsigned size) override;

    bool IsEof() const override;

    const String& GetName() const override { return pipeName_; }


    bool Open(const String& pipeName, bool isServer);

    void Close();


    bool IsOpen() const;

    bool IsServer() const { return isServer_; }

private:

    String pipeName_;

    bool isServer_;




    mutable int readHandle_;
    mutable int writeHandle_;

};

}
namespace Urho3D
{


struct PackageEntry
{

    unsigned offset_;

    unsigned size_;

    unsigned checksum_;
};


class __attribute__((visibility("default"))) PackageFile : public Object
{
    public: using ClassName = PackageFile; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("PackageFile", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit PackageFile(Context* context);

    PackageFile(Context* context, const String& fileName, unsigned startOffset = 0);

    ~PackageFile() override;


    bool Open(const String& fileName, unsigned startOffset = 0);

    bool Exists(const String& fileName) const;

    const PackageEntry* GetEntry(const String& fileName) const;


    const HashMap<String, PackageEntry>& GetEntries() const { return entries_; }


    const String& GetName() const { return fileName_; }


    StringHash GetNameHash() const { return nameHash_; }


    unsigned GetNumFiles() const { return entries_.Size(); }


    unsigned GetTotalSize() const { return totalSize_; }


    unsigned GetTotalDataSize() const { return totalDataSize_; }


    unsigned GetChecksum() const { return checksum_; }


    bool IsCompressed() const { return compressed_; }


    const Vector<String> GetEntryNames() const { return entries_.Keys(); }

private:

    HashMap<String, PackageEntry> entries_;

    String fileName_;

    StringHash nameHash_;

    unsigned totalSize_;

    unsigned totalDataSize_;

    unsigned checksum_;

    bool compressed_;
};

}
namespace Urho3D
{


template <class T> class RWOpsWrapper
{
public:

    explicit RWOpsWrapper(T& object)
    {
        ops_.type = dynamic_cast<File*>(&object) ? 2U : 4U;
        ops_.hidden.unknown.data1 = &object;
        ops_.size = &Size;
        ops_.seek = &Seek;
        ops_.close = &Close;
        ops_.read = &Read;
        ops_.write = &Write;
    }


    SDL_RWops* GetRWOps() { return &ops_; }

private:

    static Sint64 Size(SDL_RWops* context)
    {
        auto* object = reinterpret_cast<T*>(context->hidden.unknown.data1);
        auto* des = dynamic_cast<Deserializer*>(object);
        return des ? (Sint64)des->GetSize() : 0;
    }


    static Sint64 Seek(SDL_RWops* context, Sint64 offset, int whence)
    {
        auto* object = reinterpret_cast<T*>(context->hidden.unknown.data1);
        auto* des = dynamic_cast<Deserializer*>(object);
        if (!des)
            return 0;

        switch (whence)
        {
        case 0:
            des->Seek((unsigned)offset);
            break;

        case 1:
            des->Seek((unsigned)(des->GetPosition() + offset));
            break;

        case 2:
            des->Seek((unsigned)(des->GetSize() + offset));
            break;

        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/IO/RWOpsWrapper.h", 83, __PRETTY_FUNCTION__));
            break;
        }

        return (Sint64)des->GetPosition();
    }


    static int Close(SDL_RWops* context)
    {
        auto* object = reinterpret_cast<T*>(context->hidden.unknown.data1);
        auto* file = dynamic_cast<File*>(object);
        if (file)
            file->Close();
        return 0;
    }


    static size_t Read(SDL_RWops* context, void* ptr, size_t size, size_t maxNum)
    {
        auto* object = reinterpret_cast<T*>(context->hidden.unknown.data1);
        auto* des = dynamic_cast<Deserializer*>(object);
        return des ? (size_t)(des->Read(ptr, (unsigned)(size * maxNum)) / size) : 0;
    }


    static size_t Write(SDL_RWops* context, const void* ptr, size_t size, size_t maxNum)
    {
        auto* object = reinterpret_cast<T*>(context->hidden.unknown.data1);
        auto* ser = dynamic_cast<Serializer*>(object);
        return ser ? (size_t)(ser->Write(ptr, (unsigned)(size * maxNum)) / size) : 0;
    }


    SDL_RWops ops_;
};

}


namespace Urho3D
{


class __attribute__((visibility("default"))) Controls
{
public:

    Controls();

    ~Controls();


    void Reset();


    void Set(unsigned buttons, bool down = true)
    {
        if (down)
            buttons_ |= buttons;
        else
            buttons_ &= ~buttons;
    }


    bool IsDown(unsigned button) const
    {
        return (buttons_ & button) != 0;
    }


    bool IsPressed(unsigned button, const Controls& previousControls) const
    {
        return (buttons_ & button) != 0 && (previousControls.buttons_ & button) == 0;
    }


    unsigned buttons_;

    float yaw_;

    float pitch_;

    VariantMap extraData_;
};

}
namespace Urho3D
{


static const Urho3D::StringHash E_MOUSEBUTTONDOWN(Urho3D::GetEventNameRegister().RegisterString("MouseButtonDown")); namespace MouseButtonDown
{
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_MOUSEBUTTONUP(Urho3D::GetEventNameRegister().RegisterString("MouseButtonUp")); namespace MouseButtonUp
{
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_MOUSEMOVE(Urho3D::GetEventNameRegister().RegisterString("MouseMove")); namespace MouseMove
{
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_DX("DX");
    static const Urho3D::StringHash P_DY("DY");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_MOUSEWHEEL(Urho3D::GetEventNameRegister().RegisterString("MouseWheel")); namespace MouseWheel
{
    static const Urho3D::StringHash P_WHEEL("Wheel");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_KEYDOWN(Urho3D::GetEventNameRegister().RegisterString("KeyDown")); namespace KeyDown
{
    static const Urho3D::StringHash P_KEY("Key");
    static const Urho3D::StringHash P_SCANCODE("Scancode");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
    static const Urho3D::StringHash P_REPEAT("Repeat");
}


static const Urho3D::StringHash E_KEYUP(Urho3D::GetEventNameRegister().RegisterString("KeyUp")); namespace KeyUp
{
    static const Urho3D::StringHash P_KEY("Key");
    static const Urho3D::StringHash P_SCANCODE("Scancode");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_TEXTINPUT(Urho3D::GetEventNameRegister().RegisterString("TextInput")); namespace TextInput
{
    static const Urho3D::StringHash P_TEXT("Text");
}


static const Urho3D::StringHash E_TEXTEDITING(Urho3D::GetEventNameRegister().RegisterString("TextEditing")); namespace TextEditing
{
    static const Urho3D::StringHash P_COMPOSITION("Composition");
    static const Urho3D::StringHash P_CURSOR("Cursor");
    static const Urho3D::StringHash P_SELECTION_LENGTH("SelectionLength");
}


static const Urho3D::StringHash E_JOYSTICKCONNECTED(Urho3D::GetEventNameRegister().RegisterString("JoystickConnected")); namespace JoystickConnected
{
    static const Urho3D::StringHash P_JOYSTICKID("JoystickID");
}


static const Urho3D::StringHash E_JOYSTICKDISCONNECTED(Urho3D::GetEventNameRegister().RegisterString("JoystickDisconnected")); namespace JoystickDisconnected
{
    static const Urho3D::StringHash P_JOYSTICKID("JoystickID");
}


static const Urho3D::StringHash E_JOYSTICKBUTTONDOWN(Urho3D::GetEventNameRegister().RegisterString("JoystickButtonDown")); namespace JoystickButtonDown
{
    static const Urho3D::StringHash P_JOYSTICKID("JoystickID");
    static const Urho3D::StringHash P_BUTTON("Button");
}


static const Urho3D::StringHash E_JOYSTICKBUTTONUP(Urho3D::GetEventNameRegister().RegisterString("JoystickButtonUp")); namespace JoystickButtonUp
{
    static const Urho3D::StringHash P_JOYSTICKID("JoystickID");
    static const Urho3D::StringHash P_BUTTON("Button");
}


static const Urho3D::StringHash E_JOYSTICKAXISMOVE(Urho3D::GetEventNameRegister().RegisterString("JoystickAxisMove")); namespace JoystickAxisMove
{
    static const Urho3D::StringHash P_JOYSTICKID("JoystickID");
    static const Urho3D::StringHash P_AXIS("Button");
    static const Urho3D::StringHash P_POSITION("Position");
}


static const Urho3D::StringHash E_JOYSTICKHATMOVE(Urho3D::GetEventNameRegister().RegisterString("JoystickHatMove")); namespace JoystickHatMove
{
    static const Urho3D::StringHash P_JOYSTICKID("JoystickID");
    static const Urho3D::StringHash P_HAT("Button");
    static const Urho3D::StringHash P_POSITION("Position");
}


static const Urho3D::StringHash E_TOUCHBEGIN(Urho3D::GetEventNameRegister().RegisterString("TouchBegin")); namespace TouchBegin
{
    static const Urho3D::StringHash P_TOUCHID("TouchID");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_PRESSURE("Pressure");
}


static const Urho3D::StringHash E_TOUCHEND(Urho3D::GetEventNameRegister().RegisterString("TouchEnd")); namespace TouchEnd
{
    static const Urho3D::StringHash P_TOUCHID("TouchID");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
}


static const Urho3D::StringHash E_TOUCHMOVE(Urho3D::GetEventNameRegister().RegisterString("TouchMove")); namespace TouchMove
{
    static const Urho3D::StringHash P_TOUCHID("TouchID");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_DX("DX");
    static const Urho3D::StringHash P_DY("DY");
    static const Urho3D::StringHash P_PRESSURE("Pressure");
}


static const Urho3D::StringHash E_GESTURERECORDED(Urho3D::GetEventNameRegister().RegisterString("GestureRecorded")); namespace GestureRecorded
{
    static const Urho3D::StringHash P_GESTUREID("GestureID");
}


static const Urho3D::StringHash E_GESTUREINPUT(Urho3D::GetEventNameRegister().RegisterString("GestureInput")); namespace GestureInput
{
    static const Urho3D::StringHash P_GESTUREID("GestureID");
    static const Urho3D::StringHash P_CENTERX("CenterX");
    static const Urho3D::StringHash P_CENTERY("CenterY");
    static const Urho3D::StringHash P_NUMFINGERS("NumFingers");
    static const Urho3D::StringHash P_ERROR("Error");
}


static const Urho3D::StringHash E_MULTIGESTURE(Urho3D::GetEventNameRegister().RegisterString("MultiGesture")); namespace MultiGesture
{
    static const Urho3D::StringHash P_CENTERX("CenterX");
    static const Urho3D::StringHash P_CENTERY("CenterY");
    static const Urho3D::StringHash P_NUMFINGERS("NumFingers");
    static const Urho3D::StringHash P_DTHETA("DTheta");
    static const Urho3D::StringHash P_DDIST("DDist");
}


static const Urho3D::StringHash E_DROPFILE(Urho3D::GetEventNameRegister().RegisterString("DropFile")); namespace DropFile
{
    static const Urho3D::StringHash P_FILENAME("FileName");
}


static const Urho3D::StringHash E_INPUTFOCUS(Urho3D::GetEventNameRegister().RegisterString("InputFocus")); namespace InputFocus
{
    static const Urho3D::StringHash P_FOCUS("Focus");
    static const Urho3D::StringHash P_MINIMIZED("Minimized");
}


static const Urho3D::StringHash E_MOUSEVISIBLECHANGED(Urho3D::GetEventNameRegister().RegisterString("MouseVisibleChanged")); namespace MouseVisibleChanged
{
    static const Urho3D::StringHash P_VISIBLE("Visible");
}


static const Urho3D::StringHash E_MOUSEMODECHANGED(Urho3D::GetEventNameRegister().RegisterString("MouseModeChanged")); namespace MouseModeChanged
{
    static const Urho3D::StringHash P_MODE("Mode");
    static const Urho3D::StringHash P_MOUSELOCKED("MouseLocked");
}


static const Urho3D::StringHash E_EXITREQUESTED(Urho3D::GetEventNameRegister().RegisterString("ExitRequested")); namespace ExitRequested
{
}


static const Urho3D::StringHash E_SDLRAWINPUT(Urho3D::GetEventNameRegister().RegisterString("SDLRawInput")); namespace SDLRawInput
{
    static const Urho3D::StringHash P_SDLEVENT("SDLEvent");
    static const Urho3D::StringHash P_CONSUMED("Consumed");
}


static const Urho3D::StringHash E_INPUTBEGIN(Urho3D::GetEventNameRegister().RegisterString("InputBegin")); namespace InputBegin
{
}


static const Urho3D::StringHash E_INPUTEND(Urho3D::GetEventNameRegister().RegisterString("InputEnd")); namespace InputEnd
{
}

}

struct SDL_Cursor;

namespace Urho3D
{


enum CursorShape
{
    CS_NORMAL = 0,
    CS_IBEAM,
    CS_CROSS,
    CS_RESIZEVERTICAL,
    CS_RESIZEDIAGONAL_TOPRIGHT,
    CS_RESIZEHORIZONTAL,
    CS_RESIZEDIAGONAL_TOPLEFT,
    CS_RESIZE_ALL,
    CS_ACCEPTDROP,
    CS_REJECTDROP,
    CS_BUSY,
    CS_BUSY_ARROW,
    CS_MAX_SHAPES
};


struct __attribute__((visibility("default"))) CursorShapeInfo
{

    CursorShapeInfo() :
        imageRect_(IntRect::ZERO),
        hotSpot_(IntVector2::ZERO),
        osCursor_(nullptr),
        systemDefined_(false),
        systemCursor_(-1)
    {
    }


    explicit CursorShapeInfo(int systemCursor) :
        imageRect_(IntRect::ZERO),
        hotSpot_(IntVector2::ZERO),
        osCursor_(nullptr),
        systemDefined_(false),
        systemCursor_(systemCursor)
    {
    }


    SharedPtr<Image> image_;

    SharedPtr<Texture> texture_;

    IntRect imageRect_;

    IntVector2 hotSpot_;

    SDL_Cursor* osCursor_;

    bool systemDefined_;

    int systemCursor_;
};


class __attribute__((visibility("default"))) Cursor : public BorderImage
{
    public: using ClassName = Cursor; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Cursor", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Cursor(Context* context);

    ~Cursor() override;

    static void RegisterObject(Context* context);


    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;


    void DefineShape(const String& shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot);

    void DefineShape(CursorShape shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot);

    void SetShape(const String& shape);

    void SetShape(CursorShape shape);

    void SetUseSystemShapes(bool enable);


    const String& GetShape() const { return shape_; }


    bool GetUseSystemShapes() const { return useSystemShapes_; }


    void SetShapesAttr(const VariantVector& value);

    VariantVector GetShapesAttr() const;

    void ApplyOSCursorShape();

protected:

    void HandleMouseVisibleChanged(StringHash eventType, VariantMap& eventData);


    String shape_;

    HashMap<String, CursorShapeInfo> shapeInfos_;

    bool useSystemShapes_;

    bool osShapeDirty_;
};

}


namespace Urho3D
{


enum MouseMode
{
    MM_ABSOLUTE = 0,
    MM_RELATIVE,
    MM_WRAP,
    MM_FREE,
    MM_INVALID
};

class Deserializer;
class Graphics;
class Serializer;
class UIElement;
class XMLFile;

const IntVector2 MOUSE_POSITION_OFFSCREEN = IntVector2(M_MIN_INT, M_MIN_INT);


struct TouchState
{

    UIElement* GetTouchedElement();


    int touchID_;

    IntVector2 position_;

    IntVector2 lastPosition_;

    IntVector2 delta_;

    float pressure_;

    WeakPtr<UIElement> touchedElement_;
};


struct JoystickState
{

    void Initialize(unsigned numButtons, unsigned numAxes, unsigned numHats);

    void Reset();


    bool IsController() const { return controller_ != nullptr; }


    unsigned GetNumButtons() const { return buttons_.Size(); }


    unsigned GetNumAxes() const { return axes_.Size(); }


    unsigned GetNumHats() const { return hats_.Size(); }


    bool GetButtonDown(unsigned index) const { return index < buttons_.Size() ? buttons_[index] : false; }


    bool GetButtonPress(unsigned index) const { return index < buttonPress_.Size() ? buttonPress_[index] : false; }


    float GetAxisPosition(unsigned index) const { return index < axes_.Size() ? axes_[index] : 0.0f; }


    int GetHatPosition(unsigned index) const { return index < hats_.Size() ? hats_[index] : HAT_CENTER; }


    SDL_Joystick* joystick_{};

    SDL_JoystickID joystickID_{};

    SDL_GameController* controller_{};

    UIElement* screenJoystick_{};

    String name_;

    PODVector<bool> buttons_;

    PODVector<bool> buttonPress_;

    PODVector<float> axes_;

    PODVector<int> hats_;
};






class __attribute__((visibility("default"))) Input : public Object
{
    public: using ClassName = Input; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Input", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };





public:

    explicit Input(Context* context);

    ~Input() override;


    void Update();

    void SetToggleFullscreen(bool enable);

    void SetMouseVisible(bool enable, bool suppressEvent = false);

    void ResetMouseVisible();

    void SetMouseGrabbed(bool grab, bool suppressEvent = false);

    void ResetMouseGrabbed();
    void SetMouseMode(MouseMode mode, bool suppressEvent = false);

    void ResetMouseMode();







    SDL_JoystickID AddScreenJoystick(XMLFile* layoutFile = nullptr, XMLFile* styleFile = nullptr);





    bool RemoveScreenJoystick(SDL_JoystickID id);

    void SetScreenJoystickVisible(SDL_JoystickID id, bool enable);

    void SetScreenKeyboardVisible(bool enable);

    void SetTouchEmulation(bool enable);

    bool RecordGesture();

    bool SaveGestures(Serializer& dest);

    bool SaveGesture(Serializer& dest, unsigned gestureID);

    unsigned LoadGestures(Deserializer& source);

    bool RemoveGesture(unsigned gestureID);

    void RemoveAllGestures();

    void SetMousePosition(const IntVector2& position);

    void CenterMousePosition();


    Key GetKeyFromName(const String& name) const;

    Key GetKeyFromScancode(Scancode scancode) const;

    String GetKeyName(Key key) const;

    Scancode GetScancodeFromKey(Key key) const;

    Scancode GetScancodeFromName(const String& name) const;

    String GetScancodeName(Scancode scancode) const;

    bool GetKeyDown(Key key) const;

    bool GetKeyPress(Key key) const;

    bool GetScancodeDown(Scancode scancode) const;

    bool GetScancodePress(Scancode scancode) const;

    bool GetMouseButtonDown(MouseButtonFlags button) const;

    bool GetMouseButtonPress(MouseButtonFlags button) const;

    bool GetQualifierDown(Qualifier qualifier) const;

    bool GetQualifierPress(Qualifier qualifier) const;

    QualifierFlags GetQualifiers() const;

    IntVector2 GetMousePosition() const;

    IntVector2 GetMouseMove() const;

    int GetMouseMoveX() const;

    int GetMouseMoveY() const;

    int GetMouseMoveWheel() const { return mouseMoveWheel_; }

    Vector2 GetInputScale() const { return inputScale_; }


    unsigned GetNumTouches() const { return touches_.Size(); }

    TouchState* GetTouch(unsigned index) const;


    unsigned GetNumJoysticks() const { return joysticks_.Size(); }

    JoystickState* GetJoystick(SDL_JoystickID id);

    JoystickState* GetJoystickByIndex(unsigned index);

    JoystickState* GetJoystickByName(const String& name);


    bool GetToggleFullscreen() const { return toggleFullscreen_; }


    bool IsScreenJoystickVisible(SDL_JoystickID id) const;

    bool GetScreenKeyboardSupport() const;

    bool IsScreenKeyboardVisible() const;


    bool GetTouchEmulation() const { return touchEmulation_; }


    bool IsMouseVisible() const { return mouseVisible_; }

    bool IsMouseGrabbed() const { return mouseGrabbed_; }

    bool IsMouseLocked() const;


    MouseMode GetMouseMode() const { return mouseMode_; }


    bool HasFocus() { return inputFocus_; }


    bool IsMinimized() const;

private:

    void Initialize();

    SDL_JoystickID OpenJoystick(unsigned index);

    void ResetJoysticks();

    void GainFocus();

    void LoseFocus();

    void ResetState();

    void ResetTouches();

    void ResetInputAccumulation();

    unsigned GetTouchIndexFromID(int touchID);

    unsigned PopTouchIndex();

    void PushTouchIndex(int touchID);

    void SendInputFocusEvent();

    void SetMouseButton(MouseButton button, bool newState);

    void SetKey(Key key, Scancode scancode, bool newState);

    void SetMouseWheel(int delta);

    void SuppressNextMouseMove();

    void UnsuppressMouseMove();

    void HandleScreenMode(StringHash eventType, VariantMap& eventData);

    void HandleBeginFrame(StringHash eventType, VariantMap& eventData);

    void HandleScreenJoystickTouch(StringHash eventType, VariantMap& eventData);

    void HandleSDLEvent(void* sdlEvent);



    void SetMouseModeRelative(SDL_bool enable);

    void SetMouseModeAbsolute(SDL_bool enable);
    WeakPtr<Graphics> graphics_;

    HashSet<int> keyDown_;

    HashSet<int> keyPress_;

    HashSet<int> scancodeDown_;

    HashSet<int> scancodePress_;

    HashMap<int, TouchState> touches_;

    List<int> availableTouchIDs_;

    HashMap<int, int> touchIDMap_;

    String textInput_;

    HashMap<SDL_JoystickID, JoystickState> joysticks_;

    MouseButtonFlags mouseButtonDown_;

    MouseButtonFlags mouseButtonPress_;

    IntVector2 lastMousePosition_;

    IntVector2 lastVisibleMousePosition_;

    IntVector2 mouseMove_;

    int mouseMoveWheel_;

    Vector2 inputScale_;

    unsigned windowID_;

    bool toggleFullscreen_;

    bool mouseVisible_;

    bool lastMouseVisible_;

    bool mouseGrabbed_;

    bool lastMouseGrabbed_;

    MouseMode mouseMode_;

    MouseMode lastMouseMode_;


    bool sdlMouseRelative_;


    bool touchEmulation_;

    bool inputFocus_;

    bool minimized_;

    bool focusedThisFrame_;

    bool suppressNextMouseMove_;

    bool mouseMoveScaled_;

    bool initialized_;
};

}


namespace Urho3D
{


__attribute__((visibility("default"))) const char* GetRevision();


__attribute__((visibility("default"))) const char* GetCompilerDefines();

}

struct lua_State;

namespace Urho3D
{


class __attribute__((visibility("default"))) LuaFile : public Resource
{
    public: using ClassName = LuaFile; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("LuaFile", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit LuaFile(Context* context);

    ~LuaFile() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;


    bool LoadChunk(lua_State* luaState);

    bool LoadAndExecute(lua_State* luaState);

private:

    unsigned size_;

    SharedArrayPtr<char> data_;

    bool hasLoaded_;

    bool hasExecuted_;
};

}
struct lua_State;
using lua_CFunction = int (*) (lua_State *L);

namespace Urho3D
{

class LuaScript;
class LuaScriptInstance;
class Variant;


class __attribute__((visibility("default"))) LuaFunction : public RefCounted
{
public:

    LuaFunction(lua_State* L, int index);

    LuaFunction(lua_State* L, lua_CFunction func);

    ~LuaFunction() override;


    bool IsValid() const;

    bool BeginCall(const LuaScriptInstance* instance = nullptr);

    bool EndCall(int numReturns = 0);

    void PushInt(int value);

    void PushBool(bool value);

    void PushFloat(float value);

    void PushDouble(double value);

    void PushString(const String& string);

    void PushUserType(void* userType, const char* typeName);


    template <typename T> void PushUserType(const T* userType)
    {
        PushUserType((void*)userType, T::GetTypeName().CString());
    }


    template <typename T> void PushUserType(const T& userType)
    {
        PushUserType((void*)&userType, T::GetTypeName().CString());
    }


    template <typename T> void PushUserType(const T* userType, const char* typeName)
    {
        PushUserType((void*)userType, typeName);
    }


    template <typename T> void PushUserType(const T& userType, const char* typeName)
    {
        PushUserType((void*)&userType, typeName);
    }


    void PushVariant(const Variant& variant, const char* asType = nullptr);

    void PushLuaTable(const char* tableName);

    void PushLuaTable(const String& tableName) { PushLuaTable(tableName.CString()); }


    int GetFunctionRef() const { return functionRef_; }

private:

    lua_State* luaState_;

    int numArguments_;

    int functionRef_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) LuaScriptEventListener
{
public:

    virtual ~LuaScriptEventListener() = default;


    virtual void AddEventHandler(const String& eventName, int index) = 0;

    virtual void AddEventHandler(const String& eventName, const String& functionName) = 0;

    virtual void AddEventHandler(Object* sender, const String& eventName, int index) = 0;

    virtual void AddEventHandler(Object* sender, const String& eventName, const String& functionName) = 0;

    virtual void RemoveEventHandler(const String& eventName) = 0;

    virtual void RemoveEventHandler(Object* sender, const String& eventName) = 0;

    virtual void RemoveEventHandlers(Object* sender) = 0;

    virtual void RemoveAllEventHandlers() = 0;

    virtual void RemoveEventHandlersExcept(const Vector<String>& exceptionNames) = 0;

    virtual bool HasEventHandler(const String& eventName) const = 0;

    virtual bool HasEventHandler(Object* sender, const String& eventName) const = 0;
};

}


struct lua_State;

namespace Urho3D
{

extern const char* LOGIC_CATEGORY;

class LuaFunction;
class LuaScriptEventInvoker;
class Scene;


class __attribute__((visibility("default"))) LuaScript : public Object, public LuaScriptEventListener
{
    public: using ClassName = LuaScript; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("LuaScript", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit LuaScript(Context* context);

    ~LuaScript() override;


    void AddEventHandler(const String& eventName, int index) override;

    void AddEventHandler(const String& eventName, const String& functionName) override;

    void AddEventHandler(Object* sender, const String& eventName, int index) override;

    void AddEventHandler(Object* sender, const String& eventName, const String& functionName) override;

    void RemoveEventHandler(const String& eventName) override;

    void RemoveEventHandler(Object* sender, const String& eventName) override;

    void RemoveEventHandlers(Object* sender) override;

    void RemoveAllEventHandlers() override;

    void RemoveEventHandlersExcept(const Vector<String>& exceptionNames) override;

    bool HasEventHandler(const String& eventName) const override;

    bool HasEventHandler(Object* sender, const String& eventName) const override;


    bool ExecuteFile(const String& fileName);

    bool ExecuteString(const String& string);

    bool LoadRawFile(const String& fileName);

    bool ExecuteRawFile(const String& fileName);

    bool ExecuteFunction(const String& functionName);

    void SetExecuteConsoleCommands(bool enable);


    lua_State* GetState() const { return luaState_; }


    LuaFunction* GetFunction(int index);

    LuaFunction* GetFunction(const String& functionName, bool silentIfNotFound = false);


    bool GetExecuteConsoleCommands() const { return executeConsoleCommands_; }


    static bool PushLuaFunction(lua_State* L, const String& functionName);

private:

    void RegisterLoader();

    void ReplacePrint();

    void HandlePostUpdate(StringHash eventType, VariantMap& eventData);

    void HandleConsoleCommand(StringHash eventType, VariantMap& eventData);


    static int AtPanic(lua_State* L);

    static int Loader(lua_State* L);

    static int Print(lua_State* L);


    lua_State* luaState_;

    SharedPtr<LuaScriptEventInvoker> eventInvoker_;

    LuaFunction* coroutineUpdate_;

    bool executeConsoleCommands_;

    HashMap<const void*, SharedPtr<LuaFunction> > functionPointerToFunctionMap_;

    HashMap<String, SharedPtr<LuaFunction> > functionNameToFunctionMap_;
};


void __attribute__((visibility("default"))) RegisterLuaScriptLibrary(Context* context);

}
namespace Urho3D
{

class LuaFunction;
class LuaScriptInstance;


class LuaScriptEventInvoker : public Object
{
    public: using ClassName = LuaScriptEventInvoker; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("LuaScriptEventInvoker", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit LuaScriptEventInvoker(Context* context);

    explicit LuaScriptEventInvoker(LuaScriptInstance* instance);

    ~LuaScriptEventInvoker() override;


    void AddEventHandler(Object* sender, const StringHash& eventType, LuaFunction* function);

private:

    void HandleLuaScriptEvent(StringHash eventType, VariantMap& eventData);


    WeakPtr<LuaScriptInstance> instance_;
};

}

struct lua_State;

namespace Urho3D
{

class LuaFile;
class LuaFunction;
class LuaScript;
class LuaScriptEventInvoker;


enum LuaScriptObjectMethod
{
    LSOM_START = 0,
    LSOM_STOP,
    LSOM_DELAYEDSTART,
    LSOM_UPDATE,
    LSOM_POSTUPDATE,
    LSOM_FIXEDUPDATE,
    LSOM_FIXEDPOSTUPDATE,
    LSOM_LOAD,
    LSOM_SAVE,
    LSOM_READNETWORKUPDATE,
    LSOM_WRITENETWORKUPDATE,
    LSOM_APPLYATTRIBUTES,
    LSOM_TRANSFORMCHANGED,
    MAX_LUA_SCRIPT_OBJECT_METHODS
};


class __attribute__((visibility("default"))) LuaScriptInstance : public Component, public LuaScriptEventListener
{
    public: using ClassName = LuaScriptInstance; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("LuaScriptInstance", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit LuaScriptInstance(Context* context);

    ~LuaScriptInstance() override;

    static void RegisterObject(Context* context);


    void OnSetAttribute(const AttributeInfo& attr, const Variant& src) override;

    void OnGetAttribute(const AttributeInfo& attr, Variant& dest) const override;


    const Vector<AttributeInfo>* GetAttributes() const override { return &attributeInfos_; }


    void ApplyAttributes() override;

    void OnSetEnabled() override;


    void AddEventHandler(const String& eventName, int functionIndex) override;

    void AddEventHandler(const String& eventName, const String& functionName) override;

    void AddEventHandler(Object* sender, const String& eventName, int functionIndex) override;

    void AddEventHandler(Object* sender, const String& eventName, const String& functionName) override;

    void RemoveEventHandler(const String& eventName) override;

    void RemoveEventHandler(Object* sender, const String& eventName) override;

    void RemoveEventHandlers(Object* sender) override;

    void RemoveAllEventHandlers() override;

    void RemoveEventHandlersExcept(const Vector<String>& exceptionNames) override;

    bool HasEventHandler(const String& eventName) const override;

    bool HasEventHandler(Object* sender, const String& eventName) const override;


    bool CreateObject(const String& scriptObjectType);

    bool CreateObject(LuaFile* scriptFile, const String& scriptObjectType);

    void SetScriptFile(LuaFile* scriptFile);

    void SetScriptObjectType(const String& scriptObjectType);

    void SetScriptDataAttr(const PODVector<unsigned char>& data);

    void SetScriptNetworkDataAttr(const PODVector<unsigned char>& data);


    LuaFile* GetScriptFile() const;


    const String& GetScriptObjectType() const { return scriptObjectType_; }


    int GetScriptObjectRef() const { return scriptObjectRef_; }


    PODVector<unsigned char> GetScriptDataAttr() const;

    PODVector<unsigned char> GetScriptNetworkDataAttr() const;

    LuaFunction* GetScriptObjectFunction(const String& functionName) const;


    void SetScriptFileAttr(const ResourceRef& value);

    ResourceRef GetScriptFileAttr() const;

protected:

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

private:

    void GetScriptAttributes();

    void FindScriptObjectMethodRefs();

    void SubscribeToScriptMethodEvents();

    void UnsubscribeFromScriptMethodEvents();

    void HandleUpdate(StringHash eventType, VariantMap& eventData);

    void HandlePostUpdate(StringHash eventType, VariantMap& eventData);


    void HandleFixedUpdate(StringHash eventType, VariantMap& eventData);

    void HandlePostFixedUpdate(StringHash eventType, VariantMap& eventData);


    void ReleaseObject();


    LuaScript* luaScript_{};

    lua_State* luaState_{};

    SharedPtr<LuaScriptEventInvoker> eventInvoker_;

    SharedPtr<LuaFile> scriptFile_;

    String scriptObjectType_;

    Vector<AttributeInfo> attributeInfos_;

    int scriptObjectRef_{};

    LuaFunction* scriptObjectMethods_[MAX_LUA_SCRIPT_OBJECT_METHODS]{};
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) AreaAllocator
{
public:

    AreaAllocator();

    AreaAllocator(int width, int height, bool fastMode = true);

    AreaAllocator(int width, int height, int maxWidth, int maxHeight, bool fastMode = true);


    void Reset(int width, int height, int maxWidth = 0, int maxHeight = 0, bool fastMode = true);

    bool Allocate(int width, int height, int& x, int& y);


    int GetWidth() const { return size_.x_; }


    int GetHeight() const { return size_.y_; }


    bool GetFastMode() const { return fastMode_; }

private:

    bool SplitRect(unsigned freeAreaIndex, const IntRect& reserve);

    void Cleanup();


    PODVector<IntRect> freeAreas_;

    IntVector2 size_;

    IntVector2 maxSize_;

    bool doubleWidth_{true};

    bool fastMode_{true};
};

}




namespace Urho3D
{


class __attribute__((visibility("default"))) Matrix2
{
public:

    Matrix2() noexcept :
        m00_(1.0f),
        m01_(0.0f),
        m10_(0.0f),
        m11_(1.0f)
    {
    }


    Matrix2(const Matrix2& matrix) noexcept = default;


    Matrix2(float v00, float v01,
            float v10, float v11) noexcept :
        m00_(v00),
        m01_(v01),
        m10_(v10),
        m11_(v11)
    {
    }


    explicit Matrix2(const float* data) noexcept :
        m00_(data[0]),
        m01_(data[1]),
        m10_(data[2]),
        m11_(data[3])
    {
    }


    Matrix2& operator =(const Matrix2& rhs) noexcept = default;


    bool operator ==(const Matrix2& rhs) const
    {
        const float* leftData = Data();
        const float* rightData = rhs.Data();

        for (unsigned i = 0; i != 4; ++i)
        {
            if (leftData[i] != rightData[i])
                return false;
        }

        return true;
    }


    bool operator !=(const Matrix2& rhs) const { return !(*this == rhs); }


    Vector2 operator *(const Vector2& rhs) const
    {
        return Vector2(
            m00_ * rhs.x_ + m01_ * rhs.y_,
            m10_ * rhs.x_ + m11_ * rhs.y_
        );
    }


    Matrix2 operator +(const Matrix2& rhs) const
    {
        return Matrix2(
            m00_ + rhs.m00_,
            m01_ + rhs.m01_,
            m10_ + rhs.m10_,
            m11_ + rhs.m11_
        );
    }


    Matrix2 operator -(const Matrix2& rhs) const
    {
        return Matrix2(
            m00_ - rhs.m00_,
            m01_ - rhs.m01_,
            m10_ - rhs.m10_,
            m11_ - rhs.m11_
        );
    }


    Matrix2 operator *(float rhs) const
    {
        return Matrix2(
            m00_ * rhs,
            m01_ * rhs,
            m10_ * rhs,
            m11_ * rhs
        );
    }


    Matrix2 operator *(const Matrix2& rhs) const
    {
        return Matrix2(
            m00_ * rhs.m00_ + m01_ * rhs.m10_,
            m00_ * rhs.m01_ + m01_ * rhs.m11_,
            m10_ * rhs.m00_ + m11_ * rhs.m10_,
            m10_ * rhs.m01_ + m11_ * rhs.m11_
        );
    }


    void SetScale(const Vector2& scale)
    {
        m00_ = scale.x_;
        m11_ = scale.y_;
    }


    void SetScale(float scale)
    {
        m00_ = scale;
        m11_ = scale;
    }


    Vector2 Scale() const
    {
        return Vector2(
            sqrtf(m00_ * m00_ + m10_ * m10_),
            sqrtf(m01_ * m01_ + m11_ * m11_)
        );
    }


    Matrix2 Transpose() const
    {
        return Matrix2(
            m00_,
            m10_,
            m01_,
            m11_
        );
    }


    Matrix2 Scaled(const Vector2& scale) const
    {
        return Matrix2(
            m00_ * scale.x_,
            m01_ * scale.y_,
            m10_ * scale.x_,
            m11_ * scale.y_
        );
    }


    bool Equals(const Matrix2& rhs) const
    {
        const float* leftData = Data();
        const float* rightData = rhs.Data();

        for (unsigned i = 0; i != 4; ++i)
        {
            if (!Urho3D::Equals(leftData[i], rightData[i]))
                return false;
        }

        return true;
    }


    Matrix2 Inverse() const;


    const float* Data() const { return &m00_; }


    String ToString() const;

    float m00_;
    float m01_;
    float m10_;
    float m11_;


    static void BulkTranspose(float* dest, const float* src, unsigned count)
    {
        for (unsigned i = 0; i < count; ++i)
        {
            dest[0] = src[0];
            dest[1] = src[2];
            dest[2] = src[1];
            dest[3] = src[3];

            dest += 4;
            src += 4;
        }
    }


    static const Matrix2 ZERO;

    static const Matrix2 IDENTITY;
};


inline Matrix2 operator *(float lhs, const Matrix2& rhs) { return rhs * lhs; }

}
using dtPolyRef = unsigned int;


class dtCrowd;
class dtQueryFilter;
struct dtCrowdAgent;

namespace Urho3D
{

class CrowdAgent;
class NavigationMesh;


struct CrowdObstacleAvoidanceParams
{
    float velBias;
    float weightDesVel;
    float weightCurVel;
    float weightSide;
    float weightToi;
    float horizTime;
    unsigned char gridSize;
    unsigned char adaptiveDivs;
    unsigned char adaptiveRings;
    unsigned char adaptiveDepth;
};


class __attribute__((visibility("default"))) CrowdManager : public Component
{
    public: using ClassName = CrowdManager; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CrowdManager", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class CrowdAgent;

public:

    explicit CrowdManager(Context* context);

    ~CrowdManager() override;

    static void RegisterObject(Context* context);

    void ApplyAttributes() override;


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;

    void DrawDebugGeometry(bool depthTest);


    void SetCrowdTarget(const Vector3& position, Node* node = nullptr);

    void SetCrowdVelocity(const Vector3& velocity, Node* node = nullptr);

    void ResetCrowdTarget(Node* node = nullptr);

    void SetMaxAgents(unsigned maxAgents);

    void SetMaxAgentRadius(float maxAgentRadius);

    void SetNavigationMesh(NavigationMesh* navMesh);

    void SetQueryFilterTypesAttr(const VariantVector& value);

    void SetIncludeFlags(unsigned queryFilterType, unsigned short flags);

    void SetExcludeFlags(unsigned queryFilterType, unsigned short flags);

    void SetAreaCost(unsigned queryFilterType, unsigned areaID, float cost);

    void SetObstacleAvoidanceTypesAttr(const VariantVector& value);

    void SetObstacleAvoidanceParams(unsigned obstacleAvoidanceType, const CrowdObstacleAvoidanceParams& params);


    PODVector<CrowdAgent*> GetAgents(Node* node = nullptr, bool inCrowdFilter = true) const;

    Vector3 FindNearestPoint(const Vector3& point, int queryFilterType, dtPolyRef* nearestRef = nullptr);

    Vector3 MoveAlongSurface(const Vector3& start, const Vector3& end, int queryFilterType, int maxVisited = 3);

    void FindPath(PODVector<Vector3>& dest, const Vector3& start, const Vector3& end, int queryFilterType);

    Vector3 GetRandomPoint(int queryFilterType, dtPolyRef* randomRef = nullptr);

    Vector3 GetRandomPointInCircle(const Vector3& center, float radius, int queryFilterType, dtPolyRef* randomRef = nullptr);

    float GetDistanceToWall(const Vector3& point, float radius, int queryFilterType, Vector3* hitPos = nullptr, Vector3* hitNormal = nullptr);

    Vector3 Raycast(const Vector3& start, const Vector3& end, int queryFilterType, Vector3* hitNormal = nullptr);


    unsigned GetMaxAgents() const { return maxAgents_; }


    float GetMaxAgentRadius() const { return maxAgentRadius_; }


    NavigationMesh* GetNavigationMesh() const { return navigationMesh_; }


    unsigned GetNumQueryFilterTypes() const { return numQueryFilterTypes_; }


    unsigned GetNumAreas(unsigned queryFilterType) const;

    VariantVector GetQueryFilterTypesAttr() const;

    unsigned short GetIncludeFlags(unsigned queryFilterType) const;

    unsigned short GetExcludeFlags(unsigned queryFilterType) const;

    float GetAreaCost(unsigned queryFilterType, unsigned areaID) const;


    unsigned GetNumObstacleAvoidanceTypes() const { return numObstacleAvoidanceTypes_; }


    VariantVector GetObstacleAvoidanceTypesAttr() const;

    const CrowdObstacleAvoidanceParams& GetObstacleAvoidanceParams(unsigned obstacleAvoidanceType) const;

protected:

    bool CreateCrowd();

    int AddAgent(CrowdAgent* agent, const Vector3& pos);

    void RemoveAgent(CrowdAgent* agent);

protected:

    void OnSceneSet(Scene* scene) override;

    void Update(float delta);

    const dtCrowdAgent* GetDetourCrowdAgent(int agent) const;

    const dtQueryFilter* GetDetourQueryFilter(unsigned queryFilterType) const;


    dtCrowd* GetCrowd() const { return crowd_; }

private:

    void HandleSceneSubsystemUpdate(StringHash eventType, VariantMap& eventData);

    void HandleNavMeshChanged(StringHash eventType, VariantMap& eventData);

    void HandleComponentAdded(StringHash eventType, VariantMap& eventData);


    dtCrowd* crowd_{};

    WeakPtr<NavigationMesh> navigationMesh_;

    unsigned navigationMeshId_{};

    unsigned maxAgents_{};

    float maxAgentRadius_{};

    unsigned numQueryFilterTypes_{};

    PODVector<unsigned> numAreas_;

    unsigned numObstacleAvoidanceTypes_{};
};

}


namespace Urho3D
{

enum CrowdAgentRequestedTarget
{
    CA_REQUESTEDTARGET_NONE = 0,
    CA_REQUESTEDTARGET_POSITION,
    CA_REQUESTEDTARGET_VELOCITY
};

enum CrowdAgentTargetState
{
    CA_TARGET_NONE = 0,
    CA_TARGET_FAILED,
    CA_TARGET_VALID,
    CA_TARGET_REQUESTING,
    CA_TARGET_WAITINGFORQUEUE,
    CA_TARGET_WAITINGFORPATH,
    CA_TARGET_VELOCITY
};

enum CrowdAgentState
{
    CA_STATE_INVALID = 0,
    CA_STATE_WALKING,
    CA_STATE_OFFMESH
};

enum NavigationQuality
{
    NAVIGATIONQUALITY_LOW = 0,
    NAVIGATIONQUALITY_MEDIUM = 1,
    NAVIGATIONQUALITY_HIGH = 2
};

enum NavigationPushiness
{
    NAVIGATIONPUSHINESS_LOW = 0,
    NAVIGATIONPUSHINESS_MEDIUM,
    NAVIGATIONPUSHINESS_HIGH,
    NAVIGATIONPUSHINESS_NONE
};


class __attribute__((visibility("default"))) CrowdAgent : public Component
{
    public: using ClassName = CrowdAgent; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CrowdAgent", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class CrowdManager;
    friend void CrowdAgentUpdateCallback(dtCrowdAgent* ag, float dt);

public:

    explicit CrowdAgent(Context* context);

    ~CrowdAgent() override;

    static void RegisterObject(Context* context);

    void ApplyAttributes() override;


    void OnSetEnabled() override;

    void DrawDebugGeometry(bool depthTest);

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetTargetPosition(const Vector3& position);

    void SetTargetVelocity(const Vector3& velocity);

    void ResetTarget();

    void SetUpdateNodePosition(bool unodepos);

    void SetMaxAccel(float maxAccel);

    void SetMaxSpeed(float maxSpeed);

    void SetRadius(float radius);

    void SetHeight(float height);

    void SetQueryFilterType(unsigned queryFilterType);

    void SetObstacleAvoidanceType(unsigned obstacleAvoidanceType);

    void SetNavigationQuality(NavigationQuality val);

    void SetNavigationPushiness(NavigationPushiness val);


    Vector3 GetPosition() const;

    Vector3 GetDesiredVelocity() const;

    Vector3 GetActualVelocity() const;


    const Vector3& GetTargetPosition() const { return targetPosition_; }


    const Vector3& GetTargetVelocity() const { return targetVelocity_; }


    CrowdAgentRequestedTarget GetRequestedTargetType() const { return requestedTargetType_; }


    CrowdAgentState GetAgentState() const;

    CrowdAgentTargetState GetTargetState() const;


    bool GetUpdateNodePosition() const { return updateNodePosition_; }


    int GetAgentCrowdId() const { return agentCrowdId_; }


    float GetMaxAccel() const { return maxAccel_; }


    float GetMaxSpeed() const { return maxSpeed_; }


    float GetRadius() const { return radius_; }


    float GetHeight() const { return height_; }


    unsigned GetQueryFilterType() const { return queryFilterType_; }


    unsigned GetObstacleAvoidanceType() const { return obstacleAvoidanceType_; }


    NavigationQuality GetNavigationQuality() const { return navQuality_; }


    NavigationPushiness GetNavigationPushiness() const { return navPushiness_; }


    bool HasRequestedTarget() const { return requestedTargetType_ != CA_REQUESTEDTARGET_NONE; }


    bool HasArrived() const;

    bool IsInCrowd() const;

protected:

    virtual void OnCrowdUpdate(dtCrowdAgent* ag, float dt);

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

    const dtCrowdAgent* GetDetourCrowdAgent() const;

    void HandleNavigationTileAdded(StringHash eventType, VariantMap& eventData);

private:

    void UpdateParameters(unsigned scope = M_MAX_UNSIGNED);

    int AddAgentToCrowd(bool force = false);

    void RemoveAgentFromCrowd();

    WeakPtr<CrowdManager> crowdManager_;

    int agentCrowdId_;

    Vector3 targetPosition_;

    Vector3 targetVelocity_;

    CrowdAgentRequestedTarget requestedTargetType_;

    bool updateNodePosition_;

    float maxAccel_;

    float maxSpeed_;

    float radius_;

    float height_;

    unsigned queryFilterType_;

    unsigned obstacleAvoidanceType_;

    NavigationQuality navQuality_;

    NavigationPushiness navPushiness_;

    Vector3 previousPosition_;

    CrowdAgentTargetState previousTargetState_;

    CrowdAgentState previousAgentState_;

    bool ignoreTransformChanges_;
};

}

using dtPolyRef = unsigned int;


class dtNavMesh;
class dtNavMeshQuery;
class dtQueryFilter;

namespace Urho3D
{

enum NavmeshPartitionType
{
    NAVMESH_PARTITION_WATERSHED = 0,
    NAVMESH_PARTITION_MONOTONE
};

class Geometry;
class NavArea;

struct FindPathData;
struct NavBuildData;


struct NavigationGeometryInfo
{

    Component* component_;

    unsigned lodLevel_;

    Matrix3x4 transform_;

    BoundingBox boundingBox_;

};


enum NavigationPathPointFlag
{
    NAVPATHFLAG_NONE = 0,
    NAVPATHFLAG_START = 0x01,
    NAVPATHFLAG_END = 0x02,
    NAVPATHFLAG_OFF_MESH = 0x04
};

struct __attribute__((visibility("default"))) NavigationPathPoint
{

    Vector3 position_;

    NavigationPathPointFlag flag_;

    unsigned char areaID_;
};


class __attribute__((visibility("default"))) NavigationMesh : public Component
{
    public: using ClassName = NavigationMesh; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("NavigationMesh", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class CrowdManager;

public:

    explicit NavigationMesh(Context* context);

    ~NavigationMesh() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetTileSize(int size);

    void SetCellSize(float size);

    void SetCellHeight(float height);

    void SetAgentHeight(float height);

    void SetAgentRadius(float radius);

    void SetAgentMaxClimb(float maxClimb);

    void SetAgentMaxSlope(float maxSlope);

    void SetRegionMinSize(float size);

    void SetRegionMergeSize(float size);

    void SetEdgeMaxLength(float length);

    void SetEdgeMaxError(float error);

    void SetDetailSampleDistance(float distance);

    void SetDetailSampleMaxError(float error);

    void SetPadding(const Vector3& padding);

    void SetAreaCost(unsigned areaID, float cost);

    virtual bool Allocate(const BoundingBox& boundingBox, unsigned maxTiles);

    virtual bool Build();

    virtual bool Build(const BoundingBox& boundingBox);

    virtual bool Build(const IntVector2& from, const IntVector2& to);

    virtual PODVector<unsigned char> GetTileData(const IntVector2& tile) const;

    virtual bool AddTile(const PODVector<unsigned char>& tileData);

    virtual void RemoveTile(const IntVector2& tile);

    virtual void RemoveAllTiles();

    bool HasTile(const IntVector2& tile) const;

    BoundingBox GetTileBoundingBox(const IntVector2& tile) const;

    IntVector2 GetTileIndex(const Vector3& position) const;

    Vector3 FindNearestPoint
        (const Vector3& point, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr, dtPolyRef* nearestRef = nullptr);

    Vector3 MoveAlongSurface(const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE, int maxVisited = 3,
        const dtQueryFilter* filter = nullptr);

    void FindPath(PODVector<Vector3>& dest, const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE,
        const dtQueryFilter* filter = nullptr);

    void FindPath
        (PODVector<NavigationPathPoint>& dest, const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE,
            const dtQueryFilter* filter = nullptr);

    Vector3 GetRandomPoint(const dtQueryFilter* filter = nullptr, dtPolyRef* randomRef = nullptr);

    Vector3 GetRandomPointInCircle
        (const Vector3& center, float radius, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr,
            dtPolyRef* randomRef = nullptr);

    float GetDistanceToWall
        (const Vector3& point, float radius, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr,
            Vector3* hitPos = nullptr, Vector3* hitNormal = nullptr);

    Vector3 Raycast
        (const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr,
            Vector3* hitNormal = nullptr);

    void DrawDebugGeometry(bool depthTest);


    String GetMeshName() const { return meshName_; }


    void SetMeshName(const String& newName);


    int GetTileSize() const { return tileSize_; }


    float GetCellSize() const { return cellSize_; }


    float GetCellHeight() const { return cellHeight_; }


    float GetAgentHeight() const { return agentHeight_; }


    float GetAgentRadius() const { return agentRadius_; }


    float GetAgentMaxClimb() const { return agentMaxClimb_; }


    float GetAgentMaxSlope() const { return agentMaxSlope_; }


    float GetRegionMinSize() const { return regionMinSize_; }


    float GetRegionMergeSize() const { return regionMergeSize_; }


    float GetEdgeMaxLength() const { return edgeMaxLength_; }


    float GetEdgeMaxError() const { return edgeMaxError_; }


    float GetDetailSampleDistance() const { return detailSampleDistance_; }


    float GetDetailSampleMaxError() const { return detailSampleMaxError_; }


    const Vector3& GetPadding() const { return padding_; }


    float GetAreaCost(unsigned areaID) const;


    bool IsInitialized() const { return navMesh_ != nullptr; }


    const BoundingBox& GetBoundingBox() const { return boundingBox_; }


    BoundingBox GetWorldBoundingBox() const;


    IntVector2 GetNumTiles() const { return IntVector2(numTilesX_, numTilesZ_); }


    void SetPartitionType(NavmeshPartitionType partitionType);


    NavmeshPartitionType GetPartitionType() const { return partitionType_; }


    virtual void SetNavigationDataAttr(const PODVector<unsigned char>& value);

    virtual PODVector<unsigned char> GetNavigationDataAttr() const;


    void SetDrawOffMeshConnections(bool enable) { drawOffMeshConnections_ = enable; }


    bool GetDrawOffMeshConnections() const { return drawOffMeshConnections_; }


    void SetDrawNavAreas(bool enable) { drawNavAreas_ = enable; }


    bool GetDrawNavAreas() const { return drawNavAreas_; }

private:

    void WriteTile(Serializer& dest, int x, int z) const;

    bool ReadTile(Deserializer& source, bool silent);

protected:

    void CollectGeometries(Vector<NavigationGeometryInfo>& geometryList);

    void CollectGeometries(Vector<NavigationGeometryInfo>& geometryList, Node* node, HashSet<Node*>& processedNodes, bool recursive);

    void GetTileGeometry(NavBuildData* build, Vector<NavigationGeometryInfo>& geometryList, BoundingBox& box);

    void AddTriMeshGeometry(NavBuildData* build, Geometry* geometry, const Matrix3x4& transform);

    virtual bool BuildTile(Vector<NavigationGeometryInfo>& geometryList, int x, int z);

    unsigned BuildTiles(Vector<NavigationGeometryInfo>& geometryList, const IntVector2& from, const IntVector2& to);

    bool InitializeQuery();

    virtual void ReleaseNavigationMesh();


    String meshName_;

    dtNavMesh* navMesh_;

    dtNavMeshQuery* navMeshQuery_;

    UniquePtr<dtQueryFilter> queryFilter_;

    UniquePtr<FindPathData> pathData_;

    int tileSize_;

    float cellSize_;

    float cellHeight_;

    float agentHeight_;

    float agentRadius_;

    float agentMaxClimb_;

    float agentMaxSlope_;

    float regionMinSize_;

    float regionMergeSize_;

    float edgeMaxLength_;

    float edgeMaxError_;

    float detailSampleDistance_;

    float detailSampleMaxError_;

    Vector3 padding_;

    int numTilesX_;

    int numTilesZ_;

    BoundingBox boundingBox_;

    NavmeshPartitionType partitionType_;

    bool keepInterResults_;

    bool drawOffMeshConnections_;

    bool drawNavAreas_;

    Vector<WeakPtr<NavArea> > areas_;
};


void __attribute__((visibility("default"))) RegisterNavigationLibrary(Context* context);

}

class dtTileCache;
struct dtTileCacheAlloc;
struct dtTileCacheCompressor;
struct dtTileCacheMeshProcess;
struct dtTileCacheLayer;
struct dtTileCacheContourSet;
struct dtTileCachePolyMesh;

namespace Urho3D
{

class OffMeshConnection;
class Obstacle;

class __attribute__((visibility("default"))) DynamicNavigationMesh : public NavigationMesh
{
    public: using ClassName = DynamicNavigationMesh; using BaseClassName = NavigationMesh; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("DynamicNavigationMesh", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

    friend class Obstacle;
    friend struct MeshProcess;

public:

    explicit DynamicNavigationMesh(Context*);

    ~DynamicNavigationMesh() override;


    static void RegisterObject(Context*);


    bool Allocate(const BoundingBox& boundingBox, unsigned maxTiles) override;

    bool Build() override;

    bool Build(const BoundingBox& boundingBox) override;

    bool Build(const IntVector2& from, const IntVector2& to) override;

    PODVector<unsigned char> GetTileData(const IntVector2& tile) const override;

    bool IsObstacleInTile(Obstacle* obstacle, const IntVector2& tile) const;

    bool AddTile(const PODVector<unsigned char>& tileData) override;

    void RemoveTile(const IntVector2& tile) override;

    void RemoveAllTiles() override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;

    void DrawDebugGeometry(bool depthTest);


    void SetNavigationDataAttr(const PODVector<unsigned char>& value) override;

    PODVector<unsigned char> GetNavigationDataAttr() const override;


    void SetMaxObstacles(unsigned maxObstacles) { maxObstacles_ = maxObstacles; }

    void SetMaxLayers(unsigned maxLayers);


    unsigned GetMaxObstacles() const { return maxObstacles_; }

    unsigned GetMaxLayers() const { return maxLayers_; }


    void SetDrawObstacles(bool enable) { drawObstacles_ = enable; }


    bool GetDrawObstacles() const { return drawObstacles_; }

protected:
    struct TileCacheData;


    void OnSceneSet(Scene* scene) override;

    void HandleSceneSubsystemUpdate(StringHash eventType, VariantMap& eventData);


    void AddObstacle(Obstacle* obstacle, bool silent = false);

    void ObstacleChanged(Obstacle* obstacle);

    void RemoveObstacle(Obstacle*, bool silent = false);


    int BuildTile(Vector<NavigationGeometryInfo>& geometryList, int x, int z, TileCacheData* tiles);

    unsigned BuildTiles(Vector<NavigationGeometryInfo>& geometryList, const IntVector2& from, const IntVector2& to);

    PODVector<OffMeshConnection*> CollectOffMeshConnections(const BoundingBox& bounds);

    void ReleaseNavigationMesh() override;

private:

    void WriteTiles(Serializer& dest, int x, int z) const;

    bool ReadTiles(Deserializer& source, bool silent);

    void ReleaseTileCache();


    dtTileCache* tileCache_{};

    UniquePtr<dtTileCacheAlloc> allocator_;

    UniquePtr<dtTileCacheCompressor> compressor_;

    UniquePtr<dtTileCacheMeshProcess> meshProcessor_;

    unsigned maxObstacles_{1024};

    unsigned maxLayers_{};

    bool drawObstacles_{};

    PODVector<IntVector2> tileQueue_;
};

}
namespace Urho3D
{

class __attribute__((visibility("default"))) NavArea : public Component
{
    public: using ClassName = NavArea; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("NavArea", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit NavArea(Context*);

    ~NavArea() override;

    static void RegisterObject(Context*);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    unsigned GetAreaID() const { return (unsigned)areaID_; }


    void SetAreaID(unsigned newID);


    BoundingBox GetBoundingBox() const { return boundingBox_; }


    void SetBoundingBox(const BoundingBox& bnds) { boundingBox_ = bnds; }


    BoundingBox GetWorldBoundingBox() const;

private:

    BoundingBox boundingBox_;

    unsigned char areaID_;
};

}
class rcContext;

struct dtTileCacheContourSet;
struct dtTileCachePolyMesh;
struct dtTileCacheAlloc;
struct rcCompactHeightfield;
struct rcContourSet;
struct rcHeightfield;
struct rcHeightfieldLayerSet;
struct rcPolyMesh;
struct rcPolyMeshDetail;

namespace Urho3D
{


struct __attribute__((visibility("default"))) NavAreaStub
{

    BoundingBox bounds_;

    unsigned char areaID_;
};


struct __attribute__((visibility("default"))) NavBuildData
{

    NavBuildData();

    virtual ~NavBuildData();


    BoundingBox worldBoundingBox_;

    PODVector<Vector3> vertices_;

    PODVector<int> indices_;

    PODVector<Vector3> offMeshVertices_;

    PODVector<float> offMeshRadii_;

    PODVector<unsigned short> offMeshFlags_;

    PODVector<unsigned char> offMeshAreas_;

    PODVector<unsigned char> offMeshDir_;

    rcContext* ctx_;

    rcHeightfield* heightField_;

    rcCompactHeightfield* compactHeightField_;

    PODVector<NavAreaStub> navAreas_;
};

struct SimpleNavBuildData : public NavBuildData
{

    SimpleNavBuildData();

    ~SimpleNavBuildData() override;


    rcContourSet* contourSet_;

    rcPolyMesh* polyMesh_;

    rcPolyMeshDetail* polyMeshDetail_;
};

struct DynamicNavBuildData : public NavBuildData
{

    explicit DynamicNavBuildData(dtTileCacheAlloc* allocator);

    ~DynamicNavBuildData() override;


    dtTileCacheContourSet* contourSet_;

    dtTileCachePolyMesh* polyMesh_;

    rcHeightfieldLayerSet* heightFieldLayers_;

    dtTileCacheAlloc* alloc_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) Navigable : public Component
{
    public: using ClassName = Navigable; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Navigable", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Navigable(Context* context);

    ~Navigable() override;

    static void RegisterObject(Context* context);


    void SetRecursive(bool enable);


    bool IsRecursive() const { return recursive_; }

private:

    bool recursive_;
};

}
namespace Urho3D
{


static const Urho3D::StringHash E_NAVIGATION_MESH_REBUILT(Urho3D::GetEventNameRegister().RegisterString("NavigationMeshRebuilt")); namespace NavigationMeshRebuilt
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_MESH("Mesh");
}


static const Urho3D::StringHash E_NAVIGATION_AREA_REBUILT(Urho3D::GetEventNameRegister().RegisterString("NavigationAreaRebuilt")); namespace NavigationAreaRebuilt
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_MESH("Mesh");
    static const Urho3D::StringHash P_BOUNDSMIN("BoundsMin");
    static const Urho3D::StringHash P_BOUNDSMAX("BoundsMax");
}


static const Urho3D::StringHash E_NAVIGATION_TILE_ADDED(Urho3D::GetEventNameRegister().RegisterString("NavigationTileAdded")); namespace NavigationTileAdded
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_MESH("Mesh");
    static const Urho3D::StringHash P_TILE("Tile");
}


static const Urho3D::StringHash E_NAVIGATION_TILE_REMOVED(Urho3D::GetEventNameRegister().RegisterString("NavigationTileRemoved")); namespace NavigationTileRemoved
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_MESH("Mesh");
    static const Urho3D::StringHash P_TILE("Tile");
}


static const Urho3D::StringHash E_NAVIGATION_ALL_TILES_REMOVED(Urho3D::GetEventNameRegister().RegisterString("NavigationAllTilesRemoved")); namespace NavigationAllTilesRemoved
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_MESH("Mesh");
}


static const Urho3D::StringHash E_CROWD_AGENT_FORMATION(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentFormation")); namespace CrowdAgentFormation
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_INDEX("Index");
    static const Urho3D::StringHash P_SIZE("Size");
    static const Urho3D::StringHash P_POSITION("Position");
}


static const Urho3D::StringHash E_CROWD_AGENT_NODE_FORMATION(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentNodeFormation")); namespace CrowdAgentNodeFormation
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_INDEX("Index");
    static const Urho3D::StringHash P_SIZE("Size");
    static const Urho3D::StringHash P_POSITION("Position");
}


static const Urho3D::StringHash E_CROWD_AGENT_REPOSITION(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentReposition")); namespace CrowdAgentReposition
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_VELOCITY("Velocity");
    static const Urho3D::StringHash P_ARRIVED("Arrived");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_CROWD_AGENT_NODE_REPOSITION(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentNodeReposition")); namespace CrowdAgentNodeReposition
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_VELOCITY("Velocity");
    static const Urho3D::StringHash P_ARRIVED("Arrived");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_CROWD_AGENT_FAILURE(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentFailure")); namespace CrowdAgentFailure
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_VELOCITY("Velocity");
    static const Urho3D::StringHash P_CROWD_AGENT_STATE("CrowdAgentState");
    static const Urho3D::StringHash P_CROWD_TARGET_STATE("CrowdTargetState");
}


static const Urho3D::StringHash E_CROWD_AGENT_NODE_FAILURE(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentNodeFailure")); namespace CrowdAgentNodeFailure
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_VELOCITY("Velocity");
    static const Urho3D::StringHash P_CROWD_AGENT_STATE("CrowdAgentState");
    static const Urho3D::StringHash P_CROWD_TARGET_STATE("CrowdTargetState");
}


static const Urho3D::StringHash E_CROWD_AGENT_STATE_CHANGED(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentStateChanged")); namespace CrowdAgentStateChanged
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_VELOCITY("Velocity");
    static const Urho3D::StringHash P_CROWD_AGENT_STATE("CrowdAgentState");
    static const Urho3D::StringHash P_CROWD_TARGET_STATE("CrowdTargetState");
}


static const Urho3D::StringHash E_CROWD_AGENT_NODE_STATE_CHANGED(Urho3D::GetEventNameRegister().RegisterString("CrowdAgentNodeStateChanged")); namespace CrowdAgentNodeStateChanged
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CROWD_AGENT("CrowdAgent");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_VELOCITY("Velocity");
    static const Urho3D::StringHash P_CROWD_AGENT_STATE("CrowdAgentState");
    static const Urho3D::StringHash P_CROWD_TARGET_STATE("CrowdTargetState");
}


static const Urho3D::StringHash E_NAVIGATION_OBSTACLE_ADDED(Urho3D::GetEventNameRegister().RegisterString("NavigationObstacleAdded")); namespace NavigationObstacleAdded
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_OBSTACLE("Obstacle");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_RADIUS("Radius");
    static const Urho3D::StringHash P_HEIGHT("Height");
}


static const Urho3D::StringHash E_NAVIGATION_OBSTACLE_REMOVED(Urho3D::GetEventNameRegister().RegisterString("NavigationObstacleRemoved")); namespace NavigationObstacleRemoved
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_OBSTACLE("Obstacle");
    static const Urho3D::StringHash P_POSITION("Position");
    static const Urho3D::StringHash P_RADIUS("Radius");
    static const Urho3D::StringHash P_HEIGHT("Height");
}

}

namespace Urho3D
{

class DynamicNavigationMesh;


class __attribute__((visibility("default"))) Obstacle : public Component
{
    public: using ClassName = Obstacle; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Obstacle", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

    friend class DynamicNavigationMesh;

public:

    explicit Obstacle(Context*);

    ~Obstacle() override;


    static void RegisterObject(Context*);


    void OnSetEnabled() override;


    float GetHeight() const { return height_; }


    void SetHeight(float newHeight);


    float GetRadius() const { return radius_; }


    void SetRadius(float newRadius);


    unsigned GetObstacleID() const { return obstacleId_; }


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;

    void DrawDebugGeometry(bool depthTest);

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

    void HandleNavigationTileAdded(StringHash eventType, VariantMap& eventData);

private:

    float radius_;

    float height_;


    unsigned obstacleId_;

    WeakPtr<DynamicNavigationMesh> ownerMesh_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) OffMeshConnection : public Component
{
    public: using ClassName = OffMeshConnection; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("OffMeshConnection", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit OffMeshConnection(Context* context);

    ~OffMeshConnection() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetEndPoint(Node* node);

    void SetRadius(float radius);

    void SetBidirectional(bool enabled);

    void SetMask(unsigned newMask);

    void SetAreaID(unsigned newAreaID);


    Node* GetEndPoint() const;


    float GetRadius() const { return radius_; }


    bool IsBidirectional() const { return bidirectional_; }


    unsigned GetMask() const { return mask_; }


    unsigned GetAreaID() const { return areaId_; }

private:

    void MarkEndPointDirty() { endPointDirty_ = true; }

    WeakPtr<Node> endPoint_;

    unsigned endPointID_;

    float radius_;

    bool bidirectional_;

    bool endPointDirty_;

    unsigned mask_;

    unsigned areaId_;
};

}




namespace Urho3D
{

static const unsigned MAX_NETWORK_ATTRIBUTES = 64;

class Component;
class Connection;
class Node;
class Scene;

struct ReplicationState;
struct ComponentReplicationState;
struct NodeReplicationState;
struct SceneReplicationState;


struct __attribute__((visibility("default"))) DirtyBits
{

    DirtyBits() = default;


    DirtyBits(const DirtyBits& bits) :
        count_(bits.count_)
    {
        memcpy(data_, bits.data_, MAX_NETWORK_ATTRIBUTES / 8);
    }


    void Set(unsigned index)
    {
        if (index < MAX_NETWORK_ATTRIBUTES)
        {
            unsigned byteIndex = index >> 3u;
            auto bit = (unsigned)(1u << (index & 7u));
            if ((data_[byteIndex] & bit) == 0)
            {
                data_[byteIndex] |= bit;
                ++count_;
            }
        }
    }


    void Clear(unsigned index)
    {
        if (index < MAX_NETWORK_ATTRIBUTES)
        {
            unsigned byteIndex = index >> 3u;
            auto bit = (unsigned)(1u << (index & 7u));
            if ((data_[byteIndex] & bit) != 0)
            {
                data_[byteIndex] &= ~bit;
                --count_;
            }
        }
    }


    void ClearAll()
    {
        memset(data_, 0, MAX_NETWORK_ATTRIBUTES / 8);
        count_ = 0;
    }


    bool IsSet(unsigned index) const
    {
        if (index < MAX_NETWORK_ATTRIBUTES)
        {
            unsigned byteIndex = index >> 3u;
            auto bit = (unsigned)(1u << (index & 7u));
            return (data_[byteIndex] & bit) != 0;
        }
        else
            return false;
    }


    unsigned Count() const { return count_; }


    unsigned char data_[MAX_NETWORK_ATTRIBUTES / 8]{};

    unsigned char count_{};
};


struct __attribute__((visibility("default"))) NetworkState
{

    const Vector<AttributeInfo>* attributes_{};

    Vector<Variant> currentValues_;

    Vector<Variant> previousValues_;

    PODVector<ReplicationState*> replicationStates_;

    VariantMap previousVars_;

    unsigned long long interceptMask_{};
};


struct __attribute__((visibility("default"))) ReplicationState
{

    Connection* connection_;
};


struct __attribute__((visibility("default"))) ComponentReplicationState : public ReplicationState
{

    NodeReplicationState* nodeState_{};

    WeakPtr<Component> component_;

    DirtyBits dirtyAttributes_;
};


struct __attribute__((visibility("default"))) NodeReplicationState : public ReplicationState
{

    SceneReplicationState* sceneState_;

    WeakPtr<Node> node_;

    DirtyBits dirtyAttributes_;

    HashSet<StringHash> dirtyVars_;

    HashMap<unsigned, ComponentReplicationState> componentStates_;

    float priorityAcc_{};

    bool markedDirty_{};
};


struct __attribute__((visibility("default"))) SceneReplicationState : public ReplicationState
{

    HashMap<unsigned, NodeReplicationState> nodeStates_;

    HashSet<unsigned> dirtyNodes_;

    void Clear()
    {
        nodeStates_.Clear();
        dirtyNodes_.Clear();
    }
};

}


namespace SLNet
{
    class SystemAddress;
    struct AddressOrGUID;
    struct RakNetGUID;
    struct Packet;
    class NatPunchthroughClient;
    class RakPeerInterface;
}

namespace Urho3D
{

class File;
class MemoryBuffer;
class Node;
class Scene;
class Serializable;
class PackageFile;


struct RemoteEvent
{

    unsigned senderID_;

    StringHash eventType_;

    VariantMap eventData_;

    bool inOrder_;
};


struct PackageDownload
{

    PackageDownload();


    SharedPtr<File> file_;

    HashSet<unsigned> receivedFragments_;

    String name_;

    unsigned totalFragments_;

    unsigned checksum_;

    bool initiated_;
};


struct PackageUpload
{

    PackageUpload();


    SharedPtr<File> file_;

    unsigned fragment_;

    unsigned totalFragments_;
};


enum ObserverPositionSendMode
{
    OPSM_NONE = 0,
    OPSM_POSITION,
    OPSM_POSITION_ROTATION
};


class __attribute__((visibility("default"))) Connection : public Object
{
    public: using ClassName = Connection; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Connection", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    Connection(Context* context, bool isClient, const SLNet::AddressOrGUID& address, SLNet::RakPeerInterface* peer);

    ~Connection() override;


    void SendMessage(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0);

    void SendMessage(int msgID, bool reliable, bool inOrder, const unsigned char* data, unsigned numBytes, unsigned contentID = 0);

    void SendRemoteEvent(StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap);

    void SendRemoteEvent(Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap);

    void SetScene(Scene* newScene);

    void SetIdentity(const VariantMap& identity);

    void SetControls(const Controls& newControls);

    void SetPosition(const Vector3& position);

    void SetRotation(const Quaternion& rotation);

    void SetConnectPending(bool connectPending);

    void SetLogStatistics(bool enable);

    void Disconnect(int waitMSec = 0);

    void SendServerUpdate();

    void SendClientUpdate();

    void SendRemoteEvents();

    void SendPackages();

    void ProcessPendingLatestData();

    bool ProcessMessage(int msgID, MemoryBuffer& msg);

    void Ban();

    const SLNet::AddressOrGUID& GetAddressOrGUID() const { return *address_; }

    void SetAddressOrGUID(const SLNet::AddressOrGUID& addr);


    VariantMap& GetIdentity() { return identity_; }


    Scene* GetScene() const;


    const Controls& GetControls() const { return controls_; }


    unsigned char GetTimeStamp() const { return timeStamp_; }


    const Vector3& GetPosition() const { return position_; }


    const Quaternion& GetRotation() const { return rotation_; }


    bool IsClient() const { return isClient_; }


    bool IsConnected() const;


    bool IsConnectPending() const { return connectPending_; }


    bool IsSceneLoaded() const { return sceneLoaded_; }


    bool GetLogStatistics() const { return logStatistics_; }


    String GetAddress() const;


    unsigned short GetPort() const { return port_; }


    float GetRoundTripTime() const;


    unsigned GetLastHeardTime() const;


    float GetBytesInPerSec() const;


    float GetBytesOutPerSec() const;


    int GetPacketsInPerSec() const;


    int GetPacketsOutPerSec() const;


    String ToString() const;

    unsigned GetNumDownloads() const;

    const String& GetDownloadName() const;

    float GetDownloadProgress() const;

    void SendPackageToClient(PackageFile* package);


    void ConfigureNetworkSimulator(int latencyMs, float packetLoss);


    Controls controls_;

    unsigned char timeStamp_;

    VariantMap identity_;

private:

    void HandleAsyncLoadFinished(StringHash eventType, VariantMap& eventData);

    void ProcessLoadScene(int msgID, MemoryBuffer& msg);

    void ProcessSceneChecksumError(int msgID, MemoryBuffer& msg);

    void ProcessSceneUpdate(int msgID, MemoryBuffer& msg);

    void ProcessPackageDownload(int msgID, MemoryBuffer& msg);

    void ProcessIdentity(int msgID, MemoryBuffer& msg);

    void ProcessControls(int msgID, MemoryBuffer& msg);

    void ProcessSceneLoaded(int msgID, MemoryBuffer& msg);

    void ProcessRemoteEvent(int msgID, MemoryBuffer& msg);

    void ProcessNode(unsigned nodeID);

    void ProcessNewNode(Node* node);

    void ProcessExistingNode(Node* node, NodeReplicationState& nodeState);

    void ProcessPackageInfo(int msgID, MemoryBuffer& msg);

    bool RequestNeededPackages(unsigned numPackages, MemoryBuffer& msg);

    void RequestPackage(const String& name, unsigned fileSize, unsigned checksum);

    void SendPackageError(const String& name);

    void OnSceneLoadFailed();

    void OnPackageDownloadFailed(const String& name);

    void OnPackagesReady();


    WeakPtr<Scene> scene_;

    SceneReplicationState sceneState_;

    HashMap<StringHash, PackageDownload> downloads_;

    HashMap<StringHash, PackageUpload> uploads_;

    HashMap<unsigned, PODVector<unsigned char> > nodeLatestData_;

    HashMap<unsigned, PODVector<unsigned char> > componentLatestData_;

    HashSet<unsigned> nodesToProcess_;

    VectorBuffer msg_;

    Vector<RemoteEvent> remoteEvents_;

    String sceneFileName_;

    Timer statsTimer_;

    unsigned short port_;

    Vector3 position_;

    Quaternion rotation_;

    ObserverPositionSendMode sendMode_;

    bool isClient_;

    bool connectPending_;

    bool sceneLoaded_;

    bool logStatistics_;

    SLNet::AddressOrGUID* address_;

    SLNet::RakPeerInterface* peer_;

    IntVector2 tempPacketCounter_;

    IntVector2 packetCounter_;

    Timer packetCounterTimer_;

    Timer lastHeardTimer_;
};

}
namespace Urho3D
{


enum HttpRequestState
{
    HTTP_INITIALIZING = 0,
    HTTP_ERROR,
    HTTP_OPEN,
    HTTP_CLOSED
};


class __attribute__((visibility("default"))) HttpRequest : public RefCounted, public Deserializer, public Thread
{
public:

    HttpRequest(const String& url, const String& verb, const Vector<String>& headers, const String& postData);

    ~HttpRequest() override;


    void ThreadFunction() override;


    unsigned Read(void* dest, unsigned size) override;

    unsigned Seek(unsigned position) override;

    bool IsEof() const override;


    const String& GetURL() const { return url_; }


    const String& GetVerb() const { return verb_; }


    String GetError() const;

    HttpRequestState GetState() const;

    unsigned GetAvailableSize() const;


    bool IsOpen() const { return GetState() == HTTP_OPEN; }

private:

    Pair<unsigned, bool> CheckAvailableSizeAndEof() const;


    String url_;

    String verb_;

    String error_;

    Vector<String> headers_;

    String postData_;

    HttpRequestState state_;

    mutable Mutex mutex_;

    SharedArrayPtr<unsigned char> httpReadBuffer_;

    SharedArrayPtr<unsigned char> readBuffer_;

    unsigned readPosition_;

    unsigned writePosition_;
};

}
namespace Urho3D
{

class HttpRequest;
class MemoryBuffer;
class Scene;


class __attribute__((visibility("default"))) Network : public Object
{
    public: using ClassName = Network; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Network", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Network(Context* context);

    ~Network() override;


    void HandleMessage(const SLNet::AddressOrGUID& source, int packetID, int msgID, const char* data, size_t numBytes);

    void NewConnectionEstablished(const SLNet::AddressOrGUID& connection);

    void ClientDisconnected(const SLNet::AddressOrGUID& connection);


    void SetDiscoveryBeacon(const VariantMap& data);

    void DiscoverHosts(unsigned port);

    void SetPassword(const String& password);

    void SetNATServerInfo(const String& address, unsigned short port);

    bool Connect(const String& address, unsigned short port, Scene* scene, const VariantMap& identity = Variant::emptyVariantMap);

    void Disconnect(int waitMSec = 0);

    bool StartServer(unsigned short port);

    void StopServer();

    void StartNATClient();

    const String& GetGUID() const { return guid_; }

    void AttemptNATPunchtrough(const String& guid, Scene* scene, const VariantMap& identity = Variant::emptyVariantMap);

    void BroadcastMessage(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0);

    void BroadcastMessage(int msgID, bool reliable, bool inOrder, const unsigned char* data, unsigned numBytes, unsigned contentID = 0);

    void BroadcastRemoteEvent(StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap);

    void BroadcastRemoteEvent(Scene* scene, StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap);

    void BroadcastRemoteEvent(Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap);

    void SetUpdateFps(int fps);

    void SetSimulatedLatency(int ms);

    void SetSimulatedPacketLoss(float probability);

    void RegisterRemoteEvent(StringHash eventType);

    void UnregisterRemoteEvent(StringHash eventType);

    void UnregisterAllRemoteEvents();

    void SetPackageCacheDir(const String& path);

    void SendPackageToClients(Scene* scene, PackageFile* package);

    SharedPtr<HttpRequest> MakeHttpRequest(const String& url, const String& verb = String::EMPTY, const Vector<String>& headers = Vector<String>(), const String& postData = String::EMPTY);

    void BanAddress(const String& address);

    int GetUpdateFps() const { return updateFps_; }


    int GetSimulatedLatency() const { return simulatedLatency_; }


    float GetSimulatedPacketLoss() const { return simulatedPacketLoss_; }


    Connection* GetConnection(const SLNet::AddressOrGUID& connection) const;

    Connection* GetServerConnection() const;

    Vector<SharedPtr<Connection> > GetClientConnections() const;

    bool IsServerRunning() const;

    bool CheckRemoteEvent(StringHash eventType) const;


    const String& GetPackageCacheDir() const { return packageCacheDir_; }


    void Update(float timeStep);

    void PostUpdate(float timeStep);

private:

    void HandleBeginFrame(StringHash eventType, VariantMap& eventData);

    void HandleRenderUpdate(StringHash eventType, VariantMap& eventData);

    void OnServerConnected(const SLNet::AddressOrGUID& address);

    void OnServerDisconnected();

    void ConfigureNetworkSimulator();

    void HandleIncomingPacket(SLNet::Packet* packet, bool isServer);


    SLNet::RakPeerInterface* rakPeer_;

    SLNet::RakPeerInterface* rakPeerClient_;

    SharedPtr<Connection> serverConnection_;

    HashMap<SLNet::AddressOrGUID, SharedPtr<Connection> > clientConnections_;

    HashSet<StringHash> allowedRemoteEvents_;

    HashSet<StringHash> blacklistedRemoteEvents_;

    HashSet<Scene*> networkScenes_;

    int updateFps_;

    int simulatedLatency_;

    float simulatedPacketLoss_;

    float updateInterval_;

    float updateAcc_;

    String packageCacheDir_;

    bool isServer_;

    String password_;

    Scene* scene_;

    VariantMap identity_;

    SLNet::SystemAddress* natPunchServerAddress_;

    SLNet::NatPunchthroughClient* natPunchthroughServerClient_;

    SLNet::NatPunchthroughClient* natPunchthroughClient_;

    SLNet::RakNetGUID* remoteGUID_;

    String guid_;
};


void __attribute__((visibility("default"))) RegisterNetworkLibrary(Context* context);

}
namespace Urho3D
{


static const Urho3D::StringHash E_SERVERCONNECTED(Urho3D::GetEventNameRegister().RegisterString("ServerConnected")); namespace ServerConnected
{
}


static const Urho3D::StringHash E_SERVERDISCONNECTED(Urho3D::GetEventNameRegister().RegisterString("ServerDisconnected")); namespace ServerDisconnected
{
}


static const Urho3D::StringHash E_CONNECTFAILED(Urho3D::GetEventNameRegister().RegisterString("ConnectFailed")); namespace ConnectFailed
{
}


static const Urho3D::StringHash E_CONNECTIONINPROGRESS(Urho3D::GetEventNameRegister().RegisterString("ConnectionInProgress")); namespace ConnectionInProgress
{
}


static const Urho3D::StringHash E_CLIENTCONNECTED(Urho3D::GetEventNameRegister().RegisterString("ClientConnected")); namespace ClientConnected
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
}


static const Urho3D::StringHash E_CLIENTDISCONNECTED(Urho3D::GetEventNameRegister().RegisterString("ClientDisconnected")); namespace ClientDisconnected
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
}


static const Urho3D::StringHash E_CLIENTIDENTITY(Urho3D::GetEventNameRegister().RegisterString("ClientIdentity")); namespace ClientIdentity
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
    static const Urho3D::StringHash P_ALLOW("Allow");
}


static const Urho3D::StringHash E_CLIENTSCENELOADED(Urho3D::GetEventNameRegister().RegisterString("ClientSceneLoaded")); namespace ClientSceneLoaded
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
}


static const Urho3D::StringHash E_NETWORKMESSAGE(Urho3D::GetEventNameRegister().RegisterString("NetworkMessage")); namespace NetworkMessage
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
    static const Urho3D::StringHash P_MESSAGEID("MessageID");
    static const Urho3D::StringHash P_DATA("Data");
}


static const Urho3D::StringHash E_NETWORKUPDATE(Urho3D::GetEventNameRegister().RegisterString("NetworkUpdate")); namespace NetworkUpdate
{
}


static const Urho3D::StringHash E_NETWORKUPDATESENT(Urho3D::GetEventNameRegister().RegisterString("NetworkUpdateSent")); namespace NetworkUpdateSent
{
}


static const Urho3D::StringHash E_NETWORKSCENELOADFAILED(Urho3D::GetEventNameRegister().RegisterString("NetworkSceneLoadFailed")); namespace NetworkSceneLoadFailed
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
}


static const Urho3D::StringHash E_REMOTEEVENTDATA(Urho3D::GetEventNameRegister().RegisterString("RemoteEventData")); namespace RemoteEventData
{
    static const Urho3D::StringHash P_CONNECTION("Connection");
}


static const Urho3D::StringHash E_NETWORKBANNED(Urho3D::GetEventNameRegister().RegisterString("NetworkBanned")); namespace NetworkBanned
{
}


static const Urho3D::StringHash E_NETWORKINVALIDPASSWORD(Urho3D::GetEventNameRegister().RegisterString("NetworkInvalidPassword")); namespace NetworkInvalidPassword
{
}


static const Urho3D::StringHash E_NETWORKHOSTDISCOVERED(Urho3D::GetEventNameRegister().RegisterString("NetworkHostDiscovered")); namespace NetworkHostDiscovered
{
    static const Urho3D::StringHash P_ADDRESS("Address");
    static const Urho3D::StringHash P_PORT("Port");
    static const Urho3D::StringHash P_BEACON("Beacon");
}


static const Urho3D::StringHash E_NETWORKNATPUNCHTROUGHSUCCEEDED(Urho3D::GetEventNameRegister().RegisterString("NetworkNatPunchtroughSucceeded")); namespace NetworkNatPunchtroughSucceeded
{
 static const Urho3D::StringHash P_ADDRESS("Address");
 static const Urho3D::StringHash P_PORT("Port");
}


static const Urho3D::StringHash E_NETWORKNATPUNCHTROUGHFAILED(Urho3D::GetEventNameRegister().RegisterString("NetworkNatPunchtroughFailed")); namespace NetworkNatPunchtroughFailed
{
 static const Urho3D::StringHash P_ADDRESS("Address");
 static const Urho3D::StringHash P_PORT("Port");
}


static const Urho3D::StringHash E_NATMASTERCONNECTIONFAILED(Urho3D::GetEventNameRegister().RegisterString("NetworkNatMasterConnectionFailed")); namespace NetworkNatMasterConnectionFailed
{
    static const Urho3D::StringHash P_ADDRESS("Address");
    static const Urho3D::StringHash P_PORT("Port");
}


static const Urho3D::StringHash E_NATMASTERCONNECTIONSUCCEEDED(Urho3D::GetEventNameRegister().RegisterString("NetworkNatMasterConnectionSucceeded")); namespace NetworkNatMasterConnectionSucceeded
{
    static const Urho3D::StringHash P_ADDRESS("Address");
    static const Urho3D::StringHash P_PORT("Port");
}

}
namespace Urho3D
{


class __attribute__((visibility("default"))) NetworkPriority : public Component
{
    public: using ClassName = NetworkPriority; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("NetworkPriority", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit NetworkPriority(Context* context);

    ~NetworkPriority() override;

    static void RegisterObject(Context* context);


    void SetBasePriority(float priority);

    void SetDistanceFactor(float factor);

    void SetMinPriority(float priority);

    void SetAlwaysUpdateOwner(bool enable);


    float GetBasePriority() const { return basePriority_; }


    float GetDistanceFactor() const { return distanceFactor_; }


    float GetMinPriority() const { return minPriority_; }


    bool GetAlwaysUpdateOwner() const { return alwaysUpdateOwner_; }


    bool CheckUpdate(float distance, float& accumulator);

private:

    float basePriority_;

    float distanceFactor_;

    float minPriority_;

    bool alwaysUpdateOwner_;
};

}
namespace Urho3D
{


static const int MSG_IDENTITY = 0x87;

static const int MSG_CONTROLS = 0x88;

static const int MSG_SCENELOADED = 0x89;

static const int MSG_REQUESTPACKAGE = 0x8A;


static const int MSG_PACKAGEDATA = 0x8B;

static const int MSG_LOADSCENE = 0x8C;

static const int MSG_SCENECHECKSUMERROR = 0x8D;

static const int MSG_CREATENODE = 0x8E;

static const int MSG_NODEDELTAUPDATE = 0x8F;

static const int MSG_NODELATESTDATA = 0x90;

static const int MSG_REMOVENODE = 0x91;

static const int MSG_CREATECOMPONENT = 0x92;

static const int MSG_COMPONENTDELTAUPDATE = 0x93;

static const int MSG_COMPONENTLATESTDATA = 0x94;

static const int MSG_REMOVECOMPONENT = 0x95;


static const int MSG_REMOTEEVENT = 0x96;

static const int MSG_REMOTENODEEVENT = 0x97;

static const int MSG_PACKAGEINFO = 0x98;


static const unsigned CONTROLS_CONTENT_ID = 1;

static const unsigned PACKAGE_FRAGMENT_SIZE = 1024;

}


class btBvhTriangleMeshShape;
class btCollisionShape;
class btCompoundShape;
class btGImpactMeshShape;
class btTriangleMesh;

struct btTriangleInfoMap;

namespace Urho3D
{

class CustomGeometry;
class Geometry;
class Model;
class PhysicsWorld;
class RigidBody;
class Terrain;
class TriangleMeshInterface;


enum ShapeType
{
    SHAPE_BOX = 0,
    SHAPE_SPHERE,
    SHAPE_STATICPLANE,
    SHAPE_CYLINDER,
    SHAPE_CAPSULE,
    SHAPE_CONE,
    SHAPE_TRIANGLEMESH,
    SHAPE_CONVEXHULL,
    SHAPE_TERRAIN,
    SHAPE_GIMPACTMESH
};


struct CollisionGeometryData : public RefCounted
{
};



using CollisionGeometryDataCache = HashMap<Pair<Model*, unsigned>, SharedPtr<CollisionGeometryData> >;


struct TriangleMeshData : public CollisionGeometryData
{

    TriangleMeshData(Model* model, unsigned lodLevel);

    explicit TriangleMeshData(CustomGeometry* custom);


    UniquePtr<TriangleMeshInterface> meshInterface_;

    UniquePtr<btBvhTriangleMeshShape> shape_;

    UniquePtr<btTriangleInfoMap> infoMap_;
};


struct GImpactMeshData : public CollisionGeometryData
{

    GImpactMeshData(Model* model, unsigned lodLevel);

    explicit GImpactMeshData(CustomGeometry* custom);


    UniquePtr<TriangleMeshInterface> meshInterface_;
};


struct ConvexData : public CollisionGeometryData
{

    ConvexData(Model* model, unsigned lodLevel);

    explicit ConvexData(CustomGeometry* custom);


    void BuildHull(const PODVector<Vector3>& vertices);


    SharedArrayPtr<Vector3> vertexData_;

    unsigned vertexCount_{};

    SharedArrayPtr<unsigned> indexData_;

    unsigned indexCount_{};
};


struct HeightfieldData : public CollisionGeometryData
{

    HeightfieldData(Terrain* terrain, unsigned lodLevel);


    SharedArrayPtr<float> heightData_;

    Vector3 spacing_;

    IntVector2 size_;

    float minHeight_;

    float maxHeight_;
};


class __attribute__((visibility("default"))) CollisionShape : public Component
{
    public: using ClassName = CollisionShape; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionShape", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionShape(Context* context);

    ~CollisionShape() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnSetEnabled() override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetBox(const Vector3& size, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);

    void SetSphere(float diameter, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);

    void SetStaticPlane(const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);

    void SetCylinder(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);

    void SetCapsule(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);

    void SetCone(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY);

    void SetTriangleMesh(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        const Quaternion& rotation = Quaternion::IDENTITY);

    void SetCustomTriangleMesh(CustomGeometry* custom, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        const Quaternion& rotation = Quaternion::IDENTITY);

    void SetConvexHull(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        const Quaternion& rotation = Quaternion::IDENTITY);

    void SetCustomConvexHull(CustomGeometry* custom, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        const Quaternion& rotation = Quaternion::IDENTITY);

    void SetGImpactMesh(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        const Quaternion& rotation = Quaternion::IDENTITY);

    void SetCustomGImpactMesh(CustomGeometry* custom, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO,
        const Quaternion& rotation = Quaternion::IDENTITY);

    void SetTerrain(unsigned lodLevel = 0);

    void SetShapeType(ShapeType type);

    void SetSize(const Vector3& size);

    void SetPosition(const Vector3& position);

    void SetRotation(const Quaternion& rotation);

    void SetTransform(const Vector3& position, const Quaternion& rotation);

    void SetMargin(float margin);

    void SetModel(Model* model);

    void SetLodLevel(unsigned lodLevel);


    btCollisionShape* GetCollisionShape() const { return shape_.Get(); }


    CollisionGeometryData* GetGeometryData() const { return geometry_; }


    PhysicsWorld* GetPhysicsWorld() const { return physicsWorld_; }


    ShapeType GetShapeType() const { return shapeType_; }


    const Vector3& GetSize() const { return size_; }


    const Vector3& GetPosition() const { return position_; }


    const Quaternion& GetRotation() const { return rotation_; }


    float GetMargin() const { return margin_; }


    Model* GetModel() const { return model_; }


    unsigned GetLodLevel() const { return lodLevel_; }


    BoundingBox GetWorldBoundingBox() const;


    void NotifyRigidBody(bool updateMass = true);

    void SetModelAttr(const ResourceRef& value);

    ResourceRef GetModelAttr() const;

    void ReleaseShape();

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;







    virtual btCollisionShape* UpdateDerivedShape(int shapeType, const Vector3& newWorldScale);

private:

    btCompoundShape* GetParentCompoundShape();

    void UpdateShape();

    void UpdateCachedGeometryShape(CollisionGeometryDataCache& cache);

    void SetModelShape(ShapeType shapeType, Model* model, unsigned lodLevel,
        const Vector3& scale, const Vector3& position, const Quaternion& rotation);

    void SetCustomShape(ShapeType shapeType, CustomGeometry* custom,
        const Vector3& scale, const Vector3& position, const Quaternion& rotation);

    void HandleTerrainCreated(StringHash eventType, VariantMap& eventData);

    void HandleModelReloadFinished(StringHash eventType, VariantMap& eventData);

    void MarkShapeDirty() { recreateShape_ = true; }


    WeakPtr<PhysicsWorld> physicsWorld_;

    WeakPtr<RigidBody> rigidBody_;

    SharedPtr<Model> model_;

    SharedPtr<CollisionGeometryData> geometry_;

    UniquePtr<btCollisionShape> shape_;

    ShapeType shapeType_;

    Vector3 position_;

    Quaternion rotation_;

    Vector3 size_;

    Vector3 cachedWorldScale_;

    unsigned lodLevel_;

    unsigned customGeometryID_;

    float margin_;

    bool recreateShape_;

    bool retryCreation_;
};

}
class btTypedConstraint;

namespace Urho3D
{


enum ConstraintType
{
    CONSTRAINT_POINT = 0,
    CONSTRAINT_HINGE,
    CONSTRAINT_SLIDER,
    CONSTRAINT_CONETWIST
};

class PhysicsWorld;
class RigidBody;


class __attribute__((visibility("default"))) Constraint : public Component
{
    public: using ClassName = Constraint; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Constraint", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class RigidBody;

public:

    explicit Constraint(Context* context);

    ~Constraint() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnSetEnabled() override;

    void GetDependencyNodes(PODVector<Node*>& dest) override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetConstraintType(ConstraintType type);

    void SetOtherBody(RigidBody* body);

    void SetPosition(const Vector3& position);

    void SetRotation(const Quaternion& rotation);

    void SetAxis(const Vector3& axis);

    void SetOtherPosition(const Vector3& position);

    void SetOtherRotation(const Quaternion& rotation);

    void SetOtherAxis(const Vector3& axis);

    void SetWorldPosition(const Vector3& position);

    void SetHighLimit(const Vector2& limit);

    void SetLowLimit(const Vector2& limit);

    void SetERP(float erp);

    void SetCFM(float cfm);

    void SetDisableCollision(bool disable);


    PhysicsWorld* GetPhysicsWorld() const { return physicsWorld_; }


    btTypedConstraint* GetConstraint() const { return constraint_.Get(); }


    ConstraintType GetConstraintType() const { return constraintType_; }


    RigidBody* GetOwnBody() const { return ownBody_; }


    RigidBody* GetOtherBody() const { return otherBody_; }


    const Vector3& GetPosition() const { return position_; }


    const Quaternion& GetRotation() const { return rotation_; }


    const Vector3& GetOtherPosition() const { return otherPosition_; }


    const Quaternion& GetOtherRotation() const { return otherRotation_; }


    Vector3 GetWorldPosition() const;


    const Vector2& GetHighLimit() const { return highLimit_; }


    const Vector2& GetLowLimit() const { return lowLimit_; }


    float GetERP() const { return erp_; }


    float GetCFM() const { return cfm_; }


    bool GetDisableCollision() const { return disableCollision_; }


    void ReleaseConstraint();

    void ApplyFrames();

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

private:

    void CreateConstraint();

    void ApplyLimits();

    void AdjustOtherBodyPosition();

    void MarkConstraintDirty() { recreateConstraint_ = true; }

    void MarkFramesDirty() { framesDirty_ = true; }


    WeakPtr<PhysicsWorld> physicsWorld_;

    WeakPtr<RigidBody> ownBody_;

    WeakPtr<RigidBody> otherBody_;

    UniquePtr<btTypedConstraint> constraint_;

    ConstraintType constraintType_;

    Vector3 position_;

    Quaternion rotation_;

    Vector3 otherPosition_;

    Quaternion otherRotation_;

    Vector3 cachedWorldScale_;

    Vector2 highLimit_;

    Vector2 lowLimit_;

    float erp_;

    float cfm_;

    unsigned otherBodyNodeID_;

    bool disableCollision_;

    bool recreateConstraint_;

    bool framesDirty_;

    bool retryCreation_;
};

}
namespace Urho3D
{


static const Urho3D::StringHash E_PHYSICSPRESTEP(Urho3D::GetEventNameRegister().RegisterString("PhysicsPreStep")); namespace PhysicsPreStep
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_PHYSICSPOSTSTEP(Urho3D::GetEventNameRegister().RegisterString("PhysicsPostStep")); namespace PhysicsPostStep
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_PHYSICSCOLLISIONSTART(Urho3D::GetEventNameRegister().RegisterString("PhysicsCollisionStart")); namespace PhysicsCollisionStart
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_NODEA("NodeA");
    static const Urho3D::StringHash P_NODEB("NodeB");
    static const Urho3D::StringHash P_BODYA("BodyA");
    static const Urho3D::StringHash P_BODYB("BodyB");
    static const Urho3D::StringHash P_TRIGGER("Trigger");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
}


static const Urho3D::StringHash E_PHYSICSCOLLISION(Urho3D::GetEventNameRegister().RegisterString("PhysicsCollision")); namespace PhysicsCollision
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_NODEA("NodeA");
    static const Urho3D::StringHash P_NODEB("NodeB");
    static const Urho3D::StringHash P_BODYA("BodyA");
    static const Urho3D::StringHash P_BODYB("BodyB");
    static const Urho3D::StringHash P_TRIGGER("Trigger");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
}


static const Urho3D::StringHash E_PHYSICSCOLLISIONEND(Urho3D::GetEventNameRegister().RegisterString("PhysicsCollisionEnd")); namespace PhysicsCollisionEnd
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_NODEA("NodeA");
    static const Urho3D::StringHash P_NODEB("NodeB");
    static const Urho3D::StringHash P_BODYA("BodyA");
    static const Urho3D::StringHash P_BODYB("BodyB");
    static const Urho3D::StringHash P_TRIGGER("Trigger");
}


static const Urho3D::StringHash E_NODECOLLISIONSTART(Urho3D::GetEventNameRegister().RegisterString("NodeCollisionStart")); namespace NodeCollisionStart
{
    static const Urho3D::StringHash P_BODY("Body");
    static const Urho3D::StringHash P_OTHERNODE("OtherNode");
    static const Urho3D::StringHash P_OTHERBODY("OtherBody");
    static const Urho3D::StringHash P_TRIGGER("Trigger");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
}


static const Urho3D::StringHash E_NODECOLLISION(Urho3D::GetEventNameRegister().RegisterString("NodeCollision")); namespace NodeCollision
{
    static const Urho3D::StringHash P_BODY("Body");
    static const Urho3D::StringHash P_OTHERNODE("OtherNode");
    static const Urho3D::StringHash P_OTHERBODY("OtherBody");
    static const Urho3D::StringHash P_TRIGGER("Trigger");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
}


static const Urho3D::StringHash E_NODECOLLISIONEND(Urho3D::GetEventNameRegister().RegisterString("NodeCollisionEnd")); namespace NodeCollisionEnd
{
    static const Urho3D::StringHash P_BODY("Body");
    static const Urho3D::StringHash P_OTHERNODE("OtherNode");
    static const Urho3D::StringHash P_OTHERBODY("OtherBody");
    static const Urho3D::StringHash P_TRIGGER("Trigger");
}

}




inline int btGetVersion()
{
 return 286;
}
typedef float btScalar;





typedef __m128 btSimdFloat4;
inline __attribute__ ((always_inline)) btScalar btSqrt(btScalar y)
{
 return sqrtf(y);

}
inline __attribute__ ((always_inline)) btScalar btFabs(btScalar x) { return fabsf(x); }
inline __attribute__ ((always_inline)) btScalar btCos(btScalar x) { return cosf(x); }
inline __attribute__ ((always_inline)) btScalar btSin(btScalar x) { return sinf(x); }
inline __attribute__ ((always_inline)) btScalar btTan(btScalar x) { return tanf(x); }
inline __attribute__ ((always_inline)) btScalar btAcos(btScalar x) {
 if (x<btScalar(-1))
  x=btScalar(-1);
 if (x>btScalar(1))
  x=btScalar(1);
 return acosf(x);
}
inline __attribute__ ((always_inline)) btScalar btAsin(btScalar x) {
 if (x<btScalar(-1))
  x=btScalar(-1);
 if (x>btScalar(1))
  x=btScalar(1);
 return asinf(x);
}
inline __attribute__ ((always_inline)) btScalar btAtan(btScalar x) { return atanf(x); }
inline __attribute__ ((always_inline)) btScalar btAtan2(btScalar x, btScalar y) { return atan2f(x, y); }
inline __attribute__ ((always_inline)) btScalar btExp(btScalar x) { return expf(x); }
inline __attribute__ ((always_inline)) btScalar btLog(btScalar x) { return logf(x); }
inline __attribute__ ((always_inline)) btScalar btPow(btScalar x,btScalar y) { return powf(x,y); }
inline __attribute__ ((always_inline)) btScalar btFmod(btScalar x,btScalar y) { return fmodf(x,y); }
inline __attribute__ ((always_inline)) btScalar btAtan2Fast(btScalar y, btScalar x)
{
 btScalar coeff_1 = btScalar(3.1415926535897932384626433832795029) / 4.0f;
 btScalar coeff_2 = 3.0f * coeff_1;
 btScalar abs_y = btFabs(y);
 btScalar angle;
 if (x >= 0.0f) {
  btScalar r = (x - abs_y) / (x + abs_y);
  angle = coeff_1 - coeff_1 * r;
 } else {
  btScalar r = (x + abs_y) / (abs_y - x);
  angle = coeff_2 - coeff_1 * r;
 }
 return (y < 0.0f) ? -angle : angle;
}

inline __attribute__ ((always_inline)) bool btFuzzyZero(btScalar x) { return btFabs(x) < 1.19209290e-7F; }

inline __attribute__ ((always_inline)) bool btEqual(btScalar a, btScalar eps) {
 return (((a) <= eps) && !((a) < -eps));
}
inline __attribute__ ((always_inline)) bool btGreaterEqual (btScalar a, btScalar eps) {
 return (!((a) <= eps));
}


inline __attribute__ ((always_inline)) int btIsNegative(btScalar x) {
    return x < btScalar(0.0) ? 1 : 0;
}

inline __attribute__ ((always_inline)) btScalar btRadians(btScalar x) { return x * ((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)); }
inline __attribute__ ((always_inline)) btScalar btDegrees(btScalar x) { return x * (btScalar(360.0) / (btScalar(2.0) * btScalar(3.1415926535897932384626433832795029))); }




inline __attribute__ ((always_inline)) btScalar btFsel(btScalar a, btScalar b, btScalar c)
{
 return a >= 0 ? b : c;
}




inline __attribute__ ((always_inline)) bool btMachineIsLittleEndian()
{
   long int i = 1;
   const char *p = (const char *) &i;
   if (p[0] == 1)
    return true;
   else
    return false;
}





inline __attribute__ ((always_inline)) unsigned btSelect(unsigned condition, unsigned valueIfConditionNonZero, unsigned valueIfConditionZero)
{




    unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
    unsigned testEqz = ~testNz;
    return ((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
inline __attribute__ ((always_inline)) int btSelect(unsigned condition, int valueIfConditionNonZero, int valueIfConditionZero)
{
    unsigned testNz = (unsigned)(((int)condition | -(int)condition) >> 31);
    unsigned testEqz = ~testNz;
    return static_cast<int>((valueIfConditionNonZero & testNz) | (valueIfConditionZero & testEqz));
}
inline __attribute__ ((always_inline)) float btSelect(unsigned condition, float valueIfConditionNonZero, float valueIfConditionZero)
{



    return (condition != 0) ? valueIfConditionNonZero : valueIfConditionZero;

}

template<typename T> inline __attribute__ ((always_inline)) void btSwap(T& a, T& b)
{
 T tmp = a;
 a = b;
 b = tmp;
}



inline __attribute__ ((always_inline)) unsigned btSwapEndian(unsigned val)
{
 return (((val & 0xff000000) >> 24) | ((val & 0x00ff0000) >> 8) | ((val & 0x0000ff00) << 8) | ((val & 0x000000ff) << 24));
}

inline __attribute__ ((always_inline)) unsigned short btSwapEndian(unsigned short val)
{
 return static_cast<unsigned short>(((val & 0xff00) >> 8) | ((val & 0x00ff) << 8));
}

inline __attribute__ ((always_inline)) unsigned btSwapEndian(int val)
{
 return btSwapEndian((unsigned)val);
}

inline __attribute__ ((always_inline)) unsigned short btSwapEndian(short val)
{
 return btSwapEndian((unsigned short) val);
}







inline __attribute__ ((always_inline)) unsigned int btSwapEndianFloat(float d)
{
    unsigned int a = 0;
    unsigned char *dst = (unsigned char *)&a;
    unsigned char *src = (unsigned char *)&d;

    dst[0] = src[3];
    dst[1] = src[2];
    dst[2] = src[1];
    dst[3] = src[0];
    return a;
}


inline __attribute__ ((always_inline)) float btUnswapEndianFloat(unsigned int a)
{
    float d = 0.0f;
    unsigned char *src = (unsigned char *)&a;
    unsigned char *dst = (unsigned char *)&d;

    dst[0] = src[3];
    dst[1] = src[2];
    dst[2] = src[1];
    dst[3] = src[0];

    return d;
}



inline __attribute__ ((always_inline)) void btSwapEndianDouble(double d, unsigned char* dst)
{
    unsigned char *src = (unsigned char *)&d;

    dst[0] = src[7];
    dst[1] = src[6];
    dst[2] = src[5];
    dst[3] = src[4];
    dst[4] = src[3];
    dst[5] = src[2];
    dst[6] = src[1];
    dst[7] = src[0];

}


inline __attribute__ ((always_inline)) double btUnswapEndianDouble(const unsigned char *src)
{
    double d = 0.0;
    unsigned char *dst = (unsigned char *)&d;

    dst[0] = src[7];
    dst[1] = src[6];
    dst[2] = src[5];
    dst[3] = src[4];
    dst[4] = src[3];
    dst[5] = src[2];
    dst[6] = src[1];
    dst[7] = src[0];

 return d;
}

template<typename T>
inline __attribute__ ((always_inline)) void btSetZero(T* a, int n)
{
  T* acurr = a;
  size_t ncurr = n;
  while (ncurr > 0)
  {
    *(acurr++) = 0;
    --ncurr;
  }
}


inline __attribute__ ((always_inline)) btScalar btLargeDot(const btScalar *a, const btScalar *b, int n)
{
  btScalar p0,q0,m0,p1,q1,m1,sum;
  sum = 0;
  n -= 2;
  while (n >= 0) {
    p0 = a[0]; q0 = b[0];
    m0 = p0 * q0;
    p1 = a[1]; q1 = b[1];
    m1 = p1 * q1;
    sum += m0;
    sum += m1;
    a += 2;
    b += 2;
    n -= 2;
  }
  n += 2;
  while (n > 0) {
    sum += (*a) * (*b);
    a++;
    b++;
    n--;
  }
  return sum;
}



inline __attribute__ ((always_inline)) btScalar btNormalizeAngle(btScalar angleInRadians)
{
 angleInRadians = btFmod(angleInRadians, (btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)));
 if(angleInRadians < -btScalar(3.1415926535897932384626433832795029))
 {
  return angleInRadians + (btScalar(2.0) * btScalar(3.1415926535897932384626433832795029));
 }
 else if(angleInRadians > btScalar(3.1415926535897932384626433832795029))
 {
  return angleInRadians - (btScalar(2.0) * btScalar(3.1415926535897932384626433832795029));
 }
 else
 {
  return angleInRadians;
 }
}




struct btTypedObject
{
 btTypedObject(int objectType)
  :m_objectType(objectType)
 {
 }
 int m_objectType;
 inline int getObjectType() const
 {
  return m_objectType;
 }
};




template <typename T>T* btAlignPointer(T* unalignedPtr, size_t alignment)
{

 struct btConvertPointerSizeT
 {
  union
  {
    T* ptr;
    size_t integer;
  };
 };
    btConvertPointerSizeT converter;


 const size_t bit_mask = ~(alignment - 1);
    converter.ptr = unalignedPtr;
 converter.integer += alignment-1;
 converter.integer &= bit_mask;
 return converter.ptr;
}
template <class T>
inline __attribute__ ((always_inline)) const T& btMin(const T& a, const T& b)
{
  return a < b ? a : b ;
}

template <class T>
inline __attribute__ ((always_inline)) const T& btMax(const T& a, const T& b)
{
  return a > b ? a : b;
}

template <class T>
inline __attribute__ ((always_inline)) const T& btClamped(const T& a, const T& lb, const T& ub)
{
 return a < lb ? lb : (ub < a ? ub : a);
}

template <class T>
inline __attribute__ ((always_inline)) void btSetMin(T& a, const T& b)
{
    if (b < a)
 {
  a = b;
 }
}

template <class T>
inline __attribute__ ((always_inline)) void btSetMax(T& a, const T& b)
{
    if (a < b)
 {
  a = b;
 }
}

template <class T>
inline __attribute__ ((always_inline)) void btClamp(T& a, const T& lb, const T& ub)
{
 if (a < lb)
 {
  a = lb;
 }
 else if (ub < a)
 {
  a = ub;
 }
}
 void* btAlignedAllocInternal (size_t size, int alignment);
 void btAlignedFreeInternal (void* ptr);





typedef int size_type;

typedef void *(btAlignedAllocFunc)(size_t size, int alignment);
typedef void (btAlignedFreeFunc)(void *memblock);
typedef void *(btAllocFunc)(size_t size);
typedef void (btFreeFunc)(void *memblock);


void btAlignedAllocSetCustom(btAllocFunc *allocFunc, btFreeFunc *freeFunc);

void btAlignedAllocSetCustomAligned(btAlignedAllocFunc *allocFunc, btAlignedFreeFunc *freeFunc);




template < typename T , unsigned Alignment >
class btAlignedAllocator {

 typedef btAlignedAllocator< T , Alignment > self_type;

public:


 btAlignedAllocator() {}




 template < typename Other >
 btAlignedAllocator( const btAlignedAllocator< Other , Alignment > & ) {}

 typedef const T* const_pointer;
 typedef const T& const_reference;
 typedef T* pointer;
 typedef T& reference;
 typedef T value_type;

 pointer address ( reference ref ) const { return &ref; }
 const_pointer address ( const_reference ref ) const { return &ref; }
 pointer allocate ( size_type n , const_pointer * hint = 0 ) {
  (void)hint;
  return reinterpret_cast< pointer >(btAlignedAllocInternal(sizeof(value_type) * n,Alignment));
 }
 void construct ( pointer ptr , const value_type & value ) { new (ptr) value_type( value ); }
 void deallocate( pointer ptr ) {
  btAlignedFreeInternal(reinterpret_cast< void * >( ptr ));
 }
 void destroy ( pointer ptr ) { ptr->~value_type(); }


 template < typename O > struct rebind {
  typedef btAlignedAllocator< O , Alignment > other;
 };
 template < typename O >
 self_type & operator=( const btAlignedAllocator< O , Alignment > & ) { return *this; }

 friend bool operator==( const self_type & , const self_type & ) { return true; }
};
class __attribute__ ((aligned (16))) btVector3
{
public:

 inline __attribute__ ((always_inline)) void* operator new(size_t sizeInBytes) { return btAlignedAllocInternal(sizeInBytes,16); } inline __attribute__ ((always_inline)) void operator delete(void* ptr) { btAlignedFreeInternal(ptr); } inline __attribute__ ((always_inline)) void* operator new(size_t, void* ptr) { return ptr; } inline __attribute__ ((always_inline)) void operator delete(void*, void*) { } inline __attribute__ ((always_inline)) void* operator new[](size_t sizeInBytes) { return btAlignedAllocInternal(sizeInBytes,16); } inline __attribute__ ((always_inline)) void operator delete[](void* ptr) { btAlignedFreeInternal(ptr); } inline __attribute__ ((always_inline)) void* operator new[](size_t, void* ptr) { return ptr; } inline __attribute__ ((always_inline)) void operator delete[](void*, void*) { };
        union {
            btSimdFloat4 mVec128;
            btScalar m_floats[4];
        };
        inline __attribute__ ((always_inline)) btSimdFloat4 get128() const
        {
            return mVec128;
        }
        inline __attribute__ ((always_inline)) void set128(btSimdFloat4 v128)
        {
            mVec128 = v128;
        }





 public:


 inline __attribute__ ((always_inline)) btVector3()
 {

 }
 inline __attribute__ ((always_inline)) btVector3(const btScalar& _x, const btScalar& _y, const btScalar& _z)
 {
  m_floats[0] = _x;
  m_floats[1] = _y;
  m_floats[2] = _z;
  m_floats[3] = btScalar(0.f);
 }



 inline __attribute__ ((always_inline)) btVector3( btSimdFloat4 v)
 {
  mVec128 = v;
 }


 inline __attribute__ ((always_inline)) btVector3(const btVector3& rhs)
 {
  mVec128 = rhs.mVec128;
 }


 inline __attribute__ ((always_inline)) btVector3&
 operator=(const btVector3& v)
 {
  mVec128 = v.mVec128;

  return *this;
 }




 inline __attribute__ ((always_inline)) btVector3& operator+=(const btVector3& v)
 {

  mVec128 = _mm_add_ps(mVec128, v.mVec128);







  return *this;
 }




 inline __attribute__ ((always_inline)) btVector3& operator-=(const btVector3& v)
 {

  mVec128 = _mm_sub_ps(mVec128, v.mVec128);







  return *this;
 }



 inline __attribute__ ((always_inline)) btVector3& operator*=(const btScalar& s)
 {

  __m128 vs = _mm_load_ss(&s);
  vs = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vs)), (__v4sf)(__m128)((vs)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });
  mVec128 = _mm_mul_ps(mVec128, vs);







  return *this;
 }



 inline __attribute__ ((always_inline)) btVector3& operator/=(const btScalar& s)
 {
                                  ;
  return *this *= btScalar(1.0) / s;

 }



 inline __attribute__ ((always_inline)) btScalar dot(const btVector3& v) const
 {

  __m128 vd = _mm_mul_ps(mVec128, v.mVec128);
  __m128 z = _mm_movehl_ps(vd, vd);
  __m128 y = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vd), (__v4sf)(__m128)(vd), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); });
  vd = _mm_add_ss(vd, y);
  vd = _mm_add_ss(vd, z);
  return _mm_cvtss_f32(vd);
 }


 inline __attribute__ ((always_inline)) btScalar length2() const
 {
  return dot(*this);
 }


 inline __attribute__ ((always_inline)) btScalar length() const
 {
  return btSqrt(length2());
 }


 inline __attribute__ ((always_inline)) btScalar norm() const
 {
  return length();
 }


 inline __attribute__ ((always_inline)) btScalar safeNorm() const
 {
  btScalar d = length2();

  if (d>1.19209290e-7F)
   return btSqrt(d);
  return btScalar(0);
 }



 inline __attribute__ ((always_inline)) btScalar distance2(const btVector3& v) const;



 inline __attribute__ ((always_inline)) btScalar distance(const btVector3& v) const;

 inline __attribute__ ((always_inline)) btVector3& safeNormalize()
 {
  btScalar l2 = length2();

  if (l2 >= 1.19209290e-7F*1.19209290e-7F)
  {
   (*this) /= btSqrt(l2);
  }
  else
  {
   setValue(1, 0, 0);
  }
  return *this;
 }



 inline __attribute__ ((always_inline)) btVector3& normalize()
 {

                        ;



  __m128 vd = _mm_mul_ps(mVec128, mVec128);
  __m128 z = _mm_movehl_ps(vd, vd);
  __m128 y = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vd), (__v4sf)(__m128)(vd), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); });
  vd = _mm_add_ss(vd, y);
  vd = _mm_add_ss(vd, z);
        y = _mm_rsqrt_ss(vd);


        z = (_mm_set_ps(1.5f, 1.5f, 1.5f, 1.5f));
        vd = _mm_mul_ss(vd, (_mm_set_ps(0.5f, 0.5f, 0.5f, 0.5f)));

        vd = _mm_mul_ss(vd, y);
        vd = _mm_mul_ss(vd, y);
        z = _mm_sub_ss(z, vd);

        y = _mm_mul_ss(y, z);

  y = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((y))), (__v4sf)(__m128)(((y))), ((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0x3, (((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0xc) >> 2, ((((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0x30) >> 4) + 4, ((((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0xc0) >> 6) + 4); });
  mVec128 = _mm_mul_ps(mVec128, y);




  return *this;



 }


 inline __attribute__ ((always_inline)) btVector3 normalized() const;




 inline __attribute__ ((always_inline)) btVector3 rotate( const btVector3& wAxis, const btScalar angle ) const;



 inline __attribute__ ((always_inline)) btScalar angle(const btVector3& v) const
 {
  btScalar s = btSqrt(length2() * v.length2());
                                  ;
  return btAcos(dot(v) / s);
 }


 inline __attribute__ ((always_inline)) btVector3 absolute() const
 {


  return btVector3(_mm_and_ps(mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))))));
 }



 inline __attribute__ ((always_inline)) btVector3 cross(const btVector3& v) const
 {

  __m128 T, V;

  T = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((mVec128)), (__v4sf)(__m128)((mVec128)), ((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });
  V = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((v.mVec128)), (__v4sf)(__m128)((v.mVec128)), ((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });

  V = _mm_mul_ps(V, mVec128);
  T = _mm_mul_ps(T, v.mVec128);
  V = _mm_sub_ps(V, T);

  V = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((V)), (__v4sf)(__m128)((V)), ((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((3)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });
  return btVector3(V);
 }

 inline __attribute__ ((always_inline)) btScalar triple(const btVector3& v1, const btVector3& v2) const
 {


  __m128 T = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v1.mVec128), (__v4sf)(__m128)(v1.mVec128), (((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0x3, ((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0xc) >> 2, (((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0x30) >> 4) + 4, (((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0xc0) >> 6) + 4); });
  __m128 V = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v2.mVec128), (__v4sf)(__m128)(v2.mVec128), (((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0x3, ((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0xc) >> 2, (((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0x30) >> 4) + 4, (((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0xc0) >> 6) + 4); });

  V = _mm_mul_ps(V, v1.mVec128);
  T = _mm_mul_ps(T, v2.mVec128);
  V = _mm_sub_ps(V, T);

  V = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(V), (__v4sf)(__m128)(V), (((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0x3, ((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0xc) >> 2, (((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0x30) >> 4) + 4, (((((3)<<6 | (0)<<4 | (2)<<2 | (1))) & 0xc0) >> 6) + 4); });


  V = _mm_mul_ps(V, mVec128);
  __m128 z = _mm_movehl_ps(V, V);
  __m128 y = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(V), (__v4sf)(__m128)(V), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); });
  V = _mm_add_ss(V, y);
  V = _mm_add_ss(V, z);
  return _mm_cvtss_f32(V);
 }



 inline __attribute__ ((always_inline)) int minAxis() const
 {
  return m_floats[0] < m_floats[1] ? (m_floats[0] <m_floats[2] ? 0 : 2) : (m_floats[1] <m_floats[2] ? 1 : 2);
 }



 inline __attribute__ ((always_inline)) int maxAxis() const
 {
  return m_floats[0] < m_floats[1] ? (m_floats[1] <m_floats[2] ? 2 : 1) : (m_floats[0] <m_floats[2] ? 2 : 0);
 }

 inline __attribute__ ((always_inline)) int furthestAxis() const
 {
  return absolute().minAxis();
 }

 inline __attribute__ ((always_inline)) int closestAxis() const
 {
  return absolute().maxAxis();
 }


 inline __attribute__ ((always_inline)) void setInterpolate3(const btVector3& v0, const btVector3& v1, btScalar rt)
 {

  __m128 vrt = _mm_load_ss(&rt);
  btScalar s = btScalar(1.0) - rt;
  __m128 vs = _mm_load_ss(&s);
  vs = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vs)), (__v4sf)(__m128)((vs)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });
  __m128 r0 = _mm_mul_ps(v0.mVec128, vs);
  vrt = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vrt)), (__v4sf)(__m128)((vrt)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });
  __m128 r1 = _mm_mul_ps(v1.mVec128, vrt);
  __m128 tmp3 = _mm_add_ps(r0,r1);
  mVec128 = tmp3;
 }




 inline __attribute__ ((always_inline)) btVector3 lerp(const btVector3& v, const btScalar& t) const
 {

  __m128 vt = _mm_load_ss(&t);
  vt = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vt)), (__v4sf)(__m128)((vt)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });
  __m128 vl = _mm_sub_ps(v.mVec128, mVec128);
  vl = _mm_mul_ps(vl, vt);
  vl = _mm_add_ps(vl, mVec128);

  return btVector3(vl);
 }



 inline __attribute__ ((always_inline)) btVector3& operator*=(const btVector3& v)
 {

  mVec128 = _mm_mul_ps(mVec128, v.mVec128);







  return *this;
 }


  inline __attribute__ ((always_inline)) const btScalar& getX() const { return m_floats[0]; }

  inline __attribute__ ((always_inline)) const btScalar& getY() const { return m_floats[1]; }

  inline __attribute__ ((always_inline)) const btScalar& getZ() const { return m_floats[2]; }

  inline __attribute__ ((always_inline)) void setX(btScalar _x) { m_floats[0] = _x;};

  inline __attribute__ ((always_inline)) void setY(btScalar _y) { m_floats[1] = _y;};

  inline __attribute__ ((always_inline)) void setZ(btScalar _z) { m_floats[2] = _z;};

  inline __attribute__ ((always_inline)) void setW(btScalar _w) { m_floats[3] = _w;};

  inline __attribute__ ((always_inline)) const btScalar& x() const { return m_floats[0]; }

  inline __attribute__ ((always_inline)) const btScalar& y() const { return m_floats[1]; }

  inline __attribute__ ((always_inline)) const btScalar& z() const { return m_floats[2]; }

  inline __attribute__ ((always_inline)) const btScalar& w() const { return m_floats[3]; }




 inline __attribute__ ((always_inline)) operator btScalar *() { return &m_floats[0]; }
 inline __attribute__ ((always_inline)) operator const btScalar *() const { return &m_floats[0]; }

 inline __attribute__ ((always_inline)) bool operator==(const btVector3& other) const
 {

        return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));






 }

 inline __attribute__ ((always_inline)) bool operator!=(const btVector3& other) const
 {
  return !(*this == other);
 }




 inline __attribute__ ((always_inline)) void setMax(const btVector3& other)
 {

  mVec128 = _mm_max_ps(mVec128, other.mVec128);
 }




 inline __attribute__ ((always_inline)) void setMin(const btVector3& other)
 {

  mVec128 = _mm_min_ps(mVec128, other.mVec128);
 }

 inline __attribute__ ((always_inline)) void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
 {
  m_floats[0]=_x;
  m_floats[1]=_y;
  m_floats[2]=_z;
  m_floats[3] = btScalar(0.f);
 }

 void getSkewSymmetricMatrix(btVector3* v0,btVector3* v1,btVector3* v2) const
 {


  __m128 V = _mm_and_ps(mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
  __m128 V0 = _mm_xor_ps((_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f)), V);
  __m128 V2 = _mm_movelh_ps(V0, V);

  __m128 V1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(V), (__v4sf)(__m128)(V0), (0xCE) & 0x3, ((0xCE) & 0xc) >> 2, (((0xCE) & 0x30) >> 4) + 4, (((0xCE) & 0xc0) >> 6) + 4); });

        V0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(V0), (__v4sf)(__m128)(V), (0xDB) & 0x3, ((0xDB) & 0xc) >> 2, (((0xDB) & 0x30) >> 4) + 4, (((0xDB) & 0xc0) >> 6) + 4); });
  V2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(V2), (__v4sf)(__m128)(V), (0xF9) & 0x3, ((0xF9) & 0xc) >> 2, (((0xF9) & 0x30) >> 4) + 4, (((0xF9) & 0xc0) >> 6) + 4); });

  v0->mVec128 = V0;
  v1->mVec128 = V1;
  v2->mVec128 = V2;





 }

 void setZero()
 {

  mVec128 = (__m128)_mm_xor_ps(mVec128, mVec128);






 }

 inline __attribute__ ((always_inline)) bool isZero() const
 {
  return m_floats[0] == btScalar(0) && m_floats[1] == btScalar(0) && m_floats[2] == btScalar(0);
 }


 inline __attribute__ ((always_inline)) bool fuzzyZero() const
 {
  return length2() < 1.19209290e-7F*1.19209290e-7F;
 }

 inline __attribute__ ((always_inline)) void serialize(struct btVector3FloatData& dataOut) const;

 inline __attribute__ ((always_inline)) void deSerialize(const struct btVector3FloatData& dataIn);

 inline __attribute__ ((always_inline)) void serializeFloat(struct btVector3FloatData& dataOut) const;

 inline __attribute__ ((always_inline)) void deSerializeFloat(const struct btVector3FloatData& dataIn);

 inline __attribute__ ((always_inline)) void serializeDouble(struct btVector3DoubleData& dataOut) const;

 inline __attribute__ ((always_inline)) void deSerializeDouble(const struct btVector3DoubleData& dataIn);





        inline __attribute__ ((always_inline)) long maxDot( const btVector3 *array, long array_count, btScalar &dotOut ) const;





        inline __attribute__ ((always_inline)) long minDot( const btVector3 *array, long array_count, btScalar &dotOut ) const;


    inline __attribute__ ((always_inline)) btVector3 dot3( const btVector3 &v0, const btVector3 &v1, const btVector3 &v2 ) const
    {


        __m128 a0 = _mm_mul_ps( v0.mVec128, this->mVec128 );
        __m128 a1 = _mm_mul_ps( v1.mVec128, this->mVec128 );
        __m128 a2 = _mm_mul_ps( v2.mVec128, this->mVec128 );
        __m128 b0 = _mm_unpacklo_ps( a0, a1 );
        __m128 b1 = _mm_unpackhi_ps( a0, a1 );
        __m128 b2 = _mm_unpacklo_ps( a2, _mm_setzero_ps() );
        __m128 r = _mm_movelh_ps( b0, b2 );
        r = _mm_add_ps( r, _mm_movehl_ps( b2, b0 ));
        a2 = _mm_and_ps( a2, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
        r = _mm_add_ps( r, ((__m128) (_mm_move_sd( ((__m128d)(a2)), ((__m128d)(b1)) ))));
        return btVector3(r);
    }
};


inline __attribute__ ((always_inline)) btVector3
operator+(const btVector3& v1, const btVector3& v2)
{

 return btVector3(_mm_add_ps(v1.mVec128, v2.mVec128));
}


inline __attribute__ ((always_inline)) btVector3
operator*(const btVector3& v1, const btVector3& v2)
{

 return btVector3(_mm_mul_ps(v1.mVec128, v2.mVec128));
}


inline __attribute__ ((always_inline)) btVector3
operator-(const btVector3& v1, const btVector3& v2)
{



 __m128 r = _mm_sub_ps(v1.mVec128, v2.mVec128);
 return btVector3(_mm_and_ps(r, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))))));
}


inline __attribute__ ((always_inline)) btVector3
operator-(const btVector3& v)
{

 __m128 r = _mm_xor_ps(v.mVec128, (_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f)));
 return btVector3(_mm_and_ps(r, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))))));





}


inline __attribute__ ((always_inline)) btVector3
operator*(const btVector3& v, const btScalar& s)
{

 __m128 vs = _mm_load_ss(&s);
 vs = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vs)), (__v4sf)(__m128)((vs)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });
 return btVector3(_mm_mul_ps(v.mVec128, vs));






}


inline __attribute__ ((always_inline)) btVector3
operator*(const btScalar& s, const btVector3& v)
{
 return v * s;
}


inline __attribute__ ((always_inline)) btVector3
operator/(const btVector3& v, const btScalar& s)
{
                                 ;
 return v * (btScalar(1.0) / s);

}


inline __attribute__ ((always_inline)) btVector3
operator/(const btVector3& v1, const btVector3& v2)
{

 __m128 vec = _mm_div_ps(v1.mVec128, v2.mVec128);
 vec = _mm_and_ps(vec, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
 return btVector3(vec);
}


inline __attribute__ ((always_inline)) btScalar
btDot(const btVector3& v1, const btVector3& v2)
{
 return v1.dot(v2);
}



inline __attribute__ ((always_inline)) btScalar
btDistance2(const btVector3& v1, const btVector3& v2)
{
 return v1.distance2(v2);
}



inline __attribute__ ((always_inline)) btScalar
btDistance(const btVector3& v1, const btVector3& v2)
{
 return v1.distance(v2);
}


inline __attribute__ ((always_inline)) btScalar
btAngle(const btVector3& v1, const btVector3& v2)
{
 return v1.angle(v2);
}


inline __attribute__ ((always_inline)) btVector3
btCross(const btVector3& v1, const btVector3& v2)
{
 return v1.cross(v2);
}

inline __attribute__ ((always_inline)) btScalar
btTriple(const btVector3& v1, const btVector3& v2, const btVector3& v3)
{
 return v1.triple(v2, v3);
}





inline __attribute__ ((always_inline)) btVector3
lerp(const btVector3& v1, const btVector3& v2, const btScalar& t)
{
 return v1.lerp(v2, t);
}



inline __attribute__ ((always_inline)) btScalar btVector3::distance2(const btVector3& v) const
{
 return (v - *this).length2();
}

inline __attribute__ ((always_inline)) btScalar btVector3::distance(const btVector3& v) const
{
 return (v - *this).length();
}

inline __attribute__ ((always_inline)) btVector3 btVector3::normalized() const
{
 btVector3 nrm = *this;

 return nrm.normalize();
}

inline __attribute__ ((always_inline)) btVector3 btVector3::rotate( const btVector3& wAxis, const btScalar _angle ) const
{




    __m128 O = _mm_mul_ps(wAxis.mVec128, mVec128);
 btScalar ssin = btSin( _angle );
    __m128 C = wAxis.cross( mVec128 ).mVec128;
 O = _mm_and_ps(O, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
    btScalar scos = btCos( _angle );

 __m128 vsin = _mm_load_ss(&ssin);
    __m128 vcos = _mm_load_ss(&scos);

 __m128 Y = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((O)), (__v4sf)(__m128)((O)), ((0xC9)) & 0x3, (((0xC9)) & 0xc) >> 2, ((((0xC9)) & 0x30) >> 4) + 4, ((((0xC9)) & 0xc0) >> 6) + 4); });
 __m128 Z = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((O)), (__v4sf)(__m128)((O)), ((0xD2)) & 0x3, (((0xD2)) & 0xc) >> 2, ((((0xD2)) & 0x30) >> 4) + 4, ((((0xD2)) & 0xc0) >> 6) + 4); });
 O = _mm_add_ps(O, Y);
 vsin = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vsin)), (__v4sf)(__m128)((vsin)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });
 O = _mm_add_ps(O, Z);
    vcos = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vcos)), (__v4sf)(__m128)((vcos)), ((0x80)) & 0x3, (((0x80)) & 0xc) >> 2, ((((0x80)) & 0x30) >> 4) + 4, ((((0x80)) & 0xc0) >> 6) + 4); });

    vsin = vsin * C;
 O = O * wAxis.mVec128;
 __m128 X = mVec128 - O;

    O = O + vsin;
 vcos = vcos * X;
 O = O + vcos;

 return btVector3(O);
}

inline __attribute__ ((always_inline)) long btVector3::maxDot( const btVector3 *array, long array_count, btScalar &dotOut ) const
{


        const long scalar_cutoff = 10;
        long _maxdot_large( const float *array, const float *vec, unsigned long array_count, float *dotOut );




    if( array_count < scalar_cutoff )

    {
        btScalar maxDot1 = -3.40282347e+38F;
        int i = 0;
        int ptIndex = -1;
        for( i = 0; i < array_count; i++ )
        {
            btScalar dot = array[i].dot(*this);

            if( dot > maxDot1 )
            {
                maxDot1 = dot;
                ptIndex = i;
            }
        }

        dotOut = maxDot1;
        return ptIndex;
    }

    return _maxdot_large( (float*) array, (float*) &m_floats[0], array_count, &dotOut );

}

inline __attribute__ ((always_inline)) long btVector3::minDot( const btVector3 *array, long array_count, btScalar &dotOut ) const
{


        const long scalar_cutoff = 10;
        long _mindot_large( const float *array, const float *vec, unsigned long array_count, float *dotOut );







    if( array_count < scalar_cutoff )

    {
        btScalar minDot = 3.40282347e+38F;
        int i = 0;
        int ptIndex = -1;

        for( i = 0; i < array_count; i++ )
        {
            btScalar dot = array[i].dot(*this);

            if( dot < minDot )
            {
                minDot = dot;
                ptIndex = i;
            }
        }

        dotOut = minDot;

        return ptIndex;
    }

    return _mindot_large( (float*) array, (float*) &m_floats[0], array_count, &dotOut );

}


class btVector4 : public btVector3
{
public:

 inline __attribute__ ((always_inline)) btVector4() {}


 inline __attribute__ ((always_inline)) btVector4(const btScalar& _x, const btScalar& _y, const btScalar& _z,const btScalar& _w)
  : btVector3(_x,_y,_z)
 {
  m_floats[3] = _w;
 }


 inline __attribute__ ((always_inline)) btVector4(const btSimdFloat4 vec)
 {
  mVec128 = vec;
 }

 inline __attribute__ ((always_inline)) btVector4(const btVector3& rhs)
 {
  mVec128 = rhs.mVec128;
 }

 inline __attribute__ ((always_inline)) btVector4&
 operator=(const btVector4& v)
 {
  mVec128 = v.mVec128;
  return *this;
 }


 inline __attribute__ ((always_inline)) btVector4 absolute4() const
 {

  return btVector4(_mm_and_ps(mVec128, ((__m128) ((_mm_set_epi32( 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))))));
 }


 btScalar getW() const { return m_floats[3];}


  inline __attribute__ ((always_inline)) int maxAxis4() const
 {
  int maxIndex = -1;
  btScalar maxVal = btScalar(-1e18f);
  if (m_floats[0] > maxVal)
  {
   maxIndex = 0;
   maxVal = m_floats[0];
  }
  if (m_floats[1] > maxVal)
  {
   maxIndex = 1;
   maxVal = m_floats[1];
  }
  if (m_floats[2] > maxVal)
  {
   maxIndex = 2;
   maxVal =m_floats[2];
  }
  if (m_floats[3] > maxVal)
  {
   maxIndex = 3;
   maxVal = m_floats[3];
  }

  return maxIndex;
 }


 inline __attribute__ ((always_inline)) int minAxis4() const
 {
  int minIndex = -1;
  btScalar minVal = btScalar(1e18f);
  if (m_floats[0] < minVal)
  {
   minIndex = 0;
   minVal = m_floats[0];
  }
  if (m_floats[1] < minVal)
  {
   minIndex = 1;
   minVal = m_floats[1];
  }
  if (m_floats[2] < minVal)
  {
   minIndex = 2;
   minVal =m_floats[2];
  }
  if (m_floats[3] < minVal)
  {
   minIndex = 3;
   minVal = m_floats[3];
  }

  return minIndex;
 }


 inline __attribute__ ((always_inline)) int closestAxis4() const
 {
  return absolute4().maxAxis4();
 }
  inline __attribute__ ((always_inline)) void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z,const btScalar& _w)
  {
   m_floats[0]=_x;
   m_floats[1]=_y;
   m_floats[2]=_z;
   m_floats[3]=_w;
  }


};



inline __attribute__ ((always_inline)) void btSwapScalarEndian(const btScalar& sourceVal, btScalar& destVal)
{
 unsigned char* dest = (unsigned char*) &destVal;
 unsigned char* src = (unsigned char*) &sourceVal;
 dest[0] = src[3];
    dest[1] = src[2];
    dest[2] = src[1];
    dest[3] = src[0];

}

inline __attribute__ ((always_inline)) void btSwapVector3Endian(const btVector3& sourceVec, btVector3& destVec)
{
 for (int i=0;i<4;i++)
 {
  btSwapScalarEndian(sourceVec[i],destVec[i]);
 }

}


inline __attribute__ ((always_inline)) void btUnSwapVector3Endian(btVector3& vector)
{

 btVector3 swappedVec;
 for (int i=0;i<4;i++)
 {
  btSwapScalarEndian(vector[i],swappedVec[i]);
 }
 vector = swappedVec;
}

template <class T>
inline __attribute__ ((always_inline)) void btPlaneSpace1 (const T& n, T& p, T& q)
{
  if (btFabs(n[2]) > btScalar(0.7071067811865475244008443621048490)) {

    btScalar a = n[1]*n[1] + n[2]*n[2];
    btScalar k = ((btScalar)(btScalar(1.0)/btSqrt(btScalar(a))));
    p[0] = 0;
 p[1] = -n[2]*k;
 p[2] = n[1]*k;

    q[0] = a*k;
 q[1] = -n[0]*p[2];
 q[2] = n[0]*p[1];
  }
  else {

    btScalar a = n[0]*n[0] + n[1]*n[1];
    btScalar k = ((btScalar)(btScalar(1.0)/btSqrt(btScalar(a))));
    p[0] = -n[1]*k;
 p[1] = n[0]*k;
 p[2] = 0;

    q[0] = -n[2]*p[1];
 q[1] = n[2]*p[0];
 q[2] = a*k;
  }
}


struct btVector3FloatData
{
 float m_floats[4];
};

struct btVector3DoubleData
{
 double m_floats[4];

};

inline __attribute__ ((always_inline)) void btVector3::serializeFloat(struct btVector3FloatData& dataOut) const
{

 for (int i=0;i<4;i++)
  dataOut.m_floats[i] = float(m_floats[i]);
}

inline __attribute__ ((always_inline)) void btVector3::deSerializeFloat(const struct btVector3FloatData& dataIn)
{
 for (int i=0;i<4;i++)
  m_floats[i] = btScalar(dataIn.m_floats[i]);
}


inline __attribute__ ((always_inline)) void btVector3::serializeDouble(struct btVector3DoubleData& dataOut) const
{

 for (int i=0;i<4;i++)
  dataOut.m_floats[i] = double(m_floats[i]);
}

inline __attribute__ ((always_inline)) void btVector3::deSerializeDouble(const struct btVector3DoubleData& dataIn)
{
 for (int i=0;i<4;i++)
  m_floats[i] = btScalar(dataIn.m_floats[i]);
}


inline __attribute__ ((always_inline)) void btVector3::serialize(struct btVector3FloatData& dataOut) const
{

 for (int i=0;i<4;i++)
  dataOut.m_floats[i] = m_floats[i];
}

inline __attribute__ ((always_inline)) void btVector3::deSerialize(const struct btVector3FloatData& dataIn)
{
 for (int i=0;i<4;i++)
  m_floats[i] = dataIn.m_floats[i];
}

class __attribute__ ((aligned (16))) btQuadWord



{
protected:
 union {
  btSimdFloat4 mVec128;
  btScalar m_floats[4];
 };
public:
 inline __attribute__ ((always_inline)) btSimdFloat4 get128() const
 {
  return mVec128;
 }
 inline __attribute__ ((always_inline)) void set128(btSimdFloat4 v128)
 {
  mVec128 = v128;
 }






 public:




 inline __attribute__ ((always_inline)) btQuadWord(const btSimdFloat4 vec)
 {
  mVec128 = vec;
 }


 inline __attribute__ ((always_inline)) btQuadWord(const btQuadWord& rhs)
 {
  mVec128 = rhs.mVec128;
 }


 inline __attribute__ ((always_inline)) btQuadWord&
 operator=(const btQuadWord& v)
 {
  mVec128 = v.mVec128;

  return *this;
 }




  inline __attribute__ ((always_inline)) const btScalar& getX() const { return m_floats[0]; }

  inline __attribute__ ((always_inline)) const btScalar& getY() const { return m_floats[1]; }

  inline __attribute__ ((always_inline)) const btScalar& getZ() const { return m_floats[2]; }

  inline __attribute__ ((always_inline)) void setX(btScalar _x) { m_floats[0] = _x;};

  inline __attribute__ ((always_inline)) void setY(btScalar _y) { m_floats[1] = _y;};

  inline __attribute__ ((always_inline)) void setZ(btScalar _z) { m_floats[2] = _z;};

  inline __attribute__ ((always_inline)) void setW(btScalar _w) { m_floats[3] = _w;};

  inline __attribute__ ((always_inline)) const btScalar& x() const { return m_floats[0]; }

  inline __attribute__ ((always_inline)) const btScalar& y() const { return m_floats[1]; }

  inline __attribute__ ((always_inline)) const btScalar& z() const { return m_floats[2]; }

  inline __attribute__ ((always_inline)) const btScalar& w() const { return m_floats[3]; }




 inline __attribute__ ((always_inline)) operator btScalar *() { return &m_floats[0]; }
 inline __attribute__ ((always_inline)) operator const btScalar *() const { return &m_floats[0]; }

 inline __attribute__ ((always_inline)) bool operator==(const btQuadWord& other) const
 {

        return (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));






 }

 inline __attribute__ ((always_inline)) bool operator!=(const btQuadWord& other) const
 {
  return !(*this == other);
 }






  inline __attribute__ ((always_inline)) void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z)
  {
   m_floats[0]=_x;
   m_floats[1]=_y;
   m_floats[2]=_z;
   m_floats[3] = 0.f;
  }
  inline __attribute__ ((always_inline)) void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z,const btScalar& _w)
  {
   m_floats[0]=_x;
   m_floats[1]=_y;
   m_floats[2]=_z;
   m_floats[3]=_w;
  }

  inline __attribute__ ((always_inline)) btQuadWord()

  {
  }






  inline __attribute__ ((always_inline)) btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z)
  {
   m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = 0.0f;
  }







  inline __attribute__ ((always_inline)) btQuadWord(const btScalar& _x, const btScalar& _y, const btScalar& _z,const btScalar& _w)
  {
   m_floats[0] = _x, m_floats[1] = _y, m_floats[2] = _z, m_floats[3] = _w;
  }




  inline __attribute__ ((always_inline)) void setMax(const btQuadWord& other)
  {

            mVec128 = _mm_max_ps(mVec128, other.mVec128);
        }



  inline __attribute__ ((always_inline)) void setMin(const btQuadWord& other)
  {

            mVec128 = _mm_min_ps(mVec128, other.mVec128);
        }



};
class btQuaternion : public btQuadWord {
public:

 btQuaternion() {}



 inline __attribute__ ((always_inline)) btQuaternion(const btSimdFloat4 vec)
 {
  mVec128 = vec;
 }


 inline __attribute__ ((always_inline)) btQuaternion(const btQuaternion& rhs)
 {
  mVec128 = rhs.mVec128;
 }


 inline __attribute__ ((always_inline)) btQuaternion&
 operator=(const btQuaternion& v)
 {
  mVec128 = v.mVec128;

  return *this;
 }






 btQuaternion(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)
  : btQuadWord(_x, _y, _z, _w)
 {}



 btQuaternion(const btVector3& _axis, const btScalar& _angle)
 {
  setRotation(_axis, _angle);
 }




 btQuaternion(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
 {

  setEuler(yaw, pitch, roll);



 }



 void setRotation(const btVector3& axis, const btScalar& _angle)
 {
  btScalar d = axis.length();
                              ;
  btScalar s = btSin(_angle * btScalar(0.5)) / d;
  setValue(axis.x() * s, axis.y() * s, axis.z() * s,
   btCos(_angle * btScalar(0.5)));
 }




 void setEuler(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
 {
  btScalar halfYaw = btScalar(yaw) * btScalar(0.5);
  btScalar halfPitch = btScalar(pitch) * btScalar(0.5);
  btScalar halfRoll = btScalar(roll) * btScalar(0.5);
  btScalar cosYaw = btCos(halfYaw);
  btScalar sinYaw = btSin(halfYaw);
  btScalar cosPitch = btCos(halfPitch);
  btScalar sinPitch = btSin(halfPitch);
  btScalar cosRoll = btCos(halfRoll);
  btScalar sinRoll = btSin(halfRoll);
  setValue(cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,
   cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,
   sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,
   cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);
 }




 void setEulerZYX(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
 {
  btScalar halfYaw = btScalar(yaw) * btScalar(0.5);
  btScalar halfPitch = btScalar(pitch) * btScalar(0.5);
  btScalar halfRoll = btScalar(roll) * btScalar(0.5);
  btScalar cosYaw = btCos(halfYaw);
  btScalar sinYaw = btSin(halfYaw);
  btScalar cosPitch = btCos(halfPitch);
  btScalar sinPitch = btSin(halfPitch);
  btScalar cosRoll = btCos(halfRoll);
  btScalar sinRoll = btSin(halfRoll);
  setValue(sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,
                         cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,
                         cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,
                         cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);
 }


 inline __attribute__ ((always_inline)) btQuaternion& operator+=(const btQuaternion& q)
 {

  mVec128 = _mm_add_ps(mVec128, q.mVec128);
  return *this;
 }



 btQuaternion& operator-=(const btQuaternion& q)
 {

  mVec128 = _mm_sub_ps(mVec128, q.mVec128);
        return *this;
 }



 btQuaternion& operator*=(const btScalar& s)
 {

  __m128 vs = _mm_load_ss(&s);
  vs = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vs)), (__v4sf)(__m128)((vs)), ((0)) & 0x3, (((0)) & 0xc) >> 2, ((((0)) & 0x30) >> 4) + 4, ((((0)) & 0xc0) >> 6) + 4); });
  mVec128 = _mm_mul_ps(mVec128, vs);
  return *this;
 }




 btQuaternion& operator*=(const btQuaternion& q)
 {

  __m128 vQ2 = q.get128();

  __m128 A1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((mVec128)), (__v4sf)(__m128)((mVec128)), ((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x3, (((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc0) >> 6) + 4); });
  __m128 B1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x3, (((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc) >> 2, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc0) >> 6) + 4); });

  A1 = A1 * B1;

  __m128 A2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((mVec128)), (__v4sf)(__m128)((mVec128)), ((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });
  __m128 B2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });

  A2 = A2 * B2;

  B1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((mVec128)), (__v4sf)(__m128)((mVec128)), ((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });
  B2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });

  B1 = B1 * B2;

  mVec128 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((mVec128))), (__v4sf)(__m128)(((mVec128))), ((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x3, (((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc) >> 2, ((((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x30) >> 4) + 4, ((((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc0) >> 6) + 4); });
  mVec128 = mVec128 * vQ2;

  A1 = A1 + A2;
  mVec128 = mVec128 - B1;
  A1 = _mm_xor_ps(A1, (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f)));
  mVec128 = mVec128+ A1;
  return *this;
 }


 btScalar dot(const btQuaternion& q) const
 {

  __m128 vd;

  vd = _mm_mul_ps(mVec128, q.mVec128);

        __m128 t = _mm_movehl_ps(vd, vd);
  vd = _mm_add_ps(vd, t);
  t = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vd), (__v4sf)(__m128)(vd), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); });
  vd = _mm_add_ss(vd, t);

        return _mm_cvtss_f32(vd);
 }


 btScalar length2() const
 {
  return dot(*this);
 }


 btScalar length() const
 {
  return btSqrt(length2());
 }



 btQuaternion& normalize()
 {

  __m128 vd;

  vd = _mm_mul_ps(mVec128, mVec128);

        __m128 t = _mm_movehl_ps(vd, vd);
  vd = _mm_add_ps(vd, t);
  t = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(vd), (__v4sf)(__m128)(vd), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); });
  vd = _mm_add_ss(vd, t);

  vd = _mm_sqrt_ss(vd);
  vd = _mm_div_ss((_mm_set_ps(1.0f, 1.0f, 1.0f, 1.0f)), vd);
        vd = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vd)), (__v4sf)(__m128)((vd)), ((0)) & 0x3, (((0)) & 0xc) >> 2, ((((0)) & 0x30) >> 4) + 4, ((((0)) & 0xc0) >> 6) + 4); });
  mVec128 = _mm_mul_ps(mVec128, vd);

  return *this;



 }



 inline __attribute__ ((always_inline)) btQuaternion
 operator*(const btScalar& s) const
 {

  __m128 vs = _mm_load_ss(&s);
  vs = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vs)), (__v4sf)(__m128)((vs)), ((0x00)) & 0x3, (((0x00)) & 0xc) >> 2, ((((0x00)) & 0x30) >> 4) + 4, ((((0x00)) & 0xc0) >> 6) + 4); });

  return btQuaternion(_mm_mul_ps(mVec128, vs));





 }



 btQuaternion operator/(const btScalar& s) const
 {
                              ;
  return *this * (btScalar(1.0) / s);
 }



 btQuaternion& operator/=(const btScalar& s)
 {
                              ;
  return *this *= btScalar(1.0) / s;
 }


 btQuaternion normalized() const
 {
  return *this / length();
 }


 btScalar angle(const btQuaternion& q) const
 {
  btScalar s = btSqrt(length2() * q.length2());
                              ;
  return btAcos(dot(q) / s);
 }



 btScalar angleShortestPath(const btQuaternion& q) const
 {
  btScalar s = btSqrt(length2() * q.length2());
                              ;
  if (dot(q) < 0)
   return btAcos(dot(-q) / s) * btScalar(2.0);
  else
   return btAcos(dot(q) / s) * btScalar(2.0);
 }


 btScalar getAngle() const
 {
  btScalar s = btScalar(2.) * btAcos(m_floats[3]);
  return s;
 }


 btScalar getAngleShortestPath() const
 {
  btScalar s;
  if (m_floats[3] >= 0)
   s = btScalar(2.) * btAcos(m_floats[3]);
  else
   s = btScalar(2.) * btAcos(-m_floats[3]);
  return s;
 }



 btVector3 getAxis() const
 {
  btScalar s_squared = 1.f-m_floats[3]*m_floats[3];

  if (s_squared < btScalar(10.) * 1.19209290e-7F)
   return btVector3(1.0, 0.0, 0.0);
  btScalar s = 1.f/btSqrt(s_squared);
  return btVector3(m_floats[0] * s, m_floats[1] * s, m_floats[2] * s);
 }


 btQuaternion inverse() const
 {

  return btQuaternion(_mm_xor_ps(mVec128, (_mm_set_ps(+0.0f, -0.0f, -0.0f, -0.0f))));





 }



 inline __attribute__ ((always_inline)) btQuaternion
 operator+(const btQuaternion& q2) const
 {

  return btQuaternion(_mm_add_ps(mVec128, q2.mVec128));






 }



 inline __attribute__ ((always_inline)) btQuaternion
 operator-(const btQuaternion& q2) const
 {

  return btQuaternion(_mm_sub_ps(mVec128, q2.mVec128));






 }



 inline __attribute__ ((always_inline)) btQuaternion operator-() const
 {

  return btQuaternion(_mm_xor_ps(mVec128, (_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f))));






 }

 inline __attribute__ ((always_inline)) btQuaternion farthest( const btQuaternion& qd) const
 {
  btQuaternion diff,sum;
  diff = *this - qd;
  sum = *this + qd;
  if( diff.dot(diff) > sum.dot(sum) )
   return qd;
  return (-qd);
 }


 inline __attribute__ ((always_inline)) btQuaternion nearest( const btQuaternion& qd) const
 {
  btQuaternion diff,sum;
  diff = *this - qd;
  sum = *this + qd;
  if( diff.dot(diff) < sum.dot(sum) )
   return qd;
  return (-qd);
 }






 btQuaternion slerp(const btQuaternion& q, const btScalar& t) const
 {

  const btScalar magnitude = btSqrt(length2() * q.length2());
                                   ;

  const btScalar product = dot(q) / magnitude;
  const btScalar absproduct = btFabs(product);

  if(absproduct < btScalar(1.0 - 1.19209290e-7F))
  {

   const btScalar theta = btAcos(absproduct);
   const btScalar d = btSin(theta);
                            ;

   const btScalar sign = (product < 0) ? btScalar(-1) : btScalar(1);
   const btScalar s0 = btSin((btScalar(1.0) - t) * theta) / d;
   const btScalar s1 = btSin(sign * t * theta) / d;

   return btQuaternion(
    (m_floats[0] * s0 + q.x() * s1),
    (m_floats[1] * s0 + q.y() * s1),
    (m_floats[2] * s0 + q.z() * s1),
    (m_floats[3] * s0 + q.w() * s1));
  }
  else
  {
   return *this;
  }
 }

 static const btQuaternion& getIdentity()
 {
  static const btQuaternion identityQuat(btScalar(0.),btScalar(0.),btScalar(0.),btScalar(1.));
  return identityQuat;
 }

 inline __attribute__ ((always_inline)) const btScalar& getW() const { return m_floats[3]; }

 inline __attribute__ ((always_inline)) void serialize(struct btQuaternionFloatData& dataOut) const;

 inline __attribute__ ((always_inline)) void deSerialize(const struct btQuaternionFloatData& dataIn);

 inline __attribute__ ((always_inline)) void serializeFloat(struct btQuaternionFloatData& dataOut) const;

 inline __attribute__ ((always_inline)) void deSerializeFloat(const struct btQuaternionFloatData& dataIn);

 inline __attribute__ ((always_inline)) void serializeDouble(struct btQuaternionDoubleData& dataOut) const;

 inline __attribute__ ((always_inline)) void deSerializeDouble(const struct btQuaternionDoubleData& dataIn);

};






inline __attribute__ ((always_inline)) btQuaternion
operator*(const btQuaternion& q1, const btQuaternion& q2)
{

 __m128 vQ1 = q1.get128();
 __m128 vQ2 = q2.get128();
 __m128 A0, A1, B1, A2, B2;

 A1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x3, (((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc0) >> 6) + 4); });
 B1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x3, (((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc) >> 2, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc0) >> 6) + 4); });

 A1 = A1 * B1;

 A2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });
 B2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });

 A2 = A2 * B2;

 B1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });
 B2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });

 B1 = B1 * B2;

 A0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((vQ1))), (__v4sf)(__m128)(((vQ1))), ((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x3, (((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc) >> 2, ((((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x30) >> 4) + 4, ((((((3)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc0) >> 6) + 4); });
 A0 = A0 * vQ2;

 A1 = A1 + A2;
 A0 = A0 - B1;

    A1 = _mm_xor_ps(A1, (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f)));
 A0 = A0 + A1;

 return btQuaternion(A0);
}

inline __attribute__ ((always_inline)) btQuaternion
operator*(const btQuaternion& q, const btVector3& w)
{

 __m128 vQ1 = q.get128();
 __m128 vQ2 = w.get128();
 __m128 A1, B1, A2, B2, A3, B3;

 A1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x3, (((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc) >> 2, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc0) >> 6) + 4); });
 B1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x3, (((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc0) >> 6) + 4); });

 A1 = A1 * B1;

 A2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });
 B2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });

 A2 = A2 * B2;

 A3 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });
 B3 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });

 A3 = A3 * B3;

 A1 = A1 + A2;
 A1 = _mm_xor_ps(A1, (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f)));
    A1 = A1 - A3;

 return btQuaternion(A1);
}

inline __attribute__ ((always_inline)) btQuaternion
operator*(const btVector3& w, const btQuaternion& q)
{

 __m128 vQ1 = w.get128();
 __m128 vQ2 = q.get128();
 __m128 A1, B1, A2, B2, A3, B3;

 A1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x3, (((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (2)<<4 | (1)<<2 | (0)))) & 0xc0) >> 6) + 4); });
 B1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x3, (((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc) >> 2, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (3)<<4 | (3)<<2 | (3)))) & 0xc0) >> 6) + 4); });

 A1 = A1 * B1;

 A2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });
 B2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });

 A2 = A2 *B2;

 A3 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ1)), (__v4sf)(__m128)((vQ1)), ((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x3, (((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (1)<<4 | (0)<<2 | (2)))) & 0xc0) >> 6) + 4); });
 B3 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)((vQ2)), (__v4sf)(__m128)((vQ2)), ((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x3, (((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc) >> 2, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (0)<<4 | (2)<<2 | (1)))) & 0xc0) >> 6) + 4); });

 A3 = A3 * B3;

 A1 = A1 + A2;
 A1 = _mm_xor_ps(A1, (_mm_set_ps(-0.0f, +0.0f, +0.0f, +0.0f)));
 A1 = A1 - A3;

 return btQuaternion(A1);
}


inline __attribute__ ((always_inline)) btScalar
dot(const btQuaternion& q1, const btQuaternion& q2)
{
 return q1.dot(q2);
}



inline __attribute__ ((always_inline)) btScalar
length(const btQuaternion& q)
{
 return q.length();
}


inline __attribute__ ((always_inline)) btScalar
btAngle(const btQuaternion& q1, const btQuaternion& q2)
{
 return q1.angle(q2);
}


inline __attribute__ ((always_inline)) btQuaternion
inverse(const btQuaternion& q)
{
 return q.inverse();
}






inline __attribute__ ((always_inline)) btQuaternion
slerp(const btQuaternion& q1, const btQuaternion& q2, const btScalar& t)
{
 return q1.slerp(q2, t);
}

inline __attribute__ ((always_inline)) btVector3
quatRotate(const btQuaternion& rotation, const btVector3& v)
{
 btQuaternion q = rotation * v;
 q *= rotation.inverse();

 return btVector3(_mm_and_ps(q.get128(), ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))))));





}

inline __attribute__ ((always_inline)) btQuaternion
shortestArcQuat(const btVector3& v0, const btVector3& v1)
{
 btVector3 c = v0.cross(v1);
 btScalar d = v0.dot(v1);

 if (d < -1.0 + 1.19209290e-7F)
 {
  btVector3 n,unused;
  btPlaneSpace1(v0,n,unused);
  return btQuaternion(n.x(),n.y(),n.z(),0.0f);
 }

 btScalar s = btSqrt((1.0f + d) * 2.0f);
 btScalar rs = 1.0f / s;

 return btQuaternion(c.getX()*rs,c.getY()*rs,c.getZ()*rs,s * 0.5f);
}

inline __attribute__ ((always_inline)) btQuaternion
shortestArcQuatNormalize2(btVector3& v0,btVector3& v1)
{
 v0.normalize();
 v1.normalize();
 return shortestArcQuat(v0,v1);
}




struct btQuaternionFloatData
{
 float m_floats[4];
};

struct btQuaternionDoubleData
{
 double m_floats[4];

};

inline __attribute__ ((always_inline)) void btQuaternion::serializeFloat(struct btQuaternionFloatData& dataOut) const
{

 for (int i=0;i<4;i++)
  dataOut.m_floats[i] = float(m_floats[i]);
}

inline __attribute__ ((always_inline)) void btQuaternion::deSerializeFloat(const struct btQuaternionFloatData& dataIn)
{
 for (int i=0;i<4;i++)
  m_floats[i] = btScalar(dataIn.m_floats[i]);
}


inline __attribute__ ((always_inline)) void btQuaternion::serializeDouble(struct btQuaternionDoubleData& dataOut) const
{

 for (int i=0;i<4;i++)
  dataOut.m_floats[i] = double(m_floats[i]);
}

inline __attribute__ ((always_inline)) void btQuaternion::deSerializeDouble(const struct btQuaternionDoubleData& dataIn)
{
 for (int i=0;i<4;i++)
  m_floats[i] = btScalar(dataIn.m_floats[i]);
}


inline __attribute__ ((always_inline)) void btQuaternion::serialize(struct btQuaternionFloatData& dataOut) const
{

 for (int i=0;i<4;i++)
  dataOut.m_floats[i] = m_floats[i];
}

inline __attribute__ ((always_inline)) void btQuaternion::deSerialize(const struct btQuaternionFloatData& dataIn)
{
 for (int i=0;i<4;i++)
  m_floats[i] = dataIn.m_floats[i];
}


namespace Urho3D
{

inline btVector3 ToBtVector3(const Vector3& vector)
{
    return btVector3(vector.x_, vector.y_, vector.z_);
}

inline btQuaternion ToBtQuaternion(const Quaternion& quaternion)
{
    return btQuaternion(quaternion.x_, quaternion.y_, quaternion.z_, quaternion.w_);
}

inline Vector3 ToVector3(const btVector3& vector)
{
    return Vector3(vector.x(), vector.y(), vector.z());
}

inline Quaternion ToQuaternion(const btQuaternion& quaternion)
{
    return Quaternion(quaternion.w(), quaternion.x(), quaternion.y(), quaternion.z());
}

inline bool HasWorldScaleChanged(const Vector3& oldWorldScale, const Vector3& newWorldScale)
{
    Vector3 delta = newWorldScale - oldWorldScale;
    float dot = delta.DotProduct(delta);
    return dot > 0.01f;
}

}
class __attribute__ ((aligned (16))) btMatrix3x3 {


 btVector3 m_el[3];

public:

 btMatrix3x3 () {}




 explicit btMatrix3x3(const btQuaternion& q) { setRotation(q); }
 btMatrix3x3(const btScalar& xx, const btScalar& xy, const btScalar& xz,
  const btScalar& yx, const btScalar& yy, const btScalar& yz,
  const btScalar& zx, const btScalar& zy, const btScalar& zz)
 {
  setValue(xx, xy, xz,
   yx, yy, yz,
   zx, zy, zz);
 }


 inline __attribute__ ((always_inline)) btMatrix3x3 (const btSimdFloat4 v0, const btSimdFloat4 v1, const btSimdFloat4 v2 )
 {
        m_el[0].mVec128 = v0;
        m_el[1].mVec128 = v1;
        m_el[2].mVec128 = v2;
 }

 inline __attribute__ ((always_inline)) btMatrix3x3 (const btVector3& v0, const btVector3& v1, const btVector3& v2 )
 {
        m_el[0] = v0;
        m_el[1] = v1;
        m_el[2] = v2;
 }


 inline __attribute__ ((always_inline)) btMatrix3x3(const btMatrix3x3& rhs)
 {
  m_el[0].mVec128 = rhs.m_el[0].mVec128;
  m_el[1].mVec128 = rhs.m_el[1].mVec128;
  m_el[2].mVec128 = rhs.m_el[2].mVec128;
 }


 inline __attribute__ ((always_inline)) btMatrix3x3& operator=(const btMatrix3x3& m)
 {
  m_el[0].mVec128 = m.m_el[0].mVec128;
  m_el[1].mVec128 = m.m_el[1].mVec128;
  m_el[2].mVec128 = m.m_el[2].mVec128;

  return *this;
 }
 inline __attribute__ ((always_inline)) btVector3 getColumn(int i) const
 {
  return btVector3(m_el[0][i],m_el[1][i],m_el[2][i]);
 }




 inline __attribute__ ((always_inline)) const btVector3& getRow(int i) const
 {
                               ;
  return m_el[i];
 }



 inline __attribute__ ((always_inline)) btVector3& operator[](int i)
 {
                               ;
  return m_el[i];
 }



 inline __attribute__ ((always_inline)) const btVector3& operator[](int i) const
 {
                               ;
  return m_el[i];
 }




 btMatrix3x3& operator*=(const btMatrix3x3& m);




 btMatrix3x3& operator+=(const btMatrix3x3& m);




 btMatrix3x3& operator-=(const btMatrix3x3& m);



 void setFromOpenGLSubMatrix(const btScalar *m)
 {
  m_el[0].setValue(m[0],m[4],m[8]);
  m_el[1].setValue(m[1],m[5],m[9]);
  m_el[2].setValue(m[2],m[6],m[10]);

 }
 void setValue(const btScalar& xx, const btScalar& xy, const btScalar& xz,
  const btScalar& yx, const btScalar& yy, const btScalar& yz,
  const btScalar& zx, const btScalar& zy, const btScalar& zz)
 {
  m_el[0].setValue(xx,xy,xz);
  m_el[1].setValue(yx,yy,yz);
  m_el[2].setValue(zx,zy,zz);
 }



 void setRotation(const btQuaternion& q)
 {
  btScalar d = q.length2();
                                  ;
  btScalar s = btScalar(2.0) / d;


        __m128 vs, Q = q.get128();
  __m128i Qi = ((__m128i)(Q));
        __m128 Y, Z;
        __m128 V1, V2, V3;
        __m128 V11, V21, V31;
        __m128 NQ = _mm_xor_ps(Q, (_mm_set_ps(-0.0f, -0.0f, -0.0f, -0.0f)));
  __m128i NQi = ((__m128i)(NQ));

        V1 = ((__m128) (__extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(Qi), (__v4si)_mm_setzero_si128(), (((3)<<6 | (2)<<4 | (0)<<2 | (1))) & 0x3, ((((3)<<6 | (2)<<4 | (0)<<2 | (1))) & 0xc) >> 2, ((((3)<<6 | (2)<<4 | (0)<<2 | (1))) & 0x30) >> 4, ((((3)<<6 | (2)<<4 | (0)<<2 | (1))) & 0xc0) >> 6); })));
  V2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(NQ), (__v4sf)(__m128)(Q), (((3)<<6 | (1)<<4 | (0)<<2 | (0))) & 0x3, ((((3)<<6 | (1)<<4 | (0)<<2 | (0))) & 0xc) >> 2, (((((3)<<6 | (1)<<4 | (0)<<2 | (0))) & 0x30) >> 4) + 4, (((((3)<<6 | (1)<<4 | (0)<<2 | (0))) & 0xc0) >> 6) + 4); });
        V3 = ((__m128) (__extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(Qi), (__v4si)_mm_setzero_si128(), (((3)<<6 | (0)<<4 | (1)<<2 | (2))) & 0x3, ((((3)<<6 | (0)<<4 | (1)<<2 | (2))) & 0xc) >> 2, ((((3)<<6 | (0)<<4 | (1)<<2 | (2))) & 0x30) >> 4, ((((3)<<6 | (0)<<4 | (1)<<2 | (2))) & 0xc0) >> 6); })));
        V1 = _mm_xor_ps(V1, (_mm_set_ps (+0.0f, +0.0f, +0.0f, -0.0f)));

        V11 = ((__m128) (__extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(Qi), (__v4si)_mm_setzero_si128(), (((3)<<6 | (0)<<4 | (1)<<2 | (1))) & 0x3, ((((3)<<6 | (0)<<4 | (1)<<2 | (1))) & 0xc) >> 2, ((((3)<<6 | (0)<<4 | (1)<<2 | (1))) & 0x30) >> 4, ((((3)<<6 | (0)<<4 | (1)<<2 | (1))) & 0xc0) >> 6); })));
  V21 = _mm_unpackhi_ps(Q, Q);
  V31 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(Q), (__v4sf)(__m128)(NQ), (((3)<<6 | (0)<<4 | (2)<<2 | (0))) & 0x3, ((((3)<<6 | (0)<<4 | (2)<<2 | (0))) & 0xc) >> 2, (((((3)<<6 | (0)<<4 | (2)<<2 | (0))) & 0x30) >> 4) + 4, (((((3)<<6 | (0)<<4 | (2)<<2 | (0))) & 0xc0) >> 6) + 4); });

  V2 = V2 * V1;
  V1 = V1 * V11;
  V3 = V3 * V31;

        V11 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(NQ), (__v4sf)(__m128)(Q), (((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0x3, ((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0xc) >> 2, (((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0x30) >> 4) + 4, (((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0xc0) >> 6) + 4); });
  V11 = V11 * V21;
        V21 = _mm_xor_ps(V21, (_mm_set_ps (+0.0f, +0.0f, +0.0f, -0.0f)));
  V31 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(Q), (__v4sf)(__m128)(NQ), (((3)<<6 | (1)<<4 | (3)<<2 | (3))) & 0x3, ((((3)<<6 | (1)<<4 | (3)<<2 | (3))) & 0xc) >> 2, (((((3)<<6 | (1)<<4 | (3)<<2 | (3))) & 0x30) >> 4) + 4, (((((3)<<6 | (1)<<4 | (3)<<2 | (3))) & 0xc0) >> 6) + 4); });
        V31 = _mm_xor_ps(V31, (_mm_set_ps (+0.0f, +0.0f, +0.0f, -0.0f)));
  Y = ((__m128) (__extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(NQi), (__v4si)_mm_setzero_si128(), (((3)<<6 | (0)<<4 | (2)<<2 | (3))) & 0x3, ((((3)<<6 | (0)<<4 | (2)<<2 | (3))) & 0xc) >> 2, ((((3)<<6 | (0)<<4 | (2)<<2 | (3))) & 0x30) >> 4, ((((3)<<6 | (0)<<4 | (2)<<2 | (3))) & 0xc0) >> 6); })));
  Z = ((__m128) (__extension__ ({ (__m128i)__builtin_shufflevector((__v4si)(__m128i)(Qi), (__v4si)_mm_setzero_si128(), (((3)<<6 | (1)<<4 | (0)<<2 | (1))) & 0x3, ((((3)<<6 | (1)<<4 | (0)<<2 | (1))) & 0xc) >> 2, ((((3)<<6 | (1)<<4 | (0)<<2 | (1))) & 0x30) >> 4, ((((3)<<6 | (1)<<4 | (0)<<2 | (1))) & 0xc0) >> 6); })));

  vs = _mm_load_ss(&s);
  V21 = V21 * Y;
  V31 = V31 * Z;

  V1 = V1 + V11;
        V2 = V2 + V21;
        V3 = V3 + V31;

        vs = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((vs))), (__v4sf)(__m128)(((vs))), ((((3)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((3)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((3)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((3)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });

        V1 = V1 * vs;
        V2 = V2 * vs;
        V3 = V3 * vs;

        V1 = V1 + (_mm_set_ps(0.0f,0.0f,0.0f,1.0f));
        V2 = V2 + (_mm_set_ps(0.0f,0.0f,1.0f,0.0f));
        V3 = V3 + (_mm_set_ps(0.0f,1.0f,0.0f,0.0f));

        m_el[0] = V1;
        m_el[1] = V2;
        m_el[2] = V3;
    }







 void setEulerYPR(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
 {
  setEulerZYX(roll, pitch, yaw);
 }
 void setEulerZYX(btScalar eulerX,btScalar eulerY,btScalar eulerZ) {

  btScalar ci ( btCos(eulerX));
  btScalar cj ( btCos(eulerY));
  btScalar ch ( btCos(eulerZ));
  btScalar si ( btSin(eulerX));
  btScalar sj ( btSin(eulerY));
  btScalar sh ( btSin(eulerZ));
  btScalar cc = ci * ch;
  btScalar cs = ci * sh;
  btScalar sc = si * ch;
  btScalar ss = si * sh;

  setValue(cj * ch, sj * sc - cs, sj * cc + ss,
   cj * sh, sj * ss + cc, sj * cs - sc,
   -sj, cj * si, cj * ci);
 }


 void setIdentity()
 {

   m_el[0] = (_mm_set_ps(0.0f,0.0f,0.0f,1.0f));
   m_el[1] = (_mm_set_ps(0.0f,0.0f,1.0f,0.0f));
   m_el[2] = (_mm_set_ps(0.0f,1.0f,0.0f,0.0f));





 }

 static const btMatrix3x3& getIdentity()
 {

        static const btMatrix3x3
        identityMatrix((_mm_set_ps(0.0f,0.0f,0.0f,1.0f)), (_mm_set_ps(0.0f,0.0f,1.0f,0.0f)), (_mm_set_ps(0.0f,1.0f,0.0f,0.0f)));







  return identityMatrix;
 }



 void getOpenGLSubMatrix(btScalar *m) const
 {

        __m128 v0 = m_el[0].mVec128;
        __m128 v1 = m_el[1].mVec128;
        __m128 v2 = m_el[2].mVec128;
        __m128 *vm = (__m128 *)m;
        __m128 vT;

        v2 = _mm_and_ps(v2, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));

        vT = _mm_unpackhi_ps(v0, v1);
        v0 = _mm_unpacklo_ps(v0, v1);

        v1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v0), (__v4sf)(__m128)(v2), (((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0x3, ((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0xc) >> 2, (((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0x30) >> 4) + 4, (((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0xc0) >> 6) + 4); });
        v0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v0), (__v4sf)(__m128)(v2), (((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0x3, ((((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0xc) >> 2, (((((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0x30) >> 4) + 4, (((((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0xc0) >> 6) + 4); });
        v2 = ((__m128) (_mm_move_sd(((__m128d)(v2)), ((__m128d)(vT)))));

        vm[0] = v0;
        vm[1] = v1;
        vm[2] = v2;
 }



 void getRotation(btQuaternion& q) const
 {

        btScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();
        btScalar s, x;

        union {
            btSimdFloat4 vec;
            btScalar f[4];
        } temp;

        if (trace > btScalar(0.0))
        {
            x = trace + btScalar(1.0);

            temp.f[0]=m_el[2].y() - m_el[1].z();
            temp.f[1]=m_el[0].z() - m_el[2].x();
            temp.f[2]=m_el[1].x() - m_el[0].y();
            temp.f[3]=x;

        }
        else
        {
            int i, j, k;
            if(m_el[0].x() < m_el[1].y())
            {
                if( m_el[1].y() < m_el[2].z() )
                    { i = 2; j = 0; k = 1; }
                else
                    { i = 1; j = 2; k = 0; }
            }
            else
            {
                if( m_el[0].x() < m_el[2].z())
                    { i = 2; j = 0; k = 1; }
                else
                    { i = 0; j = 1; k = 2; }
            }

            x = m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0);

            temp.f[3] = (m_el[k][j] - m_el[j][k]);
            temp.f[j] = (m_el[j][i] + m_el[i][j]);
            temp.f[k] = (m_el[k][i] + m_el[i][k]);
            temp.f[i] = x;

        }

        s = btSqrt(x);
        q.set128(temp.vec);
        s = btScalar(0.5) / s;

        q *= s;
 }





 void getEulerYPR(btScalar& yaw, btScalar& pitch, btScalar& roll) const
 {


  yaw = btScalar(btAtan2(m_el[1].x(), m_el[0].x()));
  pitch = btScalar(btAsin(-m_el[2].x()));
  roll = btScalar(btAtan2(m_el[2].y(), m_el[2].z()));


  if (btFabs(pitch)==(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)))
  {
   if (yaw>0)
    yaw-=btScalar(3.1415926535897932384626433832795029);
   else
    yaw+=btScalar(3.1415926535897932384626433832795029);

   if (roll>0)
    roll-=btScalar(3.1415926535897932384626433832795029);
   else
    roll+=btScalar(3.1415926535897932384626433832795029);
  }
 };







 void getEulerZYX(btScalar& yaw, btScalar& pitch, btScalar& roll, unsigned int solution_number = 1) const
 {
  struct Euler
  {
   btScalar yaw;
   btScalar pitch;
   btScalar roll;
  };

  Euler euler_out;
  Euler euler_out2;



  if (btFabs(m_el[2].x()) >= 1)
  {
   euler_out.yaw = 0;
   euler_out2.yaw = 0;


   btScalar delta = btAtan2(m_el[0].x(),m_el[0].z());
   if (m_el[2].x() > 0)
   {
    euler_out.pitch = btScalar(3.1415926535897932384626433832795029) / btScalar(2.0);
    euler_out2.pitch = btScalar(3.1415926535897932384626433832795029) / btScalar(2.0);
    euler_out.roll = euler_out.pitch + delta;
    euler_out2.roll = euler_out.pitch + delta;
   }
   else
   {
    euler_out.pitch = -btScalar(3.1415926535897932384626433832795029) / btScalar(2.0);
    euler_out2.pitch = -btScalar(3.1415926535897932384626433832795029) / btScalar(2.0);
    euler_out.roll = -euler_out.pitch + delta;
    euler_out2.roll = -euler_out.pitch + delta;
   }
  }
  else
  {
   euler_out.pitch = - btAsin(m_el[2].x());
   euler_out2.pitch = btScalar(3.1415926535897932384626433832795029) - euler_out.pitch;

   euler_out.roll = btAtan2(m_el[2].y()/btCos(euler_out.pitch),
    m_el[2].z()/btCos(euler_out.pitch));
   euler_out2.roll = btAtan2(m_el[2].y()/btCos(euler_out2.pitch),
    m_el[2].z()/btCos(euler_out2.pitch));

   euler_out.yaw = btAtan2(m_el[1].x()/btCos(euler_out.pitch),
    m_el[0].x()/btCos(euler_out.pitch));
   euler_out2.yaw = btAtan2(m_el[1].x()/btCos(euler_out2.pitch),
    m_el[0].x()/btCos(euler_out2.pitch));
  }

  if (solution_number == 1)
  {
   yaw = euler_out.yaw;
   pitch = euler_out.pitch;
   roll = euler_out.roll;
  }
  else
  {
   yaw = euler_out2.yaw;
   pitch = euler_out2.pitch;
   roll = euler_out2.roll;
  }
 }




 btMatrix3x3 scaled(const btVector3& s) const
 {

  return btMatrix3x3(m_el[0] * s, m_el[1] * s, m_el[2] * s);






 }


 btScalar determinant() const;

 btMatrix3x3 adjoint() const;

 btMatrix3x3 absolute() const;

 btMatrix3x3 transpose() const;

 btMatrix3x3 inverse() const;




 btVector3 solve33(const btVector3& b) const
 {
  btVector3 col1 = getColumn(0);
  btVector3 col2 = getColumn(1);
  btVector3 col3 = getColumn(2);

  btScalar det = btDot(col1, btCross(col2, col3));
  if (btFabs(det)>1.19209290e-7F)
  {
   det = 1.0f / det;
  }
  btVector3 x;
  x[0] = det * btDot(b, btCross(col2, col3));
  x[1] = det * btDot(col1, btCross(b, col3));
  x[2] = det * btDot(col1, btCross(col2, b));
  return x;
 }

 btMatrix3x3 transposeTimes(const btMatrix3x3& m) const;
 btMatrix3x3 timesTranspose(const btMatrix3x3& m) const;

 inline __attribute__ ((always_inline)) btScalar tdotx(const btVector3& v) const
 {
  return m_el[0].x() * v.x() + m_el[1].x() * v.y() + m_el[2].x() * v.z();
 }
 inline __attribute__ ((always_inline)) btScalar tdoty(const btVector3& v) const
 {
  return m_el[0].y() * v.x() + m_el[1].y() * v.y() + m_el[2].y() * v.z();
 }
 inline __attribute__ ((always_inline)) btScalar tdotz(const btVector3& v) const
 {
  return m_el[0].z() * v.x() + m_el[1].z() * v.y() + m_el[2].z() * v.z();
 }
 void diagonalize(btMatrix3x3& rot, btScalar threshold, int maxSteps)
 {
  rot.setIdentity();
  for (int step = maxSteps; step > 0; step--)
  {

   int p = 0;
   int q = 1;
   int r = 2;
   btScalar max = btFabs(m_el[0][1]);
   btScalar v = btFabs(m_el[0][2]);
   if (v > max)
   {
    q = 2;
    r = 1;
    max = v;
   }
   v = btFabs(m_el[1][2]);
   if (v > max)
   {
    p = 1;
    q = 2;
    r = 0;
    max = v;
   }

   btScalar t = threshold * (btFabs(m_el[0][0]) + btFabs(m_el[1][1]) + btFabs(m_el[2][2]));
   if (max <= t)
   {
    if (max <= 1.19209290e-7F * t)
    {
     return;
    }
    step = 1;
   }


   btScalar mpq = m_el[p][q];
   btScalar theta = (m_el[q][q] - m_el[p][p]) / (2 * mpq);
   btScalar theta2 = theta * theta;
   btScalar cos;
   btScalar sin;
   if (theta2 * theta2 < btScalar(10 / 1.19209290e-7F))
   {
    t = (theta >= 0) ? 1 / (theta + btSqrt(1 + theta2))
     : 1 / (theta - btSqrt(1 + theta2));
    cos = 1 / btSqrt(1 + t * t);
    sin = cos * t;
   }
   else
   {

    t = 1 / (theta * (2 + btScalar(0.5) / theta2));
    cos = 1 - btScalar(0.5) * t * t;
    sin = cos * t;
   }


   m_el[p][q] = m_el[q][p] = 0;
   m_el[p][p] -= t * mpq;
   m_el[q][q] += t * mpq;
   btScalar mrp = m_el[r][p];
   btScalar mrq = m_el[r][q];
   m_el[r][p] = m_el[p][r] = cos * mrp - sin * mrq;
   m_el[r][q] = m_el[q][r] = cos * mrq + sin * mrp;


   for (int i = 0; i < 3; i++)
   {
    btVector3& row = rot[i];
    mrp = row[p];
    mrq = row[q];
    row[p] = cos * mrp - sin * mrq;
    row[q] = cos * mrq + sin * mrp;
   }
  }
 }
 btScalar cofac(int r1, int c1, int r2, int c2) const
 {
  return m_el[r1][c1] * m_el[r2][c2] - m_el[r1][c2] * m_el[r2][c1];
 }

 void serialize(struct btMatrix3x3FloatData& dataOut) const;

 void serializeFloat(struct btMatrix3x3FloatData& dataOut) const;

 void deSerialize(const struct btMatrix3x3FloatData& dataIn);

 void deSerializeFloat(const struct btMatrix3x3FloatData& dataIn);

 void deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn);

};


inline __attribute__ ((always_inline)) btMatrix3x3&
btMatrix3x3::operator*=(const btMatrix3x3& m)
{

    __m128 rv00, rv01, rv02;
    __m128 rv10, rv11, rv12;
    __m128 rv20, rv21, rv22;
    __m128 mv0, mv1, mv2;

    rv02 = m_el[0].mVec128;
    rv12 = m_el[1].mVec128;
    rv22 = m_el[2].mVec128;

    mv0 = _mm_and_ps(m[0].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
    mv1 = _mm_and_ps(m[1].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
    mv2 = _mm_and_ps(m[2].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));


    rv00 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv02))), (__v4sf)(__m128)(((rv02))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });
    rv01 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv02))), (__v4sf)(__m128)(((rv02))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });
    rv02 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv02))), (__v4sf)(__m128)(((rv02))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });

    rv00 = _mm_mul_ps(rv00, mv0);
    rv01 = _mm_mul_ps(rv01, mv1);
    rv02 = _mm_mul_ps(rv02, mv2);


    rv10 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv12))), (__v4sf)(__m128)(((rv12))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });
    rv11 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv12))), (__v4sf)(__m128)(((rv12))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });
    rv12 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv12))), (__v4sf)(__m128)(((rv12))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });

    rv10 = _mm_mul_ps(rv10, mv0);
    rv11 = _mm_mul_ps(rv11, mv1);
    rv12 = _mm_mul_ps(rv12, mv2);


    rv20 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv22))), (__v4sf)(__m128)(((rv22))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });
    rv21 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv22))), (__v4sf)(__m128)(((rv22))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });
    rv22 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((rv22))), (__v4sf)(__m128)(((rv22))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });

    rv20 = _mm_mul_ps(rv20, mv0);
    rv21 = _mm_mul_ps(rv21, mv1);
    rv22 = _mm_mul_ps(rv22, mv2);

    rv00 = _mm_add_ps(rv00, rv01);
    rv10 = _mm_add_ps(rv10, rv11);
    rv20 = _mm_add_ps(rv20, rv21);

    m_el[0].mVec128 = _mm_add_ps(rv00, rv02);
    m_el[1].mVec128 = _mm_add_ps(rv10, rv12);
    m_el[2].mVec128 = _mm_add_ps(rv20, rv22);
 return *this;
}

inline __attribute__ ((always_inline)) btMatrix3x3&
btMatrix3x3::operator+=(const btMatrix3x3& m)
{

    m_el[0].mVec128 = m_el[0].mVec128 + m.m_el[0].mVec128;
    m_el[1].mVec128 = m_el[1].mVec128 + m.m_el[1].mVec128;
    m_el[2].mVec128 = m_el[2].mVec128 + m.m_el[2].mVec128;
 return *this;
}

inline __attribute__ ((always_inline)) btMatrix3x3
operator*(const btMatrix3x3& m, const btScalar & k)
{

    __m128 vk = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((_mm_load_ss((float *)&k)))), (__v4sf)(__m128)(((_mm_load_ss((float *)&k)))), ((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0x3, (((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0xc) >> 2, ((((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0x30) >> 4) + 4, ((((((0x80)<<6 | (0x80)<<4 | (0x80)<<2 | (0x80)))) & 0xc0) >> 6) + 4); });
    return btMatrix3x3(
                _mm_mul_ps(m[0].mVec128, vk),
                _mm_mul_ps(m[1].mVec128, vk),
                _mm_mul_ps(m[2].mVec128, vk));
}

inline __attribute__ ((always_inline)) btMatrix3x3
operator+(const btMatrix3x3& m1, const btMatrix3x3& m2)
{

 return btMatrix3x3(
        m1[0].mVec128 + m2[0].mVec128,
        m1[1].mVec128 + m2[1].mVec128,
        m1[2].mVec128 + m2[2].mVec128);
}

inline __attribute__ ((always_inline)) btMatrix3x3
operator-(const btMatrix3x3& m1, const btMatrix3x3& m2)
{

 return btMatrix3x3(
        m1[0].mVec128 - m2[0].mVec128,
        m1[1].mVec128 - m2[1].mVec128,
        m1[2].mVec128 - m2[2].mVec128);
}


inline __attribute__ ((always_inline)) btMatrix3x3&
btMatrix3x3::operator-=(const btMatrix3x3& m)
{

    m_el[0].mVec128 = m_el[0].mVec128 - m.m_el[0].mVec128;
    m_el[1].mVec128 = m_el[1].mVec128 - m.m_el[1].mVec128;
    m_el[2].mVec128 = m_el[2].mVec128 - m.m_el[2].mVec128;
 return *this;
}


inline __attribute__ ((always_inline)) btScalar
btMatrix3x3::determinant() const
{
 return btTriple((*this)[0], (*this)[1], (*this)[2]);
}


inline __attribute__ ((always_inline)) btMatrix3x3
btMatrix3x3::absolute() const
{

    return btMatrix3x3(
            _mm_and_ps(m_el[0].mVec128, ((__m128) ((_mm_set_epi32( 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))))),
            _mm_and_ps(m_el[1].mVec128, ((__m128) ((_mm_set_epi32( 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))))),
            _mm_and_ps(m_el[2].mVec128, ((__m128) ((_mm_set_epi32( 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF))))));
}

inline __attribute__ ((always_inline)) btMatrix3x3
btMatrix3x3::transpose() const
{

    __m128 v0 = m_el[0].mVec128;
    __m128 v1 = m_el[1].mVec128;
    __m128 v2 = m_el[2].mVec128;
    __m128 vT;

    v2 = _mm_and_ps(v2, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));

    vT = _mm_unpackhi_ps(v0, v1);
    v0 = _mm_unpacklo_ps(v0, v1);

    v1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v0), (__v4sf)(__m128)(v2), (((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0x3, ((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0xc) >> 2, (((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0x30) >> 4) + 4, (((((3)<<6 | (1)<<4 | (3)<<2 | (2))) & 0xc0) >> 6) + 4); });
    v0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(v0), (__v4sf)(__m128)(v2), (((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0x3, ((((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0xc) >> 2, (((((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0x30) >> 4) + 4, (((((3)<<6 | (0)<<4 | (1)<<2 | (0))) & 0xc0) >> 6) + 4); });
    v2 = ((__m128) (_mm_move_sd(((__m128d)(v2)), ((__m128d)(vT)))));


    return btMatrix3x3( v0, v1, v2 );
}

inline __attribute__ ((always_inline)) btMatrix3x3
btMatrix3x3::adjoint() const
{
 return btMatrix3x3(cofac(1, 1, 2, 2), cofac(0, 2, 2, 1), cofac(0, 1, 1, 2),
  cofac(1, 2, 2, 0), cofac(0, 0, 2, 2), cofac(0, 2, 1, 0),
  cofac(1, 0, 2, 1), cofac(0, 1, 2, 0), cofac(0, 0, 1, 1));
}

inline __attribute__ ((always_inline)) btMatrix3x3
btMatrix3x3::inverse() const
{
 btVector3 co(cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1));
 btScalar det = (*this)[0].dot(co);

                               ;
 btScalar s = btScalar(1.0) / det;
 return btMatrix3x3(co.x() * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,
  co.y() * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,
  co.z() * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);
}

inline __attribute__ ((always_inline)) btMatrix3x3
btMatrix3x3::transposeTimes(const btMatrix3x3& m) const
{



    __m128 row = m_el[0].mVec128;
    __m128 m0 = _mm_and_ps( m.getRow(0).mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))) );
    __m128 m1 = _mm_and_ps( m.getRow(1).mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));
    __m128 m2 = _mm_and_ps( m.getRow(2).mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))) );
    __m128 r0 = _mm_mul_ps(m0, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4); }));
    __m128 r1 = _mm_mul_ps(m0, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); }));
    __m128 r2 = _mm_mul_ps(m0, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0xaa) & 0x3, ((0xaa) & 0xc) >> 2, (((0xaa) & 0x30) >> 4) + 4, (((0xaa) & 0xc0) >> 6) + 4); }));
    row = m_el[1].mVec128;
    r0 = _mm_add_ps( r0, _mm_mul_ps(m1, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4); })));
    r1 = _mm_add_ps( r1, _mm_mul_ps(m1, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); })));
    r2 = _mm_add_ps( r2, _mm_mul_ps(m1, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0xaa) & 0x3, ((0xaa) & 0xc) >> 2, (((0xaa) & 0x30) >> 4) + 4, (((0xaa) & 0xc0) >> 6) + 4); })));
    row = m_el[2].mVec128;
    r0 = _mm_add_ps( r0, _mm_mul_ps(m2, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4); })));
    r1 = _mm_add_ps( r1, _mm_mul_ps(m2, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); })));
    r2 = _mm_add_ps( r2, _mm_mul_ps(m2, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(row), (__v4sf)(__m128)(row), (0xaa) & 0x3, ((0xaa) & 0xc) >> 2, (((0xaa) & 0x30) >> 4) + 4, (((0xaa) & 0xc0) >> 6) + 4); })));
    return btMatrix3x3( r0, r1, r2 );
}

inline __attribute__ ((always_inline)) btMatrix3x3
btMatrix3x3::timesTranspose(const btMatrix3x3& m) const
{

    __m128 a0 = m_el[0].mVec128;
    __m128 a1 = m_el[1].mVec128;
    __m128 a2 = m_el[2].mVec128;

    btMatrix3x3 mT = m.transpose();
    __m128 mx = mT[0].mVec128;
    __m128 my = mT[1].mVec128;
    __m128 mz = mT[2].mVec128;

    __m128 r0 = _mm_mul_ps(mx, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a0), (__v4sf)(__m128)(a0), (0x00) & 0x3, ((0x00) & 0xc) >> 2, (((0x00) & 0x30) >> 4) + 4, (((0x00) & 0xc0) >> 6) + 4); }));
    __m128 r1 = _mm_mul_ps(mx, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a1), (__v4sf)(__m128)(a1), (0x00) & 0x3, ((0x00) & 0xc) >> 2, (((0x00) & 0x30) >> 4) + 4, (((0x00) & 0xc0) >> 6) + 4); }));
    __m128 r2 = _mm_mul_ps(mx, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a2), (__v4sf)(__m128)(a2), (0x00) & 0x3, ((0x00) & 0xc) >> 2, (((0x00) & 0x30) >> 4) + 4, (((0x00) & 0xc0) >> 6) + 4); }));
    r0 = _mm_add_ps(r0, _mm_mul_ps(my, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a0), (__v4sf)(__m128)(a0), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); })));
    r1 = _mm_add_ps(r1, _mm_mul_ps(my, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a1), (__v4sf)(__m128)(a1), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); })));
    r2 = _mm_add_ps(r2, _mm_mul_ps(my, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a2), (__v4sf)(__m128)(a2), (0x55) & 0x3, ((0x55) & 0xc) >> 2, (((0x55) & 0x30) >> 4) + 4, (((0x55) & 0xc0) >> 6) + 4); })));
    r0 = _mm_add_ps(r0, _mm_mul_ps(mz, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a0), (__v4sf)(__m128)(a0), (0xaa) & 0x3, ((0xaa) & 0xc) >> 2, (((0xaa) & 0x30) >> 4) + 4, (((0xaa) & 0xc0) >> 6) + 4); })));
    r1 = _mm_add_ps(r1, _mm_mul_ps(mz, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a1), (__v4sf)(__m128)(a1), (0xaa) & 0x3, ((0xaa) & 0xc) >> 2, (((0xaa) & 0x30) >> 4) + 4, (((0xaa) & 0xc0) >> 6) + 4); })));
    r2 = _mm_add_ps(r2, _mm_mul_ps(mz, __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(a2), (__v4sf)(__m128)(a2), (0xaa) & 0x3, ((0xaa) & 0xc) >> 2, (((0xaa) & 0x30) >> 4) + 4, (((0xaa) & 0xc0) >> 6) + 4); })));
    return btMatrix3x3( r0, r1, r2);
}

inline __attribute__ ((always_inline)) btVector3
operator*(const btMatrix3x3& m, const btVector3& v)
{

    return v.dot3(m[0], m[1], m[2]);



}


inline __attribute__ ((always_inline)) btVector3
operator*(const btVector3& v, const btMatrix3x3& m)
{


    const __m128 vv = v.mVec128;

    __m128 c0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((vv))), (__v4sf)(__m128)(((vv))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });
    __m128 c1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((vv))), (__v4sf)(__m128)(((vv))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });
    __m128 c2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((vv))), (__v4sf)(__m128)(((vv))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });

    c0 = _mm_mul_ps(c0, _mm_and_ps(m[0].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))))) );
    c1 = _mm_mul_ps(c1, _mm_and_ps(m[1].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))))) );
    c0 = _mm_add_ps(c0, c1);
    c2 = _mm_mul_ps(c2, _mm_and_ps(m[2].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF))))) );

    return btVector3(_mm_add_ps(c0, c2));
}

inline __attribute__ ((always_inline)) btMatrix3x3
operator*(const btMatrix3x3& m1, const btMatrix3x3& m2)
{


    __m128 m10 = m1[0].mVec128;
    __m128 m11 = m1[1].mVec128;
    __m128 m12 = m1[2].mVec128;

    __m128 m2v = _mm_and_ps(m2[0].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));

    __m128 c0 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m10))), (__v4sf)(__m128)(((m10))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });
    __m128 c1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m11))), (__v4sf)(__m128)(((m11))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });
    __m128 c2 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m12))), (__v4sf)(__m128)(((m12))), ((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x3, (((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc) >> 2, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0x30) >> 4) + 4, ((((((0)<<6 | (0)<<4 | (0)<<2 | (0)))) & 0xc0) >> 6) + 4); });

    c0 = _mm_mul_ps(c0, m2v);
    c1 = _mm_mul_ps(c1, m2v);
    c2 = _mm_mul_ps(c2, m2v);

    m2v = _mm_and_ps(m2[1].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));

    __m128 c0_1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m10))), (__v4sf)(__m128)(((m10))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });
    __m128 c1_1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m11))), (__v4sf)(__m128)(((m11))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });
    __m128 c2_1 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m12))), (__v4sf)(__m128)(((m12))), ((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x3, (((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc) >> 2, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0x30) >> 4) + 4, ((((((1)<<6 | (1)<<4 | (1)<<2 | (1)))) & 0xc0) >> 6) + 4); });

    c0_1 = _mm_mul_ps(c0_1, m2v);
    c1_1 = _mm_mul_ps(c1_1, m2v);
    c2_1 = _mm_mul_ps(c2_1, m2v);

    m2v = _mm_and_ps(m2[2].mVec128, ((__m128) ((_mm_set_epi32(0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF)))));

    c0 = _mm_add_ps(c0, c0_1);
    c1 = _mm_add_ps(c1, c1_1);
    c2 = _mm_add_ps(c2, c2_1);

    m10 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m10))), (__v4sf)(__m128)(((m10))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });
    m11 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m11))), (__v4sf)(__m128)(((m11))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });
    m12 = __extension__ ({ (__m128)__builtin_shufflevector((__v4sf)(__m128)(((m12))), (__v4sf)(__m128)(((m12))), ((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x3, (((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc) >> 2, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0x30) >> 4) + 4, ((((((2)<<6 | (2)<<4 | (2)<<2 | (2)))) & 0xc0) >> 6) + 4); });

    m10 = _mm_mul_ps(m10, m2v);
    m11 = _mm_mul_ps(m11, m2v);
    m12 = _mm_mul_ps(m12, m2v);

    c0 = _mm_add_ps(c0, m10);
    c1 = _mm_add_ps(c1, m11);
    c2 = _mm_add_ps(c2, m12);

    return btMatrix3x3(c0, c1, c2);
}
inline __attribute__ ((always_inline)) bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)
{


    __m128 c0, c1, c2;

    c0 = _mm_cmpeq_ps(m1[0].mVec128, m2[0].mVec128);
    c1 = _mm_cmpeq_ps(m1[1].mVec128, m2[1].mVec128);
    c2 = _mm_cmpeq_ps(m1[2].mVec128, m2[2].mVec128);

    c0 = _mm_and_ps(c0, c1);
    c0 = _mm_and_ps(c0, c2);

 int m = _mm_movemask_ps((__m128)c0);
 return (0x7 == (m & 0x7));







}


struct btMatrix3x3FloatData
{
 btVector3FloatData m_el[3];
};


struct btMatrix3x3DoubleData
{
 btVector3DoubleData m_el[3];
};




inline __attribute__ ((always_inline)) void btMatrix3x3::serialize(struct btMatrix3x3FloatData& dataOut) const
{
 for (int i=0;i<3;i++)
  m_el[i].serialize(dataOut.m_el[i]);
}

inline __attribute__ ((always_inline)) void btMatrix3x3::serializeFloat(struct btMatrix3x3FloatData& dataOut) const
{
 for (int i=0;i<3;i++)
  m_el[i].serializeFloat(dataOut.m_el[i]);
}


inline __attribute__ ((always_inline)) void btMatrix3x3::deSerialize(const struct btMatrix3x3FloatData& dataIn)
{
 for (int i=0;i<3;i++)
  m_el[i].deSerialize(dataIn.m_el[i]);
}

inline __attribute__ ((always_inline)) void btMatrix3x3::deSerializeFloat(const struct btMatrix3x3FloatData& dataIn)
{
 for (int i=0;i<3;i++)
  m_el[i].deSerializeFloat(dataIn.m_el[i]);
}

inline __attribute__ ((always_inline)) void btMatrix3x3::deSerializeDouble(const struct btMatrix3x3DoubleData& dataIn)
{
 for (int i=0;i<3;i++)
  m_el[i].deSerializeDouble(dataIn.m_el[i]);
}
class __attribute__ ((aligned (16))) btTransform {


 btMatrix3x3 m_basis;

 btVector3 m_origin;

public:


 btTransform() {}



 explicit inline __attribute__ ((always_inline)) btTransform(const btQuaternion& q,
  const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
  : m_basis(q),
  m_origin(c)
 {}




 explicit inline __attribute__ ((always_inline)) btTransform(const btMatrix3x3& b,
  const btVector3& c = btVector3(btScalar(0), btScalar(0), btScalar(0)))
  : m_basis(b),
  m_origin(c)
 {}

 inline __attribute__ ((always_inline)) btTransform (const btTransform& other)
  : m_basis(other.m_basis),
  m_origin(other.m_origin)
 {
 }

 inline __attribute__ ((always_inline)) btTransform& operator=(const btTransform& other)
 {
  m_basis = other.m_basis;
  m_origin = other.m_origin;
  return *this;
 }






  inline __attribute__ ((always_inline)) void mult(const btTransform& t1, const btTransform& t2) {
   m_basis = t1.m_basis * t2.m_basis;
   m_origin = t1(t2.m_origin);
  }
 inline __attribute__ ((always_inline)) btVector3 operator()(const btVector3& x) const
 {
        return x.dot3(m_basis[0], m_basis[1], m_basis[2]) + m_origin;
 }


 inline __attribute__ ((always_inline)) btVector3 operator*(const btVector3& x) const
 {
  return (*this)(x);
 }


 inline __attribute__ ((always_inline)) btQuaternion operator*(const btQuaternion& q) const
 {
  return getRotation() * q;
 }


 inline __attribute__ ((always_inline)) btMatrix3x3& getBasis() { return m_basis; }

 inline __attribute__ ((always_inline)) const btMatrix3x3& getBasis() const { return m_basis; }


 inline __attribute__ ((always_inline)) btVector3& getOrigin() { return m_origin; }

 inline __attribute__ ((always_inline)) const btVector3& getOrigin() const { return m_origin; }


 btQuaternion getRotation() const {
  btQuaternion q;
  m_basis.getRotation(q);
  return q;
 }




 void setFromOpenGLMatrix(const btScalar *m)
 {
  m_basis.setFromOpenGLSubMatrix(m);
  m_origin.setValue(m[12],m[13],m[14]);
 }



 void getOpenGLMatrix(btScalar *m) const
 {
  m_basis.getOpenGLSubMatrix(m);
  m[12] = m_origin.x();
  m[13] = m_origin.y();
  m[14] = m_origin.z();
  m[15] = btScalar(1.0);
 }



 inline __attribute__ ((always_inline)) void setOrigin(const btVector3& origin)
 {
  m_origin = origin;
 }

 inline __attribute__ ((always_inline)) btVector3 invXform(const btVector3& inVec) const;



 inline __attribute__ ((always_inline)) void setBasis(const btMatrix3x3& basis)
 {
  m_basis = basis;
 }


 inline __attribute__ ((always_inline)) void setRotation(const btQuaternion& q)
 {
  m_basis.setRotation(q);
 }



 void setIdentity()
 {
  m_basis.setIdentity();
  m_origin.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
 }



 btTransform& operator*=(const btTransform& t)
 {
  m_origin += m_basis * t.m_origin;
  m_basis *= t.m_basis;
  return *this;
 }


 btTransform inverse() const
 {
  btMatrix3x3 inv = m_basis.transpose();
  return btTransform(inv, inv * -m_origin);
 }




 btTransform inverseTimes(const btTransform& t) const;


 btTransform operator*(const btTransform& t) const;


 static const btTransform& getIdentity()
 {
  static const btTransform identityTransform(btMatrix3x3::getIdentity());
  return identityTransform;
 }

 void serialize(struct btTransformFloatData& dataOut) const;

 void serializeFloat(struct btTransformFloatData& dataOut) const;

 void deSerialize(const struct btTransformFloatData& dataIn);

 void deSerializeDouble(const struct btTransformDoubleData& dataIn);

 void deSerializeFloat(const struct btTransformFloatData& dataIn);

};


inline __attribute__ ((always_inline)) btVector3
btTransform::invXform(const btVector3& inVec) const
{
 btVector3 v = inVec - m_origin;
 return (m_basis.transpose() * v);
}

inline __attribute__ ((always_inline)) btTransform
btTransform::inverseTimes(const btTransform& t) const
{
 btVector3 v = t.getOrigin() - m_origin;
  return btTransform(m_basis.transposeTimes(t.m_basis),
   v * m_basis);
}

inline __attribute__ ((always_inline)) btTransform
btTransform::operator*(const btTransform& t) const
{
 return btTransform(m_basis * t.m_basis,
  (*this)(t.m_origin));
}


inline __attribute__ ((always_inline)) bool operator==(const btTransform& t1, const btTransform& t2)
{
   return ( t1.getBasis() == t2.getBasis() &&
            t1.getOrigin() == t2.getOrigin() );
}



struct btTransformFloatData
{
 btMatrix3x3FloatData m_basis;
 btVector3FloatData m_origin;
};

struct btTransformDoubleData
{
 btMatrix3x3DoubleData m_basis;
 btVector3DoubleData m_origin;
};



inline __attribute__ ((always_inline)) void btTransform::serialize(btTransformFloatData& dataOut) const
{
 m_basis.serialize(dataOut.m_basis);
 m_origin.serialize(dataOut.m_origin);
}

inline __attribute__ ((always_inline)) void btTransform::serializeFloat(btTransformFloatData& dataOut) const
{
 m_basis.serializeFloat(dataOut.m_basis);
 m_origin.serializeFloat(dataOut.m_origin);
}


inline __attribute__ ((always_inline)) void btTransform::deSerialize(const btTransformFloatData& dataIn)
{
 m_basis.deSerialize(dataIn.m_basis);
 m_origin.deSerialize(dataIn.m_origin);
}

inline __attribute__ ((always_inline)) void btTransform::deSerializeFloat(const btTransformFloatData& dataIn)
{
 m_basis.deSerializeFloat(dataIn.m_basis);
 m_origin.deSerializeFloat(dataIn.m_origin);
}

inline __attribute__ ((always_inline)) void btTransform::deSerializeDouble(const btTransformDoubleData& dataIn)
{
 m_basis.deSerializeDouble(dataIn.m_basis);
 m_origin.deSerializeDouble(dataIn.m_origin);
}







class btIDebugDraw
{
 public:

 struct __attribute__ ((aligned (16))) DefaultColors
 {
  btVector3 m_activeObject;
  btVector3 m_deactivatedObject;
  btVector3 m_wantsDeactivationObject;
  btVector3 m_disabledDeactivationObject;
  btVector3 m_disabledSimulationObject;
  btVector3 m_aabb;
  btVector3 m_contactPoint;

  DefaultColors()
  : m_activeObject(1,1,1),
   m_deactivatedObject(0,1,0),
   m_wantsDeactivationObject(0,1,1),
   m_disabledDeactivationObject(1,0,0),
   m_disabledSimulationObject(1,1,0),
   m_aabb(1,0,0),
   m_contactPoint(1,1,0)
  {
  }
 };


 enum DebugDrawModes
 {
  DBG_NoDebug=0,
  DBG_DrawWireframe = 1,
  DBG_DrawAabb=2,
  DBG_DrawFeaturesText=4,
  DBG_DrawContactPoints=8,
  DBG_NoDeactivation=16,
  DBG_NoHelpText = 32,
  DBG_DrawText=64,
  DBG_ProfileTimings = 128,
  DBG_EnableSatComparison = 256,
  DBG_DisableBulletLCP = 512,
  DBG_EnableCCD = 1024,
  DBG_DrawConstraints = (1 << 11),
  DBG_DrawConstraintLimits = (1 << 12),
  DBG_FastWireframe = (1<<13),
  DBG_DrawNormals = (1<<14),
  DBG_DrawFrames = (1<<15),
  DBG_MAX_DEBUG_DRAW_MODE
 };

 virtual ~btIDebugDraw() {};



 virtual bool isVisible(const btVector3& aabbMin,const btVector3& aabbMax)=0;

 virtual DefaultColors getDefaultColors() const { DefaultColors colors; return colors; }

 virtual void setDefaultColors(const DefaultColors& ) {}

 virtual void drawLine(const btVector3& from,const btVector3& to,const btVector3& color)=0;

 virtual void drawLine(const btVector3& from,const btVector3& to, const btVector3& fromColor, const btVector3& toColor)
 {
        (void) toColor;
  drawLine (from, to, fromColor);
 }

 virtual void drawSphere(btScalar radius, const btTransform& transform, const btVector3& color)
 {

  btVector3 center = transform.getOrigin();
  btVector3 up = transform.getBasis().getColumn(1);
  btVector3 axis = transform.getBasis().getColumn(0);
  btScalar minTh = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
  btScalar maxTh = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
  btScalar minPs = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
  btScalar maxPs = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
  btScalar stepDegrees = 30.f;
  drawSpherePatch(center, up, axis, radius,minTh, maxTh, minPs, maxPs, color, stepDegrees ,false);
  drawSpherePatch(center, up, -axis, radius,minTh, maxTh, minPs, maxPs, color, stepDegrees,false );
 }

 virtual void drawSphere (const btVector3& p, btScalar radius, const btVector3& color)
 {
  btTransform tr;
  tr.setIdentity();
  tr.setOrigin(p);
  drawSphere(radius,tr,color);
 }

 virtual void drawTriangle(const btVector3& v0,const btVector3& v1,const btVector3& v2,const btVector3& ,const btVector3& ,const btVector3& ,const btVector3& color, btScalar alpha)
 {
  drawTriangle(v0,v1,v2,color,alpha);
 }
 virtual void drawTriangle(const btVector3& v0,const btVector3& v1,const btVector3& v2,const btVector3& color, btScalar )
 {
  drawLine(v0,v1,color);
  drawLine(v1,v2,color);
  drawLine(v2,v0,color);
 }

 virtual void drawContactPoint(const btVector3& PointOnB,const btVector3& normalOnB,btScalar distance,int lifeTime,const btVector3& color)=0;

 virtual void reportErrorWarning(const char* warningString) = 0;

 virtual void draw3dText(const btVector3& location,const char* textString) = 0;

 virtual void setDebugMode(int debugMode) =0;

 virtual int getDebugMode() const = 0;

 virtual void drawAabb(const btVector3& from,const btVector3& to,const btVector3& color)
 {

  btVector3 halfExtents = (to-from)* 0.5f;
  btVector3 center = (to+from) *0.5f;
  int i,j;

  btVector3 edgecoord(1.f,1.f,1.f),pa,pb;
  for (i=0;i<4;i++)
  {
   for (j=0;j<3;j++)
   {
    pa = btVector3(edgecoord[0]*halfExtents[0], edgecoord[1]*halfExtents[1],
     edgecoord[2]*halfExtents[2]);
    pa+=center;

    int othercoord = j%3;
    edgecoord[othercoord]*=-1.f;
    pb = btVector3(edgecoord[0]*halfExtents[0], edgecoord[1]*halfExtents[1],
     edgecoord[2]*halfExtents[2]);
    pb+=center;

    drawLine(pa,pb,color);
   }
   edgecoord = btVector3(-1.f,-1.f,-1.f);
   if (i<3)
    edgecoord[i]*=-1.f;
  }
 }
 virtual void drawTransform(const btTransform& transform, btScalar orthoLen)
 {
  btVector3 start = transform.getOrigin();
  drawLine(start, start+transform.getBasis() * btVector3(orthoLen, 0, 0), btVector3(1.f,0.3,0.3));
  drawLine(start, start+transform.getBasis() * btVector3(0, orthoLen, 0), btVector3(0.3,1.f, 0.3));
  drawLine(start, start+transform.getBasis() * btVector3(0, 0, orthoLen), btVector3(0.3, 0.3,1.f));
 }

 virtual void drawArc(const btVector3& center, const btVector3& normal, const btVector3& axis, btScalar radiusA, btScalar radiusB, btScalar minAngle, btScalar maxAngle,
    const btVector3& color, bool drawSect, btScalar stepDegrees = btScalar(10.f))
 {
  const btVector3& vx = axis;
  btVector3 vy = normal.cross(axis);
  btScalar step = stepDegrees * ((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0));
  int nSteps = (int)btFabs((maxAngle - minAngle) / step);
  if(!nSteps) nSteps = 1;
  btVector3 prev = center + radiusA * vx * btCos(minAngle) + radiusB * vy * btSin(minAngle);
  if(drawSect)
  {
   drawLine(center, prev, color);
  }
  for(int i = 1; i <= nSteps; i++)
  {
   btScalar angle = minAngle + (maxAngle - minAngle) * btScalar(i) / btScalar(nSteps);
   btVector3 next = center + radiusA * vx * btCos(angle) + radiusB * vy * btSin(angle);
   drawLine(prev, next, color);
   prev = next;
  }
  if(drawSect)
  {
   drawLine(center, prev, color);
  }
 }
 virtual void drawSpherePatch(const btVector3& center, const btVector3& up, const btVector3& axis, btScalar radius,
  btScalar minTh, btScalar maxTh, btScalar minPs, btScalar maxPs, const btVector3& color, btScalar stepDegrees = btScalar(10.f),bool drawCenter = true)
 {
  btVector3 vA[74];
  btVector3 vB[74];
  btVector3 *pvA = vA, *pvB = vB, *pT;
  btVector3 npole = center + up * radius;
  btVector3 spole = center - up * radius;
  btVector3 arcStart;
  btScalar step = stepDegrees * ((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0));
  const btVector3& kv = up;
  const btVector3& iv = axis;
  btVector3 jv = kv.cross(iv);
  bool drawN = false;
  bool drawS = false;
  if(minTh <= -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)))
  {
   minTh = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)) + step;
   drawN = true;
  }
  if(maxTh >= (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)))
  {
   maxTh = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)) - step;
   drawS = true;
  }
  if(minTh > maxTh)
  {
   minTh = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)) + step;
   maxTh = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5)) - step;
   drawN = drawS = true;
  }
  int n_hor = (int)((maxTh - minTh) / step) + 1;
  if(n_hor < 2) n_hor = 2;
  btScalar step_h = (maxTh - minTh) / btScalar(n_hor - 1);
  bool isClosed = false;
  if(minPs > maxPs)
  {
   minPs = -btScalar(3.1415926535897932384626433832795029) + step;
   maxPs = btScalar(3.1415926535897932384626433832795029);
   isClosed = true;
  }
  else if((maxPs - minPs) >= btScalar(3.1415926535897932384626433832795029) * btScalar(2.f))
  {
   isClosed = true;
  }
  else
  {
   isClosed = false;
  }
  int n_vert = (int)((maxPs - minPs) / step) + 1;
  if(n_vert < 2) n_vert = 2;
  btScalar step_v = (maxPs - minPs) / btScalar(n_vert - 1);
  for(int i = 0; i < n_hor; i++)
  {
   btScalar th = minTh + btScalar(i) * step_h;
   btScalar sth = radius * btSin(th);
   btScalar cth = radius * btCos(th);
   for(int j = 0; j < n_vert; j++)
   {
    btScalar psi = minPs + btScalar(j) * step_v;
    btScalar sps = btSin(psi);
    btScalar cps = btCos(psi);
    pvB[j] = center + cth * cps * iv + cth * sps * jv + sth * kv;
    if(i)
    {
     drawLine(pvA[j], pvB[j], color);
    }
    else if(drawS)
    {
     drawLine(spole, pvB[j], color);
    }
    if(j)
    {
     drawLine(pvB[j-1], pvB[j], color);
    }
    else
    {
     arcStart = pvB[j];
    }
    if((i == (n_hor - 1)) && drawN)
    {
     drawLine(npole, pvB[j], color);
    }

    if (drawCenter)
    {
     if(isClosed)
     {
      if(j == (n_vert-1))
      {
       drawLine(arcStart, pvB[j], color);
      }
     }
     else
     {
      if(((!i) || (i == (n_hor-1))) && ((!j) || (j == (n_vert-1))))
      {
       drawLine(center, pvB[j], color);
      }
     }
    }
   }
   pT = pvA; pvA = pvB; pvB = pT;
  }
 }


 virtual void drawBox(const btVector3& bbMin, const btVector3& bbMax, const btVector3& color)
 {
  drawLine(btVector3(bbMin[0], bbMin[1], bbMin[2]), btVector3(bbMax[0], bbMin[1], bbMin[2]), color);
  drawLine(btVector3(bbMax[0], bbMin[1], bbMin[2]), btVector3(bbMax[0], bbMax[1], bbMin[2]), color);
  drawLine(btVector3(bbMax[0], bbMax[1], bbMin[2]), btVector3(bbMin[0], bbMax[1], bbMin[2]), color);
  drawLine(btVector3(bbMin[0], bbMax[1], bbMin[2]), btVector3(bbMin[0], bbMin[1], bbMin[2]), color);
  drawLine(btVector3(bbMin[0], bbMin[1], bbMin[2]), btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
  drawLine(btVector3(bbMax[0], bbMin[1], bbMin[2]), btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
  drawLine(btVector3(bbMax[0], bbMax[1], bbMin[2]), btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
  drawLine(btVector3(bbMin[0], bbMax[1], bbMin[2]), btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
  drawLine(btVector3(bbMin[0], bbMin[1], bbMax[2]), btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
  drawLine(btVector3(bbMax[0], bbMin[1], bbMax[2]), btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
  drawLine(btVector3(bbMax[0], bbMax[1], bbMax[2]), btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
  drawLine(btVector3(bbMin[0], bbMax[1], bbMax[2]), btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
 }
 virtual void drawBox(const btVector3& bbMin, const btVector3& bbMax, const btTransform& trans, const btVector3& color)
 {
  drawLine(trans * btVector3(bbMin[0], bbMin[1], bbMin[2]), trans * btVector3(bbMax[0], bbMin[1], bbMin[2]), color);
  drawLine(trans * btVector3(bbMax[0], bbMin[1], bbMin[2]), trans * btVector3(bbMax[0], bbMax[1], bbMin[2]), color);
  drawLine(trans * btVector3(bbMax[0], bbMax[1], bbMin[2]), trans * btVector3(bbMin[0], bbMax[1], bbMin[2]), color);
  drawLine(trans * btVector3(bbMin[0], bbMax[1], bbMin[2]), trans * btVector3(bbMin[0], bbMin[1], bbMin[2]), color);
  drawLine(trans * btVector3(bbMin[0], bbMin[1], bbMin[2]), trans * btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMax[0], bbMin[1], bbMin[2]), trans * btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMax[0], bbMax[1], bbMin[2]), trans * btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMin[0], bbMax[1], bbMin[2]), trans * btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMin[0], bbMin[1], bbMax[2]), trans * btVector3(bbMax[0], bbMin[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMax[0], bbMin[1], bbMax[2]), trans * btVector3(bbMax[0], bbMax[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMax[0], bbMax[1], bbMax[2]), trans * btVector3(bbMin[0], bbMax[1], bbMax[2]), color);
  drawLine(trans * btVector3(bbMin[0], bbMax[1], bbMax[2]), trans * btVector3(bbMin[0], bbMin[1], bbMax[2]), color);
 }

 virtual void drawCapsule(btScalar radius, btScalar halfHeight, int upAxis, const btTransform& transform, const btVector3& color)
 {
  int stepDegrees = 30;

  btVector3 capStart(0.f,0.f,0.f);
  capStart[upAxis] = -halfHeight;

  btVector3 capEnd(0.f,0.f,0.f);
  capEnd[upAxis] = halfHeight;


  {

   btTransform childTransform = transform;
   childTransform.getOrigin() = transform * capStart;
   {
    btVector3 center = childTransform.getOrigin();
    btVector3 up = childTransform.getBasis().getColumn((upAxis+1)%3);
    btVector3 axis = -childTransform.getBasis().getColumn(upAxis);
    btScalar minTh = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    btScalar maxTh = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    btScalar minPs = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    btScalar maxPs = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));

    drawSpherePatch(center, up, axis, radius,minTh, maxTh, minPs, maxPs, color, btScalar(stepDegrees) ,false);
   }



  }

  {
   btTransform childTransform = transform;
   childTransform.getOrigin() = transform * capEnd;
   {
    btVector3 center = childTransform.getOrigin();
    btVector3 up = childTransform.getBasis().getColumn((upAxis+1)%3);
    btVector3 axis = childTransform.getBasis().getColumn(upAxis);
    btScalar minTh = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    btScalar maxTh = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    btScalar minPs = -(btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    btScalar maxPs = (btScalar(3.1415926535897932384626433832795029) * btScalar(0.5));
    drawSpherePatch(center, up, axis, radius,minTh, maxTh, minPs, maxPs, color, btScalar(stepDegrees) ,false);
   }
  }


  btVector3 start = transform.getOrigin();

  for (int i=0;i<360;i+=stepDegrees)
  {
   capEnd[(upAxis+1)%3] = capStart[(upAxis+1)%3] = btSin(btScalar(i)*((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)))*radius;
   capEnd[(upAxis+2)%3] = capStart[(upAxis+2)%3] = btCos(btScalar(i)*((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)))*radius;
   drawLine(start+transform.getBasis() * capStart,start+transform.getBasis() * capEnd, color);
  }

 }

 virtual void drawCylinder(btScalar radius, btScalar halfHeight, int upAxis, const btTransform& transform, const btVector3& color)
 {
  btVector3 start = transform.getOrigin();
  btVector3 offsetHeight(0,0,0);
  offsetHeight[upAxis] = halfHeight;
  int stepDegrees=30;
  btVector3 capStart(0.f,0.f,0.f);
  capStart[upAxis] = -halfHeight;
  btVector3 capEnd(0.f,0.f,0.f);
  capEnd[upAxis] = halfHeight;

  for (int i=0;i<360;i+=stepDegrees)
  {
   capEnd[(upAxis+1)%3] = capStart[(upAxis+1)%3] = btSin(btScalar(i)*((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)))*radius;
   capEnd[(upAxis+2)%3] = capStart[(upAxis+2)%3] = btCos(btScalar(i)*((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)))*radius;
   drawLine(start+transform.getBasis() * capStart,start+transform.getBasis() * capEnd, color);
  }

  btVector3 yaxis(0,0,0);
  yaxis[upAxis] = btScalar(1.0);
  btVector3 xaxis(0,0,0);
  xaxis[(upAxis+1)%3] = btScalar(1.0);
  drawArc(start-transform.getBasis()*(offsetHeight),transform.getBasis()*yaxis,transform.getBasis()*xaxis,radius,radius,0,(btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)),color,false,btScalar(10.0));
  drawArc(start+transform.getBasis()*(offsetHeight),transform.getBasis()*yaxis,transform.getBasis()*xaxis,radius,radius,0,(btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)),color,false,btScalar(10.0));
 }

 virtual void drawCone(btScalar radius, btScalar height, int upAxis, const btTransform& transform, const btVector3& color)
 {
  int stepDegrees = 30;
  btVector3 start = transform.getOrigin();

  btVector3 offsetHeight(0,0,0);
  btScalar halfHeight = height * btScalar(0.5);
  offsetHeight[upAxis] = halfHeight;
  btVector3 offsetRadius(0,0,0);
  offsetRadius[(upAxis+1)%3] = radius;
  btVector3 offset2Radius(0,0,0);
  offset2Radius[(upAxis+2)%3] = radius;


  btVector3 capEnd(0.f,0.f,0.f);
  capEnd[upAxis] = -halfHeight;

  for (int i=0;i<360;i+=stepDegrees)
  {
   capEnd[(upAxis+1)%3] = btSin(btScalar(i)*((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)))*radius;
   capEnd[(upAxis+2)%3] = btCos(btScalar(i)*((btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)) / btScalar(360.0)))*radius;
   drawLine(start+transform.getBasis() * (offsetHeight),start+transform.getBasis() * capEnd, color);
  }

  drawLine(start+transform.getBasis() * (offsetHeight),start+transform.getBasis() * (-offsetHeight+offsetRadius),color);
  drawLine(start+transform.getBasis() * (offsetHeight),start+transform.getBasis() * (-offsetHeight-offsetRadius),color);
  drawLine(start+transform.getBasis() * (offsetHeight),start+transform.getBasis() * (-offsetHeight+offset2Radius),color);
  drawLine(start+transform.getBasis() * (offsetHeight),start+transform.getBasis() * (-offsetHeight-offset2Radius),color);


  btVector3 yaxis(0,0,0);
  yaxis[upAxis] = btScalar(1.0);
  btVector3 xaxis(0,0,0);
  xaxis[(upAxis+1)%3] = btScalar(1.0);
  drawArc(start-transform.getBasis()*(offsetHeight),transform.getBasis()*yaxis,transform.getBasis()*xaxis,radius,radius,0,(btScalar(2.0) * btScalar(3.1415926535897932384626433832795029)),color,false,10.0);
 }

 virtual void drawPlane(const btVector3& planeNormal, btScalar planeConst, const btTransform& transform, const btVector3& color)
 {
  btVector3 planeOrigin = planeNormal * planeConst;
  btVector3 vec0,vec1;
  btPlaneSpace1(planeNormal,vec0,vec1);
  btScalar vecLen = 100.f;
  btVector3 pt0 = planeOrigin + vec0*vecLen;
  btVector3 pt1 = planeOrigin - vec0*vecLen;
  btVector3 pt2 = planeOrigin + vec1*vecLen;
  btVector3 pt3 = planeOrigin - vec1*vecLen;
  drawLine(transform*pt0,transform*pt1,color);
  drawLine(transform*pt2,transform*pt3,color);
 }

 virtual void flushLines()
 {
 }
};


class btCollisionConfiguration;
class btCollisionShape;
class btBroadphaseInterface;
class btConstraintSolver;
class btDiscreteDynamicsWorld;
class btDispatcher;
class btDynamicsWorld;
class btPersistentManifold;

namespace Urho3D
{

class CollisionShape;
class Deserializer;
class Constraint;
class Model;
class Node;
class Ray;
class RigidBody;
class Scene;
class Serializer;
class XMLElement;

struct CollisionGeometryData;


struct __attribute__((visibility("default"))) PhysicsRaycastResult
{

    bool operator !=(const PhysicsRaycastResult& rhs) const
    {
        return position_ != rhs.position_ || normal_ != rhs.normal_ || distance_ != rhs.distance_ || body_ != rhs.body_;
    }


    Vector3 position_;

    Vector3 normal_;

    float distance_{};

    float hitFraction_{};

    RigidBody* body_{};
};


struct DelayedWorldTransform
{

    RigidBody* rigidBody_;

    RigidBody* parentRigidBody_;

    Vector3 worldPosition_;

    Quaternion worldRotation_;
};


struct ManifoldPair
{

    ManifoldPair() :
        manifold_(nullptr),
        flippedManifold_(nullptr)
    {
    }


    btPersistentManifold* manifold_;

    btPersistentManifold* flippedManifold_;
};


struct PhysicsWorldConfig
{
    PhysicsWorldConfig() :
        collisionConfig_(nullptr)
    {
    }


    btCollisionConfiguration* collisionConfig_;
};

static const int DEFAULT_FPS = 60;
static const float DEFAULT_MAX_NETWORK_ANGULAR_VELOCITY = 100.0f;


using CollisionGeometryDataCache = HashMap<Pair<Model*, unsigned>, SharedPtr<CollisionGeometryData> >;


class __attribute__((visibility("default"))) PhysicsWorld : public Component, public btIDebugDraw
{
    public: using ClassName = PhysicsWorld; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("PhysicsWorld", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend void InternalPreTickCallback(btDynamicsWorld* world, btScalar timeStep);
    friend void InternalTickCallback(btDynamicsWorld* world, btScalar timeStep);

public:

    explicit PhysicsWorld(Context* context);

    ~PhysicsWorld() override;

    static void RegisterObject(Context* context);


    bool isVisible(const btVector3& aabbMin, const btVector3& aabbMax) override;

    void drawLine(const btVector3& from, const btVector3& to, const btVector3& color) override;

    void reportErrorWarning(const char* warningString) override;

    void drawContactPoint
        (const btVector3& pointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color) override;

    void draw3dText(const btVector3& location, const char* textString) override;


    void setDebugMode(int debugMode) override { debugMode_ = debugMode; }


    int getDebugMode() const override { return debugMode_; }


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void Update(float timeStep);

    void UpdateCollisions();

    void SetFps(int fps);

    void SetGravity(const Vector3& gravity);

    void SetMaxSubSteps(int num);

    void SetNumIterations(int num);

    void SetUpdateEnabled(bool enable);

    void SetInterpolation(bool enable);

    void SetInternalEdge(bool enable);

    void SetSplitImpulse(bool enable);

    void SetMaxNetworkAngularVelocity(float velocity);

    void Raycast
        (PODVector<PhysicsRaycastResult>& result, const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED);

    void RaycastSingle(PhysicsRaycastResult& result, const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED);


    void RaycastSingleSegmented(PhysicsRaycastResult& result, const Ray& ray, float maxDistance, float segmentDistance, unsigned collisionMask = M_MAX_UNSIGNED, float overlapDistance = 0.1f);

    void SphereCast
        (PhysicsRaycastResult& result, const Ray& ray, float radius, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED);

    void ConvexCast(PhysicsRaycastResult& result, CollisionShape* shape, const Vector3& startPos, const Quaternion& startRot,
        const Vector3& endPos, const Quaternion& endRot, unsigned collisionMask = M_MAX_UNSIGNED);

    void ConvexCast(PhysicsRaycastResult& result, btCollisionShape* shape, const Vector3& startPos, const Quaternion& startRot,
        const Vector3& endPos, const Quaternion& endRot, unsigned collisionMask = M_MAX_UNSIGNED);

    void RemoveCachedGeometry(Model* model);

    void GetRigidBodies(PODVector<RigidBody*>& result, const Sphere& sphere, unsigned collisionMask = M_MAX_UNSIGNED);

    void GetRigidBodies(PODVector<RigidBody*>& result, const BoundingBox& box, unsigned collisionMask = M_MAX_UNSIGNED);

    void GetRigidBodies(PODVector<RigidBody*>& result, const RigidBody* body);

    void GetCollidingBodies(PODVector<RigidBody*>& result, const RigidBody* body);


    Vector3 GetGravity() const;


    int GetMaxSubSteps() const { return maxSubSteps_; }


    int GetNumIterations() const;


    bool IsUpdateEnabled() const { return updateEnabled_; }


    bool GetInterpolation() const { return interpolation_; }


    bool GetInternalEdge() const { return internalEdge_; }


    bool GetSplitImpulse() const;


    int GetFps() const { return fps_; }


    float GetMaxNetworkAngularVelocity() const { return maxNetworkAngularVelocity_; }


    void AddRigidBody(RigidBody* body);

    void RemoveRigidBody(RigidBody* body);

    void AddCollisionShape(CollisionShape* shape);

    void RemoveCollisionShape(CollisionShape* shape);

    void AddConstraint(Constraint* constraint);

    void RemoveConstraint(Constraint* constraint);

    void AddDelayedWorldTransform(const DelayedWorldTransform& transform);

    void DrawDebugGeometry(bool depthTest);

    void SetDebugRenderer(DebugRenderer* debug);

    void SetDebugDepthTest(bool enable);


    btDiscreteDynamicsWorld* GetWorld() { return world_.Get(); }


    void CleanupGeometryCache();


    CollisionGeometryDataCache& GetTriMeshCache() { return triMeshCache_; }


    CollisionGeometryDataCache& GetConvexCache() { return convexCache_; }


    CollisionGeometryDataCache& GetGImpactTrimeshCache() { return gimpactTrimeshCache_; }


    void SetApplyingTransforms(bool enable) { applyingTransforms_ = enable; }


    bool IsApplyingTransforms() const { return applyingTransforms_; }


    bool IsSimulating() const { return simulating_; }


    static struct PhysicsWorldConfig config;

protected:

    void OnSceneSet(Scene* scene) override;

private:

    void HandleSceneSubsystemUpdate(StringHash eventType, VariantMap& eventData);

    void PreStep(float timeStep);

    void PostStep(float timeStep);

    void SendCollisionEvents();


    btCollisionConfiguration* collisionConfiguration_{};

    UniquePtr<btDispatcher> collisionDispatcher_;

    UniquePtr<btBroadphaseInterface> broadphase_;

    UniquePtr<btConstraintSolver> solver_;

    UniquePtr<btDiscreteDynamicsWorld> world_;

    WeakPtr<Scene> scene_;

    PODVector<RigidBody*> rigidBodies_;

    PODVector<CollisionShape*> collisionShapes_;

    PODVector<Constraint*> constraints_;

    HashMap<Pair<WeakPtr<RigidBody>, WeakPtr<RigidBody> >, ManifoldPair> currentCollisions_;

    HashMap<Pair<WeakPtr<RigidBody>, WeakPtr<RigidBody> >, ManifoldPair> previousCollisions_;

    HashMap<RigidBody*, DelayedWorldTransform> delayedWorldTransforms_;

    CollisionGeometryDataCache triMeshCache_;

    CollisionGeometryDataCache convexCache_;

    CollisionGeometryDataCache gimpactTrimeshCache_;

    VariantMap physicsCollisionData_;

    VariantMap nodeCollisionData_;

    VectorBuffer contacts_;

    unsigned fps_{DEFAULT_FPS};

    int maxSubSteps_{};

    float timeAcc_{};

    float maxNetworkAngularVelocity_{DEFAULT_MAX_NETWORK_ANGULAR_VELOCITY};

    bool updateEnabled_{true};

    bool interpolation_{true};

    bool internalEdge_{true};

    bool applyingTransforms_{};

    bool simulating_{};

    bool debugDepthTest_{};

    DebugRenderer* debugRenderer_{};

    int debugMode_{};
};


void __attribute__((visibility("default"))) RegisterPhysicsLibrary(Context* context);

}
namespace Urho3D
{

enum UpdateEvent : unsigned
{

    USE_NO_EVENT = 0x0,

    USE_UPDATE = 0x1,

    USE_POSTUPDATE = 0x2,

    USE_FIXEDUPDATE = 0x4,

    USE_FIXEDPOSTUPDATE = 0x8,
};
template<> struct IsFlagSet<UpdateEvent> { constexpr static bool value_ = true; }; using UpdateEventFlags = FlagSet<UpdateEvent>;


class __attribute__((visibility("default"))) LogicComponent : public Component
{
    public: using ClassName = LogicComponent; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("LogicComponent", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };


    explicit LogicComponent(Context* context);

    ~LogicComponent() override;


    void OnSetEnabled() override;


    virtual void Start() { }


    virtual void DelayedStart() { }


    virtual void Stop() { }


    virtual void Update(float timeStep);

    virtual void PostUpdate(float timeStep);

    virtual void FixedUpdate(float timeStep);

    virtual void FixedPostUpdate(float timeStep);


    void SetUpdateEventMask(UpdateEventFlags mask);


    UpdateEventFlags GetUpdateEventMask() const { return updateEventMask_; }


    bool IsDelayedStartCalled() const { return delayedStartCalled_; }

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

private:

    void UpdateEventSubscription();

    void HandleSceneUpdate(StringHash eventType, VariantMap& eventData);

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);


    void HandlePhysicsPreStep(StringHash eventType, VariantMap& eventData);

    void HandlePhysicsPostStep(StringHash eventType, VariantMap& eventData);


    UpdateEventFlags updateEventMask_;

    UpdateEventFlags currentEventMask_;

    bool delayedStartCalled_;
};

}

class btMotionState
{
 public:

  virtual ~btMotionState()
  {

  }

  virtual void getWorldTransform(btTransform& worldTrans ) const =0;


  virtual void setWorldTransform(const btTransform& worldTrans)=0;


};


class btCompoundShape;
class btRigidBody;

namespace Urho3D
{

class CollisionShape;
class Constraint;
class PhysicsWorld;
class SmoothedTransform;


enum CollisionEventMode
{
    COLLISION_NEVER = 0,
    COLLISION_ACTIVE,
    COLLISION_ALWAYS
};


class __attribute__((visibility("default"))) RigidBody : public Component, public btMotionState
{
    public: using ClassName = RigidBody; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RigidBody", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit RigidBody(Context* context);

    ~RigidBody() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnSetEnabled() override;

    void getWorldTransform(btTransform& worldTrans) const override;

    void setWorldTransform(const btTransform& worldTrans) override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetMass(float mass);

    void SetPosition(const Vector3& position);

    void SetRotation(const Quaternion& rotation);

    void SetTransform(const Vector3& position, const Quaternion& rotation);

    void SetLinearVelocity(const Vector3& velocity);

    void SetLinearFactor(const Vector3& factor);

    void SetLinearRestThreshold(float threshold);

    void SetLinearDamping(float damping);

    void SetAngularVelocity(const Vector3& velocity);

    void SetAngularFactor(const Vector3& factor);

    void SetAngularRestThreshold(float threshold);

    void SetAngularDamping(float damping);

    void SetFriction(float friction);

    void SetAnisotropicFriction(const Vector3& friction);

    void SetRollingFriction(float friction);

    void SetRestitution(float restitution);

    void SetContactProcessingThreshold(float threshold);

    void SetCcdRadius(float radius);

    void SetCcdMotionThreshold(float threshold);

    void SetUseGravity(bool enable);

    void SetGravityOverride(const Vector3& gravity);

    void SetKinematic(bool enable);

    void SetTrigger(bool enable);

    void SetCollisionLayer(unsigned layer);

    void SetCollisionMask(unsigned mask);

    void SetCollisionLayerAndMask(unsigned layer, unsigned mask);

    void SetCollisionEventMode(CollisionEventMode mode);

    void ApplyForce(const Vector3& force);

    void ApplyForce(const Vector3& force, const Vector3& position);

    void ApplyTorque(const Vector3& torque);

    void ApplyImpulse(const Vector3& impulse);

    void ApplyImpulse(const Vector3& impulse, const Vector3& position);

    void ApplyTorqueImpulse(const Vector3& torque);

    void ResetForces();

    void Activate();

    void ReAddBodyToWorld();

    void DisableMassUpdate();

    void EnableMassUpdate();


    PhysicsWorld* GetPhysicsWorld() const { return physicsWorld_; }


    btRigidBody* GetBody() const { return body_.Get(); }


    btCompoundShape* GetCompoundShape() const { return compoundShape_.Get(); }


    float GetMass() const { return mass_; }


    Vector3 GetPosition() const;

    Quaternion GetRotation() const;

    Vector3 GetLinearVelocity() const;

    Vector3 GetLinearFactor() const;

    Vector3 GetVelocityAtPoint(const Vector3& position) const;

    float GetLinearRestThreshold() const;

    float GetLinearDamping() const;

    Vector3 GetAngularVelocity() const;

    Vector3 GetAngularFactor() const;

    float GetAngularRestThreshold() const;

    float GetAngularDamping() const;

    float GetFriction() const;

    Vector3 GetAnisotropicFriction() const;

    float GetRollingFriction() const;

    float GetRestitution() const;

    float GetContactProcessingThreshold() const;

    float GetCcdRadius() const;

    float GetCcdMotionThreshold() const;


    bool GetUseGravity() const { return useGravity_; }


    const Vector3& GetGravityOverride() const { return gravityOverride_; }


    const Vector3& GetCenterOfMass() const { return centerOfMass_; }


    bool IsKinematic() const { return kinematic_; }


    bool IsTrigger() const { return trigger_; }


    bool IsActive() const;


    unsigned GetCollisionLayer() const { return collisionLayer_; }


    unsigned GetCollisionMask() const { return collisionMask_; }


    CollisionEventMode GetCollisionEventMode() const { return collisionEventMode_; }


    void GetCollidingBodies(PODVector<RigidBody*>& result) const;


    void ApplyWorldTransform(const Vector3& newWorldPosition, const Quaternion& newWorldRotation);

    void UpdateMass();

    void UpdateGravity();

    void SetNetAngularVelocityAttr(const PODVector<unsigned char>& value);

    const PODVector<unsigned char>& GetNetAngularVelocityAttr() const;

    void AddConstraint(Constraint* constraint);

    void RemoveConstraint(Constraint* constraint);

    void ReleaseBody();

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

private:

    void AddBodyToWorld();

    void RemoveBodyFromWorld();

    void HandleTargetPosition(StringHash eventType, VariantMap& eventData);

    void HandleTargetRotation(StringHash eventType, VariantMap& eventData);

    void MarkBodyDirty() { readdBody_ = true; }


    UniquePtr<btRigidBody> body_;

    UniquePtr<btCompoundShape> compoundShape_;

    UniquePtr<btCompoundShape> shiftedCompoundShape_;

    WeakPtr<PhysicsWorld> physicsWorld_;

    WeakPtr<SmoothedTransform> smoothedTransform_;

    PODVector<Constraint*> constraints_;

    Vector3 gravityOverride_;

    Vector3 centerOfMass_;

    float mass_;

    mutable VectorBuffer attrBuffer_;

    unsigned collisionLayer_;

    unsigned collisionMask_;

    CollisionEventMode collisionEventMode_;

    mutable Vector3 lastPosition_;

    mutable Quaternion lastRotation_;

    bool kinematic_;

    bool trigger_;

    bool useGravity_;

    bool readdBody_;

    bool inWorld_;

    bool enableMassUpdate_;

    mutable bool hasSimulated_;
};

}

namespace Urho3D
{
struct RaycastVehicleData;

class __attribute__((visibility("default"))) RaycastVehicle : public LogicComponent
{
    public: using ClassName = RaycastVehicle; using BaseClassName = LogicComponent; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RaycastVehicle", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    explicit RaycastVehicle(Urho3D::Context* context);

    ~RaycastVehicle() override;


    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    void ApplyAttributes() override;


    void AddWheel(Node* wheelNode, Vector3 wheelDirection, Vector3 wheelAxle, float restLength, float wheelRadius, bool frontWheel);

    void ResetSuspension();

    void UpdateWheelTransform(int wheel, bool interpolated);

    void SetSteeringValue(int wheel, float steeringValue);

    void SetWheelSuspensionStiffness(int wheel, float stiffness);

    void SetWheelDampingRelaxation(int wheel, float damping);

    void SetWheelDampingCompression(int wheel, float compression);

    void SetWheelFrictionSlip(int wheel, float slip);

    void SetWheelRollInfluence(int wheel, float rollInfluence);

    void SetEngineForce(int wheel, float force);

    void SetBrake(int wheel, float force);

    void SetWheelRadius(int wheel, float wheelRadius);

    void ResetWheels();

    void SetWheelSkidInfo(int wheel, float factor);

    bool WheelIsGrounded(int wheel) const;

    void SetMaxSuspensionTravel(int wheel, float maxSuspensionTravel);

    void SetWheelDirection(int wheel, Vector3 direction);

    void SetWheelAxle(int wheel, Vector3 axle);

    void SetMaxSideSlipSpeed(float speed);

    void SetWheelSkidInfoCumulative(int wheel, float skid);

    void SetInAirRPM(float rpm);

    void SetCoordinateSystem(const IntVector3& coordinateSystem = RIGHT_FORWARD_UP);

    void Init();

    void FixedUpdate(float timeStep) override;

    void FixedPostUpdate(float timeStep) override;

    void PostUpdate(float timeStep) override;


    Vector3 GetWheelPosition(int wheel);

    Quaternion GetWheelRotation(int wheel);

    Vector3 GetWheelConnectionPoint(int wheel) const;

    int GetNumWheels() const;

    Node* GetWheelNode(int wheel) const;

    float GetSteeringValue(int wheel) const;

    float GetWheelSuspensionStiffness(int wheel) const;

    float GetWheelDampingRelaxation(int wheel) const;

    float GetWheelDampingCompression(int wheel) const;

    float GetWheelFrictionSlip(int wheel) const;

    float GetWheelRollInfluence(int wheel) const;

    float GetEngineForce(int wheel) const;

    float GetBrake(int wheel) const;

    float GetWheelRadius(int wheel) const;

    void SetWheelRestLength(int wheel, float length);

    float GetWheelRestLength(int wheel) const;

    float GetMaxSuspensionTravel(int wheel);

    Vector3 GetWheelAxle(int wheel) const;

    float GetWheelSideSlipSpeed(int wheel) const;

    float GetMaxSideSlipSpeed() const;

    float GetWheelSkidInfo(int wheel) const;

    Vector3 GetWheelDirection(int wheel) const;

    float GetWheelSkidInfoCumulative(int wheel) const;

    bool IsFrontWheel(int wheel) const;

    Vector3 GetContactPosition(int wheel) const;

    Vector3 GetContactNormal(int wheel) const;

    float GetInAirRPM() const;

    IntVector3 GetCoordinateSystem() const { return coordinateSystem_; }


    VariantVector GetWheelDataAttr() const;

    void SetWheelDataAttr(const VariantVector& value);


    static const IntVector3 RIGHT_UP_FORWARD;

    static const IntVector3 RIGHT_FORWARD_UP;

    static const IntVector3 UP_FORWARD_RIGHT;

    static const IntVector3 UP_RIGHT_FORWARD;

    static const IntVector3 FORWARD_RIGHT_UP;

    static const IntVector3 FORWARD_UP_RIGHT;

private:

    bool activate_;

    WeakPtr<RigidBody> hullBody_;

    RaycastVehicleData* vehicleData_;

    IntVector3 coordinateSystem_;

    Vector<Node*> wheelNodes_;

    Vector<Quaternion> origRotation_;

    float inAirRPM_;

    Vector<float> skidInfoCumulative_;

    Vector<float> wheelSideSlipSpeed_;

    float maxSideSlipSpeed_;

    VariantVector loadedWheelData_;
};

}


namespace Urho3D
{

class Resource;
class ResourceCache;


struct BackgroundLoadItem
{

    SharedPtr<Resource> resource_;

    HashSet<Pair<StringHash, StringHash> > dependencies_;

    HashSet<Pair<StringHash, StringHash> > dependents_;

    bool sendEventOnFailure_;
};


class BackgroundLoader : public RefCounted, public Thread
{
public:

    explicit BackgroundLoader(ResourceCache* owner);


    ~BackgroundLoader() override;


    void ThreadFunction() override;


    bool QueueResource(StringHash type, const String& name, bool sendEventOnFailure, Resource* caller);

    void WaitForResource(StringHash type, StringHash nameHash);

    void FinishResources(int maxMs);


    unsigned GetNumQueuedResources() const;

private:

    void FinishBackgroundLoading(BackgroundLoadItem& item);


    ResourceCache* owner_;

    mutable Mutex backgroundLoadMutex_;

    HashMap<Pair<StringHash, StringHash>, BackgroundLoadItem> backgroundLoadQueue_;
};

}
namespace Urho3D
{


__attribute__((visibility("default"))) void
    DecompressImageDXT(unsigned char* rgba, const void* blocks, int width, int height, int depth, CompressedFormat format);

__attribute__((visibility("default"))) void DecompressImageETC(unsigned char* rgba, const void* blocks, int width, int height);

__attribute__((visibility("default"))) void DecompressImagePVRTC(unsigned char* rgba, const void* blocks, int width, int height, CompressedFormat format);

__attribute__((visibility("default"))) void FlipBlockVertical(unsigned char* dest, const unsigned char* src, CompressedFormat format);

__attribute__((visibility("default"))) void FlipBlockHorizontal(unsigned char* dest, const unsigned char* src, CompressedFormat format);

}



namespace Urho3D
{


class __attribute__((visibility("default"))) Localization : public Object
{
    public: using ClassName = Localization; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Localization", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Localization(Context* context);

    ~Localization() override;


    int GetNumLanguages() const { return (int)languages_.Size(); }


    int GetLanguageIndex() const { return languageIndex_; }


    int GetLanguageIndex(const String& language);

    String GetLanguage();

    String GetLanguage(int index);

    void SetLanguage(int index);

    void SetLanguage(const String& language);

    String Get(const String& id);

    void Reset();

    void LoadJSONFile(const String& name, const String& basePath = String::EMPTY, const String language = String::EMPTY);

    void LoadMultipleLanguageJSON(const JSONValue& source);

    void LoadSingleLanguageJSON(const JSONValue& source, const String& language = String::EMPTY);

private:

    Vector<String> languages_;

    int languageIndex_;

    HashMap<StringHash, HashMap<StringHash, String> > strings_;
};

}
namespace Urho3D
{

class XMLElement;


enum PListValueType
{
    PLVT_NONE = 0,
    PLVT_INT,
    PLVT_BOOL,
    PLVT_FLOAT,
    PLVT_STRING,
    PLVT_VALUEMAP,
    PLVT_VALUEVECTOR,
};

class PListValue;


using PListValueMap = HashMap<String, PListValue>;


using PListValueVector = Vector<PListValue>;


class __attribute__((visibility("default"))) PListValue
{
public:

    PListValue();

    explicit PListValue(int value);

    explicit PListValue(bool value);

    explicit PListValue(float value);

    explicit PListValue(const String& value);

    explicit PListValue(PListValueMap& valueMap);

    explicit PListValue(PListValueVector& valueVector);

    PListValue(const PListValue& value);

    ~PListValue();


    PListValue& operator =(const PListValue& rhs);


    explicit operator bool() const { return type_ != PLVT_NONE; }


    void SetInt(int value);

    void SetBool(bool value);

    void SetFloat(float value);

    void SetString(const String& value);

    void SetValueMap(const PListValueMap& valueMap);

    void SetValueVector(const PListValueVector& valueVector);


    PListValueType GetType() const { return type_; }


    int GetInt() const;

    bool GetBool() const;

    float GetFloat() const;

    const String& GetString() const;

    IntRect GetIntRect() const;

    IntVector2 GetIntVector2() const;

    IntVector3 GetIntVector3() const;

    const PListValueMap& GetValueMap() const;

    const PListValueVector& GetValueVector() const;


    PListValueMap& ConvertToValueMap();

    PListValueVector& ConvertToValueVector();

private:

    void Reset();


    PListValueType type_;

    union
    {
        int int_;
        bool bool_;
        float float_;
        String* string_;
        PListValueMap* valueMap_;
        PListValueVector* valueVector_;
    };
};


class __attribute__((visibility("default"))) PListFile : public Resource
{
    public: using ClassName = PListFile; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("PListFile", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit PListFile(Context* context);

    ~PListFile() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;


    const PListValueMap& GetRoot() const { return root_; }

private:

    bool LoadDict(PListValueMap& dict, const XMLElement& dictElem);

    bool LoadArray(PListValueVector& array, const XMLElement& arrayElem);

    bool LoadValue(PListValue& value, const XMLElement& valueElem);


    PListValueMap root_;
};

}

namespace Urho3D
{

class BackgroundLoader;
class FileWatcher;
class PackageFile;


static const unsigned PRIORITY_LAST = 0xffffffff;


struct ResourceGroup
{

    ResourceGroup() :
        memoryBudget_(0),
        memoryUse_(0)
    {
    }


    unsigned long long memoryBudget_;

    unsigned long long memoryUse_;

    HashMap<StringHash, SharedPtr<Resource> > resources_;
};


enum ResourceRequest
{
    RESOURCE_CHECKEXISTS = 0,
    RESOURCE_GETFILE = 1
};


class __attribute__((visibility("default"))) ResourceRouter : public Object
{
public:

    explicit ResourceRouter(Context* context) :
        Object(context)
    {
    }


    virtual void Route(String& name, ResourceRequest requestType) = 0;
};


class __attribute__((visibility("default"))) ResourceCache : public Object
{
    public: using ClassName = ResourceCache; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ResourceCache", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ResourceCache(Context* context);

    ~ResourceCache() override;


    bool AddResourceDir(const String& pathName, unsigned priority = PRIORITY_LAST);

    bool AddPackageFile(PackageFile* package, unsigned priority = PRIORITY_LAST);

    bool AddPackageFile(const String& fileName, unsigned priority = PRIORITY_LAST);

    bool AddManualResource(Resource* resource);

    void RemoveResourceDir(const String& pathName);

    void RemovePackageFile(PackageFile* package, bool releaseResources = true, bool forceRelease = false);

    void RemovePackageFile(const String& fileName, bool releaseResources = true, bool forceRelease = false);

    void ReleaseResource(StringHash type, const String& name, bool force = false);

    void ReleaseResources(StringHash type, bool force = false);

    void ReleaseResources(StringHash type, const String& partialName, bool force = false);

    void ReleaseResources(const String& partialName, bool force = false);

    void ReleaseAllResources(bool force = false);

    bool ReloadResource(Resource* resource);

    void ReloadResourceWithDependencies(const String& fileName);

    void SetMemoryBudget(StringHash type, unsigned long long budget);

    void SetAutoReloadResources(bool enable);

    void SetReturnFailedResources(bool enable) { returnFailedResources_ = enable; }


    void SetSearchPackagesFirst(bool value) { searchPackagesFirst_ = value; }


    void SetFinishBackgroundResourcesMs(int ms) { finishBackgroundResourcesMs_ = Max(ms, 1); }


    void AddResourceRouter(ResourceRouter* router, bool addAsFirst = false);

    void RemoveResourceRouter(ResourceRouter* router);


    SharedPtr<File> GetFile(const String& name, bool sendEventOnFailure = true);

    Resource* GetResource(StringHash type, const String& name, const String& basePath = String::EMPTY, bool sendEventOnFailure = true);

    SharedPtr<Resource> GetTempResource(StringHash type, const String& name, const String& basePath = String::EMPTY, bool sendEventOnFailure = true);

    bool BackgroundLoadResource(StringHash type, const String& name, const String& basePath = String::EMPTY, bool sendEventOnFailure = true, Resource* caller = nullptr);

    unsigned GetNumBackgroundLoadResources() const;

    void GetResources(PODVector<Resource*>& result, StringHash type) const;

    Resource* GetExistingResource(StringHash type, const String& name);


    const HashMap<StringHash, ResourceGroup>& GetAllResources() const { return resourceGroups_; }


    const Vector<String>& GetResourceDirs() const { return resourceDirs_; }


    const Vector<SharedPtr<PackageFile> >& GetPackageFiles() const { return packages_; }


    template <class T> T* GetResource(const String& name, const String& basePath = String::EMPTY, bool sendEventOnFailure = true);

    template <class T> T* GetExistingResource(const String& name);

    template <class T> SharedPtr<T> GetTempResource(const String& name, const String& basePath = String::EMPTY, bool sendEventOnFailure = true);

    template <class T> void ReleaseResource(const String& name, bool force = false);

    template <class T> bool BackgroundLoadResource(const String& name, const String& basePath = String::EMPTY, bool sendEventOnFailure = true, Resource* caller = nullptr);

    template <class T> void GetResources(PODVector<T*>& result) const;

    bool Exists(const String& name, const String& basePath = String::EMPTY) const;

    unsigned long long GetMemoryBudget(StringHash type) const;

    unsigned long long GetMemoryUse(StringHash type) const;

    unsigned long long GetTotalMemoryUse() const;

    String GetResourceFileName(const String& name) const;


    bool GetAutoReloadResources() const { return autoReloadResources_; }


    bool GetReturnFailedResources() const { return returnFailedResources_; }


    bool GetSearchPackagesFirst() const { return searchPackagesFirst_; }


    int GetFinishBackgroundResourcesMs() const { return finishBackgroundResourcesMs_; }


    ResourceRouter* GetResourceRouter(unsigned index) const;


    String GetPreferredResourceDir(const String& path) const;

    String SanitateResourceName(const String& name) const;

    String SanitateResourceDirName(const String& name) const;

    void StoreResourceDependency(Resource* resource, const String& dependency);

    void ResetDependencies(Resource* resource);


    String PrintMemoryUsage() const;

private:

    const SharedPtr<Resource>& FindResource(StringHash type, StringHash nameHash);

    const SharedPtr<Resource>& FindResource(StringHash nameHash);

    void ReleasePackageResources(PackageFile* package, bool force = false);

    void UpdateResourceGroup(StringHash type);

    void HandleBeginFrame(StringHash eventType, VariantMap& eventData);

    File* SearchResourceDirs(const String& name);

    File* SearchPackages(const String& name);


    mutable Mutex resourceMutex_;

    HashMap<StringHash, ResourceGroup> resourceGroups_;

    Vector<String> resourceDirs_;

    Vector<SharedPtr<FileWatcher> > fileWatchers_;

    Vector<SharedPtr<PackageFile> > packages_;

    HashMap<StringHash, HashSet<StringHash> > dependentResources_;

    SharedPtr<BackgroundLoader> backgroundLoader_;

    Vector<SharedPtr<ResourceRouter> > resourceRouters_;

    bool autoReloadResources_;

    bool returnFailedResources_;

    bool searchPackagesFirst_;

    mutable bool isRouting_;

    int finishBackgroundResourcesMs_;
};

template <class T> T* ResourceCache::GetExistingResource(const String& name)
{
    StringHash type = T::GetTypeStatic();
    return static_cast<T*>(GetExistingResource(type, name));
}

template <class T> T* ResourceCache::GetResource(const String& name, const String &basePath, bool sendEventOnFailure)
{
    StringHash type = T::GetTypeStatic();
    return static_cast<T*>(GetResource(type, name, basePath, sendEventOnFailure));
}

template <class T> void ResourceCache::ReleaseResource(const String& name, bool force)
{
    StringHash type = T::GetTypeStatic();
    ReleaseResource(type, name, force);
}

template <class T> SharedPtr<T> ResourceCache::GetTempResource(const String& name, const String &basePath, bool sendEventOnFailure)
{
    StringHash type = T::GetTypeStatic();
    return StaticCast<T>(GetTempResource(type, name, basePath, sendEventOnFailure));
}

template <class T> bool ResourceCache::BackgroundLoadResource(const String& name, const String& basePath, bool sendEventOnFailure, Resource* caller)
{
    StringHash type = T::GetTypeStatic();
    return BackgroundLoadResource(type, name, basePath, sendEventOnFailure, caller);
}

template <class T> void ResourceCache::GetResources(PODVector<T*>& result) const
{
    auto& resources = reinterpret_cast<PODVector<Resource*>&>(result);
    StringHash type = T::GetTypeStatic();
    GetResources(resources, type);


    for (unsigned i = 0; i < result.Size(); ++i)
    {
        Resource* resource = resources[i];
        result[i] = static_cast<T*>(resource);
    }
}


void __attribute__((visibility("default"))) RegisterResourceLibrary(Context* context);

}
namespace Urho3D
{


static const Urho3D::StringHash E_RELOADSTARTED(Urho3D::GetEventNameRegister().RegisterString("ReloadStarted")); namespace ReloadStarted
{
}


static const Urho3D::StringHash E_RELOADFINISHED(Urho3D::GetEventNameRegister().RegisterString("ReloadFinished")); namespace ReloadFinished
{
}


static const Urho3D::StringHash E_RELOADFAILED(Urho3D::GetEventNameRegister().RegisterString("ReloadFailed")); namespace ReloadFailed
{
}


static const Urho3D::StringHash E_FILECHANGED(Urho3D::GetEventNameRegister().RegisterString("FileChanged")); namespace FileChanged
{
    static const Urho3D::StringHash P_FILENAME("FileName");
    static const Urho3D::StringHash P_RESOURCENAME("ResourceName");
}


static const Urho3D::StringHash E_LOADFAILED(Urho3D::GetEventNameRegister().RegisterString("LoadFailed")); namespace LoadFailed
{
    static const Urho3D::StringHash P_RESOURCENAME("ResourceName");
}


static const Urho3D::StringHash E_RESOURCENOTFOUND(Urho3D::GetEventNameRegister().RegisterString("ResourceNotFound")); namespace ResourceNotFound
{
    static const Urho3D::StringHash P_RESOURCENAME("ResourceName");
}


static const Urho3D::StringHash E_UNKNOWNRESOURCETYPE(Urho3D::GetEventNameRegister().RegisterString("UnknownResourceType")); namespace UnknownResourceType
{
    static const Urho3D::StringHash P_RESOURCETYPE("ResourceType");
}


static const Urho3D::StringHash E_RESOURCEBACKGROUNDLOADED(Urho3D::GetEventNameRegister().RegisterString("ResourceBackgroundLoaded")); namespace ResourceBackgroundLoaded
{
    static const Urho3D::StringHash P_RESOURCENAME("ResourceName");
    static const Urho3D::StringHash P_SUCCESS("Success");
    static const Urho3D::StringHash P_RESOURCE("Resource");
}


static const Urho3D::StringHash E_CHANGELANGUAGE(Urho3D::GetEventNameRegister().RegisterString("ChangeLanguage")); namespace ChangeLanguage
{
}

}


























namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {



      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };






  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };

}


namespace std __attribute__ ((__visibility__ ("default")))
{
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
   : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
   : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   try
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
       throw;
     }
 }

      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p) noexcept
      {
 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();
      }


      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:

      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }


   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
     _M_header(), _M_node_count(0)
   { _M_initialize(); }


   void
   _M_reset()
   {
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
     this->_M_node_count = 0;
   }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() noexcept
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const noexcept
      { return reinterpret_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return *__x->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);


      template<typename _Arg, typename _NodeGen>
        iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
        iterator
        _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
        iterator
        _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen&);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __p, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare,
         _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Compare(), _Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }

      _Rb_tree(_Rb_tree&& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   _M_move_data(__x, std::true_type());
      }

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void

      swap(_Rb_tree& __t) noexcept(_Alloc_traits::_S_nothrow_swap());






      template<typename _Arg>
        pair<iterator, bool>
        _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
        iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() noexcept
      {
        _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      template<typename _Cmp, typename _Kt, typename = __void_t<>>
 struct __is_transparent { };

      template<typename _Cmp, typename _Kt>
 struct
 __is_transparent<_Cmp, _Kt, __void_t<typename _Cmp::is_transparent>>
 { typedef void type; };

      static auto _S_iter(_Link_type __x) { return iterator(__x); }

      static auto _S_iter(_Const_Link_type __x) { return const_iterator(__x); }

      template<typename _Cmp, typename _Link, typename _Kt>
 static auto
 _S_lower_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)
 {
   while (__x != 0)
     if (!__cmp(_S_key(__x), __k))
       __y = __x, __x = _S_left(__x);
     else
       __x = _S_right(__x);
   return _S_iter(__y);
 }

      template<typename _Cmp, typename _Link, typename _Kt>
 static auto
 _S_upper_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)
 {
   while (__x != 0)
     if (__cmp(__k, _S_key(__x)))
       __y = __x, __x = _S_left(__x);
     else
       __x = _S_right(__x);
   return _S_iter(__y);
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 iterator
 _M_find_tr(const _Kt& __k)
 {
   auto& __cmp = _M_impl._M_key_compare;
   auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
   return (__j == end() || __cmp(__k, _S_key(__j._M_node)))
     ? end() : __j;
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_find_tr(const _Kt& __k) const
 {
   auto& __cmp = _M_impl._M_key_compare;
   auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
   return (__j == end() || __cmp(__k, _S_key(__j._M_node)))
     ? end() : __j;
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 size_type
 _M_count_tr(const _Kt& __k) const
 {
   auto __p = _M_equal_range_tr(__k);
   return std::distance(__p.first, __p.second);
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 iterator
 _M_lower_bound_tr(const _Kt& __k)
 {
   auto& __cmp = _M_impl._M_key_compare;
   return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_lower_bound_tr(const _Kt& __k) const
 {
   auto& __cmp = _M_impl._M_key_compare;
   return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 iterator
 _M_upper_bound_tr(const _Kt& __k)
 {
   auto& __cmp = _M_impl._M_key_compare;
   return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 const_iterator
 _M_upper_bound_tr(const _Kt& __k) const
 {
   auto& __cmp = _M_impl._M_key_compare;
   return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 pair<iterator, iterator>
 _M_equal_range_tr(const _Kt& __k)
 {
   auto __low = _M_lower_bound_tr(__k);
   auto __high = __low;
   auto& __cmp = _M_impl._M_key_compare;
   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
     ++__high;
   return { __low, __high };
 }

      template<typename _Kt,
        typename _Req = typename __is_transparent<_Compare, _Kt>::type>
 pair<const_iterator, const_iterator>
 _M_equal_range_tr(const _Kt& __k) const
 {
   auto __low = _M_lower_bound_tr(__k);
   auto __high = __low;
   auto& __cmp = _M_impl._M_key_compare;
   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
     ++__high;
   return { __low, __high };
 }



      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&) noexcept(_Alloc_traits::_S_nothrow_move());

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree&, std::true_type);



      void
      _M_move_data(_Rb_tree&, std::false_type);

    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
    {
      using __eq = integral_constant<bool, _Alloc_traits::_S_always_equal()>;
      if (__x._M_root() != nullptr)
 _M_move_data(__x, __eq());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::true_type)
    {
      _M_root() = __x._M_root();
      _M_leftmost() = __x._M_leftmost();
      _M_rightmost() = __x._M_rightmost();
      _M_root()->_M_parent = _M_end();

      __x._M_root() = 0;
      __x._M_leftmost() = __x._M_end();
      __x._M_rightmost() = __x._M_end();

      this->_M_impl._M_node_count = __x._M_impl._M_node_count;
      __x._M_impl._M_node_count = 0;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
   _M_move_data(__x, std::true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
   _M_leftmost() = _S_minimum(_M_root());
   _M_rightmost() = _S_maximum(_M_root());
   _M_impl._M_node_count = __x._M_impl._M_node_count;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move())
    {
      _M_impl._M_key_compare = __x._M_impl._M_key_compare;
      if (_Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal()
   || _M_get_Node_allocator() == __x._M_get_Node_allocator())
 {
   clear();
   if (__x._M_root() != nullptr)
     _M_move_data(__x, std::true_type());
   std::__alloc_on_move(_M_get_Node_allocator(),
          __x._M_get_Node_allocator());
   return *this;
 }



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
   _M_leftmost() = _S_minimum(_M_root());
   _M_rightmost() = _S_maximum(_M_root());
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   __x.clear();
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end(), __roan);
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 try
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 catch(...)
   {
     _M_erase(__top);
     throw;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)

    noexcept(_Alloc_traits::_S_nothrow_swap())

    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();
       _M_impl._M_node_count = __t._M_impl._M_node_count;

       __t._M_impl._M_reset();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();
   __t._M_impl._M_node_count = _M_impl._M_node_count;

   _M_impl._M_reset();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(static_cast<_Link_type>(__res.first));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(static_cast<_Link_type>(__res.first));
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }


  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 _Alloc_node __an(*this);
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }


}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
      map(const map& __x)
      : _M_t(__x._M_t) { }
      map(map&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      map(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }



      map&
      operator=(map&&) = default;
      map&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        std::pair<iterator, bool>
        insert(_Pair&& __x)
        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_unique_(__position,
     std::forward<_Pair>(__x)); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      swap(map& __x)

      noexcept(_Alloc_traits::_S_nothrow_swap())

      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }



      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      multimap()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
      multimap(multimap&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }


      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }



      multimap&
      operator=(multimap&&) = default;
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(_Pair&& __x)
        { return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }


      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_equal_(__position,
           std::forward<_Pair>(__x)); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      swap(multimap& __x)

      noexcept(_Alloc_traits::_S_nothrow_swap())

      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
 { return _M_t._M_find_tr(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }



      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}


namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_unique(__first, __last); }
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
      set(const set& __x)
      : _M_t(__x._M_t) { }
      set(set&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
      set(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      explicit
      set(const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a)) { }


      set(const set& __x, const allocator_type& __a)
      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }


      set(set&& __x, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }


      set(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Compare(), _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }



      set&
      operator=(set&&) = default;
      set&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
      void
      swap(set& __x)

      noexcept(_Alloc_traits::_S_nothrow_swap())

      { _M_t.swap(__x._M_t); }
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }


      std::pair<iterator, bool>
      insert(value_type&& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(std::move(__x));
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_unique(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      clear() noexcept
      { _M_t.clear(); }
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const
 -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(iterator{_M_t._M_find_tr(__x)})
 { return iterator{_M_t._M_find_tr(__x)}; }

      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(const_iterator{_M_t._M_find_tr(__x)})
 { return const_iterator{_M_t._M_find_tr(__x)}; }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }

      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }

      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }

      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }



      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
      multiset(multiset&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }
      multiset(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      explicit
      multiset(const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a)) { }


      multiset(const multiset& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }


      multiset(multiset&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }


      multiset(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Compare(), _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }



      multiset&
      operator=(multiset&&) = default;
      multiset&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
      void
      swap(multiset& __x)

      noexcept(_Alloc_traits::_S_nothrow_swap())

      { _M_t.swap(__x._M_t); }
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      clear() noexcept
      { _M_t.clear(); }
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(iterator{_M_t._M_find_tr(__x)})
 { return iterator{_M_t._M_find_tr(__x)}; }

      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(const_iterator{_M_t._M_find_tr(__x)})
 { return const_iterator{_M_t._M_find_tr(__x)}; }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }

      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(_M_t._M_lower_bound_tr(__x))
 { return _M_t._M_lower_bound_tr(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }

      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(_M_t._M_upper_bound_tr(__x))
 { return _M_t._M_upper_bound_tr(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }

      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(_M_t._M_equal_range_tr(__x))
 { return _M_t._M_equal_range_tr(__x); }



      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


}



namespace Rocket {
namespace Core {

bool __attribute__((visibility("default"))) Assert(const char* message, const char* file, int line);
}
}


namespace Rocket {
namespace Core {

template <bool> struct STATIC_ASSERTION_FAILURE;
template <> struct STATIC_ASSERTION_FAILURE<true>{};

}
}

namespace Rocket {
namespace Core {


typedef unsigned char byte;
typedef unsigned short word;
typedef double Time;
typedef float TimeDelta;
typedef unsigned int Hash;
typedef void* ScriptObject;

}
}








namespace Rocket {
namespace Core {







template < typename ColourType, int AlphaDefault >
class Colour
{
public:

 inline Colour();





 inline Colour(ColourType red, ColourType green, ColourType blue, ColourType alpha = AlphaDefault);




 inline Colour operator+(const Colour& rhs) const;



 inline Colour operator-(const Colour& rhs) const;



 Colour operator*(const Colour& rhs) const;



 inline Colour operator*(float rhs) const;



 inline Colour operator/(float rhs) const;



 inline void operator+=(const Colour& rhs);


 inline void operator-=(const Colour& rhs);



 void operator*=(const Colour& rhs);


 inline void operator*=(float rhs);


 inline void operator/=(float rhs);




 inline bool operator==(const Colour& rhs) { return red == rhs.red && green == rhs.green && blue == rhs.blue && alpha == rhs.alpha; }



 inline bool operator!=(const Colour& rhs) { return red != rhs.red || green != rhs.green || blue != rhs.blue || alpha != rhs.alpha; }



 inline operator const ColourType*() const { return &red; }


 inline operator ColourType*() { return &red; }

 ColourType red, green, blue, alpha;
};

}
}

namespace Rocket {
namespace Core {


template < typename ColourType, int AlphaDefault >
Colour< ColourType, AlphaDefault >::Colour()
{
}


template < typename ColourType, int AlphaDefault >
Colour< ColourType, AlphaDefault >::Colour(ColourType _red, ColourType _green, ColourType _blue, ColourType _alpha)
{
 red = _red;
 green = _green;
 blue = _blue;
 alpha = _alpha;
}


template < typename ColourType, int AlphaDefault >
Colour< ColourType, AlphaDefault > Colour< ColourType, AlphaDefault >::operator+(const Colour< ColourType, AlphaDefault >& rhs) const
{
 return Colour< ColourType, AlphaDefault >(red + rhs.red, green + rhs.green, blue + rhs.blue, alpha + rhs.alpha);
}


template < typename ColourType, int AlphaDefault >
Colour< ColourType, AlphaDefault > Colour< ColourType, AlphaDefault >::operator-(const Colour< ColourType, AlphaDefault >& rhs) const
{
 return Colour< ColourType, AlphaDefault >(red - rhs.red, green - rhs.green, blue - rhs.blue, alpha - rhs.alpha);
}


template < typename ColourType, int AlphaDefault >
Colour< ColourType, AlphaDefault > Colour< ColourType, AlphaDefault >::operator*(float rhs) const
{
 return Colour((ColourType) (red * rhs), (ColourType) (green * rhs), (ColourType) (blue * rhs), (ColourType) (alpha * rhs));
}


template < typename ColourType, int AlphaDefault >
Colour< ColourType, AlphaDefault > Colour< ColourType, AlphaDefault >::operator/(float rhs) const
{
 return Colour((ColourType) (red / rhs), (ColourType) (green / rhs), (ColourType) (blue / rhs), (ColourType) (alpha / rhs));
}


template < typename ColourType, int AlphaDefault >
void Colour< ColourType, AlphaDefault >::operator+=(const Colour& rhs)
{
 red += rhs.red;
 green += rhs.green;
 blue += rhs.blue;
 alpha += rhs.alpha;
}


template < typename ColourType, int AlphaDefault >
void Colour< ColourType, AlphaDefault >::operator-=(const Colour& rhs)
{
 red -= rhs.red;
 green -= rhs.green;
 blue -= rhs.blue;
 alpha -= rhs.alpha;
}


template < typename ColourType, int AlphaDefault >
void Colour< ColourType, AlphaDefault >::operator*=(float rhs)
{
 red = (ColourType)(red * rhs);
 green = (ColourType)(green * rhs);
 blue = (ColourType)(blue * rhs);
 alpha = (ColourType)(alpha * rhs);
}


template < typename ColourType, int AlphaDefault >
void Colour< ColourType, AlphaDefault >::operator/=(float rhs)
{
 *this *= (1.0f / rhs);
}

template < >
Colour< float, 1 > __attribute__((visibility("default"))) Colour< float, 1 >::operator*(const Colour< float, 1 >& rhs) const;

template < >
Colour< byte, 255 > __attribute__((visibility("default"))) Colour< byte, 255 >::operator*(const Colour< byte, 255 >& rhs) const;

template < >
void __attribute__((visibility("default"))) Colour< float, 1 >::operator*=(const Colour& rhs);

template < >
void __attribute__((visibility("default"))) Colour< byte, 255 >::operator*=(const Colour& rhs);

}
}
namespace Rocket {
namespace Core {
namespace Math {


extern __attribute__((visibility("default"))) const float ROCKET_PI;

template < typename Type >
Type Max(Type a, Type b)
{
 return (a > b) ? a : b;
}

template< typename Type >
Type Min(Type a, Type b)
{
 return (a < b) ? a : b;
}

template < typename Type >
Type ClampLower(Type value, Type min)
{
 return (value < min) ? min : value;
}

template < typename Type >
Type ClampUpper(Type value, Type max)
{
 return (value > max) ? max: value;
}

template< typename Type >
Type Clamp(Type value, Type min, Type max)
{
 return (value < min) ? min : (value > max) ? max : value;
}




__attribute__((visibility("default"))) bool IsZero(float value);





__attribute__((visibility("default"))) bool AreEqual(float value_0, float value_1);




__attribute__((visibility("default"))) float AbsoluteValue(float value);




__attribute__((visibility("default"))) float Cos(float angle);



__attribute__((visibility("default"))) float ACos(float value);



__attribute__((visibility("default"))) float Sin(float angle);



__attribute__((visibility("default"))) float ASin(float angle);



__attribute__((visibility("default"))) float Tan(float angle);




__attribute__((visibility("default"))) float ATan2(float y, float x);




__attribute__((visibility("default"))) float RadiansToDegrees(float angle);



__attribute__((visibility("default"))) float DegreesToRadians(float angle);



__attribute__((visibility("default"))) float NormaliseAngle(float angle);




__attribute__((visibility("default"))) float SquareRoot(float value);




__attribute__((visibility("default"))) int Round(float value);



__attribute__((visibility("default"))) int RoundUp(float value);



__attribute__((visibility("default"))) int RoundDown(float value);




__attribute__((visibility("default"))) int RealToInteger(float value);




__attribute__((visibility("default"))) int ToPowerOfTwo(int value);




__attribute__((visibility("default"))) int HexToDecimal(char hex_digit);




__attribute__((visibility("default"))) float RandomReal(float max_value);



__attribute__((visibility("default"))) int RandomInteger(int max_value);


__attribute__((visibility("default"))) bool RandomBool();

}
}
}

namespace Rocket {
namespace Core {






template < typename Type >
class Vector2
{
 public:

  inline Vector2();



  inline Vector2(Type x, Type y);



  inline float Magnitude() const;


  inline Type SquaredMagnitude() const;


  inline Vector2 Normalise() const;




  inline Type DotProduct(const Vector2& rhs) const;




  inline Vector2 Rotate(float theta) const;



  inline Vector2 operator-() const;




  inline Vector2 operator+(const Vector2& rhs) const;



  inline Vector2 operator-(const Vector2& rhs) const;



  inline Vector2 operator*(Type rhs) const;



  inline Vector2 operator/(Type rhs) const;




  inline Vector2& operator+=(const Vector2& rhs);



  inline Vector2& operator-=(const Vector2& rhs);



  inline Vector2& operator*=(const Type& rhs);



  inline Vector2& operator/=(const Type& rhs);




  inline bool operator==(const Vector2& rhs) const;



  inline bool operator!=(const Vector2& rhs) const;



  inline operator const Type*() const;


  inline operator Type*();


  Type x;
  Type y;
};


template < typename Type >
Vector2< Type >::Vector2()
{
}


template < typename Type >
Vector2< Type >::Vector2(Type _x, Type _y)
{
 x = _x;
 y = _y;
}


template < typename Type >
float Vector2< Type >::Magnitude() const
{
 float squared_magnitude = (float) SquaredMagnitude();
 if (Math::IsZero(squared_magnitude))
  return 0;

 return Math::SquareRoot(squared_magnitude);
}


template < typename Type >
Type Vector2< Type >::SquaredMagnitude() const
{
 return x * x +
     y * y;
}


template < typename Type >
Vector2< Type > Vector2< Type >::Normalise() const
{
 float magnitude = Magnitude();
 if (Math::IsZero(magnitude))
  return *this;

 return *this / magnitude;
}


template < typename Type >
Type Vector2< Type >::DotProduct(const Vector2< Type >& rhs) const
{
 return x * rhs.x +
     y * rhs.y;
}


template < typename Type >
Vector2< Type > Vector2< Type >::Rotate(float theta) const
{
 float cos_theta = Math::Cos(theta);
 float sin_theta = Math::Sin(theta);

 return Vector2< Type >(((Type)(cos_theta * x - sin_theta * y)),
       ((Type)(sin_theta * x + cos_theta * y)));
}


template < typename Type >
Vector2< Type > Vector2< Type >::operator-() const
{
 return Vector2(-x, -y);
}


template < typename Type >
Vector2< Type > Vector2< Type >::operator+(const Vector2< Type >& rhs) const
{
 return Vector2< Type >(x + rhs.x, y + rhs.y);
}


template < typename Type >
Vector2< Type > Vector2< Type >::operator-(const Vector2< Type >& rhs) const
{
 return Vector2(x - rhs.x, y - rhs.y);
}


template < typename Type >
Vector2< Type > Vector2< Type >::operator*(Type rhs) const
{
 return Vector2(x * rhs, y * rhs);
}


template < typename Type >
Vector2< Type > Vector2< Type >::operator/(Type rhs) const
{
 return Vector2(x / rhs, y / rhs);
}


template < typename Type >
Vector2< Type >& Vector2< Type >::operator+=(const Vector2& rhs)
{
 x += rhs.x;
 y += rhs.y;

 return *this;
}


template < typename Type >
Vector2< Type >& Vector2< Type >::operator-=(const Vector2& rhs)
{
 x -= rhs.x;
 y -= rhs.y;

 return *this;
}


template < typename Type >
Vector2< Type >& Vector2< Type >::operator*=(const Type& rhs)
{
 x *= rhs;
 y *= rhs;

 return *this;
}


template < typename Type >
Vector2< Type >& Vector2< Type >::operator/=(const Type& rhs)
{
 x /= rhs;
 y /= rhs;

 return *this;
}


template < typename Type >
bool Vector2< Type >::operator==(const Vector2& rhs) const
{
 return (x == rhs.x && y == rhs.y);
}


template < typename Type >
bool Vector2< Type >::operator!=(const Vector2& rhs) const
{
 return (x != rhs.x || y != rhs.y);
}


template < typename Type >
Vector2< Type >::operator const Type*() const
{
 return &x;
}


template < typename Type >
Vector2< Type >::operator Type*()
{
 return &x;
}

}
}
namespace Rocket {
namespace Core {





template< typename T >
class StringBase
{
public:
 typedef size_t size_type;
 static const size_type npos = (size_type)-1;

 StringBase();
 StringBase(const StringBase& copy);
 StringBase(const T* string);
 StringBase(const T* string_start, const T* string_end);
 StringBase(size_type length, const T character);
 StringBase(size_type max_length, const T* fmt, ...);

 ~StringBase();


 inline bool Empty() const;

 void Clear();


 inline size_type Length() const;

 inline unsigned int Hash() const;

 inline const T* CString() const;


 inline void Reserve(size_type size);




 size_type Find(const T* find, size_type offset = 0) const;



 size_type Find(const StringBase<T>& find, size_type offset = 0) const;



 size_type RFind(const T* find, size_type offset = npos) const;



 size_type RFind(const StringBase<T>& find, size_type offset = npos) const;




 StringBase<T> Replace(const T* find, const T* replace) const;



 StringBase<T> Replace(const StringBase<T>& find, const StringBase<T>& replace) const;




 inline StringBase<T> Substring(size_type start, size_type length = StringBase<T>::npos) const;




 inline StringBase<T>& Append(const T* append, size_type count = StringBase<T>::npos);



 inline StringBase<T>& Append(const StringBase<T>& append, size_type count = StringBase<T>::npos);


 inline StringBase<T>& Append(const T& append);




 inline StringBase<T>& Assign(const T* assign, size_type count = StringBase<T>::npos);



 inline StringBase<T>& Assign(const T* assign, const T* end);



 inline StringBase<T>& Assign(const StringBase<T>& assign, size_type count = StringBase<T>::npos);





 inline void Insert(size_type index, const T* insert, size_type count = StringBase<T>::npos);




 inline void Insert(size_type index, const StringBase<T>& insert, size_type count = StringBase<T>::npos);



 inline void Insert(size_type index, const T& insert);




 inline void Erase(size_type index, size_type length = StringBase<T>::npos);






 int FormatString(size_type max_length, const T* format, ...);



 void Resize(size_type size);



 StringBase<T> ToLower() const;


 StringBase<T> ToUpper() const;

 inline bool operator==(const T* compare) const;
 inline bool operator==(const StringBase<T>& compare) const;

 inline bool operator!=(const T* compare) const;
 inline bool operator!=(const StringBase<T>& compare) const;

 inline bool operator<(const T* compare) const;
 inline bool operator<(const StringBase<T>& compare) const;

 inline StringBase<T>& operator=(const T* assign);
 inline StringBase<T>& operator=(const StringBase<T>& assign);

 inline StringBase<T> operator+(const T* append) const;
 inline StringBase<T> operator+(const StringBase<T>& append) const;

 inline StringBase<T>& operator+=(const T* append);
 inline StringBase<T>& operator+=(const StringBase<T>& append);
 inline StringBase<T>& operator+=(const T& append);

 inline const T& operator[](size_type index) const;
 inline T& operator[](size_type index);

protected:

 T* value;
 size_type buffer_size;
 size_type length;
 mutable unsigned int hash;
 static const size_type LOCAL_BUFFER_SIZE = 8;
 char local_buffer[LOCAL_BUFFER_SIZE];

 size_type GetLength(const T* string) const;


 inline void Copy(T* target, const T* src, size_type length, bool terminate = false);





 inline size_type _Find(const T* find, size_type find_length, size_type offset = 0) const;
 inline size_type _RFind(const T* find, size_type find_length, size_type offset = 0) const;
 inline StringBase<T> _Replace(const T* find, size_type find_length, const T* replace, size_type replace_length) const;
 inline StringBase<T>& _Append(const T* append, size_type append_length, size_type count = StringBase<T>::npos);
 inline StringBase<T>& _Assign(const T* assign, size_type assign_length, size_type count = StringBase<T>::npos);
 inline void _Insert(size_type index, const T* insert, size_type insert_length, size_type count = StringBase<T>::npos);
};


template< typename T >
StringBase< T >::StringBase() : value((T*)local_buffer), buffer_size(LOCAL_BUFFER_SIZE), length(0), hash(0)
{
 value[0] = 0;
}

template< typename T >
StringBase< T >::StringBase(const StringBase< T >& copy) : value((T*)local_buffer), buffer_size(LOCAL_BUFFER_SIZE), length(0), hash(0)
{
 value[0] = 0;
 *this = copy;
}

template< typename T >
StringBase< T >::StringBase(const T* string) : value((T*)local_buffer), buffer_size(LOCAL_BUFFER_SIZE), length(0), hash(0)
{
 value[0] = 0;
 *this = string;
}

template< typename T >
StringBase< T >::StringBase(const T* string_start, const T* string_end) : value((T*)local_buffer), buffer_size(LOCAL_BUFFER_SIZE), length(0), hash(0)
{
 value[0] = 0;
 length = (string_end - string_start);

 if (length > 0)
 {
  Reserve(length);
  Copy(value, string_start, length, true);
 }
}

template< typename T >
StringBase< T >::StringBase(size_type count, const T character) : value((T*)local_buffer), buffer_size(LOCAL_BUFFER_SIZE), length(0), hash(0)
{
 value[0] = 0;
 length = count;

 if (length > 0)
 {
  Reserve(length);
  for (size_type i = 0; i < length; i++)
   value[i] = character;
  value[length] = '\0';
 }
}

template< typename T >
StringBase< T >::StringBase(size_type UNUSED_max_length __attribute__((unused)), const T* UNUSED_fmt __attribute__((unused)), ...) : value((T*)local_buffer), buffer_size(LOCAL_BUFFER_SIZE), length(0), hash(0)
{
                          ;
                   ;

 value[0] = 0;

 if (!Rocket::Core::Assert("Not implemented.", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 84)) { {__builtin_trap();}; };
}

template< typename T >
StringBase< T >::~StringBase()
{
 if (value != (T*)local_buffer)
  free(value);
}

template< typename T >
bool StringBase< T >::Empty() const
{
 return length == 0;
}

template< typename T >
void StringBase< T >::Clear()
{
 if (value != (T*)local_buffer)
  free(value);

 length = 0;
 hash = 0;
 value = (T*)local_buffer;
 buffer_size = LOCAL_BUFFER_SIZE;
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::Length() const
{
 return length;
}

template< typename T >
unsigned int StringBase< T >::Hash() const
{
 if (hash == 0 && length > 0)
 {

  unsigned char* bp = (unsigned char *)value;
  unsigned char* be = (unsigned char *)value + (length * sizeof(T));


  while (bp < be)
  {

   hash ^= *bp++;






    hash += (hash<<1) + (hash<<4) + (hash<<7) + (hash<<8) + (hash<<24);

  }
 }
 return hash;
}

template< typename T >
const T* StringBase< T >::CString() const
{
 return value;
}

template< typename T >
void StringBase< T >::Reserve(size_type size)
{
 size_type new_size = (size + 1) * sizeof(T);

 if (buffer_size >= new_size)
  return;


 const int BLOCK_SIZE = 16;
 new_size = (new_size+BLOCK_SIZE-1)&(~(BLOCK_SIZE-1));

 if (value == (T*)local_buffer)
 {
  T* new_value = (T*)realloc(__null, new_size);
  if (!(new_value)) { if (!Rocket::Core::Assert("Could not reserve memory for String, realloc failed.", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 166 )) { {__builtin_trap();}; } };
  if(new_value != __null)
  {
   buffer_size = new_size;
   Copy(new_value, (T*)local_buffer, LOCAL_BUFFER_SIZE / sizeof(T));
   value = new_value;
  }
 }
 else
 {
  T* new_value = (T*)realloc(value, new_size);
  if (!(new_value)) { if (!Rocket::Core::Assert("Could not reserve memory for String, realloc failed.", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 177 )) { {__builtin_trap();}; } };
  if(new_value != __null)
  {
   buffer_size = new_size;
   value = new_value;
  }
 }
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::Find(const T* find, size_type offset) const
{
 return _Find(find, GetLength(find), offset);
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::Find(const StringBase< T >& find, size_type offset) const
{
 return _Find(find.CString(), find.Length(), offset);
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::RFind(const T* find, size_type offset) const
{
 return _RFind(find, GetLength(find), offset);
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::RFind(const StringBase< T >& find, size_type offset) const
{
 return _RFind(find.CString(), find.Length(), offset);
}

template< typename T >
StringBase< T > StringBase< T >::Replace(const T* find, const T* replace) const
{
 return _Replace(find, GetLength(find), replace, GetLength(replace));
}

template< typename T >
StringBase< T > StringBase< T >::Replace(const StringBase< T >& find, const StringBase< T >& replace) const
{
 return _Replace(find.CString(), find.Length(), replace.CString(), replace.Length());
}

template< typename T >
StringBase< T > StringBase< T >::Substring(size_type start, size_type count) const
{

 if (count > length - start)
  count = length - start;

 if (start > length)
  count = 0;

 return StringBase< T >(&value[start], &value[start + count]);
}

template< typename T >
StringBase< T >& StringBase< T >::Append(const T* append, size_type count)
{
 return _Append(append, GetLength(append), count);
}

template< typename T >
StringBase< T >& StringBase< T >::Append(const StringBase< T >& append, size_type count)
{
 return _Append(append.CString(), append.Length(), count);
}

template< typename T >
StringBase< T >& StringBase< T >::Append(const T& append)
{
 T buffer[2] = { append, 0 };
 return (*this += buffer);
}

template< typename T >
StringBase< T >& StringBase< T >::Assign(const T* assign, size_type count)
{
 size_type assign_length = GetLength(assign);
 return _Assign(assign, count > assign_length ? assign_length : count);
}

template< typename T >
StringBase< T >& StringBase< T >::Assign(const T* assign, const T* end)
{
 return _Assign(assign, end - assign);
}

template< typename T >
StringBase< T >& StringBase< T >::Assign(const StringBase< T >& assign, size_type count)
{
 return _Assign(assign.CString(), assign.length, count);
}


template< typename T >
void StringBase< T >::Insert(size_type index, const T* insert, size_type count)
{
 return _Insert(index, insert, GetLength(insert), count);
}


template< typename T >
void StringBase< T >::Insert(size_type index, const StringBase< T >& insert, size_type count)
{
 return _Insert(index, insert.value, insert.length, count);
}


template< typename T >
void StringBase< T >::Insert(size_type index, const T& insert)
{
 return _Insert(index, &insert, 1, 1);
}


template< typename T >
void StringBase< T >::Erase(size_type index, size_type count)
{
 if (index >= length)
  return;

 if (count == npos)
 {
  Resize(index);
 }
 else
 {
  size_type erase_amount = count < length - index ? count : length - index;

  Copy(&value[index], &value[index + erase_amount], length - index - erase_amount, true);

  length -= erase_amount;

  if (length == 0)
   Clear();
 }
}

template< typename T >
int StringBase< T >::FormatString(size_type UNUSED_max_length __attribute__((unused)), const T* UNUSED_fmt __attribute__((unused)), ...)
{
                          ;
                   ;

 if (!Rocket::Core::Assert("Not implemented.", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 324)) { {__builtin_trap();}; };
 return -1;
}

template< typename T >
void StringBase< T >::Resize(size_type new_length)
{
 Reserve(new_length);
 length = new_length;
 value[length] = '\0';

 if (length == 0)
  Clear();
}


template< typename T >
StringBase< T > StringBase< T >::ToLower() const
{

 size_t copy_index = npos;
 for (size_t i = 0; i < length; i++)
 {
  if (value[i] >= 'A' && value[i] <= 'Z')
  {
   copy_index = i;
   break;
  }
 }


 if (copy_index == npos)
  return StringBase< T >(*this);

 StringBase< T > lowercase(CString(), CString() + copy_index);

 for (size_t i = copy_index; i < length; i++)
 {
  if (value[i] >= 'A' && value[i] <= 'Z')
   lowercase.Append((T)(value[i] + ('a' - 'A')));
  else
   lowercase.Append(value[i]);
 }

 return lowercase;
}


template< typename T >
StringBase< T > StringBase< T >::ToUpper() const
{

 size_t copy_index = npos;
 for (size_t i = 0; i < length; i++)
 {
  if (value[i] >= 'a' && value[i] <= 'z')
  {
   copy_index = i;
   break;
  }
 }


 if (copy_index == npos)
  return StringBase< T >(*this);

 StringBase< T > uppercase(CString(), CString() + copy_index);

 for (size_t i = copy_index; i < length; i++)
 {
  if (value[i] >= 'a' && value[i] <= 'z')
   uppercase.Append((T)(value[i] - ('a' - 'A')));
  else
   uppercase.Append(value[i]);
 }

 return uppercase;
}

template< typename T >
bool StringBase< T >::operator==(const T* compare) const
{
 size_type index = 0;

 while (index < length && compare[index] == value[index])
  index++;

 return index == length && compare[index] == '\0';
}

template< typename T >
bool StringBase< T >::operator==(const StringBase< T >& compare) const
{
 if (length != compare.length)
  return false;

 if (Hash() != compare.Hash())
  return false;

 return (*this) == compare.value;
}

template< typename T >
bool StringBase< T >::operator!=(const T* compare) const
{
 return !(*this == compare);
}

template< typename T >
bool StringBase< T >::operator!=(const StringBase< T >& compare) const
{
 return !(*this == compare);
}

template< typename T >
bool StringBase< T >::operator<(const T* compare) const
{
 size_type index = 0;
 while (index < length && compare[index] == value[index])
  index++;


 if (index < length)
 {



  if (compare[index] == 0)
   return false;


  return value[index] < compare[index];
 }
 else
 {



  if (compare[index] != 0)
   return true;
 }

 return false;
}

template< typename T >
bool StringBase< T >::operator<(const StringBase< T >& compare) const
{
 return *this < compare.CString();
}

template< typename T >
StringBase< T >& StringBase< T >::operator=(const T* assign)
{
 return Assign(assign);
}

template< typename T >
StringBase< T >& StringBase< T >::operator=(const StringBase< T >& assign)
{
 StringBase< T >&out = Assign(assign);
 out.hash = assign.hash;
 return out;
}

template< typename T >
StringBase< T > StringBase< T >::operator+(const T* add) const
{
 StringBase< T > combined(*this);
 combined.Append(add);

 return combined;
}

template< typename T >
StringBase< T > StringBase< T >::operator+(const StringBase< T >& add) const
{
 StringBase< T > combined(*this);
 combined.Append(add);

 return combined;
}

template< typename T >
StringBase< T >& StringBase< T >::operator+=(const T* add)
{
 return Append(add);
}

template< typename T >
StringBase< T >& StringBase< T >::operator+=(const StringBase< T >& add)
{
 return _Append(add.CString(), add.length);
}

template< typename T >
StringBase< T >& StringBase< T >::operator+=(const T& add)
{
 return Append(add);
}

template< typename T >
const T& StringBase< T >::operator[](size_type index) const
{
 if (!(index < length)) { if (!Rocket::Core::Assert("ROCKET_ASSERT(""index < length"")", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 528 )) { {__builtin_trap();}; } };
 return value[index];
}

template< typename T >
T& StringBase< T >::operator[](size_type index)
{
 if (!(index < length)) { if (!Rocket::Core::Assert("ROCKET_ASSERT(""index < length"")", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 535 )) { {__builtin_trap();}; } };
 return value[index];
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::GetLength(const T* string) const
{
 const T* ptr = string;

 while (*ptr)
 {
  ptr++;
 }

 return ptr - string;
}

template< typename T >
void StringBase< T >::Copy(T* target, const T* src, size_type length, bool terminate)
{

 for (size_type i = 0; i < length; i++)
 {
  *target++ = *src++;
 }

 if (terminate)
 {
  *target++ = 0;
 }
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::_Find(const T* find, size_type find_length, size_type offset) const
{
 size_type needle_index = 0;
 size_type haystack_index = offset;


 if (find_length > length)
  return npos;


 while (value[haystack_index])
 {


  if (value[haystack_index + needle_index] == find[needle_index])
  {
   needle_index++;


   if (needle_index == find_length)
    return haystack_index;
  }
  else
  {

   haystack_index++;
   needle_index = 0;
  }
 }

 return npos;
}

template< typename T >
typename StringBase< T >::size_type StringBase< T >::_RFind(const T* find, size_type find_length, size_type offset) const
{
 if (!(find_length > 0)) { if (!Rocket::Core::Assert("ROCKET_ASSERT(""find_length > 0"")", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/StringBase.inl", 604 )) { {__builtin_trap();}; } };

 size_type needle_index = 0;
 size_type haystack_index = (offset < length ? offset : length) - find_length;


 if (find_length > length)
  return npos;


 for (;;)
 {


  if (value[haystack_index + needle_index] == find[needle_index])
  {
   needle_index++;


   if (find[needle_index] == 0)
    return haystack_index;
  }
  else
  {
   if (haystack_index == 0)
    return npos;


   haystack_index--;
   needle_index = 0;
  }
 }
}

template< typename T >
StringBase< T > StringBase< T >::_Replace(const T* find, size_type find_length, const T* replace, size_type replace_length) const
{
 StringBase< T > result;

 size_type offset = 0;

 while (offset < Length())
 {

  size_type pos = _Find(find, find_length, offset);


  if (pos == npos)
   return result + (Substring(offset).CString());


  result += Substring(offset, pos - offset);
  result._Append(replace, replace_length);


  offset = pos + find_length;
 }

 hash = 0;

 return result;
}

template< typename T >
StringBase< T >& StringBase< T >::_Append(const T* append, size_type append_length, size_type count)
{
 size_type add_length = count < append_length ? count : append_length;

 if (add_length == 0)
  return *this;

 Reserve(length + add_length);
 Copy(&value[length], append, add_length, true);
 length += add_length;

 hash = 0;

 return *this;
}

template< typename T >
StringBase< T >& StringBase< T >::_Assign(const T* assign, size_type assign_length, size_type count)
{
 size_type new_length = count < assign_length ? count : assign_length;

 if (new_length == 0)
 {
  Clear();
 }
 else
 {
  Reserve(new_length);
  Copy(value, assign, new_length, true);
 }

 length = new_length;

 hash = 0;

 return *this;
}

template< typename T >
void StringBase< T >::_Insert(size_type index, const T* insert, size_type insert_length, size_type count)
{
 if (index >= length)
 {
  Append(insert, count);
  return;
 }

 size_type add_length = count < insert_length ? count : insert_length;

 Reserve(length + add_length);

 for (size_type i = length + 1; i > index; i--)
  value[i + add_length - 1] = value[i - 1];

 Copy(&value[index], insert, add_length);
 length += add_length;

 hash = 0;
}

}
}




namespace Rocket {
namespace Core {

typedef StringBase< char > String;
typedef std::vector< String > StringList;


template<>
__attribute__((visibility("default"))) StringBase<char>::StringBase(StringBase<char>::size_type max_size, const char* fmt, ...);
template<>
__attribute__((visibility("default"))) int StringBase<char>::FormatString(StringBase<char>::size_type max_size, const char* fmt, ...);


__attribute__((visibility("default"))) String operator+(const char* cstring, const String& string);




template<>
__attribute__((visibility("default"))) inline bool StringBase< char >::operator<(const char * compare) const
{
 return strcmp( value, compare ) < 0;
}


template<>
__attribute__((visibility("default"))) inline bool StringBase< char >::operator==(const char * compare) const
{
 return strcmp( value, compare ) == 0;
}


template<>
__attribute__((visibility("default"))) inline bool StringBase< char >::operator!=(const char * compare) const
{
 return strcmp( value, compare ) != 0;
}







}
}

namespace Rocket {
namespace Core {


typedef Colour< float, 1 > Colourf;
typedef Colour< byte, 255 > Colourb;
typedef Vector2< float > Vector2f;
typedef Vector2< int > Vector2i;


class Element;
class Dictionary;


typedef uintptr_t FileHandle;
typedef uintptr_t TextureHandle;
typedef uintptr_t CompiledGeometryHandle;
typedef uintptr_t DecoratorDataHandle;


typedef std::vector< Element* > ElementList;
typedef std::set< String > PseudoClassList;
typedef std::set< String > PropertyNameList;
typedef std::set< String > AttributeNameList;
typedef Dictionary ElementAttributes;

}
}
namespace Rocket {
namespace Core {






class __attribute__((visibility("default"))) ReferenceCountable
{
public:


 ReferenceCountable(int initial_count = 1);

 virtual ~ReferenceCountable();


 virtual int GetReferenceCount();

 virtual void AddReference();

 virtual void RemoveReference();


 ReferenceCountable& operator=(const ReferenceCountable& copy);


 static void DumpLeakReport();

protected:

 virtual void OnReferenceActivate();

 virtual void OnReferenceDeactivate();

private:

 int reference_count;
};

}
}

namespace Rocket {
namespace Core {
class __attribute__((visibility("default"))) FileInterface : public ReferenceCountable
{
public:
 FileInterface();
 virtual ~FileInterface();




 virtual FileHandle Open(const String& path) = 0;


 virtual void Close(FileHandle file) = 0;






 virtual size_t Read(void* buffer, size_t size, FileHandle file) = 0;





 virtual bool Seek(FileHandle file, long offset, int origin) = 0;



 virtual size_t Tell(FileHandle file) = 0;





 virtual size_t Length(FileHandle file);


 virtual void Release();

protected:
 virtual void OnReferenceDeactivate();
};

}
}



namespace Urho3D
{
 class File;
 class Context;

class RocketFileInterface: public Urho3D::Object, public ::Rocket::Core::FileInterface
{
public:
 public: using ClassName = RocketFileInterface; using BaseClassName = Urho3D::Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RocketFileInterface", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

 RocketFileInterface(Urho3D::Context* context);


 virtual Rocket::Core::FileHandle Open(const Rocket::Core::String& path);


 virtual void Close(Rocket::Core::FileHandle file);


 virtual size_t Read(void* buffer, size_t size, Rocket::Core::FileHandle file);


 virtual bool Seek(Rocket::Core::FileHandle file, long offset, int origin);


 virtual size_t Tell(Rocket::Core::FileHandle file);
private:

 Urho3D::Vector<Urho3D::File* > files_;
};

}




namespace Rocket {
namespace Core {

class TextureResource;
class RenderInterface;







struct __attribute__((visibility("default"))) Texture
{
public:

 Texture();

 Texture(const Texture&);
 ~Texture();





 bool Load(const String& source, const String& source_path = "");



 String GetSource() const;



 TextureHandle GetHandle(RenderInterface* render_interface) const;



 Vector2i GetDimensions(RenderInterface* render_interface) const;


 const Texture& operator=(const Texture&);

private:
 TextureResource* resource;
};

}
}
namespace Rocket {
namespace Core {







struct __attribute__((visibility("default"))) Vertex
{

 Vector2f position;

 Colourb colour;

 Vector2f tex_coord;
};

}
}

namespace Rocket {
namespace Core {

class Context;
class __attribute__((visibility("default"))) RenderInterface : public ReferenceCountable
{
public:
 RenderInterface();
 virtual ~RenderInterface();
 virtual void RenderGeometry(Vertex* vertices, int num_vertices, int* indices, int num_indices, TextureHandle texture, const Vector2f& translation) = 0;
 virtual CompiledGeometryHandle CompileGeometry(Vertex* vertices, int num_vertices, int* indices, int num_indices, TextureHandle texture);



 virtual void RenderCompiledGeometry(CompiledGeometryHandle geometry, const Vector2f& translation);


 virtual void ReleaseCompiledGeometry(CompiledGeometryHandle geometry);



 virtual void EnableScissorRegion(bool enable) = 0;





 virtual void SetScissorRegion(int x, int y, int width, int height) = 0;






 virtual bool LoadTexture(TextureHandle& texture_handle, Vector2i& texture_dimensions, const String& source);





 virtual bool GenerateTexture(TextureHandle& texture_handle, const byte* source, const Vector2i& source_dimensions);


 virtual void ReleaseTexture(TextureHandle texture);



 virtual float GetHorizontalTexelOffset();


 virtual float GetVerticalTexelOffset();



 virtual float GetPixelsPerInch();


 virtual void Release();



 Context* GetContext() const;

protected:
 virtual void OnReferenceDeactivate();

private:
 Context* context;

 friend class Context;
};

}
}








namespace Urho3D
{




   struct Urho3DCompiledGeometry
   {
    WeakPtr<Urho3D::IndexBuffer> iBuff;
    SharedPtr<Urho3D::VertexBuffer> vBuff;
    SharedPtr<Texture2D> texture;
   };

   class RenderInterface : public Urho3D::Object, public ::Rocket::Core::RenderInterface
   {
    public: using ClassName = RenderInterface; using BaseClassName = Urho3D::Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RenderInterface", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };
   public:
    RenderInterface(Urho3D::Context* context);
    ~RenderInterface();

    static void RegisterObject(Urho3D::Context* context);

    void AddReference();
    void RemoveReference();


    virtual void RenderGeometry(::Rocket::Core::Vertex* vertices, int num_vertices, int* indices, int num_indices, ::Rocket::Core::TextureHandle texture, const ::Rocket::Core::Vector2f& translation);


    virtual ::Rocket::Core::CompiledGeometryHandle CompileGeometry(::Rocket::Core::Vertex* vertices, int num_vertices, int* indices, int num_indices, ::Rocket::Core::TextureHandle texture);


    virtual void RenderCompiledGeometry(::Rocket::Core::CompiledGeometryHandle geometry, const ::Rocket::Core::Vector2f& translation);

    virtual void ReleaseCompiledGeometry(::Rocket::Core::CompiledGeometryHandle geometry);


    virtual void EnableScissorRegion(bool enable);

    virtual void SetScissorRegion(int x, int y, int width, int height);


    virtual bool LoadTexture(::Rocket::Core::TextureHandle& texture_handle, ::Rocket::Core::Vector2i& texture_dimensions, const ::Rocket::Core::String& source);

    virtual bool GenerateTexture(::Rocket::Core::TextureHandle& texture_handle, const ::Rocket::Core::byte* source, const ::Rocket::Core::Vector2i& source_dimensions);

    virtual void ReleaseTexture(::Rocket::Core::TextureHandle texture_handle);



    virtual float GetHorizontalTexelOffset();


    virtual float GetVerticalTexelOffset();

   private:
    std::vector<Texture2D*> textures;
    IntRect scissors;
    Graphics* graphics;

    SharedPtr<ShaderVariation> noTextureVS;
    SharedPtr<ShaderVariation> noTexturePS;
    SharedPtr<ShaderVariation> diffTextureVS;
    SharedPtr<ShaderVariation> diffTexturePS;
   };


}



namespace Rocket {
namespace Core {







class __attribute__((visibility("default"))) Log
{
public:
 enum Type
 {
  LT_ALWAYS = 0,
  LT_ERROR,
  LT_ASSERT,
  LT_WARNING,
  LT_INFO,
  LT_DEBUG,
  LT_MAX
 };

public:


 static bool Initialise();

 static void Shutdown();




 static void Message(Type type, const char* format, ...);





 static void ParseError(const String& filename, int line_number, const char* format, ...);
};

}
}




namespace Rocket {
namespace Core {
class __attribute__((visibility("default"))) SystemInterface : public ReferenceCountable
{
public:
 SystemInterface();
 virtual ~SystemInterface();



 virtual float GetElapsedTime() = 0;





 virtual int TranslateString(String& translated, const String& input);





 virtual void JoinPath(String& translated_path, const String& document_path, const String& path);





 virtual bool LogMessage(Log::Type type, const String& message);


 virtual void ActivateKeyboard();


 virtual void DeactivateKeyboard();


 virtual void Release();

protected:
 virtual void OnReferenceDeactivate();
};

}
}







namespace Urho3D
{
 class SystemInterface : public Urho3D::Object, public ::Rocket::Core::SystemInterface
 {
  public: using ClassName = SystemInterface; using BaseClassName = Urho3D::Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SystemInterface", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

 public:
  SystemInterface(Urho3D::Context* context) :
   Object(context) {};

  static void RegisterObject(Urho3D::Context* context);



  virtual float GetElapsedTime();





  virtual bool LogMessage(::Rocket::Core::Log::Type type, const String& message);


  void AddReference();
  void RemoveReference();
 };
}





namespace Rocket {
namespace Core {






class __attribute__((visibility("default"))) ScriptInterface : public ReferenceCountable
{
 public:
  virtual ~ScriptInterface()
  {
  }

  virtual ScriptObject GetScriptObject() const
  {
   return __null;
  }
};

}
}

namespace Rocket {
namespace Core {
class __attribute__((visibility("default"))) Box
{
public:
 enum Area
 {
  MARGIN = 0,
  BORDER = 1,
  PADDING = 2,
  CONTENT = 3,
  NUM_AREAS = 3,
 };

 enum Edge
 {
  TOP = 0,
  RIGHT = 1,
  BOTTOM = 2,
  LEFT = 3,
  NUM_EDGES = 4
 };


 Box();

 Box(const Vector2f& content);
 ~Box();



 const Vector2f& GetOffset() const;




 Vector2f GetPosition(Area area = Box::CONTENT) const;



 Vector2f GetSize(Area area = Box::CONTENT) const;




 void SetOffset(const Vector2f& offset);


 void SetContent(const Vector2f& content);




 void SetEdge(Area area, Edge edge, float size);





 float GetEdge(Area area, Edge edge) const;




 float GetCumulativeEdge(Area area, Edge edge) const;



 bool operator==(const Box& rhs) const;


 bool operator!=(const Box& rhs) const;

private:
 Vector2f content;
 float area_edges[NUM_AREAS][NUM_EDGES];

 Vector2f offset;
};

}
}
namespace Rocket {
namespace Core {





class __attribute__((visibility("default"))) URL
{
public:

 URL();

 URL(const String& url);


 URL(const char* url);

 ~URL();



 bool SetURL(const String& url);

 const String& GetURL() const;


 bool SetProtocol(const String& protocol);

 const String& GetProtocol() const;


 bool SetLogin( const String& login );

 const String& GetLogin() const;


 bool SetPassword( const String& password );

 const String& GetPassword() const;


 bool SetHost(const String& host);

 const String& GetHost() const;


 bool SetPort(int port);

 int GetPort() const;


 bool SetPath(const String& path);

 bool PrefixPath(const String& prefix);

 const String& GetPath() const;


 bool SetFileName(const String& file_name);

 const String& GetFileName() const;


 bool SetExtension(const String& extension);

 const String& GetExtension() const;


 typedef std::map< String, String > Parameters;
 const Parameters& GetParameters() const;
 void SetParameter(const String& name, const String& value);
 void SetParameters( const Parameters& parameters );
 void ClearParameters();


 String GetPathedFileName() const;

 String GetQueryString() const;


 bool operator<(const URL& rhs) const;



 static String UrlEncode(const String &value);
 static String UrlDecode(const String &value);

private:
 void ConstructURL() const;





 static bool IsUnreservedChar(const char c);

 mutable String url;
 String protocol;
 String login;
 String password;
 String host;
 String path;
 String file_name;
 String extension;

 Parameters parameters;

 int port;
 mutable int url_dirty;
};

}
}




namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) noexcept;

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) noexcept;

      void
      _M_reverse() noexcept;

      void
      _M_hook(_List_node_base* const __position) noexcept;

      void
      _M_unhook() noexcept;
    };


  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      _Tp _M_data;


      template<typename... _Args>
        _List_node(_Args&&... __args)
 : __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...)
        { }

    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator() noexcept
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x) noexcept
      : _M_node(__x) { }

      _Self
      _M_const_cast() const noexcept
      { return *this; }


      reference
      operator*() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const noexcept
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator() noexcept
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      noexcept
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x) noexcept
      : _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }



      reference
      operator*() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const noexcept
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }

namespace __cxx11 {

  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      static size_t
      _S_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last)
      {
 size_t __n = 0;
 while (__first != __last)
   {
     __first = __first->_M_next;
     ++__n;
   }
 return __n;
      }

      struct _List_impl
      : public _Node_alloc_type
      {

 _List_node<size_t> _M_node;




 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a) noexcept
 : _Node_alloc_type(__a), _M_node()
 { }


 _List_impl(_Node_alloc_type&& __a) noexcept
 : _Node_alloc_type(std::move(__a)), _M_node()
 { }

      };

      _List_impl _M_impl;


      size_t _M_get_size() const { return _M_impl._M_node._M_data; }

      void _M_set_size(size_t __n) { _M_impl._M_node._M_data = __n; }

      void _M_inc_size(size_t __n) { _M_impl._M_node._M_data += __n; }

      void _M_dec_size(size_t __n) { _M_impl._M_node._M_data -= __n; }

      size_t
      _M_distance(const __detail::_List_node_base* __first,
    const __detail::_List_node_base* __last) const
      { return _S_distance(__first, __last); }


      size_t _M_node_count() const { return _M_impl._M_node._M_data; }
      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p) noexcept
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_alloc_type*>(&_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_alloc_type*>(&_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const noexcept
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a) noexcept
      : _M_impl(__a)
      { _M_init(); }


      _List_base(_List_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Node_allocator()))
      {
 auto* const __xnode = std::__addressof(__x._M_impl._M_node);
 if (__xnode->_M_next == __xnode)
   _M_init();
 else
   {
     auto* const __node = std::__addressof(_M_impl._M_node);
     __node->_M_next = __xnode->_M_next;
     __node->_M_prev = __xnode->_M_prev;
     __node->_M_next->_M_prev = __node->_M_prev->_M_next = __node;
     _M_set_size(__x._M_get_size());
     __x._M_init();
   }
      }



      ~_List_base() noexcept
      { _M_clear(); }

      void
      _M_clear() noexcept;

      void
      _M_init() noexcept
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
 _M_set_size(0);
      }
    };
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
 {
   _Node* __p = this->_M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__p,
      std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__p);
       throw;
     }
   return __p;
 }


    public:






      list()

      noexcept(is_nothrow_default_constructible<_Node_alloc_type>::value)

      : _Base() { }





      explicit
      list(const allocator_type& __a) noexcept
      : _Base(_Node_alloc_type(__a)) { }
      explicit
      list(size_type __n)
      : _Base()
      { _M_default_initialize(__n); }
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
      list(list&& __x) noexcept
      : _Base(std::move(__x)) { }
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
        { _M_initialize_dispatch(__first, __last, __false_type()); }
      list&
      operator=(const list& __x);
      list&
      operator=(list&& __x)
      {


 this->clear();
 this->swap(__x);
 return *this;
      }
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }







      bool
      empty() const noexcept
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const noexcept
      { return this->_M_node_count(); }


      size_type
      max_size() const noexcept
      { return _M_get_Node_allocator().max_size(); }
      void
      resize(size_type __new_size);
      void
      resize(size_type __new_size, const value_type& __x);
      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
      void
      pop_front() noexcept
      { this->_M_erase(begin()); }
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
      void
      pop_back() noexcept
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
      iterator
      insert(const_iterator __position, const value_type& __x);
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x);
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last);
      iterator

      erase(const_iterator __position) noexcept;
      iterator

      erase(const_iterator __first, const_iterator __last) noexcept



      {
 while (__first != __last)
   __first = erase(__first);
 return __last._M_const_cast();
      }
      void
      swap(list& __x)
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);

 size_t __xsize = __x._M_get_size();
 __x._M_set_size(this->_M_get_size());
 this->_M_set_size(__xsize);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear() noexcept
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
      void

      splice(const_iterator __position, list&& __x) noexcept



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position._M_const_cast(),
         __x.begin(), __x.end());

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
      }


      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
      void
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
      {
 iterator __j = __i._M_const_cast();
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position._M_const_cast(),
     __i._M_const_cast(), __j);

 this->_M_inc_size(1);
 __x._M_dec_size(1);
      }
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
      void
      splice(const_iterator __position, list&& __x, const_iterator __first,
      const_iterator __last) noexcept
      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     size_t __n = this->_M_distance(__first._M_node, __last._M_node);
     this->_M_inc_size(__n);
     __x._M_dec_size(__n);

     this->_M_transfer(__position._M_const_cast(),
         __first._M_const_cast(),
         __last._M_const_cast());
   }
      }
      void
      splice(const_iterator __position, list& __x, const_iterator __first,
      const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
      void
      remove(const _Tp& __value);
      template<typename _Predicate>
        void
        remove_if(_Predicate);
      void
      unique();
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
      template<typename _StrictWeakOrdering>
        void
        merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp)
        { merge(std::move(__x), __comp); }
      void
      reverse() noexcept
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }



      void
      _M_default_initialize(size_type __n)
      {
 for (; __n; --__n)
   emplace_back();
      }


      void
      _M_default_append(size_type __n);
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
  this->_M_inc_size(1);
       }



      void
      _M_erase(iterator __position) noexcept
      {
 this->_M_dec_size(1);
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);

        _M_get_Node_allocator().destroy(__n);



        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x) noexcept
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __builtin_abort();
      }
    };
}
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear() noexcept
    {
      typedef _List_node<_Tp> _Node;
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = static_cast<_Node*>(__cur);
   __cur = __tmp->_M_next;

   _M_get_Node_allocator().destroy(__tmp);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_const_cast()._M_node);
 this->_M_inc_size(1);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_const_cast()._M_node);
      this->_M_inc_size(1);
      return iterator(__tmp);
    }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(const_iterator __position, size_type __n, const value_type& __x)
    {
      if (__n)
 {
   list __tmp(__n, __x, get_allocator());
   iterator __it = __tmp.begin();
   splice(__position, __tmp);
   return __it;
 }
      return __position._M_const_cast();
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator, typename>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      insert(const_iterator __position, _InputIterator __first,
      _InputIterator __last)
      {
 list __tmp(__first, __last, get_allocator());
 if (!__tmp.empty())
   {
     iterator __it = __tmp.begin();
     splice(__position, __tmp);
     return __it;
   }
 return __position._M_const_cast();
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    erase(const_iterator __position) noexcept



    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position._M_const_cast());
      return __ret;
    }


  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++__i)
     emplace_back();
 }
      catch(...)
 {
   for (; __i; --__i)
     pop_back();
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
 _M_default_append(__new_size - __len);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);

   this->_M_inc_size(__x._M_get_size());
   __x._M_set_size(0);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);

     this->_M_inc_size(__x._M_get_size());
     __x._M_set_size(0);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}

namespace Rocket {
namespace Core {

class StreamListener;






class __attribute__((visibility("default"))) Stream : public ReferenceCountable
{
 public:

  enum StreamMode
  {
   MODE_WRITE = 1 << 0,
   MODE_APPEND = 1 << 1,
   MODE_READ = 1 << 2,
   MODE_ASYNC = 1 << 3,

   MODE_MASK = MODE_WRITE | MODE_APPEND | MODE_READ
  };

  Stream();
  virtual ~Stream();


  virtual void Close();


  int GetStreamMode() const;


  const URL& GetSourceURL() const;


  virtual bool IsEOS() const;


  virtual size_t Length() const = 0;


  virtual size_t Tell() const = 0;

  virtual bool Seek(long offset, int origin) const = 0;


  virtual size_t Read(void* buffer, size_t bytes) const = 0;

  virtual size_t Read(Stream* stream, size_t bytes) const;

  virtual size_t Read(String& buffer, size_t bytes) const;

  virtual size_t Peek(void* buffer, size_t bytes) const;


  virtual size_t Write(const void* buffer, size_t bytes) = 0;

  virtual size_t Write(const Stream* stream, size_t bytes);

  virtual size_t Write(const char* string);

  virtual size_t Write(const String& string);


  virtual size_t Truncate(size_t bytes) = 0;


  virtual size_t PushFront(const void* buffer, size_t bytes);

  virtual size_t PushBack(const void* buffer, size_t bytes);


  virtual size_t PopFront(size_t bytes);

  virtual size_t PopBack(size_t bytes);




  virtual bool IsReadReady() = 0;



  virtual bool IsWriteReady() = 0;

 protected:


  void SetStreamDetails(const URL& url, int stream_mode);


  virtual void OnReferenceDeactivate();

 private:
  URL url;
  int stream_mode;
};

}
}
namespace Rocket {
namespace Core {






class __attribute__((visibility("default"))) StringUtilities
{
public:





 static void ExpandString(StringList& string_list, const String& string, const char delimiter = ',');




 static void JoinString(String& string, const StringList& string_list, const char delimiter = ',');





 static Hash FNVHash(const char* data, int length = -1);






 static bool UTF8toUCS2(const String& input, std::vector< word >& output);





 static bool UCS2toUTF8(const std::vector< word >& input, String& output);






 static bool UCS2toUTF8(const word* input, size_t input_size, String& output);




 template < typename CharacterType >
 static bool IsWhitespace(CharacterType x)
 {
  return (x == '\r' || x == '\n' || x == ' ' || x == '\t');
 }




 static String StripWhitespace(const String& string);


 struct __attribute__((visibility("default"))) StringComparei
 {
  bool operator()(const String& lhs, const String& rhs) const;
 };
};

}
}




namespace Rocket {
namespace Core {
template <typename SourceType, typename DestType>
class TypeConverter
{
public:
 static bool Convert(const SourceType& src, DestType& dest);
};


template <typename SourceType, typename DestType>
bool TypeConverter<SourceType, DestType>::Convert(const SourceType& , DestType& )
{
 if (!Rocket::Core::Assert("No converter specified.", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/TypeConverter.inl", 31)) { {__builtin_trap();}; };
 return false;
}




template< typename T >
class TypeConverter< T, Stream >
{
public:
 static bool Convert(const T& src, Stream* dest)
 {
  String string_dest;
  bool result = TypeConverter< T, String >::Convert(src, string_dest);
  if (result)
   dest->Write(string_dest);

  return result;
 }
};

template< typename T >
class TypeConverter< Stream, T >
{
public:
 static bool Convert(Stream* src, T& dest, size_t length = String::npos)
 {
  String string_src;
  src->Read(string_src, src->Length() < length ? src->Length() : length);
  return TypeConverter< String, T >::Convert(string_src, dest);
 }
};
template<> class TypeConverter< int, int > { public: static bool Convert(const int& src, int& dest) { dest = (int)src; return true; } };
template<> class TypeConverter< unsigned int, unsigned int > { public: static bool Convert(const unsigned int& src, unsigned int& dest) { dest = (unsigned int)src; return true; } };
template<> class TypeConverter< float, float > { public: static bool Convert(const float& src, float& dest) { dest = (float)src; return true; } };
template<> class TypeConverter< bool, bool > { public: static bool Convert(const bool& src, bool& dest) { dest = (bool)src; return true; } };
template<> class TypeConverter< char, char > { public: static bool Convert(const char& src, char& dest) { dest = (char)src; return true; } };
template<> class TypeConverter< word, word > { public: static bool Convert(const word& src, word& dest) { dest = (word)src; return true; } };
template<> class TypeConverter< Vector2i, Vector2i > { public: static bool Convert(const Vector2i& src, Vector2i& dest) { dest = (Vector2i)src; return true; } };
template<> class TypeConverter< Vector2f, Vector2f > { public: static bool Convert(const Vector2f& src, Vector2f& dest) { dest = (Vector2f)src; return true; } };
template<> class TypeConverter< Colourf, Colourf > { public: static bool Convert(const Colourf& src, Colourf& dest) { dest = (Colourf)src; return true; } };
template<> class TypeConverter< Colourb, Colourb > { public: static bool Convert(const Colourb& src, Colourb& dest) { dest = (Colourb)src; return true; } };
template<> class TypeConverter< String, String > { public: static bool Convert(const String& src, String& dest) { dest = (String)src; return true; } };


class ScriptInterface;
typedef ScriptInterface* ScriptInterfacePtr;
template<> class TypeConverter< ScriptInterfacePtr, ScriptInterfacePtr > { public: static bool Convert(const ScriptInterfacePtr& src, ScriptInterfacePtr& dest) { dest = (ScriptInterfacePtr)src; return true; } };
typedef void* voidPtr;
template<> class TypeConverter< voidPtr, voidPtr > { public: static bool Convert(const voidPtr& src, voidPtr& dest) { dest = (voidPtr)src; return true; } };

template<>
class TypeConverter< Stream, Stream >
{
public:
 static bool Convert(Stream* src, Stream* dest)
 {
  return src->Write(dest, src->Length()) == src->Length();
 }
};




template<> class TypeConverter< bool, int > { public: static bool Convert(const bool& src, int& dest) { dest = (int)src; return true; } };
template<> class TypeConverter< bool, unsigned int > { public: static bool Convert(const bool& src, unsigned int& dest) { dest = (unsigned int)src; return true; } };
template<> class TypeConverter< bool, float > { public: static bool Convert(const bool& src, float& dest) { dest = (float)src; return true; } };

template<> class TypeConverter< int, unsigned int > { public: static bool Convert(const int& src, unsigned int& dest) { dest = (unsigned int)src; return true; } };
template<> class TypeConverter< int, bool > { public: static bool Convert(const int& src, bool& dest) { dest = src != 0; return true; } };
template<> class TypeConverter< int, float > { public: static bool Convert(const int& src, float& dest) { dest = (float)src; return true; } };

template<> class TypeConverter< float, bool > { public: static bool Convert(const float& src, bool& dest) { dest = src != 0; return true; } };
template<> class TypeConverter< float, int > { public: static bool Convert(const float& src, int& dest) { dest = (int)src; return true; } };
template<> class TypeConverter< float, unsigned int > { public: static bool Convert(const float& src, unsigned int& dest) { dest = (unsigned int)src; return true; } };

template<> class TypeConverter< char, word > { public: static bool Convert(const char& src, word& dest) { dest = (word)src; return true; } };
template<> class TypeConverter< String, float > { public: static bool Convert(const String& src, float& dest) { dest = (float) atof(src.CString()); return true; } };;
template<> class TypeConverter< String, double > { public: static bool Convert(const String& src, double& dest) { dest = (double) atof(src.CString()); return true; } };;

template<>
class TypeConverter< String, int >
{
public:
 static bool Convert(const String& src, int& dest)
 {
  return sscanf(src.CString(), "%d", &dest) == 1;
 }
};

template<>
class TypeConverter< String, unsigned int >
{
public:
 static bool Convert(const String& src, unsigned int& dest)
 {
  return sscanf(src.CString(), "%u", &dest) == 1;
 }
};

template<>
class TypeConverter< String, byte >
{
public:
 static bool Convert(const String& src, byte& dest)
 {
  int value;
  bool ret = sscanf(src.CString(), "%d", &value) == 1;
  dest = (byte) value;
  return ret && (value <= 255);
 }
};

template<>
class TypeConverter< String, bool >
{
public:
 static bool Convert(const String& src, bool& dest)
 {
  String lower = src.ToLower();
  if (lower == "1" || lower == "true")
  {
   dest = true;
   return true;
  }
  else if (lower == "0" || lower == "false")
  {
   dest = false;
   return true;
  }
  return false;
 }
};

template<>
class TypeConverter< String, URL >
{
public:
 static bool Convert(const String& src, URL& dest)
 {
  return dest.SetURL(src);
 }
};

template< typename DestType, typename InternalType, int count >
class TypeConverterStringVector
{
public:
 static bool Convert(const String& src, DestType& dest)
 {
  StringList string_list;
  StringUtilities::ExpandString(string_list, src);
  if (string_list.size() < count)
   return false;
  for (int i = 0; i < count; i++)
  {
   if (!TypeConverter< String, InternalType >::Convert(string_list[i], dest[i]))
    return false;
  }
  return true;
 }
};
template<> class TypeConverter< String, Vector2i > { public: static bool Convert(const String& src, Vector2i& dest) { return TypeConverterStringVector< Vector2i, int, 2 >::Convert(src, dest); } };
template<> class TypeConverter< String, Vector2f > { public: static bool Convert(const String& src, Vector2f& dest) { return TypeConverterStringVector< Vector2f, float, 2 >::Convert(src, dest); } };
template<> class TypeConverter< String, Colourf > { public: static bool Convert(const String& src, Colourf& dest) { return TypeConverterStringVector< Colourf, float, 4 >::Convert(src, dest); } };
template<> class TypeConverter< String, Colourb > { public: static bool Convert(const String& src, Colourb& dest) { return TypeConverterStringVector< Colourb, byte, 4 >::Convert(src, dest); } };
template<> class TypeConverter< float, String > { public: static bool Convert(const float& src, String& dest) { return dest.FormatString(32, "%.4f", src) > 0; } };;
template<> class TypeConverter< double, String > { public: static bool Convert(const double& src, String& dest) { return dest.FormatString(32, "%.4f", src) > 0; } };;

template<>
class TypeConverter< int, String >
{
public:
 static bool Convert(const int& src, String& dest)
 {
  return dest.FormatString(32, "%d", src) > 0;
 }
};

template<>
class TypeConverter< unsigned int, String >
{
public:
 static bool Convert(const unsigned int& src, String& dest)
 {
  return dest.FormatString(32, "%u", src) > 0;
 }
};

template<>
class TypeConverter< byte, String >
{
public:
 static bool Convert(const byte& src, String& dest)
 {
  return dest.FormatString(32, "%u", src) > 0;
 }
};

template<>
class TypeConverter< bool, String >
{
public:
 static bool Convert(const bool& src, String& dest)
 {
  dest = src ? "1" : "0";
  return true;
 }
};

template<>
class TypeConverter< char*, String >
{
public:
 static bool Convert(char* const & src, String& dest)
 {
  dest = src;
  return true;
 }
};

template<>
class TypeConverter< URL, String >
{
public:
 static bool Convert(const URL& src, String& dest)
 {
  dest = src.GetURL();
  return true;
 }
};

template< typename SourceType, typename InternalType, int count >
class TypeConverterVectorString
{
public:
 static bool Convert(const SourceType& src, String& dest)
 {
  dest = "";
  for (int i = 0; i < count; i++)
  {
   String value;
   if (!TypeConverter< InternalType, String >::Convert(src[i], value))
    return false;

   dest += value;
   if (i < count - 1)
    dest += ", ";
  }
  return true;
 }
};
template<> class TypeConverter< Vector2i, String > { public: static bool Convert(const Vector2i& src, String& dest) { return TypeConverterVectorString< Vector2i, int, 2 >::Convert(src, dest); } };
template<> class TypeConverter< Vector2f, String > { public: static bool Convert(const Vector2f& src, String& dest) { return TypeConverterVectorString< Vector2f, float, 2 >::Convert(src, dest); } };
template<> class TypeConverter< Colourf, String > { public: static bool Convert(const Colourf& src, String& dest) { return TypeConverterVectorString< Colourf, float, 4 >::Convert(src, dest); } };
template<> class TypeConverter< Colourb, String > { public: static bool Convert(const Colourb& src, String& dest) { return TypeConverterVectorString< Colourb, byte, 4 >::Convert(src, dest); } };

}
}


namespace Rocket {
namespace Core {
class __attribute__((visibility("default"))) Variant
{
public:
 Variant();


 Variant(const Variant&);


 template< typename T >
 Variant(const T& t);

 ~Variant();


 enum Type
 {
  NONE = '-',
  BYTE = 'b',
  CHAR = 'c',
  FLOAT = 'f',
  INT = 'i',
  STRING = 's',
  WORD = 'w',
  VECTOR2 = '2',
  COLOURF = 'g',
  COLOURB = 'h',
  SCRIPTINTERFACE = 'p',
  VOIDPTR = '*',
 };


 void Clear();



 Type GetType() const;



 void Set(const Variant& copy);


 void Set(const byte value);


 void Set(const char value);


 void Set(const float value);


 void Set(const int value);


 void Set(const word value);


 void Set(const char* value);


 void Set(void* value);


 void Set(const String& value);


 void Set(const Vector2f& value);


 void Set(const Colourf& value);


 void Set(const Colourb& value);


 void Set(ScriptInterface* value);




 template< typename T >
 T Get() const;





 template< typename T >
 bool GetInto(T& value) const;



 Variant& operator=(const Variant& copy);

private:


  static const int LOCAL_DATA_SIZE = 40;



 Type type;
 char data[LOCAL_DATA_SIZE];
};


template< typename T >
Variant::Variant(const T& t) : type(NONE)
{
 Set( t );
}


template< typename T >
bool Variant::GetInto(T& value) const
{
 switch (type)
 {
  case BYTE:
   return TypeConverter< byte, T >::Convert(*(byte*)data, value);
  break;

  case CHAR:
   return TypeConverter< char, T >::Convert(*(char*)data, value);
  break;

  case FLOAT:
   return TypeConverter< float, T >::Convert(*(float*)data, value);
  break;

  case INT:
   return TypeConverter< int, T >::Convert(*(int*)data, value);
  break;

  case STRING:
   return TypeConverter< String, T >::Convert(*(String*)data, value);
  break;

  case WORD:
   return TypeConverter< word, T >::Convert(*(word*)data, value);
  break;

  case VECTOR2:
   return TypeConverter< Vector2f, T >::Convert(*(Vector2f*)data, value);
  break;

  case COLOURF:
   return TypeConverter< Colourf, T >::Convert(*(Colourf*)data, value);
  break;

  case COLOURB:
   return TypeConverter< Colourb, T >::Convert(*(Colourb*)data, value);
  break;

  case SCRIPTINTERFACE:
   return TypeConverter< ScriptInterface*, T >::Convert(*(ScriptInterface**)data, value);
  break;

  case VOIDPTR:
   return TypeConverter< void*, T >::Convert(*(void**)data, value);
  break;

  case NONE:
  break;

 }

 return false;
}


template< typename T >
T Variant::Get() const
{
 T value;
 GetInto(value);
 return value;
}

}
}

namespace Rocket {
namespace Core {
class __attribute__((visibility("default"))) Dictionary
{
public:
 Dictionary();
 Dictionary(const Dictionary &dict);
 ~Dictionary();


 void Set(const String& key, const Variant &value);


 template <typename T>
 inline void Set(const String& key, const T& value);


 Variant* Get(const String& key) const;
 Variant* operator[](const String& key) const;



 template <typename T>
 inline T Get(const String& key, const T& default_val) const;



 template <typename T>
 inline bool GetInto(const String& key, T& value) const;


 bool Remove(const String& key);


 bool Iterate(int &pos, String& key, Variant* &value) const;
 template <typename T>
 bool Iterate(int &pos, String& key, T& value) const;


 bool Reserve(int size);


 void Clear();


 bool IsEmpty() const;


 int Size() const;


 void Merge(const Dictionary& dict);


 void operator=(const Dictionary &dict);

private:
 unsigned int num_full;
 unsigned int num_used;
 static const int DICTIONARY_MINSIZE = 8;


 struct DictionaryEntry
 {
  DictionaryEntry() : hash(0) {}
  Hash hash;
  String key;
  Variant value;
 };





 unsigned int mask;


 DictionaryEntry small_table[DICTIONARY_MINSIZE];


 DictionaryEntry* table;


 void Insert(const String& key, Hash hash, const Variant& value);


 DictionaryEntry* Retrieve(const String& key, Hash hash) const;


 void ResetToMinimumSize();


 void Copy(const Dictionary &dict);
};


template< typename T >
inline void Dictionary::Set(const String& key, const T& value)
{
 Set(key, Variant(value));
}

template< typename T >
inline T Dictionary::Get(const String& key, const T& default_value) const
{
 T value;
 if (!GetInto(key, value))
  return default_value;

 return value;
}


template <typename T>
inline bool Dictionary::GetInto(const String& key, T& value) const
{
 Variant* variant = Get(key);
 if (!variant)
  return false;

 return variant->GetInto<T>(value);
}

template <typename T>
inline bool Dictionary::Iterate(int &pos, String& key, T& value) const
{
 Variant* variant;
 bool iterate = Iterate(pos, key, variant);
 if (iterate)
  variant->GetInto(value);
 return iterate;
}

}
}



namespace Rocket {
namespace Core {

class Element;
class EventInstancer;
class __attribute__((visibility("default"))) Event : public ScriptInterface
{
public:

 Event();





 Event(Element* target, const String& type, const Dictionary& parameters, bool interruptible = false);

 virtual ~Event();

 enum EventPhase { PHASE_UNKNOWN, PHASE_CAPTURE, PHASE_TARGET, PHASE_BUBBLE };



 EventPhase GetPhase() const;


 void SetPhase(EventPhase phase);



 void SetCurrentElement(Element* element);


 Element* GetCurrentElement() const;



 Element* GetTargetElement() const;



 const String& GetType() const;



 bool operator==(const String& type) const;



 bool IsPropagating() const;

 void StopPropagation();




 template < typename T >
 T GetParameter(const String& key, const T& default_value)
 {
  return parameters.Get(key, default_value);
 }


 const Dictionary* GetParameters() const;


 virtual void OnReferenceDeactivate();

protected:
 String type;
 Dictionary parameters;

 Element* target_element;
 Element* current_element;

private:
 bool interruptible;
 bool interruped;

 EventPhase phase;

 EventInstancer* instancer;

 friend class Factory;
};

}
}
namespace Rocket {
namespace Core {

class PropertyDefinition;





class __attribute__((visibility("default"))) Property
{
public:
 enum Unit
 {
  UNKNOWN = 1 << 0,

  KEYWORD = 1 << 1,

  STRING = 1 << 2,


  NUMBER = 1 << 3,
  PX = 1 << 4,
  COLOUR = 1 << 5,
  ABSOLUTE_UNIT = NUMBER | PX | COLOUR,


  EM = 1 << 6,
  PERCENT = 1 << 7,


  INCH = 1 << 8,
  CM = 1 << 9,
  MM = 1 << 10,
  PT = 1 << 11,
  PC = 1 << 12,
  PPI_UNIT = INCH | CM | MM | PT | PC,

  REM = 1 << 13,
  RELATIVE_UNIT = EM | REM | PERCENT
 };

 Property();
 template < typename PropertyType >
 Property(PropertyType value, Unit unit, int specificity = -1) : value(Variant(value)), unit(unit), specificity(specificity)
 {
  definition = __null;
  parser_index = -1;

  source_line_number = 0;
 }

 ~Property();


 String ToString() const;


 template <typename T>
 T Get() const
 {
  return value.Get<T>();
 }

 Variant value;
 Unit unit;
 int specificity;

 const PropertyDefinition* definition;
 int parser_index;

 String source;
 int source_line_number;
};

}
}


namespace Rocket {
namespace Core {
 class Dictionary;
}
}

namespace Rocket {
namespace Core {

class Context;
class Decorator;
class ElementInstancer;
class EventDispatcher;
class EventListener;
class ElementBackground;
class ElementBorder;
class ElementDecoration;
class ElementDefinition;
class ElementDocument;
class ElementScroll;
class ElementStyle;
class FontFaceHandle;
class PropertyDictionary;
class RenderInterface;
class StyleSheet;







class __attribute__((visibility("default"))) Element : public ScriptInterface
{
public:



 Element(const String& tag);
 virtual ~Element();

 void Update();
 void Render();


 Element* Clone() const;







 void SetClass(const String& class_name, bool activate);



 bool IsClassSet(const String& class_name) const;


 void SetClassNames(const String& class_names);


 String GetClassNames() const;




 virtual StyleSheet* GetStyleSheet() const;



 const ElementDefinition* GetDefinition();




 String GetAddress(bool include_pseudo_classes = false) const;





 void SetOffset(const Vector2f& offset, Element* offset_parent, bool offset_fixed = false);




 Vector2f GetRelativeOffset(Box::Area area = Box::CONTENT);




 Vector2f GetAbsoluteOffset(Box::Area area = Box::CONTENT);



 void SetClientArea(Box::Area client_area);


 Box::Area GetClientArea() const;





 void SetContentBox(const Vector2f& content_offset, const Vector2f& content_box);


 void SetBox(const Box& box);


 void AddBox(const Box& box);



 const Box& GetBox(int index = 0);


 int GetNumBoxes();



 virtual float GetBaseline() const;




 virtual bool GetIntrinsicDimensions(Vector2f& dimensions);




 virtual bool IsPointWithinElement(const Vector2f& point);



 bool IsVisible() const;


 float GetZIndex() const;



 FontFaceHandle* GetFontFaceHandle() const;
 bool SetProperty(const String& name, const String& value);




 bool SetProperty(const String& name, const Property& property);



 void RemoveProperty(const String& name);




 const Property* GetProperty(const String& name);



 template < typename T >
 T GetProperty(const String& name);




 const Property* GetLocalProperty(const String& name);





 float ResolveProperty(const String& name, float base_value);





 float ResolveProperty(const Property *property, float base_value);


 void GetOffsetProperties(const Property **top, const Property **bottom, const Property **left, const Property **right );

 void GetBorderWidthProperties(const Property **border_top_width, const Property **border_bottom_width, const Property **border_left_width, const Property **border_right_width);

 void GetMarginProperties(const Property **margin_top, const Property **margin_bottom, const Property **margin_left, const Property **margin_right);

 void GetPaddingProperties(const Property **padding_top, const Property **padding_bottom, const Property **padding_left, const Property **padding_right);

 void GetDimensionProperties(const Property **width, const Property **height);


 void GetLocalDimensionProperties(const Property **width, const Property **height);

 void GetOverflow(int *overflow_x, int *overflow_y);

 int GetPosition();

 int GetFloat();

 int GetDisplay();

 int GetWhitespace();


 const Property *GetLineHeightProperty();

 int GetTextAlign();

 int GetTextTransform();

 const Property *GetVerticalAlignProperty();







 bool IterateProperties(int& index, PseudoClassList& pseudo_classes, String& name, const Property*& property) const;
 void SetPseudoClass(const String& pseudo_class, bool activate);



 bool IsPseudoClassSet(const String& pseudo_class) const;



 bool ArePseudoClassesSet(const PseudoClassList& pseudo_classes) const;


 const PseudoClassList& GetActivePseudoClasses() const;
 template< typename T >
 void SetAttribute(const String& name, const T& value);



 Variant* GetAttribute(const String& name) const;



 template< typename T >
 T GetAttribute(const String& name, const T& default_value) const;



 bool HasAttribute(const String& name);


 void RemoveAttribute(const String& name);


 void SetAttributes(const ElementAttributes* attributes);





 template< typename T >
 bool IterateAttributes(int& index, String& name, T& value) const;


 int GetNumAttributes() const;
 bool IterateDecorators(int& index, PseudoClassList& pseudo_classes, String& name, Decorator*& decorator, DecoratorDataHandle& decorator_data);




 Element* GetFocusLeafNode();



 Context* GetContext();







 const String& GetTagName() const;



 const String& GetId() const;


 void SetId(const String& id);



 float GetAbsoluteLeft();


 float GetAbsoluteTop();




 float GetClientLeft();



 float GetClientTop();



 float GetClientWidth();



 float GetClientHeight();



 Element* GetOffsetParent();


 float GetOffsetLeft();


 float GetOffsetTop();


 float GetOffsetWidth();


 float GetOffsetHeight();



 float GetScrollLeft();


 void SetScrollLeft(float scroll_left);


 float GetScrollTop();


 void SetScrollTop(float scroll_top);


 float GetScrollWidth();


 float GetScrollHeight();



 ElementStyle* GetStyle();



 virtual ElementDocument* GetOwnerDocument();



 Element* GetParentNode() const;



 Element* GetNextSibling() const;


 Element* GetPreviousSibling() const;



 Element* GetFirstChild() const;


 Element* GetLastChild() const;



 Element* GetChild(int index) const;



 int GetNumChildren(bool include_non_dom_elements = false) const;



 virtual void GetInnerRML(String& content) const;


 String GetInnerRML() const;


 void SetInnerRML(const String& rml);
 bool Focus();

 void Blur();

 void Click();





 void AddEventListener(const String& event, EventListener* listener, bool in_capture_phase = false);




 void RemoveEventListener(const String& event, EventListener* listener, bool in_capture_phase = false);





 bool DispatchEvent(const String& event, const Dictionary& parameters, bool interruptible = false);



 void ScrollIntoView(bool align_with_top = true);




 void AppendChild(Element* element, bool dom_element = true);




 void InsertBefore(Element* element, Element* adjacent_element);




 bool ReplaceChild(Element* inserted_element, Element* replaced_element);



 bool RemoveChild(Element* element);


 bool HasChildNodes() const;




 Element* GetElementById(const String& id);



 void GetElementsByTagName(ElementList& elements, const String& tag);



 void GetElementsByClassName(ElementList& elements, const String& class_name);
 EventDispatcher* GetEventDispatcher() const;


 ElementBackground* GetElementBackground() const;


 ElementBorder* GetElementBorder() const;


 ElementDecoration* GetElementDecoration() const;


 ElementScroll* GetElementScroll() const;



 int GetClippingIgnoreDepth();

 bool IsClippingEnabled();



 RenderInterface* GetRenderInterface();



 void SetInstancer(ElementInstancer* instancer);



 virtual void ProcessEvent(Event& event);


 void UpdateLayout();

protected:


 void ForceLocalStackingContext();


 virtual void OnUpdate();

 virtual void OnRender();


 virtual void OnLayout();



 virtual void OnAttributeChange(const AttributeNameList& changed_attributes);


 virtual void OnPropertyChange(const PropertyNameList& changed_properties);



 virtual void OnChildAdd(Element* child);


 virtual void OnChildRemove(Element* child);


 virtual void DirtyLayout();


 virtual bool IsLayoutDirty();


 virtual void LockLayout(bool lock);


 virtual void DirtyFont();



 virtual void GetRML(String& content);

 virtual void OnReferenceDeactivate();

private:
 void SetParent(Element* parent);

 void ReleaseDeletedElements();
 void ReleaseElements(ElementList& elements);

 void DirtyOffset();
 void UpdateOffset();

 void BuildLocalStackingContext();
 void BuildStackingContext(ElementList* stacking_context);
 void DirtyStackingContext();

 void DirtyStructure();


 String tag;


 String id;


 ElementInstancer* instancer;


 Element* parent;

 Element* focus;

 ElementDocument* owner_document;


 EventDispatcher* event_dispatcher;

 ElementStyle* style;

 ElementBackground* background;

 ElementBorder* border;

 ElementDecoration* decoration;

 ElementScroll* scroll;

 ElementAttributes attributes;


 Element* offset_parent;
 Vector2f relative_offset_base;
 Vector2f relative_offset_position;
 bool offset_fixed;

 mutable Vector2f absolute_offset;
 mutable bool offset_dirty;


 Vector2f scroll_offset;


 typedef std::vector< Box > BoxList;
 BoxList boxes;

 Vector2f content_offset;
 Vector2f content_box;


 Box::Area client_area;


 bool visible;

 ElementList children;
 int num_non_dom_children;

 ElementList active_children;
 ElementList deleted_children;

 float z_index;
 bool local_stacking_context;
 bool local_stacking_context_forced;

 ElementList stacking_context;
 bool stacking_context_dirty;


 FontFaceHandle* font_face_handle;


 int clipping_ignore_depth;
 bool clipping_enabled;
 bool clipping_state_dirty;

 friend class Context;
 friend class ElementStyle;
 friend class LayoutEngine;
 friend class LayoutInlineBox;
};


template < typename T >
T Element::GetProperty(const String& name)
{
 const Property* property = GetProperty(name);
 if (!(property)) { if (!Rocket::Core::Assert("Invalid property name.", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Rocket/Core/Element.inl", 34 )) { {__builtin_trap();}; } };
 return property->Get< T >();
}


template< typename T >
void Element::SetAttribute(const String& name, const T& value)
{
 attributes.Set(name, value);
 AttributeNameList changed_attributes;
 changed_attributes.insert(name);

 OnAttributeChange(changed_attributes);
}


template< typename T >
T Element::GetAttribute(const String& name, const T& default_value) const
{
 return attributes.Get(name, default_value);
}


template< typename T >
bool Element::IterateAttributes(int& index, String& name, T& value) const
{
 return attributes.Iterate(index, name, value);
}

}
}

namespace Rocket {
namespace Core {

class Stream;

}
}

namespace Rocket {
namespace Core {

class Context;
class DocumentHeader;
class ElementText;
class StyleSheet;







class __attribute__((visibility("default"))) ElementDocument : public Element
{
public:
 ElementDocument(const String& tag);
 virtual ~ElementDocument();


 void ProcessHeader(const DocumentHeader* header);


 virtual ElementDocument* GetOwnerDocument();



 Context* GetContext();



 void SetTitle(const String& title);


 const String& GetTitle() const;



 const String& GetSourceURL() const;



 void SetStyleSheet(StyleSheet* style_sheet);


 virtual StyleSheet* GetStyleSheet() const;


 void PullToFront();

 void PushToBack();




 enum FocusFlags
 {
  NONE = 0,
  FOCUS = (1 << 1),
  MODAL = (1 << 2)
 };



 void Show(int focus_flags = FOCUS);

 void Hide();

 void Close();



 Element* CreateElement(const String& name);


 ElementText* CreateTextNode(const String& text);



 bool IsModal() const;





 virtual void LoadScript(Stream* stream, const String& source_name);


 inline void UpdateLayout() { if (layout_dirty && lock_layout == 0) _UpdateLayout(); }

 void UpdatePosition();


 void LockLayout(bool lock);

protected:

 virtual void OnUpdate();


 virtual void OnPropertyChange(const PropertyNameList& changed_properties);


 virtual void DirtyLayout();


 virtual bool IsLayoutDirty();


 virtual void ProcessEvent(Event& event);

private:

 bool FocusNextTabElement(Element* current_element, bool forward);

 bool SearchFocusSubtree(Element* element, bool forward);


 String title;


 String source_url;


 StyleSheet* style_sheet;

 Context* context;


 bool modal;


 bool layout_dirty;
 int lock_layout;

 friend class Context;
 friend class Factory;

 void _UpdateLayout();
};

}
}






namespace std __attribute__ ((__visibility__ ("default")))
{
  constexpr inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {






    private:
      template<typename _Up>
 using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
      template<typename _CvTp>
 using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
    public:
      typedef __iter<_Tp> iterator;
      typedef __iter<const _Tp> const_iterator;
      typedef __ptr_to<_Tp> _Elt_pointer;
      typedef __ptr_to<_Elt_pointer> _Map_pointer;


      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Deque_iterator _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() noexcept
      : _M_cur(), _M_first(), _M_last(), _M_node() { }

      _Deque_iterator(const iterator& __x) noexcept
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const noexcept
      { return *_M_cur; }

      pointer
      operator->() const noexcept
      { return _M_cur; }

      _Self&
      operator++() noexcept
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n) noexcept
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n) noexcept
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const noexcept
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node) noexcept
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    noexcept
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;





      typedef typename _Alloc_traits::pointer _Ptr;
      typedef typename _Alloc_traits::const_pointer _Ptr_const;


      typedef typename _Alloc_traits::template rebind<_Ptr>::other
 _Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

    public:
      typedef _Alloc allocator_type;
      typedef typename _Alloc_traits::size_type size_type;

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x, false_type)
      : _M_impl(__x._M_move_impl())
      { }

      _Deque_base(_Deque_base&& __x, true_type)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x)
      : _Deque_base(std::move(__x),
      __gnu_cxx::__allocator_always_compares_equal<_Alloc>{})
      { }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   {
     if (__x._M_impl._M_map)
       {
  _M_initialize_map(0);
  this->_M_impl._M_swap_data(__x._M_impl);
       }
   }
 else
   {
     _M_initialize_map(__n);
   }
      }


      ~_Deque_base() noexcept;

    protected:
      typedef typename iterator::_Map_pointer _Map_pointer;




      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Map_pointer _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a) noexcept
 : _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 _Deque_impl(_Deque_impl&&) = default;

 _Deque_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 void _M_swap_data(_Deque_impl& __x) noexcept
 {
   using std::swap;
   swap(this->_M_start, __x._M_start);
   swap(this->_M_finish, __x._M_finish);
   swap(this->_M_map, __x._M_map);
   swap(this->_M_map_size, __x._M_map_size);
 }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const noexcept
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) noexcept
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;


    private:
      _Deque_impl
      _M_move_impl()
      {
 if (!_M_impl._M_map)
   return std::move(_M_impl);


 _Tp_alloc_type __alloc{_M_get_Tp_allocator()};

 _Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};

 _Deque_base __empty{__alloc};
 __empty._M_initialize_map(0);

 _Deque_impl __ret{std::move(_M_get_Tp_allocator())};
 _M_impl._M_swap_data(__ret);
 _M_impl._M_swap_data(__empty._M_impl);
 return __ret;
      }

    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() noexcept
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Map_pointer __nstart = (this->_M_impl._M_map
          + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = _Map_pointer();
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Alloc_traits _Alloc_traits;
      typedef typename _Base::_Map_pointer _Map_pointer;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:






      deque() : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_default_initialize(); }
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
       __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
      deque(deque&& __x)
      : _Base(std::move(__x)) { }


      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }


      deque(deque&& __x, const allocator_type& __a)
      : _Base(std::move(__x), __a, __x.size())
      {
 if (__x.get_allocator() != __a)
   {
     std::__uninitialized_move_a(__x.begin(), __x.end(),
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
     __x.clear();
   }
      }
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
      deque&
      operator=(const deque& __x);
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
 constexpr bool __always_equal = _Alloc_traits::_S_always_equal();
 _M_move_assign1(std::move(__x),
          integral_constant<bool, __always_equal>());
 return *this;
      }
      deque&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }






      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const noexcept
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
      void
      resize(size_type __new_size)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_default_append(__new_size - __len);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
      void
      resize(size_type __new_size, const value_type& __x)
      {
 const size_type __len = size();
 if (__new_size > __len)
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }






      bool
      empty() const noexcept
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
      reference
      operator[](size_type __n) noexcept
      { return this->_M_impl._M_start[difference_type(__n)]; }
      const_reference
      operator[](size_type __n) const noexcept
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)"),


       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                              __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args);
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
      void
      pop_front() noexcept
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     _Alloc_traits::destroy(this->_M_impl,
                            this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
      void
      pop_back() noexcept
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     _Alloc_traits::destroy(this->_M_impl,
                            this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
      iterator
      insert(const_iterator __position, const value_type& __x);
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
      void
      swap(deque& __x)

      noexcept(_Alloc_traits::_S_nothrow_swap())

      {
 _M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
      void
      _M_fill_initialize(const value_type& __value);



      void
      _M_default_initialize();
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
      template<typename... _Args>
        void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
        void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
        iterator
        _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();




      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);





      void
      _M_move_assign1(deque&& __x, true_type) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 __x.clear();
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }

      void
      _M_move_assign1(deque&& __x, false_type)
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign();
 _M_move_assign2(std::move(__x),
   integral_constant<bool, __move_storage>());
      }



      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {

 deque __newobj(std::forward<_Args>(__args)...);

 clear();
 _M_deallocate_node(*begin()._M_node);
 _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 this->_M_impl._M_map = nullptr;
 this->_M_impl._M_map_size = 0;

 this->_M_impl._M_swap_data(__newobj._M_impl);
      }


      void
      _M_move_assign2(deque&& __x, true_type)
      {

 auto __alloc = __x._M_get_Tp_allocator();


 _M_replace_map(std::move(__x));

 _M_get_Tp_allocator() = std::move(__alloc);
      }



      void
      _M_move_assign2(deque&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   {


     _M_replace_map(std::move(__x), __x.get_allocator());
   }
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }

    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }




}

namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
        _M_get_Tp_allocator());
          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
      this->_M_impl._M_finish._M_cur,
      _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {


    _M_replace_map(__x, __x.get_allocator());
    std::__alloc_on_copy(_M_get_Tp_allocator(),
           __x._M_get_Tp_allocator());
    return *this;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __len = size();
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);
      }



  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     emplace_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     emplace_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position._M_const_cast(),
          std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
 return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_default_a(this->_M_impl._M_finish,
          __new_finish,
          _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
 = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
 return false;

      const difference_type __back_capacity
 = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
 return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)

       emplace_back(*__first);



          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur,
                std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::move_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }



}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {

      typedef typename _Sequence::value_type _Sequence_value_type;




      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;

    public:
      explicit
      stack(const _Sequence& __c)
      : c(__c) { }

      explicit
      stack(_Sequence&& __c = _Sequence())
      : c(std::move(__c)) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      top()
      {
                              ;
 return c.back();
      }





      const_reference
      top() const
      {
                              ;
 return c.back();
      }
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
      void
      pop()
      {
                              ;
 c.pop_back();
      }


      void
      swap(stack& __s)
      noexcept(noexcept(swap(c, __s.c)))
      {
 using std::swap;
 swap(c, __s.c);
      }

    };
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline void
    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<stack<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };



}

namespace Rocket {
namespace Core {

class Stream;

typedef Dictionary XMLAttributes;





class __attribute__((visibility("default"))) BaseXMLParser
{
 public:
  BaseXMLParser();
  virtual ~BaseXMLParser();




  void RegisterCDATATag(const String& tag);



  void Parse(Stream* stream);



  int GetLineNumber();


  virtual void HandleElementStart(const String& name, const XMLAttributes& attributes);

  virtual void HandleElementEnd(const String& name);

  virtual void HandleData(const String& data);

 protected:

  Stream* xml_source;

 private:
  void ReadHeader();
  void ReadBody();

  bool ReadOpenTag();
  bool ReadCloseTag();
  bool ReadAttributes(XMLAttributes& attributes);
  bool ReadCDATA(const char* terminator = __null);




  bool FindWord(String& word, const char* terminators = __null);


  bool FindString(const unsigned char* string, String& data);



  bool PeekString(const unsigned char* string, bool consume = true);


  bool FillBuffer();

  unsigned char* read;
  unsigned char* buffer;
  int buffer_size;
  int buffer_used;
  int line_number;
  int open_tag_depth;


  XMLAttributes attributes;

  String data;

  std::set< String > cdata_tags;
};

}
}

namespace Rocket {
namespace Core {

class DocumentHeader;
class Element;
class XMLNodeHandler;







class __attribute__((visibility("default"))) XMLParser : public BaseXMLParser
{
public:
 XMLParser(Element* root);
 ~XMLParser();





 static XMLNodeHandler* RegisterNodeHandler(const String& tag, XMLNodeHandler* handler);

 static void ReleaseHandlers();



 DocumentHeader* GetDocumentHeader();


 const URL& GetSourceURL() const;


 struct ParseFrame
 {

  String tag;


  Element* element;


  XMLNodeHandler* node_handler;


  XMLNodeHandler* child_handler;
 };




 bool PushHandler(const String& tag);

 void PushDefaultHandler();



 const ParseFrame* GetParseFrame() const;

protected:

 virtual void HandleElementStart(const String& name, const XMLAttributes& attributes);

 virtual void HandleElementEnd(const String& name);

 virtual void HandleData(const String& data);

private:

 DocumentHeader* header;


 XMLNodeHandler* active_handler;


 typedef std::stack< ParseFrame > ParserStack;
 ParserStack stack;
};

}
}


namespace Rocket {
namespace Core {

class Element;
class __attribute__((visibility("default"))) ElementInstancer : public ReferenceCountable
{
public:
 virtual ~ElementInstancer();





 virtual Element* InstanceElement(Element* parent, const String& tag, const XMLAttributes& attributes) = 0;


 virtual void ReleaseElement(Element* element) = 0;

 virtual void Release() = 0;

protected:
 virtual void OnReferenceDeactivate();
};

}
}




namespace Urho3D
{




   class RocketDocumentElementInstancer : public ::Rocket::Core::ElementInstancer
   {




    virtual ::Rocket::Core::Element* InstanceElement(::Rocket::Core::Element* parent, const ::Rocket::Core::String& tag, const ::Rocket::Core::XMLAttributes& attributes);


    virtual void ReleaseElement(::Rocket::Core::Element* element);

    virtual void Release();
   };

   class RocketDocument : public Urho3D::Object, public ::Rocket::Core::ElementDocument
   {
    public: using ClassName = RocketDocument; using BaseClassName = Urho3D::Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RocketDocument", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };
   public:
    RocketDocument(Urho3D::Context* context);
    ~RocketDocument();
       RocketDocument(const ::Rocket::Core::String& tag);
       void SetContext(Urho3D::Context* context);
       virtual void LoadScript(::Rocket::Core::Stream* stream, const ::Rocket::Core::String& source_name);
       Urho3D::ScriptFile* GetScript() const { return script_.Get(); }
    static void RegisterObject(Urho3D::Context* context);

    void AddReference();
    void RemoveReference();
   protected:
   private:
    static WeakPtr<Urho3D::Context> globalContext;
    SharedPtr<Urho3D::ScriptFile> script_;

    PODVector<unsigned char> buffer_;
   };


}








namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };


}













namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}






namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    private:
      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:

      constexpr default_delete() noexcept = default;
      template<typename _Up, typename = typename
        enable_if<!__is_derived_Tp<_Up>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }

      template<typename _Up>
 typename enable_if<__is_derived_Tp<_Up>::value>::type
 operator()(_Up*) const = delete;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
        __not_<is_array<_Up>>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
      template<typename _Up, typename _Ep>
 typename enable_if< __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
   >::value,
   unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
                                          ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
                                          ;
 return get();
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

      template<typename _Up, typename _Ep,
        typename _Tp_pointer = typename _Pointer::type,
        typename _Up_pointer = typename unique_ptr<_Up, _Ep>::pointer>
 using __safe_conversion = __and_<
     is_convertible<_Up_pointer, _Tp_pointer>,
     is_array<_Up>,
     __or_<__not_<is_pointer<_Up_pointer>>,
    __not_<is_pointer<_Tp_pointer>>,
    __not_<__is_derived_Tp<typename remove_extent<_Up>::type>>
     >
   >;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 explicit
 unique_ptr(_Up* __p) = delete;
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
       deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
      unique_ptr(pointer __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion<_Up, _Ep>,
   typename conditional<is_reference<_Dp>::value,
          is_same<_Ep, _Dp>,
          is_convertible<_Ep, _Dp>>::type
        >>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
      template<typename _Up, typename _Ep>
 typename
 enable_if<__safe_conversion<_Up, _Ep>::value, unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
                                          ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 void reset(_Up*) = delete;


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 unique_ptr(_Up*, typename
     conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type) = delete;


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 unique_ptr(_Up*, typename
     remove_reference<deleter_type>::type&&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(&__a), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(&__a), _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return _S_raw_ptr(_M_ptr); }

    private:
      value_type* _S_raw_ptr(value_type* __ptr) { return __ptr; }

      template<typename _Ptr>
 auto _S_raw_ptr(_Ptr __ptr) -> decltype(_S_raw_ptr(__ptr.operator->()))
 { return _S_raw_ptr(__ptr.operator->()); }

      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}


namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename> class auto_ptr;






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const*
    what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

                                                              ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
                                                                 ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
         __asm __volatile ("":::"memory");
         __asm __volatile ("":::"memory");
       }


                                                                   ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                                                                      ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

                                                               ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
                                                                  ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


         __asm __volatile ("":::"memory");
         __asm __volatile ("":::"memory");
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag { };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;

      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }


      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {

 if (__ti == typeid(_Sp_make_shared_tag))
   return const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());

 return nullptr;
      }

    private:
      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr, typename _Deleter>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
         _Args&&... __args)
 : _M_pi(0)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   ::new (__mem) _Sp_cp_type(std::move(__a),
        std::forward<_Args>(__args)...);
   _M_pi = __mem;
   __guard = nullptr;
 }



      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {
   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }




  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&,
         const __enable_shared_from_this<_Tp1,
         _Lp>*, const _Tp2*) noexcept;


  template<typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<>&,
         const enable_shared_from_this<_Tp1>*,
         const _Tp2*) noexcept;

  template<_Lock_policy _Lp>
    inline void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
      template<typename _Ptr>
 using _Convertible
   = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;

    public:
      typedef _Tp element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
 explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
 {

   static_assert( !is_void<_Tp1>::value, "incomplete type" );
   static_assert( sizeof(_Tp1) > 0, "incomplete type" );
   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Tp1, typename _Deleter>
 __shared_ptr(_Tp1* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, __d)
 {


   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
 __shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))
 {


   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, __d)
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, __d, std::move(__a))
 { }

      template<typename _Tp1>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Tp1>
 explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {




   _M_ptr = __r._M_ptr;
 }


      template<typename _Tp1, typename _Del, typename
        = _Convertible<typename unique_ptr<_Tp1, _Del>::pointer>>
 __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {

   auto __raw = _S_raw_ptr(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __raw, __raw);
 }



      template<typename _Tp1>
 __shared_ptr(std::auto_ptr<_Tp1>&& __r);


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Tp1>
 __shared_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


      template<typename _Tp1>
 __shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Tp1>
 __shared_ptr&
 operator=(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Tp1, typename _Del>
 __shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Tp1>
 void
 reset(_Tp1* __p)
 {

                                                   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Tp1, typename _Deleter>
 void
 reset(_Tp1* __p, _Deleter __d)
 { __shared_ptr(__p, __d).swap(*this); }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
 void
        reset(_Tp1* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, __d, std::move(__a)).swap(*this); }


      typename std::add_lvalue_reference<_Tp>::type
      operator*() const noexcept
      {
                                   ;
 return *_M_ptr;
      }

      _Tp*
      operator->() const noexcept
      {
                                   ;
 return _M_ptr;
      }

      _Tp*
      get() const noexcept
      { return _M_ptr; }

      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }

      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
       _Args&&... __args)
 : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
 {


   void* __p = _M_refcount._M_get_deleter(typeid(__tag));
   _M_ptr = static_cast<_Tp*>(__p);
   __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
 }
      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:
      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1>
 static _Tp1*
 _S_raw_ptr(_Tp1* __ptr)
 { return __ptr; }

      template<typename _Tp1>
 static auto
 _S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))
 { return std::__addressof(*__ptr); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      _Tp* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    {
      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
      return std::less<_CT>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept
      {
 typedef typename _Sp::element_type element_type;
 return std::less<element_type*>()(__lhs.get(), __rhs.get());
      }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return __shared_ptr<_Tp, _Lp>(__r, __p);
      return __shared_ptr<_Tp, _Lp>();
    }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Ptr>
 using _Convertible
   = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;

    public:
      typedef _Tp element_type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 __weak_ptr(__weak_ptr<_Tp1, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Tp1>
 __weak_ptr&
 operator=(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Tp1>
 __weak_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Tp1>
 __weak_ptr&
 operator=(__weak_ptr<_Tp1, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 _M_ptr = __ptr;
 _M_refcount = __refcount;
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      _Tp* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
 friend void
 __enable_shared_from_this_helper(const __shared_count<_Lp1>&,
      const __enable_shared_from_this<_Tp1,
      _Lp1>*, const _Tp2*) noexcept;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<_Lock_policy _Lp1, typename _Tp1, typename _Tp2>
    inline void
    __enable_shared_from_this_helper(const __shared_count<_Lp1>& __pn,
         const __enable_shared_from_this<_Tp1,
         _Lp1>* __pe,
         const _Tp2* __px) noexcept
    {
      if (__pe != nullptr)
 __pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
    }

  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      { return std::hash<_Tp*>()(__s.get()); }
    };


}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }


  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename _Ptr>
 using _Convertible
   = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;

    public:




      constexpr shared_ptr() noexcept
      : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Tp1>
 explicit shared_ptr(_Tp1* __p)
        : __shared_ptr<_Tp>(__p) { }
      template<typename _Tp1, typename _Deleter>
 shared_ptr(_Tp1* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
      template<typename _Tp1, typename _Deleter, typename _Alloc>
 shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
      template<typename _Tp1>
 shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 shared_ptr(const shared_ptr<_Tp1>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 shared_ptr(shared_ptr<_Tp1>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
      template<typename _Tp1>
 explicit shared_ptr(const weak_ptr<_Tp1>& __r)
 : __shared_ptr<_Tp>(__r) { }


      template<typename _Tp1>
 shared_ptr(std::auto_ptr<_Tp1>&& __r);




      template<typename _Tp1, typename _Del, typename
        = _Convertible<typename unique_ptr<_Tp1, _Del>::pointer>>
 shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }





      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Tp1>
 shared_ptr&
 operator=(const shared_ptr<_Tp1>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


      template<typename _Tp1>
 shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Tp1>
 shared_ptr&
 operator=(shared_ptr<_Tp1>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Tp1, typename _Del>
 shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
     _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
 { }

      template<typename _Tp1, typename _Alloc, typename... _Args>
 friend shared_ptr<_Tp1>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };


  template<typename _Tp1, typename _Tp2>
    inline bool
    operator==(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator!=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<(const shared_ptr<_Tp1>& __a,
       const shared_ptr<_Tp2>& __b) noexcept
    {
      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
      return std::less<_CT>()(__a.get(), __b.get());
    }

  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator>(const shared_ptr<_Tp1>& __a,
       const shared_ptr<_Tp2>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator>=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
    { };


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }


  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return shared_ptr<_Tp>(__r, __p);
      return shared_ptr<_Tp>();
    }







  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Ptr>
 using _Convertible
   = typename enable_if<is_convertible<_Ptr, _Tp*>::value>::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 weak_ptr(const shared_ptr<_Tp1>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 weak_ptr(const weak_ptr<_Tp1>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Tp1, typename = _Convertible<_Tp1*>>
 weak_ptr(weak_ptr<_Tp1>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Tp1>
 weak_ptr&
 operator=(const weak_ptr<_Tp1>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Tp1>
 weak_ptr&
 operator=(const shared_ptr<_Tp1>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Tp1>
 weak_ptr&
 operator=(weak_ptr<_Tp1>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };


  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp>
    struct owner_less;


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1, typename _Tp2>
 friend void
 __enable_shared_from_this_helper(const __shared_count<>&,
      const enable_shared_from_this<_Tp1>*,
      const _Tp2*) noexcept;

      mutable weak_ptr<_Tp> _M_weak_this;
    };

  template<typename _Tp1, typename _Tp2>
    inline void
    __enable_shared_from_this_helper(const __shared_count<>& __pn,
         const enable_shared_from_this<_Tp1>*
         __pe, const _Tp2* __px) noexcept
    {
      if (__pe != nullptr)
 __pe->_M_weak_assign(const_cast<_Tp2*>(__px), __pn);
    }
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      { return std::hash<_Tp*>()(__s.get()); }
    };




}








namespace std __attribute__ ((__visibility__ ("default")))
{
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;

  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(__m | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(__m & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | (__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(__m); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(__m); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }



  template<typename _IntTp>
    struct __atomic_base;




  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b = __m & __memory_order_mask;
                                                   ;
                                                   ;
                                                   ;

      __atomic_clear (&_M_i, __m);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b = __m & __memory_order_mask;
                                                   ;
                                                   ;
                                                   ;

      __atomic_clear (&_M_i, __m);
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
  template<typename _ITp>
    struct __atomic_base
    {
    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-__alignof(_M_i)));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
        memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
       memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
        memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_i, __m);
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, __m);
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, __m);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
       memory_order __b2 = __m2 & __memory_order_mask;
       memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
       memory_order __b2 = __m2 & __memory_order_mask;
       memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
        memory_order __b2 = __m2 & __memory_order_mask;
        memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
        memory_order __b2 = __m2 & __memory_order_mask;
        memory_order __b1 = __m1 & __memory_order_mask;

                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, __m); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, __m); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      memory_order_seq_cst); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      memory_order_seq_cst); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;

                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
        memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;
                                              ;

 __atomic_store_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
        memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
        memory_order __b = __m & __memory_order_mask;
                                              ;
                                              ;

 return __atomic_load_n(&_M_p, __m);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, __m);
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, __m);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
        memory_order __b2 = __m2 & __memory_order_mask;
        memory_order __b1 = __m1 & __memory_order_mask;
                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
        memory_order __b2 = __m2 & __memory_order_mask;
        memory_order __b1 = __m1 & __memory_order_mask;

                                               ;
                                               ;
                               ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);
      }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }
    };




}

namespace std __attribute__ ((__visibility__ ("default")))
{







  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };







  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }





}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
      ~auto_ptr() { delete _M_ptr; }
      element_type&
      operator*() const throw()
      {
                                   ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                                   ;
 return _M_ptr;
      }
      element_type*
      get() const throw() { return _M_ptr; }
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {

      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
    }

  template<typename _Tp>
  template<typename _Tp1>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }



}








namespace std __attribute__ ((__visibility__ ("default")))
{
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{
  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if ((__size + __diff) > __space)
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;



namespace __detail
{







  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    {
      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
      return __distance_fw(__first, __last, _Tag());
    }


  template <typename _Key, typename _Hash>
    struct __is_noexcept_hash : std::__bool_constant<
 noexcept(declval<const _Hash&>()(declval<const _Key&>()))>
    { };

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __value_alloc_type = typename __hashtable_alloc::__value_alloc_type;
      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
 : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       __value_alloc_type __a(_M_h._M_node_allocator());
       __value_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __value_alloc_traits::construct(__a, __node->_M_valptr(),
        std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    __node->~__node_type();
    __node_alloc_traits::deallocate(_M_h._M_node_allocator(),
        __node, 1);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
 : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base : _Hash_node_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
    {
      std::size_t _M_hash_code;

      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    noexcept
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::tuple<const key_type&>(__k),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::forward_as_tuple(std::move(__k)),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    -> const mapped_type&
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&);

    public:
      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
      }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen);
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __unique_keys());
      }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      std::pair<iterator, bool>
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      iterator
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits, bool _Unique_keys>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false, _Unique_keys>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys(),
    std::forward<_Pair>(__v));
 }
   };







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _Prime_rehash_policy, _Traits>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _Prime_rehash_policy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_Prime_rehash_policy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__builtin_ceil(__n / max_load_factor()));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _Tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return static_cast<const _Tp&>(__eboh); }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
      { return _M_ranged_hash()(__k, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
         (std::size_t)0)) )
      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_ranged_hash(), __x._M_ranged_hash());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }

      _Hash&
      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
    && noexcept(declval<const _H2&>()((__hash_code)0,
          (std::size_t)0)) )
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;


      _Hash_code_base() = default;
      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _M_h2()(__p->_M_hash_code, __n); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };





  template <typename _Key, typename _Value, typename _ExtractKey,
     typename _Equal, typename _HashCodeType,
     bool __cache_hash_code>
  struct _Equal_helper;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }
  };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
    { return __eq(__k, __extract(__n->_M_v())); }
  };



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != -1)
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
        _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 _M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() == __y._M_curr(); }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() != __y._M_curr(); }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __p,
        std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __p,
       std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
 : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
    using _EqualHelper = _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
     __hash_code, __hash_cached::value>;

  protected:
    _Hashtable_base() = default;
    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
         __k, __c, __n);
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_M_eq(), __x._M_eq());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_S_cget(*this); }

    _Equal&
    _M_eq() { return _EqualEBO::_S_get(*this); }
  };






  struct _Equality_base
  {
  protected:
    template<typename _Uiterator>
      static bool
      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
  };


  template<typename _Uiterator>
    bool
    _Equality_base::
    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
        _Uiterator __first2)
    {
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;

      _Uiterator __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));

      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
 {
   _Uiterator __tmp = __first1;
   while (__tmp != __it1 && !bool(*__tmp == *__it1))
     ++__tmp;


   if (__tmp != __it1)
     continue;

   std::ptrdiff_t __n2 = 0;
   for (__tmp = __first2; __tmp != __last2; ++__tmp)
     if (*__tmp == *__it1)
       ++__n2;

   if (!__n2)
     return false;

   std::ptrdiff_t __n1 = 0;
   for (__tmp = __it1; __tmp != __last1; ++__tmp)
     if (*__tmp == *__it1)
       ++__n1;

   if (__n1 != __n2)
     return false;
 }
      return true;
    }
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   const auto __ity = __other.find(_ExtractKey()(*__itx));
   if (__ity == __other.end() || !bool(*__ity == *__itx))
     return false;
 }
      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    : public _Equality_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
   const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));

   if (std::distance(__xrange.first, __xrange.second)
       != std::distance(__yrange.first, __yrange.second))
     return false;

   if (!_S_is_permutation(__xrange.first, __xrange.second,
     __yrange.first))
     return false;

   __itx = __xrange.second;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_type = typename __node_type::value_type;
      using __value_alloc_type =
 __alloc_rebind<__node_alloc_type, __value_type>;
      using __value_alloc_traits = std::allocator_traits<__value_alloc_type>;

      using __node_base = __detail::_Hash_node_base;
      using __bucket_type = __node_base*;
      using __bucket_alloc_type =
 __alloc_rebind<__node_alloc_type, __bucket_type>;
      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
   : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_S_get(*this); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_S_cget(*this); }

      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);

      void
      _M_deallocate_node(__node_type* __n);


      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(std::size_t __n);

      void
      _M_deallocate_buckets(__bucket_type*, std::size_t __n);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      typename _Hashtable_alloc<_NodeAlloc>::__node_type*
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_type* __n = std::__addressof(*__nptr);
 try
   {
     __value_alloc_type __a(_M_node_allocator());
     ::new ((void*)__n) __node_type;
     __value_alloc_traits::construct(__a, __n->_M_valptr(),
         std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __value_alloc_type __a(_M_node_allocator());
      __value_alloc_traits::destroy(__a, __n->_M_valptr());
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)
    {
      __bucket_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
      __bucket_type* __p = std::__addressof(*__ptr);
      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
       std::size_t __n)
    {
      typedef typename __bucket_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __bucket_alloc_type __alloc(_M_node_allocator());
      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);
    }



}
}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __detail::__is_noexcept_hash<_Tp, _Hash>>>;
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 typename __alloctr_rebind<_Alloc,
   __detail::_Hash_node<_Value,
          _Traits::__hash_cached::value> >::__type>
    {
      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type =
 typename __alloctr_rebind<_Alloc, __node_type>::__type;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __bucket_type = typename __hashtable_alloc::__bucket_type;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_type =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;


      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
        ._M_bucket_index((const __node_type*)nullptr,
           (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");






      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa, bool _Unique_keysa>
 friend struct __detail::_Insert;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;

    private:
      __bucket_type* _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __bucket_type _M_single_bucket = nullptr;

      bool
      _M_uses_single_bucket(__bucket_type* __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __bucket_type*
      _M_allocate_buckets(size_type __n)
      {
 if (__builtin_expect(__n == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__n);
      }

      void
      _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __n);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }

      template<typename _NodeGenerator>
 void
 _M_assign(const _Hashtable&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, std::true_type);

      void
      _M_move_assign(_Hashtable&&, std::false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
 : __hashtable_base(__exk, __h1, __h2, __h, __eq),
   __hashtable_alloc(__node_alloc_type(__a))
      { }

    public:

      _Hashtable() = default;
      _Hashtable(size_type __bucket_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bucket_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&&) noexcept;

      _Hashtable(const _Hashtable&, const allocator_type&);

      _Hashtable(_Hashtable&&, const allocator_type&);


      explicit
      _Hashtable(const allocator_type& __a)
 : __hashtable_alloc(__node_alloc_type(__a))
      { }

      explicit
      _Hashtable(size_type __n,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __n = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __n = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          __node_alloc_traits::_S_propagate_on_move_assign()
          || __node_alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__ht),
                       integral_constant<bool, __move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_type __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();
 this->_M_insert_range(__l.begin(), __l.end(), __roan);
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__node_alloc_traits::_S_nothrow_swap());


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __n) const
      { return std::distance(begin(__n), end(__n)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __n)
      {
 return local_iterator(*this, _M_bucket_begin(__n),
         __n, _M_bucket_count);
      }

      local_iterator
      end(size_type __n)
      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }

      const_local_iterator
      begin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy&);


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code __code,
       __node_type* __n);



      iterator
      _M_insert_multi_node(__node_type* __hint,
      __hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(std::true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(std::false_type __uk, _Args&&... __args)
 { return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)
 { return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::false_type, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, std::true_type);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    std::false_type __uk)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uk);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, std::true_type __uk)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, std::false_type);

      size_type
      _M_erase(std::true_type, const key_type&);

      size_type
      _M_erase(std::false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys(),
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;


      void rehash(size_type __n);




    private:

      void _M_rehash_aux(size_type __n, std::true_type);


      void _M_rehash_aux(size_type __n, std::false_type);



      void _M_rehash(size_type __n, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    -> __node_type*
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bucket_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
    {
      auto __bkt = _M_rehash_policy._M_next_bkt(__bucket_hint);
      if (__bkt > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt);
   _M_bucket_count = __bkt;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bucket_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
 : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bucket_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 try
   {
     for (; __f != __l; ++__f)
       this->insert(*__f);
   }
 catch(...)
   {
     clear();
     _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       try
  {
    _M_assign(__ht,
       [this](const __node_type* __n)
       { return this->_M_allocate_node(__n->_M_v()); });
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      __bucket_type* __former_buckets = nullptr;
      std::size_t __former_bucket_count = _M_bucket_count;
      const __rehash_state& __former_state = _M_rehash_policy._M_state();

      if (_M_bucket_count != __ht._M_bucket_count)
 {
   __former_buckets = _M_buckets;
   _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
   _M_bucket_count = __ht._M_bucket_count;
 }
      else
 __builtin_memset(_M_buckets, 0,
    _M_bucket_count * sizeof(__bucket_type));

      try
 {
   __hashtable_base::operator=(__ht);
   _M_element_count = __ht._M_element_count;
   _M_rehash_policy = __ht._M_rehash_policy;
   __reuse_or_alloc_node_type __roan(_M_begin(), *this);
   _M_before_begin._M_nxt = nullptr;
   _M_assign(__ht,
      [&__roan](const __node_type* __n)
      { return __roan(__n->_M_v()); });
   if (__former_buckets)
     _M_deallocate_buckets(__former_buckets, __former_bucket_count);
 }
      catch(...)
 {
   if (__former_buckets)
     {

       _M_deallocate_buckets();
       _M_rehash_policy._M_reset(__former_state);
       _M_buckets = __former_buckets;
       _M_bucket_count = __former_bucket_count;
     }
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__bucket_type));
   throw;
 }
      return *this;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_type* __ht_n = __ht._M_begin();
     __node_type* __this_n = __node_gen(__ht_n);
     this->_M_copy_code(__this_n, __ht_n);
     _M_before_begin._M_nxt = __this_n;
     _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;


     __node_base* __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__ht_n);
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(__this_n, __ht_n);
  size_type __bkt = _M_bucket_index(__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::true_type)
    {
      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }
      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), std::true_type());
      else
 {

   __bucket_type* __former_buckets = nullptr;
   size_type __former_bucket_count = _M_bucket_count;
   const __rehash_state& __former_state = _M_rehash_policy._M_state();

   if (_M_bucket_count != __ht._M_bucket_count)
     {
       __former_buckets = _M_buckets;
       _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
       _M_bucket_count = __ht._M_bucket_count;
     }
   else
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));

   try
     {
       __hashtable_base::operator=(std::move(__ht));
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       __reuse_or_alloc_node_type __roan(_M_begin(), *this);
       _M_before_begin._M_nxt = nullptr;
       _M_assign(__ht,
   [&__roan](__node_type* __n)
   { return __roan(std::move_if_noexcept(__n->_M_v())); });
       __ht.clear();
     }
   catch(...)
     {
       if (__former_buckets)
  {
    _M_deallocate_buckets();
    _M_rehash_policy._M_reset(__former_state);
    _M_buckets = __former_buckets;
    _M_bucket_count = __former_bucket_count;
  }
       __builtin_memset(_M_buckets, 0,
          _M_bucket_count * sizeof(__bucket_type));
       throw;
     }
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht) noexcept
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__ht._M_base_alloc())),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;

   _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;


   if (_M_begin())
     _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
   __ht._M_reset();
 }
      else
 {
   _M_assign(__ht,
      [this](__node_type* __n)
      {
        return this->_M_allocate_node(
     std::move_if_noexcept(__n->_M_v()));
      });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__node_alloc_traits::_S_nothrow_swap())
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &__x._M_before_begin;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    __rehash_policy(const _RehashPolicy& __pol)
    {
      auto __do_rehash =
 __pol._M_need_rehash(_M_bucket_count, _M_element_count, 0);
      if (__do_rehash.first)
 _M_rehash(__do_rehash.second, _M_rehash_policy._M_state());
      _M_rehash_policy = __pol;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? const_iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__n);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __n, const key_type& __k,
   __hash_code __code) const
    -> __node_base*
    {
      __node_base* __prev_p = _M_buckets[__n];
      if (!__prev_p)
 return nullptr;

      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    -> __node_base*
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(std::true_type, _Args&&... __args)
      -> pair<iterator, bool>
      {

 __node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);
 const key_type& __k = this->_M_extract()(__node->_M_v());
 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(__k);
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))
   {

     this->_M_deallocate_node(__node);
     return std::make_pair(iterator(__p), false);
   }


 return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
         true);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)
      -> iterator
      {

 __node_type* __node =
   this->_M_allocate_node(std::forward<_Args>(__args)...);

 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     {
       _M_rehash(__do_rehash.second, __saved_state);
       __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);
     }

   this->_M_store_code(__node, __code);


   _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_type* __hint, __hash_code __code,
    __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     _M_rehash(__do_rehash.second, __saved_state);

   this->_M_store_code(__node, __code);
   const key_type& __k = this->_M_extract()(__node->_M_v());
   size_type __bkt = _M_bucket_index(__k, __code);



   __node_base* __prev
     = __builtin_expect(__hint != nullptr, false)
       && this->_M_equals(__k, __code, __hint)
  ? __hint
  : _M_find_before_node(__bkt, __k, __code);
   if (__prev)
     {

       __node->_M_nxt = __prev->_M_nxt;
       __prev->_M_nxt = __node;
       if (__builtin_expect(__prev == __hint, false))


        if (__node->_M_nxt
            && !this->_M_equals(__k, __code, __node->_M_next()))
          {
            size_type __next_bkt = _M_bucket_index(__node->_M_next());
            if (__next_bkt != __bkt)
              _M_buckets[__next_bkt] = __node;
          }
     }
   else




     _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, std::true_type)
      -> pair<iterator, bool>
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 __node_type* __n = _M_find_node(__bkt, __k, __code);
 if (__n)
   return std::make_pair(iterator(__n), false);

 __n = __node_gen(std::forward<_Arg>(__v));
 return std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen, std::false_type)
      -> iterator
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 __node_type* __node = __node_gen(std::forward<_Arg>(__v));

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::true_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::false_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __n)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::size_t __buckets
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __n);
      __buckets = _M_rehash_policy._M_next_bkt(__buckets);

      if (__buckets != _M_bucket_count)
 _M_rehash(__buckets, __saved_state);
      else

 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __n, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__n, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);

      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __n);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }


}
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;





      unordered_map() = default;
      explicit
      unordered_map(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
      : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
      : _M_h(std::move(__umap._M_h), __a)
      { }
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a)
      { }

      unordered_map(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
   : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_map(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 std::pair<iterator, bool>
 insert(_Pair&& __x)
        { return _M_h.insert(std::forward<_Pair>(__x)); }
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
      operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
   const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;





      unordered_multimap() = default;
      explicit
      unordered_multimap(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
      : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
      : _M_h(std::move(__ummap._M_h), __a)
      { }
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(_Pair&& __x)
        { return _M_h.insert(std::forward<_Pair>(__x)); }
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


}


namespace Rocket {
namespace Core {

class Element;







class __attribute__((visibility("default"))) ElementReference
{
public:
 ElementReference(Element* element = __null);
 ElementReference(const ElementReference& copy);
 ~ElementReference();



 operator bool() const;




 ElementReference& operator=(Element* element);



 ElementReference& operator=(const ElementReference& element_reference);



 Element* operator*();


 Element* operator->();




 bool operator==(const ElementReference& rhs) const;



 bool operator==(const Element* rhs) const;




 bool operator<(const ElementReference& rhs) const;




 bool operator!=(const ElementReference& rhs) const;



 bool operator!=(const Element* rhs) const;

private:
 Element* element;
};

}
}
namespace Rocket {
namespace Core {







namespace Input
{
 enum KeyIdentifier
 {
  KI_UNKNOWN = 0,

  KI_SPACE = 1,

  KI_0 = 2,
  KI_1 = 3,
  KI_2 = 4,
  KI_3 = 5,
  KI_4 = 6,
  KI_5 = 7,
  KI_6 = 8,
  KI_7 = 9,
  KI_8 = 10,
  KI_9 = 11,

  KI_A = 12,
  KI_B = 13,
  KI_C = 14,
  KI_D = 15,
  KI_E = 16,
  KI_F = 17,
  KI_G = 18,
  KI_H = 19,
  KI_I = 20,
  KI_J = 21,
  KI_K = 22,
  KI_L = 23,
  KI_M = 24,
  KI_N = 25,
  KI_O = 26,
  KI_P = 27,
  KI_Q = 28,
  KI_R = 29,
  KI_S = 30,
  KI_T = 31,
  KI_U = 32,
  KI_V = 33,
  KI_W = 34,
  KI_X = 35,
  KI_Y = 36,
  KI_Z = 37,

  KI_OEM_1 = 38,
  KI_OEM_PLUS = 39,
  KI_OEM_COMMA = 40,
  KI_OEM_MINUS = 41,
  KI_OEM_PERIOD = 42,
  KI_OEM_2 = 43,
  KI_OEM_3 = 44,

  KI_OEM_4 = 45,
  KI_OEM_5 = 46,
  KI_OEM_6 = 47,
  KI_OEM_7 = 48,
  KI_OEM_8 = 49,

  KI_OEM_102 = 50,

  KI_NUMPAD0 = 51,
  KI_NUMPAD1 = 52,
  KI_NUMPAD2 = 53,
  KI_NUMPAD3 = 54,
  KI_NUMPAD4 = 55,
  KI_NUMPAD5 = 56,
  KI_NUMPAD6 = 57,
  KI_NUMPAD7 = 58,
  KI_NUMPAD8 = 59,
  KI_NUMPAD9 = 60,
  KI_NUMPADENTER = 61,
  KI_MULTIPLY = 62,
  KI_ADD = 63,
  KI_SEPARATOR = 64,
  KI_SUBTRACT = 65,
  KI_DECIMAL = 66,
  KI_DIVIDE = 67,




  KI_OEM_NEC_EQUAL = 68,

  KI_BACK = 69,
  KI_TAB = 70,

  KI_CLEAR = 71,
  KI_RETURN = 72,

  KI_PAUSE = 73,
  KI_CAPITAL = 74,

  KI_KANA = 75,
  KI_HANGUL = 76,
  KI_JUNJA = 77,
  KI_FINAL = 78,
  KI_HANJA = 79,
  KI_KANJI = 80,

  KI_ESCAPE = 81,

  KI_CONVERT = 82,
  KI_NONCONVERT = 83,
  KI_ACCEPT = 84,
  KI_MODECHANGE = 85,

  KI_PRIOR = 86,
  KI_NEXT = 87,
  KI_END = 88,
  KI_HOME = 89,
  KI_LEFT = 90,
  KI_UP = 91,
  KI_RIGHT = 92,
  KI_DOWN = 93,
  KI_SELECT = 94,
  KI_PRINT = 95,
  KI_EXECUTE = 96,
  KI_SNAPSHOT = 97,
  KI_INSERT = 98,
  KI_DELETE = 99,
  KI_HELP = 100,

  KI_LWIN = 101,
  KI_RWIN = 102,
  KI_APPS = 103,

  KI_POWER = 104,
  KI_SLEEP = 105,
  KI_WAKE = 106,

  KI_F1 = 107,
  KI_F2 = 108,
  KI_F3 = 109,
  KI_F4 = 110,
  KI_F5 = 111,
  KI_F6 = 112,
  KI_F7 = 113,
  KI_F8 = 114,
  KI_F9 = 115,
  KI_F10 = 116,
  KI_F11 = 117,
  KI_F12 = 118,
  KI_F13 = 119,
  KI_F14 = 120,
  KI_F15 = 121,
  KI_F16 = 122,
  KI_F17 = 123,
  KI_F18 = 124,
  KI_F19 = 125,
  KI_F20 = 126,
  KI_F21 = 127,
  KI_F22 = 128,
  KI_F23 = 129,
  KI_F24 = 130,

  KI_NUMLOCK = 131,
  KI_SCROLL = 132,




  KI_OEM_FJ_JISHO = 133,
  KI_OEM_FJ_MASSHOU = 134,
  KI_OEM_FJ_TOUROKU = 135,
  KI_OEM_FJ_LOYA = 136,
  KI_OEM_FJ_ROYA = 137,

  KI_LSHIFT = 138,
  KI_RSHIFT = 139,
  KI_LCONTROL = 140,
  KI_RCONTROL = 141,
  KI_LMENU = 142,
  KI_RMENU = 143,

  KI_BROWSER_BACK = 144,
  KI_BROWSER_FORWARD = 145,
  KI_BROWSER_REFRESH = 146,
  KI_BROWSER_STOP = 147,
  KI_BROWSER_SEARCH = 148,
  KI_BROWSER_FAVORITES = 149,
  KI_BROWSER_HOME = 150,

  KI_VOLUME_MUTE = 151,
  KI_VOLUME_DOWN = 152,
  KI_VOLUME_UP = 153,
  KI_MEDIA_NEXT_TRACK = 154,
  KI_MEDIA_PREV_TRACK = 155,
  KI_MEDIA_STOP = 156,
  KI_MEDIA_PLAY_PAUSE = 157,
  KI_LAUNCH_MAIL = 158,
  KI_LAUNCH_MEDIA_SELECT = 159,
  KI_LAUNCH_APP1 = 160,
  KI_LAUNCH_APP2 = 161,




  KI_OEM_AX = 162,
  KI_ICO_HELP = 163,
  KI_ICO_00 = 164,

  KI_PROCESSKEY = 165,

  KI_ICO_CLEAR = 166,

  KI_ATTN = 167,
  KI_CRSEL = 168,
  KI_EXSEL = 169,
  KI_EREOF = 170,
  KI_PLAY = 171,
  KI_ZOOM = 172,
  KI_PA1 = 173,
  KI_OEM_CLEAR = 174,

  KI_LMETA = 175,
  KI_RMETA = 176
 };

 enum KeyModifier
 {
  KM_CTRL = 1 << 0,
  KM_SHIFT = 1 << 1,
  KM_ALT = 1 << 2,
  KM_META = 1 << 3,
  KM_CAPSLOCK = 1 << 4,
  KM_NUMLOCK = 1 << 5,
  KM_SCROLLLOCK = 1 << 6
 };
}

}
}



namespace Rocket {
namespace Core {

class Stream;
class Dictionary;

}
}

namespace Rocket {
namespace Core {

class ContextInstancer;
class ElementDocument;
class EventListener;
class RenderInterface;







class __attribute__((visibility("default"))) Context : public ScriptInterface
{
public:



 Context(const String& name);

 virtual ~Context();



 const String& GetName() const;



 void SetDimensions(const Vector2i& dimensions);


 const Vector2i& GetDimensions() const;


 bool Update();

 bool Render();




 ElementDocument* CreateDocument(const String& tag = "body");



 ElementDocument* LoadDocument(const String& document_path);



 ElementDocument* LoadDocument(Stream* document_stream);



 ElementDocument* LoadDocumentFromMemory(const String& string);


 void UnloadDocument(ElementDocument* document);

 void UnloadAllDocuments();




 void AddMouseCursor(ElementDocument* cursor_document);



 ElementDocument* LoadMouseCursor(const String& cursor_document_path);


 void UnloadMouseCursor(const String& cursor_name);

 void UnloadAllMouseCursors();



 bool SetMouseCursor(const String& cursor_name);


 void ShowMouseCursor(bool show);




 ElementDocument* GetDocument(const String& id);



 ElementDocument* GetDocument(int index);


 int GetNumDocuments() const;



 Element* GetHoverElement();



 Element* GetFocusElement();



 Element* GetRootElement();



 void PullDocumentToFront(ElementDocument* document);


 void PushDocumentToBack(ElementDocument* document);





 void AddEventListener(const String& event, EventListener* listener, bool in_capture_phase = false);




 void RemoveEventListener(const String& event, EventListener* listener, bool in_capture_phase = false);





 bool ProcessKeyDown(Input::KeyIdentifier key_identifier, int key_modifier_state);




 bool ProcessKeyUp(Input::KeyIdentifier key_identifier, int key_modifier_state);




 bool ProcessTextInput(word character);



 bool ProcessTextInput(const String& string);





 void ProcessMouseMove(int x, int y, int key_modifier_state);



 void ProcessMouseButtonDown(int button_index, int key_modifier_state);



 void ProcessMouseButtonUp(int button_index, int key_modifier_state);




 bool ProcessMouseWheel(int wheel_delta, int key_modifier_state);



 RenderInterface* GetRenderInterface() const;



 bool GetActiveClipRegion(Vector2i& origin, Vector2i& dimensions) const;



 void SetActiveClipRegion(const Vector2i& origin, const Vector2i& dimensions);



 void SetInstancer(ContextInstancer* instancer);

protected:
 virtual void OnReferenceDeactivate();

private:
 String name;
 Vector2i dimensions;

 ContextInstancer* instancer;

 typedef std::set< ElementReference > ElementSet;
 typedef std::vector< ElementReference > ElementList;

 ElementSet hover_chain;

 ElementList active_chain;

 ElementList document_focus_history;


 ElementList unloaded_documents;


 Element* root;

 ElementReference focus;

 ElementReference hover;

 ElementReference active;


 Element* last_click_element;

 float last_click_time;

 typedef std::map< String, ElementDocument* > CursorMap;
 CursorMap cursors;
 ElementReference default_cursor;
 ElementReference active_cursor;
 bool show_cursor;

 ElementDocument* cursor_proxy;


 ElementReference drag;

 bool drag_started;

 bool drag_verbose;

 Element* drag_clone;



 ElementReference drag_hover;


 ElementSet drag_hover_chain;


 Vector2i mouse_position;


 RenderInterface* render_interface;
 Vector2i clip_origin;
 Vector2i clip_dimensions;


 void OnElementRemove(Element* element);

 bool OnFocusChange(Element* element);


 void GenerateClickEvent(Element* element);


 void UpdateHoverChain(const Dictionary& parameters, const Dictionary& drag_parameters, const Vector2i& old_mouse_position);





 Element* GetElementAtPoint(const Vector2f& point, const Element* ignore_element = __null, Element* element = __null);




 void CreateDragClone(Element* element);

 void ReleaseDragClone();


 void GenerateKeyEventParameters(Dictionary& parameters, Input::KeyIdentifier key_identifier);

 void GenerateMouseEventParameters(Dictionary& parameters, int button_index = -1);

 void GenerateKeyModifierEventParameters(Dictionary& parameters, int key_modifier_state);

 void GenerateDragEventParameters(Dictionary& parameters);


 void ReleaseUnloadedDocuments();


 static void SendEvents(const ElementSet& old_items, const ElementSet& new_items, const String& event, const Dictionary& parameters, bool interruptible);

 friend class Element;
 friend __attribute__((visibility("default"))) Context* CreateContext(const String&, const Vector2i&, RenderInterface*);
};

}
}





namespace Urho3D
{


  class RocketDocument2D : public Urho3D::Component
  {
   public: using ClassName = RocketDocument2D; using BaseClassName = Urho3D::Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RocketDocument2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };
  public:
   RocketDocument2D(Urho3D::Context* context);
   ~RocketDocument2D();

   static void RegisterObject(Urho3D::Context* context);

   void AddReference();
   void RemoveReference();

   void LoadRML(const Urho3D::String& filename);

   void SetVisible(bool show);
   bool GetVisible() const { return visible_; }

   ::Rocket::Core::ElementDocument* GetRocketDocument() { return document_; }


  protected:




  private:





   ::Rocket::Core::ElementDocument* document_;
   bool visible_;

  };

}

namespace Rocket {
namespace Core {

class EventListener;
class __attribute__((visibility("default"))) EventListenerInstancer : public ReferenceCountable
{
public:
 virtual ~EventListenerInstancer();




 virtual EventListener* InstanceEventListener(const String& value, Element* element) = 0;


 virtual void Release() = 0;

protected:
 virtual void OnReferenceDeactivate();
};

}
}
namespace Rocket {
namespace Core {

class Event;
class Element;







class __attribute__((visibility("default"))) EventListener
{
public:
 virtual ~EventListener() {}


 virtual void ProcessEvent(Event& event) = 0;


 virtual void OnAttach(Element* UNUSED_element __attribute__((unused)))
 {
                        ;
 }


 virtual void OnDetach(Element* UNUSED_element __attribute__((unused)))
 {
                        ;
 }
};

}
}




class RocketEventListenerInstancer: public Urho3D::Object, public ::Rocket::Core::EventListenerInstancer
{
public:
 public: using ClassName = RocketEventListenerInstancer; using BaseClassName = Urho3D::Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RocketEventListenerInstancer", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };
 virtual ~RocketEventListenerInstancer();
 static RocketEventListenerInstancer* Register(Urho3D::Context* context);




 virtual ::Rocket::Core::EventListener* InstanceEventListener(const ::Rocket::Core::String& value, ::Rocket::Core::Element* element);


 virtual void Release();

 void Execute(::Rocket::Core::EventListener* l, ::Rocket::Core::Event& e, const Urho3D::String& call);

protected:
 RocketEventListenerInstancer(Urho3D::Context* context);
 bool executeAngelScript_;
 bool executeLuaScript_;
 bool sendUrhoEvents_;
};

class RocketEventListener: public ::Rocket::Core::EventListener
{
public:

 RocketEventListener(const ::Rocket::Core::String& context, Urho3D::ScriptFile* sf, RocketEventListenerInstancer* parent);
 virtual ~RocketEventListener();



 virtual void ProcessEvent(::Rocket::Core::Event& event);


 virtual void OnAttach(::Rocket::Core::Element* element);


 virtual void OnDetach(::Rocket::Core::Element* element);

 virtual Urho3D::ScriptFile* GetContext() { return scriptContext_.Get(); }


protected:
 Urho3D::String eventCall_;
 RocketEventListenerInstancer* parent_;
 Urho3D::SharedPtr<Urho3D::ScriptFile> scriptContext_;
};


namespace Rocket {
namespace Core {

class Context;
class Event;







class __attribute__((visibility("default"))) ContextInstancer : public ReferenceCountable
{
public:
 virtual ~ContextInstancer();




 virtual Context* InstanceContext(const String& name) = 0;



 virtual void ReleaseContext(Context* context) = 0;


 virtual void Release() = 0;

private:
 virtual void OnReferenceDeactivate();
};

}
}
namespace Rocket {
namespace Core {

class DecoratorInstancer;
class Element;
class PropertyDictionary;
class Property;
struct Texture;
class TextureResource;







class __attribute__((visibility("default"))) Decorator : public ReferenceCountable
{
public:
 Decorator();
 virtual ~Decorator();




 virtual DecoratorDataHandle GenerateElementData(Element* element) = 0;


 virtual void ReleaseElementData(DecoratorDataHandle element_data) = 0;




 void SetZIndex(float z_index);


 float GetZIndex() const;



 void SetSpecificity(int specificity);



 int GetSpecificity() const;




 virtual void RenderElement(Element* element, DecoratorDataHandle element_data) = 0;


 static const DecoratorDataHandle INVALID_DECORATORDATAHANDLE = 0;

protected:

 virtual void OnReferenceDeactivate();





 int LoadTexture(const String& texture_name, const String& rcss_path);



 const Texture* GetTexture(int index = 0) const;






 float ResolveProperty(const PropertyDictionary& properties, const String& name, float base_value) const;

private:
 DecoratorInstancer* instancer;



 float z_index;

 int specificity;


 std::vector< Texture > textures;

 friend class Factory;
};

}
}
namespace Rocket {
namespace Core {

typedef std::map< String, Property > PropertyMap;







class __attribute__((visibility("default"))) PropertyDictionary
{
public:
 PropertyDictionary();
 ~PropertyDictionary();




 void SetProperty(const String& name, const Property& property);


 void RemoveProperty(const String& name);


 const Property* GetProperty(const String& name) const;



 int GetNumProperties() const;


 const PropertyMap& GetProperties() const;







 void Import(const PropertyDictionary& property_dictionary, int specificity = -1);






 void Merge(const PropertyDictionary& property_dictionary, int specificity_offset = 0);

private:



 void SetProperty(const String& name, const Rocket::Core::Property& property, int specificity);

 PropertyMap properties;
};

}
}
namespace Rocket {
namespace Core {

typedef std::map< String, int, StringUtilities::StringComparei > ParameterMap;







class __attribute__((visibility("default"))) PropertyParser
{
public:
 virtual ~PropertyParser()
 {
 }






 virtual bool ParseValue(Property& property, const String& value, const ParameterMap& parameters) const = 0;


 virtual void Release() = 0;
};

}
}

namespace Rocket {
namespace Core {





class __attribute__((visibility("default"))) PropertyDefinition
{
public:
 PropertyDefinition(const String& default_value, bool inherited, bool forces_layout);
 virtual ~PropertyDefinition();





 PropertyDefinition& AddParser(const String& parser_name, const String& parser_parameters = "");





 bool ParseValue(Property& property, const String& value) const;




 bool GetValue(String& value, const Property& property) const;


 bool IsInherited() const;


 bool IsLayoutForced() const;


 const Property* GetDefaultValue() const;

private:
 Property default_value;
 bool inherited;
 bool forces_layout;

 struct ParserState
 {
  PropertyParser* parser;
  ParameterMap parameters;
 };

 std::vector< ParserState > parsers;
};

}
}

namespace Rocket {
namespace Core {

class PropertyDictionary;
struct PropertyShorthandDefinition;







class __attribute__((visibility("default"))) PropertySpecification
{
public:
 enum ShorthandType
 {


  FALL_THROUGH,

  REPLICATE,

  BOX,

  AUTO
 };

 PropertySpecification();
 ~PropertySpecification();







 PropertyDefinition& RegisterProperty(const String& property_name, const String& default_value, bool inherited, bool forces_layout);



 const PropertyDefinition* GetProperty(const String& property_name) const;



 const PropertyNameList& GetRegisteredProperties() const;



 const PropertyNameList& GetRegisteredInheritedProperties() const;






 bool RegisterShorthand(const String& shorthand_name, const String& property_names, ShorthandType type = AUTO);



 const PropertyShorthandDefinition* GetShorthand(const String& shorthand_name) const;






 bool ParsePropertyDeclaration(PropertyDictionary& dictionary, const String& property_name, const String& property_value, const String& source_file = "", int source_line_number = 0) const;


 void SetPropertyDefaults(PropertyDictionary& dictionary) const;

private:
 typedef std::map< String, PropertyDefinition* > PropertyMap;
 typedef std::map< String, PropertyShorthandDefinition* > ShorthandMap;

 PropertyMap properties;
 ShorthandMap shorthands;
 PropertyNameList property_names;
 PropertyNameList inherited_property_names;

 bool ParsePropertyValues(StringList& values_list, const String& values, bool split_values) const;
};

}
}

namespace Rocket {
namespace Core {

class Decorator;
class __attribute__((visibility("default"))) DecoratorInstancer : public ReferenceCountable
{
public:
 DecoratorInstancer();
 virtual ~DecoratorInstancer();





 virtual Decorator* InstanceDecorator(const String& name, const PropertyDictionary& properties) = 0;


 virtual void ReleaseDecorator(Decorator* decorator) = 0;


 virtual void Release() = 0;


 const PropertySpecification& GetPropertySpecification() const;

protected:




 PropertyDefinition& RegisterProperty(const String& property_name, const String& default_value);





 bool RegisterShorthand(const String& shorthand_name, const String& property_names, PropertySpecification::ShorthandType type = PropertySpecification::AUTO);


 virtual void OnReferenceDeactivate();

private:
 PropertySpecification properties;
};

}
}



namespace Rocket {
namespace Core {
template <typename T>
class ElementInstancerGeneric : public ElementInstancer
{
public:
 virtual ~ElementInstancerGeneric();




 virtual Element* InstanceElement(Element* parent, const String& tag, const XMLAttributes& attributes);



 virtual void ReleaseElement(Element* element);


 virtual void Release();
};


template <typename T>
ElementInstancerGeneric<T>::~ElementInstancerGeneric()
{
}


template <typename T>
Element* ElementInstancerGeneric<T>::InstanceElement(Element* , const String& tag, const XMLAttributes& )
{
 return new T(tag);
}




template <typename T>
void ElementInstancerGeneric<T>::ReleaseElement(Element* element)
{
 delete element;
}




template <typename T>
void ElementInstancerGeneric<T>::Release()
{
 delete this;
}

}
}

namespace Rocket {
namespace Core {

class Element;
class WidgetSliderScroll;







class __attribute__((visibility("default"))) ElementScroll : public EventListener
{
public:
 enum Orientation
 {
  VERTICAL = 0,
  HORIZONTAL = 1
 };

 ElementScroll(Element* element);
 virtual ~ElementScroll();


 void Update();




 void EnableScrollbar(Orientation orientation, float element_width);


 void DisableScrollbar(Orientation orientation);



 void UpdateScrollbar(Orientation orientation);




 Element* GetScrollbar(Orientation orientation);



 float GetScrollbarSize(Orientation orientation);


 void FormatScrollbars();

protected:

 void ProcessEvent(Event& event);

private:
 struct Scrollbar
 {
  Scrollbar();
  ~Scrollbar();

  Element* element;
  WidgetSliderScroll* widget;
  bool enabled;
  float size;
 };


 bool CreateScrollbar(Orientation orientation);

 bool CreateCorner();

 Element* element;

 Scrollbar scrollbars[2];
 Element* corner;
};

}
}
namespace Rocket {
namespace Core {

typedef StringBase< word > WStringBase;







class __attribute__((visibility("default"))) WString : public WStringBase
{
public:

 WString();


 WString(const WStringBase& ucs2_string);

 WString(const word* ucs2_string_begin, const word* ucs2_string_end);

 WString(WStringBase::size_type count, word ucs2_char);


 WString(const char* utf8_string);

 WString(const char* utf8_string_begin, const char* utf8_string_end);

 WString(const String& utf8_string);


 ~WString();


 String& ToUTF8(String& utf8_string, bool append = false) const;


 WString& operator=(const WStringBase& string);

 WString& operator=(const WString& string);

 WString& operator=(const word* string);

 WString& operator=(const char* string);


 bool operator==(const WString& string) const;

 bool operator==(const char* string) const;

 WStringBase::size_type Find(const WString& s, WStringBase::size_type pos = WStringBase::npos) const;
 WStringBase::size_type Find(const word* s, WStringBase::size_type pos = WStringBase::npos) const;
 WStringBase::size_type Find(const word& s, WStringBase::size_type pos = WStringBase::npos) const;

 word& operator[](WStringBase::size_type offset);
 word operator[](WStringBase::size_type offset) const;
};

}
}

namespace Rocket {
namespace Core {







class __attribute__((visibility("default"))) ElementText : public Element
{
public:
 ElementText(const String& tag);
 virtual ~ElementText();




 virtual void SetText(const WString& text) = 0;


 virtual const WString& GetText() const = 0;





 virtual bool GenerateToken(float& token_width, int token_begin) = 0;
 virtual bool GenerateLine(WString& line, int& line_length, float& line_width, int line_begin, float maximum_line_width, float right_spacing_width, bool trim_whitespace_prefix) = 0;


 virtual void ClearLines() = 0;



 virtual void AddLine(const Vector2f& line_position, const WString& line) = 0;


 virtual void SuppressAutoLayout() = 0;
};

}
}
namespace Rocket {
namespace Core {

class Context;
class FontFaceHandle;
class RenderInterface;







class __attribute__((visibility("default"))) ElementUtilities
{
public:
 enum PositionAnchor
 {
  TOP = 1 << 0,
  BOTTOM = 1 << 1,
  LEFT = 1 << 2,
  RIGHT = 1 << 3,

  TOP_LEFT = TOP | LEFT,
  TOP_RIGHT = TOP | RIGHT,
  BOTTOM_LEFT = BOTTOM | LEFT,
  BOTTOM_RIGHT = BOTTOM | RIGHT
 };




 static Element* GetElementById(Element* root_element, const String& id);




 static void GetElementsByTagName(ElementList& elements, Element* root_element, const String& tag);




 static void GetElementsByClassName(ElementList& elements, Element* root_element, const String& class_name);




 static FontFaceHandle* GetFontFaceHandle(Element* element);



 static int GetFontSize(Element* element);



 static int GetLineHeight(Element* element);




 static int GetStringWidth(Element* element, const WString& string);



 static void BindEventAttributes(Element* element);






 static bool GetClippingRegion(Vector2i& clip_origin, Vector2i& clip_dimensions, Element* element);




 static bool SetClippingRegion(Element* element, Context* context = __null);



 static void ApplyActiveClipRegion(Context* context, RenderInterface* render_interface);





 static bool FormatElement(Element* element, const Vector2f& containing_block);






 static void BuildBox(Box& box, const Vector2f& containing_block, Element* element, bool inline_element = false);





 static bool PositionElement(Element* element, const Vector2f& offset);





 static bool PositionElement(Element* element, const Vector2f& offset, PositionAnchor anchor);
};

}
}

namespace Rocket {
namespace Core {

class Element;
class Event;







class __attribute__((visibility("default"))) EventInstancer : public ReferenceCountable
{
public:
 virtual ~EventInstancer();






 virtual Event* InstanceEvent(Element* target, const String& name, const Dictionary& parameters, bool interruptible) = 0;



 virtual void ReleaseEvent(Event* event) = 0;


 virtual void Release() = 0;

private:
 virtual void OnReferenceDeactivate();
};

}
}


namespace Rocket {
namespace Core {

class Context;
class ContextInstancer;
class Decorator;
class DecoratorInstancer;
class Element;
class ElementDocument;
class ElementInstancer;
class Event;
class EventInstancer;
class EventListener;
class EventListenerInstancer;
class FontEffect;
class FontEffectInstancer;
class StyleSheet;
class PropertyDictionary;
class __attribute__((visibility("default"))) Factory
{
public:

 static bool Initialise();

 static void Shutdown();



 static ContextInstancer* RegisterContextInstancer(ContextInstancer* instancer);



 static Context* InstanceContext(const String& name);





 static ElementInstancer* RegisterElementInstancer(const String& name, ElementInstancer* instancer);



 static ElementInstancer* GetElementInstancer(const String& tag);






 static Element* InstanceElement(Element* parent, const String& instancer, const String& tag, const XMLAttributes& attributes);






 static bool InstanceElementText(Element* parent, const String& text);




 static bool InstanceElementStream(Element* parent, Stream* stream);




 static ElementDocument* InstanceDocumentStream(Rocket::Core::Context* context, Stream* stream);





 static DecoratorInstancer* RegisterDecoratorInstancer(const String& name, DecoratorInstancer* instancer);




 static Decorator* InstanceDecorator(const String& name, const PropertyDictionary& properties);





 static FontEffectInstancer* RegisterFontEffectInstancer(const String& name, FontEffectInstancer* instancer);




 static FontEffect* InstanceFontEffect(const String& name, const PropertyDictionary& properties);




 static StyleSheet* InstanceStyleSheetString(const String& string);



 static StyleSheet* InstanceStyleSheetFile(const String& file_name);



 static StyleSheet* InstanceStyleSheetStream(Stream* stream);

 static void ClearStyleSheetCache();

 static void ClearTemplateCache();




 static EventInstancer* RegisterEventInstancer(EventInstancer* instancer);






 static Event* InstanceEvent(Element* target, const String& name, const Dictionary& parameters, bool interruptible);



 static EventListenerInstancer* RegisterEventListenerInstancer(EventListenerInstancer* instancer);




 static EventListener* InstanceEventListener(const String& value, Element* element);

private:
 Factory();
 ~Factory();
};

}
}

namespace Rocket {
namespace Core {

namespace Font
{
 enum Style
 {
  STYLE_NORMAL = 0,
  STYLE_ITALIC = 1,
  NUM_STYLES = 2
 };

 enum Weight
 {
  WEIGHT_NORMAL = 0,
  WEIGHT_BOLD = 1,
  NUM_WEIGHTS = 2
 };

 enum Line
 {
  UNDERLINE = 0,
  OVERLINE = 1,
  STRIKE_THROUGH = 2
 };
};

}
}
namespace Rocket {
namespace Core {

class FontFaceHandle;
class FontFamily;






class __attribute__((visibility("default"))) FontProvider
{
public:
    FontFaceHandle* GetFontFaceHandle(const String& family, const String& charset, Font::Style style, Font::Weight weight, int size);

protected:

    typedef std::map< String, FontFamily*, StringUtilities::StringComparei > FontFamilyMap;
    FontFamilyMap font_families;
};

}
}

namespace Rocket {
namespace Core {

class FontEffect;
class FontFamily;
class FontFaceHandle;
class PropertyDictionary;







class __attribute__((visibility("default"))) FontDatabase
{
public:

    enum FontProviderType
    {
        FreeType = 0,
        BitmapFont
    };

 static bool Initialise();
 static void Shutdown();




 static bool LoadFontFace(const String& file_name);






 static bool LoadFontFace(const String& file_name, const String& family, Font::Style style, Font::Weight weight);




    static bool LoadFontFace(FontProviderType font_provider_type, const byte* data, int data_length);







    static bool LoadFontFace(FontProviderType font_provider_type, const byte* data, int data_length, const String& family, Font::Style style, Font::Weight weight);
 static FontFaceHandle* GetFontFaceHandle(const String& family, const String& charset, Font::Style style, Font::Weight weight, int size);






 static FontEffect* GetFontEffect(const String& name, const PropertyDictionary& properties);



 static void ReleaseFontEffect(const FontEffect* effect);

    static void AddFontProvider(FontProvider * provider);

    static void RemoveFontProvider(FontProvider * provider);

private:
 FontDatabase(void);
 ~FontDatabase(void);

    static FontProviderType GetFontProviderType(const String& file_name);

    typedef std::vector< FontProvider *> FontProviderTable;

    static FontProviderTable font_provider_table;
 static FontDatabase* instance;
};

}
}
namespace Rocket {
namespace Core {







class FontGlyph
{
public:
 FontGlyph() : character(0), dimensions(0,0), bearing(0,0), advance(0), bitmap_data(__null),
  bitmap_dimensions(0,0)
 {
 }


 word character;


 Vector2i dimensions;


 Vector2i bearing;


 int advance;



 byte* bitmap_data;

 Vector2i bitmap_dimensions;
};

typedef std::vector< FontGlyph > FontGlyphList;

}
}

namespace Rocket {
namespace Core {

class FontEffectInstancer;





class FontEffect : public ReferenceCountable
{
public:
 FontEffect();
 virtual ~FontEffect();



 const String& GetName() const;




 virtual bool HasUniqueTexture() const;






 virtual bool GetGlyphMetrics(Vector2i& origin, Vector2i& dimensions, const FontGlyph& glyph) const;







 virtual void GenerateGlyphTexture(byte* destination_data, const Vector2i& destination_dimensions, int destination_stride, const FontGlyph& glyph) const;



 void SetColour(const Colourb& colour);


 const Colourb& GetColour() const;




 void SetZIndex(float z_index);


 float GetZIndex() const;



 void SetSpecificity(int specificity);



 int GetSpecificity() const;



 const String& GetGenerationKey() const;

protected:

 virtual void OnReferenceDeactivate();

private:
 FontEffectInstancer* instancer;


 String name;


 Colourb colour;


 float z_index;

 int specificity;


 String generation_key;

 friend class Factory;
};

typedef std::vector< FontEffect* > FontEffectList;
typedef std::map< String, FontEffect* > FontEffectMap;

}
}

namespace Rocket {
namespace Core {

class Context;
class Element;
class RenderInterface;
struct Texture;







class __attribute__((visibility("default"))) Geometry
{
public:
 Geometry(Element* host_element = __null);
 Geometry(Context* host_context);
 ~Geometry();



 void SetHostElement(Element* host_element);



 void Render(const Vector2f& translation);



 std::vector< Vertex >& GetVertices();


 std::vector< int >& GetIndices();



 const Texture* GetTexture() const;

 void SetTexture(const Texture* texture);



 void Release(bool clear_buffers = false);

private:

 RenderInterface* GetRenderInterface();

 Context* host_context;
 Element* host_element;

 std::vector< Vertex > vertices;
 std::vector< int > indices;
 const Texture* texture;

 CompiledGeometryHandle compiled_geometry;
 bool compile_attempted;
 bool fixed_texcoords;
};

typedef std::vector< Geometry > GeometryList;

}
}
namespace Rocket {
namespace Core {







class __attribute__((visibility("default"))) GeometryUtilities
{
public:







 static void GenerateQuad(Vertex* vertices, int* indices, const Vector2f& origin, const Vector2f& dimensions, const Colourb& colour, int index_offset = 0);
 static void GenerateQuad(Vertex* vertices, int* indices, const Vector2f& origin, const Vector2f& dimensions, const Colourb& colour, const Vector2f& top_left_texcoord, const Vector2f& bottom_right_texcoord, int index_offset = 0);

private:
 GeometryUtilities();
 ~GeometryUtilities();
};

}
}


namespace Rocket {
namespace Core {

class Element;
class ElementDocument;
class Context;







class __attribute__((visibility("default"))) Plugin
{
public:
 virtual ~Plugin();

 enum EventClasses
 {
  EVT_BASIC = (1 << 0),
  EVT_DOCUMENT = (1 << 1),
  EVT_ELEMENT = (1 << 2),

  EVT_ALL = EVT_BASIC | EVT_DOCUMENT | EVT_ELEMENT
 };


 virtual int GetEventClasses();



 virtual void OnInitialise();

 virtual void OnShutdown();


 virtual void OnContextCreate(Context* context);

 virtual void OnContextDestroy(Context* context);


 virtual void OnDocumentOpen(Context* context, const String& document_path);


 virtual void OnDocumentLoad(ElementDocument* document);


 virtual void OnDocumentUnload(ElementDocument* document);


 virtual void OnElementCreate(Element* element);

 virtual void OnElementDestroy(Element* element);
};

}
}







namespace Rocket {
namespace Core {

class Element;
class ElementDefinition;
class StyleSheetNode;
class __attribute__((visibility("default"))) StyleSheet : public ReferenceCountable
{
public:
 typedef std::set< StyleSheetNode* > NodeList;
 typedef std::map< String, NodeList > NodeIndex;

 StyleSheet();
 virtual ~StyleSheet();


 bool LoadStyleSheet(Stream* stream);


 StyleSheet* CombineStyleSheet(const StyleSheet* sheet) const;

 void BuildNodeIndex();



 ElementDefinition* GetElementDefinition(const Element* element) const;

protected:

 virtual void OnReferenceDeactivate();

private:

 StyleSheetNode* root;






 int specificity_offset;


 NodeIndex styled_node_index;

 NodeIndex complete_node_index;

 typedef std::map< String, ElementDefinition* > ElementDefinitionCache;

 mutable ElementDefinitionCache address_cache;

 mutable ElementDefinitionCache node_cache;
};

}
}
namespace Rocket {
namespace Core {

const int POSITION_STATIC = 0;
const int POSITION_RELATIVE = 1;
const int POSITION_ABSOLUTE = 2;
const int POSITION_FIXED = 3;

const int FLOAT_NONE = 0;
const int FLOAT_LEFT = 1;
const int FLOAT_RIGHT = 2;

const int CLEAR_NONE = 0;
const int CLEAR_LEFT = 1;
const int CLEAR_RIGHT = 2;
const int CLEAR_BOTH = 3;

const int DISPLAY_NONE = 0;
const int DISPLAY_BLOCK = 1;
const int DISPLAY_INLINE = 2;
const int DISPLAY_INLINE_BLOCK = 3;

const int VISIBILITY_VISIBLE = 0;
const int VISIBILITY_HIDDEN = 1;

const int OVERFLOW_VISIBLE = 0;
const int OVERFLOW_HIDDEN = 1;
const int OVERFLOW_AUTO = 2;
const int OVERFLOW_SCROLL = 3;

const int CLIP_AUTO = 0;
const int CLIP_NONE = 1;

const int FONT_STYLE_NORMAL = 0;
const int FONT_STYLE_ITALIC = 1;

const int FONT_WEIGHT_NORMAL = 0;
const int FONT_WEIGHT_BOLD = 1;

const int TEXT_ALIGN_LEFT = 0;
const int TEXT_ALIGN_RIGHT = 1;
const int TEXT_ALIGN_CENTER = 2;
const int TEXT_ALIGN_JUSTIFY = 3;

const int TEXT_DECORATION_NONE = 0;
const int TEXT_DECORATION_UNDERLINE = 1;
const int TEXT_DECORATION_OVERLINE = 2;
const int TEXT_DECORATION_LINE_THROUGH = 3;

const int TEXT_TRANSFORM_NONE = 0;
const int TEXT_TRANSFORM_CAPITALIZE = 1;
const int TEXT_TRANSFORM_UPPERCASE = 2;
const int TEXT_TRANSFORM_LOWERCASE = 3;

const int WHITE_SPACE_NORMAL = 0;
const int WHITE_SPACE_PRE = 1;
const int WHITE_SPACE_NOWRAP = 2;
const int WHITE_SPACE_PRE_WRAP = 3;
const int WHITE_SPACE_PRE_LINE = 4;

const int VERTICAL_ALIGN_BASELINE = 0;
const int VERTICAL_ALIGN_MIDDLE = 1;
const int VERTICAL_ALIGN_SUB = 2;
const int VERTICAL_ALIGN_SUPER = 3;
const int VERTICAL_ALIGN_TEXT_TOP = 4;
const int VERTICAL_ALIGN_TEXT_BOTTOM = 5;
const int VERTICAL_ALIGN_TOP = 6;
const int VERTICAL_ALIGN_BOTTOM = 7;

const int Z_INDEX_AUTO = 0;
const int Z_INDEX_TOP = 1;
const int Z_INDEX_BOTTOM = 2;

const int DRAG_NONE = 0;
const int DRAG_DRAG = 1;
const int DRAG_DRAG_DROP = 2;
const int DRAG_BLOCK = 3;
const int DRAG_CLONE = 4;

const int TAB_INDEX_NONE = 0;
const int TAB_INDEX_AUTO = 1;

const int FOCUS_NONE = 0;
const int FOCUS_AUTO = 1;

}
}
namespace Rocket {
namespace Core {

class PropertyParser;





class __attribute__((visibility("default"))) StyleSheetSpecification
{
public:


 static bool Initialise();

 static void Shutdown();





 static bool RegisterParser(const String& parser_name, PropertyParser* parser);



 static PropertyParser* GetParser(const String& parser_name);







 static PropertyDefinition& RegisterProperty(const String& property_name, const String& default_value, bool inherited, bool forces_layout = false);



 static const PropertyDefinition* GetProperty(const String& property_name);



 static const PropertyNameList & GetRegisteredProperties();



 static const PropertyNameList & GetRegisteredInheritedProperties();






 static bool RegisterShorthand(const String& shorthand_name, const String& property_names, PropertySpecification::ShorthandType type = PropertySpecification::AUTO);



 static const PropertyShorthandDefinition* GetShorthand(const String& shorthand_name);
 static bool ParsePropertyDeclaration(PropertyDictionary& dictionary, const String& property_name, const String& property_value, const String& source_file = "", int source_line_number = 0);

private:
 StyleSheetSpecification();
 ~StyleSheetSpecification();


 void RegisterDefaultParsers();

 void RegisterDefaultProperties();


 typedef std::map< String, PropertyParser* > ParserMap;
 ParserMap parsers;


 PropertySpecification properties;
};

}
}




namespace Rocket {
namespace Core {

class Element;
class XMLParser;







class __attribute__((visibility("default"))) XMLNodeHandler : public ReferenceCountable
{
public:
 virtual ~XMLNodeHandler();






 virtual Element* ElementStart(XMLParser* parser, const String& name, const XMLAttributes& attributes) = 0;




 virtual bool ElementEnd(XMLParser* parser, const String& name) = 0;




 virtual bool ElementData(XMLParser* parser, const String& data) = 0;


 virtual void Release() = 0;

protected:
 virtual void OnReferenceDeactivate();
};

}
}


namespace Rocket {
namespace Core {

class Plugin;
__attribute__((visibility("default"))) bool Initialise();

__attribute__((visibility("default"))) void Shutdown();



__attribute__((visibility("default"))) String GetVersion();



__attribute__((visibility("default"))) void SetSystemInterface(SystemInterface* system_interface);


__attribute__((visibility("default"))) SystemInterface* GetSystemInterface();





__attribute__((visibility("default"))) void SetRenderInterface(RenderInterface* render_interface);


__attribute__((visibility("default"))) RenderInterface* GetRenderInterface();




__attribute__((visibility("default"))) void SetFileInterface(FileInterface* file_interface);


__attribute__((visibility("default"))) FileInterface* GetFileInterface();






__attribute__((visibility("default"))) Context* CreateContext(const String& name, const Vector2i& dimensions, RenderInterface* render_interface = __null);



__attribute__((visibility("default"))) Context* GetContext(const String& name);



__attribute__((visibility("default"))) Context* GetContext(int index);


__attribute__((visibility("default"))) int GetNumContexts();


__attribute__((visibility("default"))) void RegisterPlugin(Plugin* plugin);


__attribute__((visibility("default"))) void ReleaseCompiledGeometries();

__attribute__((visibility("default"))) void ReleaseTextures();

}
}





class RocketInput: public Urho3D::Object
{



 ::Rocket::Core::Context* _rocketContext;

public:
 public: using ClassName = RocketInput; using BaseClassName = Urho3D::Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RocketInput", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }
 RocketInput(Urho3D::Context* context, ::Rocket::Core::Context* rContext);
 virtual ~RocketInput();
 void HandleInput(Urho3D::StringHash eventType, Urho3D::VariantMap& eventData);
};


namespace Urho3D
{


class __attribute__((visibility("default"))) RocketSys : public Object, public ::Rocket::Core::RenderInterface
{
    public: using ClassName = RocketSys; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RocketSys", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };


public:

    RocketSys(Context* context);

    ~RocketSys();

 ::Rocket::Core::Context* GetRocketContext() const { return _rocketContext.get(); }
    RocketInput* GetRocketInput() const { return input.Get(); }


   virtual void RenderGeometry(::Rocket::Core::Vertex* vertices, int num_vertices, int* indices, int num_indices, ::Rocket::Core::TextureHandle texture, const ::Rocket::Core::Vector2f& translation);


   virtual ::Rocket::Core::CompiledGeometryHandle CompileGeometry(::Rocket::Core::Vertex* vertices, int num_vertices, int* indices, int num_indices, ::Rocket::Core::TextureHandle texture);


   virtual void RenderCompiledGeometry(::Rocket::Core::CompiledGeometryHandle geometry, const ::Rocket::Core::Vector2f& translation);

   virtual void ReleaseCompiledGeometry(::Rocket::Core::CompiledGeometryHandle geometry);


   virtual void EnableScissorRegion(bool enable);

   virtual void SetScissorRegion(int x, int y, int width, int height);


   virtual bool LoadTexture(::Rocket::Core::TextureHandle& texture_handle, ::Rocket::Core::Vector2i& texture_dimensions, const ::Rocket::Core::String& source);

   virtual bool GenerateTexture(::Rocket::Core::TextureHandle& texture_handle, const ::Rocket::Core::byte* source, const ::Rocket::Core::Vector2i& source_dimensions);

   virtual void ReleaseTexture(::Rocket::Core::TextureHandle texture_handle);



   virtual float GetHorizontalTexelOffset();


   virtual float GetVerticalTexelOffset();

private:
    void HandleUpdate(Urho3D::StringHash eventType, Urho3D::VariantMap& eventData);
    void HandlePostRender(Urho3D::StringHash eventType, Urho3D::VariantMap& eventData);

 std::shared_ptr< ::Rocket::Core::Context> _rocketContext;

 SharedPtr<RocketInput> input;
 SharedPtr<RocketEventListenerInstancer> eventListener_;
 SharedPtr<Urho3D::SystemInterface> systemInterface_;
 SharedPtr<RocketFileInterface> fileInterface_;
   std::vector<SharedPtr<Texture2D> > textures;


   IntRect scissors;
   bool scissor;

   SharedPtr<ShaderVariation> noTextureVS;
   SharedPtr<ShaderVariation> noTexturePS;
   SharedPtr<ShaderVariation> diffTextureVS;
   SharedPtr<ShaderVariation> diffTexturePS;


};

}
namespace Urho3D
{

class ValueAnimation;
class ValueAnimationInfo;
class XMLElement;
class JSONValue;


class __attribute__((visibility("default"))) ObjectAnimation : public Resource
{
    public: using ClassName = ObjectAnimation; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ObjectAnimation", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ObjectAnimation(Context* context);

    ~ObjectAnimation() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;

    bool LoadXML(const XMLElement& source);

    bool SaveXML(XMLElement& dest) const;

    bool LoadJSON(const JSONValue& source);

    bool SaveJSON(JSONValue& dest) const;


    void AddAttributeAnimation
        (const String& name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f);

    void RemoveAttributeAnimation(const String& name);

    void RemoveAttributeAnimation(ValueAnimation* attributeAnimation);


    ValueAnimation* GetAttributeAnimation(const String& name) const;

    WrapMode GetAttributeAnimationWrapMode(const String& name) const;

    float GetAttributeAnimationSpeed(const String& name) const;


    const HashMap<String, SharedPtr<ValueAnimationInfo> >& GetAttributeAnimationInfos() const { return attributeAnimationInfos_; }


    ValueAnimationInfo* GetAttributeAnimationInfo(const String& name) const;

private:

    void SendAttributeAnimationAddedEvent(const String& name);

    void SendAttributeAnimationRemovedEvent(const String& name);


    HashMap<String, SharedPtr<ValueAnimationInfo> > attributeAnimationInfos_;
};

}


namespace Urho3D
{


static const Urho3D::StringHash E_SCENEUPDATE(Urho3D::GetEventNameRegister().RegisterString("SceneUpdate")); namespace SceneUpdate
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_SCENESUBSYSTEMUPDATE(Urho3D::GetEventNameRegister().RegisterString("SceneSubsystemUpdate")); namespace SceneSubsystemUpdate
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_UPDATESMOOTHING(Urho3D::GetEventNameRegister().RegisterString("UpdateSmoothing")); namespace UpdateSmoothing
{
    static const Urho3D::StringHash P_CONSTANT("Constant");
    static const Urho3D::StringHash P_SQUAREDSNAPTHRESHOLD("SquaredSnapThreshold");
}


static const Urho3D::StringHash E_SCENEDRAWABLEUPDATEFINISHED(Urho3D::GetEventNameRegister().RegisterString("SceneDrawableUpdateFinished")); namespace SceneDrawableUpdateFinished
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_TARGETPOSITION(Urho3D::GetEventNameRegister().RegisterString("TargetPositionChanged")); namespace TargetPositionChanged
{
}


static const Urho3D::StringHash E_TARGETROTATION(Urho3D::GetEventNameRegister().RegisterString("TargetRotationChanged")); namespace TargetRotationChanged
{
}


static const Urho3D::StringHash E_ATTRIBUTEANIMATIONUPDATE(Urho3D::GetEventNameRegister().RegisterString("AttributeAnimationUpdate")); namespace AttributeAnimationUpdate
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_ATTRIBUTEANIMATIONADDED(Urho3D::GetEventNameRegister().RegisterString("AttributeAnimationAdded")); namespace AttributeAnimationAdded
{
    static const Urho3D::StringHash P_OBJECTANIMATION("ObjectAnimation");
    static const Urho3D::StringHash P_ATTRIBUTEANIMATIONNAME("AttributeAnimationName");
}


static const Urho3D::StringHash E_ATTRIBUTEANIMATIONREMOVED(Urho3D::GetEventNameRegister().RegisterString("AttributeAnimationRemoved")); namespace AttributeAnimationRemoved
{
    static const Urho3D::StringHash P_OBJECTANIMATION("ObjectAnimation");
    static const Urho3D::StringHash P_ATTRIBUTEANIMATIONNAME("AttributeAnimationName");
}


static const Urho3D::StringHash E_SCENEPOSTUPDATE(Urho3D::GetEventNameRegister().RegisterString("ScenePostUpdate")); namespace ScenePostUpdate
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_TIMESTEP("TimeStep");
}


static const Urho3D::StringHash E_ASYNCLOADPROGRESS(Urho3D::GetEventNameRegister().RegisterString("AsyncLoadProgress")); namespace AsyncLoadProgress
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_PROGRESS("Progress");
    static const Urho3D::StringHash P_LOADEDNODES("LoadedNodes");
    static const Urho3D::StringHash P_TOTALNODES("TotalNodes");
    static const Urho3D::StringHash P_LOADEDRESOURCES("LoadedResources");
    static const Urho3D::StringHash P_TOTALRESOURCES("TotalResources");
}


static const Urho3D::StringHash E_ASYNCLOADFINISHED(Urho3D::GetEventNameRegister().RegisterString("AsyncLoadFinished")); namespace AsyncLoadFinished
{
    static const Urho3D::StringHash P_SCENE("Scene");
}


static const Urho3D::StringHash E_NODEADDED(Urho3D::GetEventNameRegister().RegisterString("NodeAdded")); namespace NodeAdded
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_PARENT("Parent");
    static const Urho3D::StringHash P_NODE("Node");
}


static const Urho3D::StringHash E_NODEREMOVED(Urho3D::GetEventNameRegister().RegisterString("NodeRemoved")); namespace NodeRemoved
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_PARENT("Parent");
    static const Urho3D::StringHash P_NODE("Node");
}


static const Urho3D::StringHash E_COMPONENTADDED(Urho3D::GetEventNameRegister().RegisterString("ComponentAdded")); namespace ComponentAdded
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_COMPONENT("Component");
}


static const Urho3D::StringHash E_COMPONENTREMOVED(Urho3D::GetEventNameRegister().RegisterString("ComponentRemoved")); namespace ComponentRemoved
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_COMPONENT("Component");
}


static const Urho3D::StringHash E_NODENAMECHANGED(Urho3D::GetEventNameRegister().RegisterString("NodeNameChanged")); namespace NodeNameChanged
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
}


static const Urho3D::StringHash E_NODEENABLEDCHANGED(Urho3D::GetEventNameRegister().RegisterString("NodeEnabledChanged")); namespace NodeEnabledChanged
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
}


static const Urho3D::StringHash E_NODETAGADDED(Urho3D::GetEventNameRegister().RegisterString("NodeTagAdded")); namespace NodeTagAdded
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_TAG("Tag");
}


static const Urho3D::StringHash E_NODETAGREMOVED(Urho3D::GetEventNameRegister().RegisterString("NodeTagRemoved")); namespace NodeTagRemoved
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_TAG("Tag");
}


static const Urho3D::StringHash E_COMPONENTENABLEDCHANGED(Urho3D::GetEventNameRegister().RegisterString("ComponentEnabledChanged")); namespace ComponentEnabledChanged
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_COMPONENT("Component");
}


static const Urho3D::StringHash E_TEMPORARYCHANGED(Urho3D::GetEventNameRegister().RegisterString("TemporaryChanged")); namespace TemporaryChanged
{
    static const Urho3D::StringHash P_SERIALIZABLE("Serializable");
}


static const Urho3D::StringHash E_NODECLONED(Urho3D::GetEventNameRegister().RegisterString("NodeCloned")); namespace NodeCloned
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_CLONENODE("CloneNode");
}


static const Urho3D::StringHash E_COMPONENTCLONED(Urho3D::GetEventNameRegister().RegisterString("ComponentCloned")); namespace ComponentCloned
{
    static const Urho3D::StringHash P_SCENE("Scene");
    static const Urho3D::StringHash P_COMPONENT("Component");
    static const Urho3D::StringHash P_CLONECOMPONENT("CloneComponent");
}


static const Urho3D::StringHash E_INTERCEPTNETWORKUPDATE(Urho3D::GetEventNameRegister().RegisterString("InterceptNetworkUpdate")); namespace InterceptNetworkUpdate
{
    static const Urho3D::StringHash P_SERIALIZABLE("Serializable");
    static const Urho3D::StringHash P_TIMESTAMP("TimeStamp");
    static const Urho3D::StringHash P_INDEX("Index");
    static const Urho3D::StringHash P_NAME("Name");
    static const Urho3D::StringHash P_VALUE("Value");
}

}


namespace Urho3D
{

enum SmoothingType : unsigned
{

    SMOOTH_NONE = 0,

    SMOOTH_POSITION = 1,

    SMOOTH_ROTATION = 2,
};
template<> struct IsFlagSet<SmoothingType> { constexpr static bool value_ = true; }; using SmoothingTypeFlags = FlagSet<SmoothingType>;


class __attribute__((visibility("default"))) SmoothedTransform : public Component
{
    public: using ClassName = SmoothedTransform; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SmoothedTransform", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit SmoothedTransform(Context* context);

    ~SmoothedTransform() override;

    static void RegisterObject(Context* context);


    void Update(float constant, float squaredSnapThreshold);

    void SetTargetPosition(const Vector3& position);

    void SetTargetRotation(const Quaternion& rotation);

    void SetTargetWorldPosition(const Vector3& position);

    void SetTargetWorldRotation(const Quaternion& rotation);


    const Vector3& GetTargetPosition() const { return targetPosition_; }


    const Quaternion& GetTargetRotation() const { return targetRotation_; }


    Vector3 GetTargetWorldPosition() const;

    Quaternion GetTargetWorldRotation() const;


    bool IsInProgress() const { return smoothingMask_ != SMOOTH_NONE; }

protected:

    void OnNodeSet(Node* node) override;

private:

    void HandleUpdateSmoothing(StringHash eventType, VariantMap& eventData);


    Vector3 targetPosition_;

    Quaternion targetRotation_;

    SmoothingTypeFlags smoothingMask_;

    bool subscribed_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) SplinePath : public Component
{
    public: using ClassName = SplinePath; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SplinePath", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    explicit SplinePath(Context* context);


    ~SplinePath() override = default;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void AddControlPoint(Node* point, unsigned index = M_MAX_UNSIGNED);

    void RemoveControlPoint(Node* point);

    void ClearControlPoints();


    void SetInterpolationMode(InterpolationMode interpolationMode);


    void SetSpeed(float speed) { speed_ = speed; }


    void SetPosition(float factor);

    void SetControlledNode(Node* controlled);


    InterpolationMode GetInterpolationMode() const { return spline_.GetInterpolationMode(); }


    float GetSpeed() const { return speed_; }


    float GetLength() const { return length_; }


    Vector3 GetPosition() const { return GetPoint(traveled_); }


    Node* GetControlledNode() const { return controlledNode_; }


    Vector3 GetPoint(float factor) const;


    void Move(float timeStep);

    void Reset();


    bool IsFinished() const { return traveled_ >= 1.0f; }


    void SetControlPointIdsAttr(const VariantVector& value);


    const VariantVector& GetControlPointIdsAttr() const { return controlPointIdsAttr_; }


    void SetControlledIdAttr(unsigned value);


    unsigned GetControlledIdAttr() const { return controlledIdAttr_; }

protected:

    void OnMarkedDirty(Node* point) override;

    void OnNodeSetEnabled(Node* point) override;

private:

    void UpdateNodeIds();

    void CalculateLength();


    Spline spline_;

    float speed_;

    float elapsedTime_;

    float traveled_;

    float length_;

    bool dirty_;

    WeakPtr<Node> controlledNode_;

    Vector<WeakPtr<Node> > controlPoints_;

    mutable VariantVector controlPointIdsAttr_;

    mutable unsigned controlledIdAttr_;
};
}
namespace Urho3D
{


class __attribute__((visibility("default"))) UnknownComponent : public Component
{
public:

    explicit UnknownComponent(Context* context);


    static void RegisterObject(Context* context);


    StringHash GetType() const override { return typeHash_; }


    const String& GetTypeName() const override { return typeName_; }


    const Vector<AttributeInfo>* GetAttributes() const override { return &xmlAttributeInfos_; }


    bool Load(Deserializer& source) override;

    bool LoadXML(const XMLElement& source) override;

    bool LoadJSON(const JSONValue& source) override;

    bool Save(Serializer& dest) const override;

    bool SaveXML(XMLElement& dest) const override;

    bool SaveJSON(JSONValue& dest) const override;


    void SetTypeName(const String& typeName);

    void SetType(StringHash typeHash);


    const Vector<String>& GetXMLAttributes() const { return xmlAttributes_; }


    const PODVector<unsigned char>& GetBinaryAttributes() const { return binaryAttributes_; }


    bool GetUseXML() const { return useXML_; }


    static Urho3D::StringHash GetTypeStatic()
    {
        static const StringHash typeStatic("UnknownComponent");
        return typeStatic;
    }

    static const Urho3D::String& GetTypeNameStatic()
    {
        static const String typeNameStatic("UnknownComponent");
        return typeNameStatic;
    }

private:

    StringHash typeHash_;

    String typeName_;

    Vector<AttributeInfo> xmlAttributeInfos_;

    Vector<String> xmlAttributes_;

    PODVector<unsigned char> binaryAttributes_;

    bool useXML_;

};

}
namespace Urho3D
{

class XMLElement;
class JSONValue;


enum InterpMethod
{

    IM_NONE = 0,

    IM_LINEAR,

    IM_SPLINE,
};


struct VAnimKeyFrame
{

    float time_;

    Variant value_;
};


struct VAnimEventFrame
{

    float time_;

    StringHash eventType_;

    VariantMap eventData_;
};


class __attribute__((visibility("default"))) ValueAnimation : public Resource
{
    public: using ClassName = ValueAnimation; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ValueAnimation", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ValueAnimation(Context* context);

    ~ValueAnimation() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool Save(Serializer& dest) const override;

    bool LoadXML(const XMLElement& source);

    bool SaveXML(XMLElement& dest) const;

    bool LoadJSON(const JSONValue& source);

    bool SaveJSON(JSONValue& dest) const;


    void SetOwner(void* owner);

    void SetInterpolationMethod(InterpMethod method);

    void SetSplineTension(float tension);

    void SetValueType(VariantType valueType);


    bool SetKeyFrame(float time, const Variant& value);

    void SetEventFrame(float time, const StringHash& eventType, const VariantMap& eventData = VariantMap());


    bool IsValid() const;


    void* GetOwner() const { return owner_; }


    InterpMethod GetInterpolationMethod() const { return interpolationMethod_; }


    float GetSplineTension() const { return splineTension_; }


    VariantType GetValueType() const { return valueType_; }


    float GetBeginTime() const { return beginTime_; }


    float GetEndTime() const { return endTime_; }


    Variant GetAnimationValue(float scaledTime) const;


    const Vector<VAnimKeyFrame>& GetKeyFrames() const { return keyFrames_; }


    bool HasEventFrames() const { return !eventFrames_.Empty(); }


    void GetEventFrames(float beginTime, float endTime, PODVector<const VAnimEventFrame*>& eventFrames) const;

protected:

    Variant LinearInterpolation(unsigned index1, unsigned index2, float scaledTime) const;

    Variant SplineInterpolation(unsigned index1, unsigned index2, float scaledTime) const;

    void UpdateSplineTangents() const;

    Variant SubstractAndMultiply(const Variant& value1, const Variant& value2, float t) const;


    void* owner_;

    InterpMethod interpolationMethod_;

    float splineTension_;

    VariantType valueType_;

    bool interpolatable_;

    float beginTime_;

    float endTime_;

    Vector<VAnimKeyFrame> keyFrames_;

    mutable VariantVector splineTangents_;

    mutable bool splineTangentsDirty_;

    Vector<VAnimEventFrame> eventFrames_;
};

}


namespace Urho3D
{


class __attribute__((visibility("default"))) Button : public BorderImage
{
    public: using ClassName = Button; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Button", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Button(Context* context);

    ~Button() override;

    static void RegisterObject(Context* context);


    void Update(float timeStep) override;

    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;

    void OnClickBegin
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) override;

    void OnClickEnd
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor,
            UIElement* beginElement) override;

    void OnDragMove
        (const IntVector2& position, const IntVector2& screenPosition, const IntVector2& deltaPos, int buttons, int qualifiers,
            Cursor* cursor) override;

    void OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers) override;


    void SetPressedOffset(const IntVector2& offset);

    void SetPressedOffset(int x, int y);

    void SetDisabledOffset(const IntVector2& offset);

    void SetDisabledOffset(int x, int y);

    void SetPressedChildOffset(const IntVector2& offset);

    void SetPressedChildOffset(int x, int y);

    void SetRepeat(float delay, float rate);

    void SetRepeatDelay(float delay);

    void SetRepeatRate(float rate);


    const IntVector2& GetPressedOffset() const { return pressedOffset_; }


    const IntVector2& GetDisabledOffset() const { return disabledOffset_; }


    const IntVector2& GetPressedChildOffset() const { return pressedChildOffset_; }


    float GetRepeatDelay() const { return repeatDelay_; }


    float GetRepeatRate() const { return repeatRate_; }


    bool IsPressed() const { return pressed_; }

protected:

    void SetPressed(bool enable);


    IntVector2 pressedOffset_;

    IntVector2 disabledOffset_;

    IntVector2 pressedChildOffset_;

    float repeatDelay_;

    float repeatRate_;

    float repeatTimer_;

    bool pressed_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) CheckBox : public BorderImage
{
    public: using ClassName = CheckBox; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CheckBox", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CheckBox(Context* context);

    ~CheckBox() override;

    static void RegisterObject(Context* context);


    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;

    void OnClickBegin
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) override;

    void OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers) override;


    void SetChecked(bool enable);

    void SetCheckedOffset(const IntVector2& offset);

    void SetCheckedOffset(int x, int y);


    bool IsChecked() const { return checked_; }


    const IntVector2& GetCheckedOffset() const { return checkedOffset_; }

protected:

    IntVector2 checkedOffset_;

    bool checked_;
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) Menu : public Button
{
    public: using ClassName = Menu; using BaseClassName = Button; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Menu", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    using UIElement::LoadXML;

public:

    explicit Menu(Context* context);

    ~Menu() override;

    static void RegisterObject(Context* context);


    bool LoadXML(const XMLElement& source, XMLFile* styleFile) override;

    bool SaveXML(XMLElement& dest) const override;


    void Update(float timeStep) override;

    void OnHover(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor) override;

    virtual void OnShowPopup();


    virtual void OnHidePopup() { }


    void SetPopup(UIElement* popup);

    void SetPopupOffset(const IntVector2& offset);

    void SetPopupOffset(int x, int y);

    void ShowPopup(bool enable);

    void SetAccelerator(int key, int qualifiers);


    UIElement* GetPopup() const { return popup_; }


    const IntVector2& GetPopupOffset() const { return popupOffset_; }


    bool GetShowPopup() const { return showPopup_; }


    int GetAcceleratorKey() const { return acceleratorKey_; }


    int GetAcceleratorQualifiers() const { return acceleratorQualifiers_; }

protected:

    virtual bool FilterPopupImplicitAttributes(XMLElement& dest) const;

    SharedPtr<UIElement> popup_;

    IntVector2 popupOffset_;

    bool showPopup_;

    int acceleratorKey_;

    int acceleratorQualifiers_;

private:

    void HandlePressedReleased(StringHash eventType, VariantMap& eventData);

    void HandleFocusChanged(StringHash eventType, VariantMap& eventData);

    void HandleKeyDown(StringHash eventType, VariantMap& eventData);

    bool autoPopup_;
};

}


namespace Urho3D
{

class ListView;


class __attribute__((visibility("default"))) DropDownList : public Menu
{
    public: using ClassName = DropDownList; using BaseClassName = Menu; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("DropDownList", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    explicit DropDownList(Context* context);

    ~DropDownList() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;

    void OnShowPopup() override;

    void OnHidePopup() override;

    void OnSetEditable() override;


    void AddItem(UIElement* item);

    void InsertItem(unsigned index, UIElement* item);

    void RemoveItem(UIElement* item);

    void RemoveItem(unsigned index);

    void RemoveAllItems();

    void SetSelection(unsigned index);

    void SetPlaceholderText(const String& text);

    void SetResizePopup(bool enable);


    unsigned GetNumItems() const;

    UIElement* GetItem(unsigned index) const;

    PODVector<UIElement*> GetItems() const;

    unsigned GetSelection() const;

    UIElement* GetSelectedItem() const;


    ListView* GetListView() const { return listView_; }


    UIElement* GetPlaceholder() const { return placeholder_; }


    const String& GetPlaceholderText() const;


    bool GetResizePopup() const { return resizePopup_; }


    void SetSelectionAttr(unsigned index);

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    bool FilterPopupImplicitAttributes(XMLElement& dest) const override;


    SharedPtr<ListView> listView_;

    SharedPtr<UIElement> placeholder_;

    bool resizePopup_;

private:

    void HandleItemClicked(StringHash eventType, VariantMap& eventData);

    void HandleListViewKey(StringHash eventType, VariantMap& eventData);

    void HandleSelectionChanged(StringHash eventType, VariantMap& eventData);


    unsigned selectionAttr_;
};

}
namespace Urho3D
{

class Button;
class DropDownList;
class Font;
class LineEdit;
class ListView;
class ResourceCache;
class Text;
class UIElement;
class Window;
class XMLFile;


struct FileSelectorEntry
{

    String name_;

    bool directory_;
};


class __attribute__((visibility("default"))) FileSelector : public Object
{
    public: using ClassName = FileSelector; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("FileSelector", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit FileSelector(Context* context);

    ~FileSelector() override;

    static void RegisterObject(Context* context);


    void SetDefaultStyle(XMLFile* style);

    void SetTitle(const String& text);

    void SetButtonTexts(const String& okText, const String& cancelText);

    void SetPath(const String& path);

    void SetFileName(const String& fileName);

    void SetFilters(const Vector<String>& filters, unsigned defaultIndex);

    void SetDirectoryMode(bool enable);

    void UpdateElements();


    XMLFile* GetDefaultStyle() const;


    Window* GetWindow() const { return window_; }


    Text* GetTitleText() const { return titleText_; }


    ListView* GetFileList() const { return fileList_; }


    LineEdit* GetPathEdit() const { return pathEdit_; }


    LineEdit* GetFileNameEdit() const { return fileNameEdit_; }


    DropDownList* GetFilterList() const { return filterList_; }


    Button* GetOKButton() const { return okButton_; }


    Button* GetCancelButton() const { return cancelButton_; }


    Button* GetCloseButton() const { return closeButton_; }


    const String& GetTitle() const;


    const String& GetPath() const { return path_; }


    const String& GetFileName() const;

    const String& GetFilter() const;

    unsigned GetFilterIndex() const;


    bool GetDirectoryMode() const { return directoryMode_; }

private:

    void SetLineEditText(LineEdit* edit, const String& text);

    void RefreshFiles();

    bool EnterFile();

    void HandleFilterChanged(StringHash eventType, VariantMap& eventData);

    void HandlePathChanged(StringHash eventType, VariantMap& eventData);

    void HandleFileSelected(StringHash eventType, VariantMap& eventData);

    void HandleFileDoubleClicked(StringHash eventType, VariantMap& eventData);

    void HandleFileListKey(StringHash eventType, VariantMap& eventData);

    void HandleOKPressed(StringHash eventType, VariantMap& eventData);

    void HandleCancelPressed(StringHash eventType, VariantMap& eventData);


    SharedPtr<Window> window_;

    UIElement* titleLayout;

    Text* titleText_;

    ListView* fileList_;

    LineEdit* pathEdit_;

    LineEdit* fileNameEdit_;

    DropDownList* filterList_;

    Button* okButton_;

    Text* okButtonText_;

    Button* cancelButton_;

    Text* cancelButtonText_;

    Button* closeButton_;

    UIElement* fileNameLayout_;

    UIElement* separatorLayout_;

    UIElement* buttonLayout_;

    String path_;

    Vector<String> filters_;

    Vector<FileSelectorEntry> fileEntries_;

    String lastUsedFilter_;

    bool directoryMode_;

    bool ignoreEvents_;
};

}
namespace Urho3D
{

class FontFace;

static const int FONT_TEXTURE_MIN_SIZE = 128;
static const int FONT_DPI = 96;


enum FontType
{
    FONT_NONE = 0,
    FONT_FREETYPE,
    FONT_BITMAP,
    MAX_FONT_TYPES
};


class __attribute__((visibility("default"))) Font : public Resource
{
    public: using ClassName = Font; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Font", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Font(Context* context);

    ~Font() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool SaveXML(Serializer& dest, int pointSize, bool usedGlyphs = false, const String& indentation = "\t");

    void SetAbsoluteGlyphOffset(const IntVector2& offset);

    void SetScaledGlyphOffset(const Vector2& offset);


    FontFace* GetFace(float pointSize);


    FontType GetFontType() const { return fontType_; }


    bool IsSDFFont() const { return sdfFont_; }


    const IntVector2& GetAbsoluteGlyphOffset() const { return absoluteOffset_; }


    const Vector2& GetScaledGlyphOffset() const { return scaledOffset_; }


    IntVector2 GetTotalGlyphOffset(float pointSize) const;


    void ReleaseFaces();

private:

    void LoadParameters();

    FontFace* GetFaceFreeType(float pointSize);

    FontFace* GetFaceBitmap(float pointSize);


    HashMap<int, SharedPtr<FontFace> > faces_;

    SharedArrayPtr<unsigned char> fontData_;

    unsigned fontDataSize_;

    IntVector2 absoluteOffset_;

    Vector2 scaledOffset_;

    FontType fontType_;

    bool sdfFont_;
};

}
namespace Urho3D
{

class Font;
class Image;
class Texture2D;


struct __attribute__((visibility("default"))) FontGlyph
{

    short x_{};

    short y_{};

    short texWidth_{};

    short texHeight_{};

    float width_{};

    float height_{};

    float offsetX_{};

    float offsetY_{};

    float advanceX_{};

    unsigned page_{M_MAX_UNSIGNED};

    bool used_{};
};


class __attribute__((visibility("default"))) FontFace : public RefCounted
{
    friend class Font;

public:

    explicit FontFace(Font* font);

    ~FontFace() override;


    virtual bool Load(const unsigned char* fontData, unsigned fontDataSize, float pointSize) = 0;

    virtual const FontGlyph* GetGlyph(unsigned c);


    virtual bool HasMutableGlyphs() const { return false; }


    float GetKerning(unsigned c, unsigned d) const;

    bool IsDataLost() const;


    float GetPointSize() const { return pointSize_; }


    float GetRowHeight() const { return rowHeight_; }


    const Vector<SharedPtr<Texture2D> >& GetTextures() const { return textures_; }

protected:
    friend class FontFaceBitmap;

    SharedPtr<Texture2D> CreateFaceTexture();

    SharedPtr<Texture2D> LoadFaceTexture(const SharedPtr<Image>& image);


    Font* font_{};

    HashMap<unsigned, FontGlyph> glyphMapping_;

    HashMap<unsigned, float> kerningMapping_;

    Vector<SharedPtr<Texture2D> > textures_;

    float pointSize_{};

    float rowHeight_{};
};

}
namespace Urho3D
{

class Image;
class Serializer;


class __attribute__((visibility("default"))) FontFaceBitmap : public FontFace
{
public:

    explicit FontFaceBitmap(Font* font);

    ~FontFaceBitmap() override;


    bool Load(const unsigned char* fontData, unsigned fontDataSize, float pointSize) override;

    bool Load(FontFace* fontFace, bool usedGlyphs);

    bool Save(Serializer& dest, int pointSize, const String& indentation = "\t");

private:

    unsigned ConvertFormatToNumComponents(unsigned format);

    SharedPtr<Image> SaveFaceTexture(Texture2D* texture);

    bool SaveFaceTexture(Texture2D* texture, const String& fileName);

    void Blit(Image* dest, int x, int y, int width, int height, Image* source, int sourceX, int sourceY, int components);
};

}
namespace Urho3D
{

class FreeTypeLibrary;
class Texture2D;


class __attribute__((visibility("default"))) FontFaceFreeType : public FontFace
{
public:

    explicit FontFaceFreeType(Font* font);

    ~FontFaceFreeType() override;


    bool Load(const unsigned char* fontData, unsigned fontDataSize, float pointSize) override;

    const FontGlyph* GetGlyph(unsigned c) override;


    bool HasMutableGlyphs() const override { return hasMutableGlyph_; }

private:

    bool SetupNextTexture(int textureWidth, int textureHeight);

    bool LoadCharGlyph(unsigned charCode, Image* image = nullptr);

    void BoxFilter(unsigned char* dest, size_t destSize, const unsigned char* src, size_t srcSize);


    SharedPtr<FreeTypeLibrary> freeType_;

    void* face_{};

    int loadMode_{};

    bool subpixel_{};

    int oversampling_{};

    float ascender_{};

    bool hasMutableGlyph_{};

    AreaAllocator allocator_;
};

}
namespace Urho3D
{

class Font;
class Text;


class __attribute__((visibility("default"))) LineEdit : public BorderImage
{
    public: using ClassName = LineEdit; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("LineEdit", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit LineEdit(Context* context);

    ~LineEdit() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void Update(float timeStep) override;

    void OnClickBegin
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) override;

    void OnDoubleClick
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) override;

    void
        OnDragBegin(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor) override;

    void OnDragMove
        (const IntVector2& position, const IntVector2& screenPosition, const IntVector2& deltaPos, int buttons, int qualifiers,
            Cursor* cursor) override;

    bool OnDragDropTest(UIElement* source) override;

    bool OnDragDropFinish(UIElement* source) override;

    void OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers) override;

    void OnTextInput(const String& text) override;


    void SetText(const String& text);

    void SetCursorPosition(unsigned position);

    void SetCursorBlinkRate(float rate);

    void SetMaxLength(unsigned length);

    void SetEchoCharacter(unsigned c);

    void SetCursorMovable(bool enable);

    void SetTextSelectable(bool enable);

    void SetTextCopyable(bool enable);


    const String& GetText() const { return line_; }


    unsigned GetCursorPosition() const { return cursorPosition_; }


    float GetCursorBlinkRate() const { return cursorBlinkRate_; }


    unsigned GetMaxLength() const { return maxLength_; }


    unsigned GetEchoCharacter() const { return echoCharacter_; }


    bool IsCursorMovable() const { return cursorMovable_; }


    bool IsTextSelectable() const { return textSelectable_; }


    bool IsTextCopyable() const { return textCopyable_; }


    Text* GetTextElement() const { return text_; }


    BorderImage* GetCursor() const { return cursor_; }

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    void UpdateText();

    void UpdateCursor();

    unsigned GetCharIndex(const IntVector2& position);


    SharedPtr<Text> text_;

    SharedPtr<BorderImage> cursor_;

    String line_;

    Font* lastFont_;

    int lastFontSize_;

    unsigned cursorPosition_;

    unsigned dragBeginCursor_;

    float cursorBlinkRate_;

    float cursorBlinkTimer_;

    unsigned maxLength_;

    unsigned echoCharacter_;

    bool cursorMovable_;

    bool textSelectable_;

    bool textCopyable_;

private:

    void HandleFocused(StringHash eventType, VariantMap& eventData);

    void HandleDefocused(StringHash eventType, VariantMap& eventData);

    void HandleLayoutUpdated(StringHash eventType, VariantMap& eventData);
};

}
namespace Urho3D
{

class BorderImage;
class ScrollBar;


class __attribute__((visibility("default"))) ScrollView : public UIElement
{
    public: using ClassName = ScrollView; using BaseClassName = UIElement; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ScrollView", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ScrollView(Context* context);

    ~ScrollView() override;

    static void RegisterObject(Context* context);


    void Update(float timeStep) override;

    void ApplyAttributes() override;

    void OnWheel(int delta, MouseButtonFlags buttons, QualifierFlags qualifiers) override;

    void OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers) override;

    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;


    bool IsWheelHandler() const override { return true; }


    void SetContentElement(UIElement* element);

    void SetViewPosition(const IntVector2& position);

    void SetViewPosition(int x, int y);

    void SetScrollBarsVisible(bool horizontal, bool vertical);

    void SetHorizontalScrollBarVisible(bool visible);

    void SetVerticalScrollBarVisible(bool visible);

    void SetScrollBarsAutoVisible(bool enable);

    void SetScrollStep(float step);

    void SetPageStep(float step);


    void SetScrollDeceleration(float deceleration) { scrollDeceleration_ = deceleration; }


    void SetScrollSnapEpsilon(float snap) { scrollSnapEpsilon_ = snap; }


    void SetAutoDisableChildren(bool disable) { autoDisableChildren_ = disable; };


    void SetAutoDisableThreshold(float amount) { autoDisableThreshold_ = amount; };


    const IntVector2& GetViewPosition() const { return viewPosition_; }


    UIElement* GetContentElement() const { return contentElement_; }


    ScrollBar* GetHorizontalScrollBar() const { return horizontalScrollBar_; }


    ScrollBar* GetVerticalScrollBar() const { return verticalScrollBar_; }


    BorderImage* GetScrollPanel() const { return scrollPanel_; }


    bool GetScrollBarsAutoVisible() const { return scrollBarsAutoVisible_; }


    bool GetHorizontalScrollBarVisible() const;


    bool GetVerticalScrollBarVisible() const;


    float GetScrollStep() const;


    float GetPageStep() const { return pageStep_; }


    float GetScrollDeceleration() const { return scrollDeceleration_; }


    float GetScrollSnapEpsilon() const { return scrollSnapEpsilon_; }


    bool GetAutoDisableChildren() const { return autoDisableChildren_; }


    float GetAutoDisableThreshold() const { return autoDisableThreshold_; }


    void SetViewPositionAttr(const IntVector2& value);

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    bool FilterScrollBarImplicitAttributes(XMLElement& dest, const String& name) const;

    void UpdatePanelSize();

    void UpdateViewSize();

    void UpdateScrollBars();

    void UpdateView(const IntVector2& position);


    SharedPtr<UIElement> contentElement_;

    SharedPtr<ScrollBar> horizontalScrollBar_;

    SharedPtr<ScrollBar> verticalScrollBar_;

    SharedPtr<BorderImage> scrollPanel_;

    IntVector2 viewPosition_;

    IntVector2 viewSize_;

    IntVector2 viewPositionAttr_;

    Vector2 touchScrollSpeed_;

    Vector2 touchScrollSpeedMax_;

    float pageStep_;

    bool scrollBarsAutoVisible_;

    bool ignoreEvents_;

    bool resizeContentWidth_;

    float scrollDeceleration_;

    float scrollSnapEpsilon_;

    bool scrollTouchDown_;

    bool barScrolling_;

    bool autoDisableChildren_;

    bool scrollChildrenDisable_;

    float touchDistanceSum_;

    float autoDisableThreshold_;

private:

    void HandleScrollBarChanged(StringHash eventType, VariantMap& eventData);

    void HandleScrollBarVisibleChanged(StringHash eventType, VariantMap& eventData);

    void HandleElementResized(StringHash eventType, VariantMap& eventData);

    void HandleTouchMove(StringHash eventType, VariantMap& eventData);

    void ScrollSmooth(float timeStep);
};

}


namespace Urho3D
{


enum HighlightMode
{

    HM_NEVER,

    HM_FOCUS,

    HM_ALWAYS
};


class __attribute__((visibility("default"))) ListView : public ScrollView
{
    public: using ClassName = ListView; using BaseClassName = ScrollView; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ListView", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ListView(Context* context);

    ~ListView() override;

    static void RegisterObject(Context* context);


    void OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers) override;

    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;


    void UpdateInternalLayout();

    void DisableInternalLayoutUpdate();

    void EnableInternalLayoutUpdate();


    void AddItem(UIElement* item);




    void InsertItem(unsigned index, UIElement* item, UIElement* parentItem = nullptr);

    void RemoveItem(UIElement* item, unsigned index = 0);

    void RemoveItem(unsigned index);

    void RemoveAllItems();

    void SetSelection(unsigned index);

    void SetSelections(const PODVector<unsigned>& indices);

    void AddSelection(unsigned index);

    void RemoveSelection(unsigned index);

    void ToggleSelection(unsigned index);

    void ChangeSelection(int delta, bool additive = false);

    void ClearSelection();

    void SetHighlightMode(HighlightMode mode);

    void SetMultiselect(bool enable);


    void SetHierarchyMode(bool enable);

    void SetBaseIndent(int baseIndent);

    void SetClearSelectionOnDefocus(bool enable);

    void SetSelectOnClickEnd(bool enable);


    void Expand(unsigned index, bool enable, bool recursive = false);

    void ToggleExpand(unsigned index, bool recursive = false);


    unsigned GetNumItems() const;

    UIElement* GetItem(unsigned index) const;

    PODVector<UIElement*> GetItems() const;

    unsigned FindItem(UIElement* item) const;

    unsigned GetSelection() const;


    const PODVector<unsigned>& GetSelections() const { return selections_; }


    void CopySelectedItemsToClipboard() const;

    UIElement* GetSelectedItem() const;

    PODVector<UIElement*> GetSelectedItems() const;

    bool IsSelected(unsigned index) const;

    bool IsExpanded(unsigned index) const;


    HighlightMode GetHighlightMode() const { return highlightMode_; }


    bool GetMultiselect() const { return multiselect_; }


    bool GetClearSelectionOnDefocus() const { return clearSelectionOnDefocus_; }


    bool GetSelectOnClickEnd() const { return selectOnClickEnd_; }


    bool GetHierarchyMode() const { return hierarchyMode_; }


    int GetBaseIndent() const { return baseIndent_; }


    void EnsureItemVisibility(unsigned index);

    void EnsureItemVisibility(UIElement* item);

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    void UpdateSelectionEffect();


    PODVector<unsigned> selections_;

    HighlightMode highlightMode_;

    bool multiselect_;

    bool hierarchyMode_;

    int baseIndent_;

    SharedPtr<UIElement> overlayContainer_;

    bool clearSelectionOnDefocus_;

    bool selectOnClickEnd_;

private:

    void HandleUIMouseClick(StringHash eventType, VariantMap& eventData);

    void HandleUIMouseDoubleClick(StringHash eventType, VariantMap& eventData);

    void HandleItemFocusChanged(StringHash eventType, VariantMap& eventData);

    void HandleFocusChanged(StringHash eventType, VariantMap& eventData);

    void UpdateUIClickSubscription();
};

}

namespace Urho3D
{

class Button;
class Text;
class UIElement;
class XMLFile;


class __attribute__((visibility("default"))) MessageBox : public Object
{
    public: using ClassName = MessageBox; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("MessageBox", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit MessageBox(Context* context, const String& messageString = String::EMPTY, const String& titleString = String::EMPTY,
        XMLFile* layoutFile = nullptr, XMLFile* styleFile = nullptr);

    ~MessageBox() override;

    static void RegisterObject(Context* context);


    void SetTitle(const String& text);

    void SetMessage(const String& text);


    const String& GetTitle() const;

    const String& GetMessage() const;


    UIElement* GetWindow() const { return window_; }

private:

    void HandleMessageAcknowledged(StringHash eventType, VariantMap& eventData);


    UIElement* window_;

    Text* titleText_;

    Text* messageText_;

    Button* okButton_;
};

}
namespace Urho3D
{

class __attribute__((visibility("default"))) UISelectable : public UIElement
{
public:
    public: using ClassName = UISelectable; using BaseClassName = UIElement; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("UISelectable", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };


    using UIElement::UIElement;

    ~UISelectable() override = default;


    static void RegisterObject(Context* context);


    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;


    void SetSelectionColor(const Color& color);

    void SetHoverColor(const Color& color);


    const Color& GetSelectionColor() const { return selectionColor_; }

    const Color& GetHoverColor() const { return hoverColor_; }

protected:

    Color selectionColor_{Color::TRANSPARENT_BLACK};

    Color hoverColor_{Color::TRANSPARENT_BLACK};
};

}


namespace Urho3D
{

static const float DEFAULT_FONT_SIZE = 12;

class Font;
class FontFace;
struct FontGlyph;


enum TextEffect
{
    TE_NONE = 0,
    TE_SHADOW,
    TE_STROKE
};


struct CharLocation
{

    Vector2 position_;

    Vector2 size_;
};


struct GlyphLocation
{

    GlyphLocation(float x, float y, const FontGlyph* glyph) :
        x_(x),
        y_(y),
        glyph_(glyph)
    {
    }


    float x_;

    float y_;

    const FontGlyph* glyph_;
};


class __attribute__((visibility("default"))) Text : public UISelectable
{
    public: using ClassName = Text; using BaseClassName = UISelectable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Text", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend class Text3D;

public:

    explicit Text(Context* context);

    ~Text() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;

    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;

    void OnIndentSet() override;


    bool SetFont(const String& fontName, float size = DEFAULT_FONT_SIZE);

    bool SetFont(Font* font, float size = DEFAULT_FONT_SIZE);

    bool SetFontSize(float size);

    void SetText(const String& text);

    void SetTextAlignment(HorizontalAlignment align);

    void SetRowSpacing(float spacing);

    void SetWordwrap(bool enable);

    void SetAutoLocalizable(bool enable);

    void SetSelection(unsigned start, unsigned length = M_MAX_UNSIGNED);

    void ClearSelection();

    void SetTextEffect(TextEffect textEffect);

    void SetEffectShadowOffset(const IntVector2& offset);

    void SetEffectStrokeThickness(int thickness);

    void SetEffectRoundStroke(bool roundStroke);

    void SetEffectColor(const Color& effectColor);


    Font* GetFont() const { return font_; }


    float GetFontSize() const { return fontSize_; }


    const String& GetText() const { return text_; }


    HorizontalAlignment GetTextAlignment() const { return textAlignment_; }


    float GetRowSpacing() const { return rowSpacing_; }


    bool GetWordwrap() const { return wordWrap_; }


    bool GetAutoLocalizable() const { return autoLocalizable_; }


    unsigned GetSelectionStart() const { return selectionStart_; }


    unsigned GetSelectionLength() const { return selectionLength_; }


    TextEffect GetTextEffect() const { return textEffect_; }


    const IntVector2& GetEffectShadowOffset() const { return shadowOffset_; }


    int GetEffectStrokeThickness() const { return strokeThickness_; }


    bool GetEffectRoundStroke() const { return roundStroke_; }


    const Color& GetEffectColor() const { return effectColor_; }


    float GetRowHeight() const { return rowHeight_; }


    unsigned GetNumRows() const { return rowWidths_.Size(); }


    unsigned GetNumChars() const { return unicodeText_.Size(); }


    float GetRowWidth(unsigned index) const;

    Vector2 GetCharPosition(unsigned index);

    Vector2 GetCharSize(unsigned index);


    void SetEffectDepthBias(float bias);


    float GetEffectDepthBias() const { return effectDepthBias_; }


    void SetFontAttr(const ResourceRef& value);

    ResourceRef GetFontAttr() const;

    void SetTextAttr(const String& value);

    String GetTextAttr() const;

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    void UpdateText(bool onResize = false);

    void UpdateCharLocations();

    void ValidateSelection();

    int GetRowStartPosition(unsigned rowIndex) const;

    void ConstructBatch
        (UIBatch& pageBatch, const PODVector<GlyphLocation>& pageGlyphLocation, float dx = 0, float dy = 0, Color* color = nullptr,
            float depthBias = 0.0f);


    SharedPtr<Font> font_;

    WeakPtr<FontFace> fontFace_;

    float fontSize_;

    String text_;

    HorizontalAlignment textAlignment_;

    float rowSpacing_;

    bool wordWrap_;

    bool charLocationsDirty_;

    unsigned selectionStart_;

    unsigned selectionLength_;

    TextEffect textEffect_;

    IntVector2 shadowOffset_;

    int strokeThickness_;

    bool roundStroke_;

    Color effectColor_;

    float effectDepthBias_;

    float rowHeight_;

    PODVector<unsigned> unicodeText_;

    PODVector<unsigned> printText_;

    PODVector<unsigned> printToText_;

    PODVector<float> rowWidths_;

    Vector<PODVector<GlyphLocation> > pageGlyphLocations_;

    PODVector<CharLocation> charLocations_;

    bool autoLocalizable_;

    String stringId_;

    void HandleChangeLanguage(StringHash eventType, VariantMap& eventData);

    void DecodeToUnicode();
};

}


namespace Urho3D
{


class __attribute__((visibility("default"))) ProgressBar : public BorderImage
{
    public: using ClassName = ProgressBar; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ProgressBar", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ProgressBar(Context *context);


    ~ProgressBar() override;


    static void RegisterObject(Context *context);


    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;


    void SetOrientation(Orientation orientation);


    void SetRange(float range);


    void SetValue(float value);


    void ChangeValue(float delta);


    Orientation GetOrientation() const { return orientation_; }


    float GetRange() const { return range_; }


    float GetValue() const { return value_; }


    BorderImage *GetKnob() const { return knob_; }


    void SetLoadingPercentStyle(const String &style) { loadingPercentStyle_ = style; }


    const String& GetLoadingPercentStyle() const { return loadingPercentStyle_; }


    void SetShowPercentText(bool enable);


    bool GetShowPercentText() const { return showPercentText_; }

protected:

    bool FilterImplicitAttributes(XMLElement &dest) const override;


    void UpdateProgressBar();


    SharedPtr <BorderImage> knob_;

    SharedPtr <Text> loadingText_;

    Orientation orientation_;

    String loadingPercentStyle_;

    float range_;

    float value_;

    bool showPercentText_;
};

}
namespace Urho3D
{

class Button;
class Slider;


class __attribute__((visibility("default"))) ScrollBar : public BorderImage
{
    public: using ClassName = ScrollBar; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ScrollBar", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ScrollBar(Context* context);

    ~ScrollBar() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;

    void OnSetEditable() override;


    void SetOrientation(Orientation orientation);

    void SetRange(float range);

    void SetValue(float value);

    void ChangeValue(float delta);

    void SetScrollStep(float step);

    void SetStepFactor(float factor);

    void StepBack();

    void StepForward();


    Orientation GetOrientation() const;

    float GetRange() const;

    float GetValue() const;


    float GetScrollStep() const { return scrollStep_; }


    float GetStepFactor() const { return stepFactor_; }


    float GetEffectiveScrollStep() const;


    Button* GetBackButton() const { return backButton_; }


    Button* GetForwardButton() const { return forwardButton_; }


    Slider* GetSlider() const { return slider_; }

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    bool FilterButtonImplicitAttributes(XMLElement& dest, const String& name) const;


    SharedPtr<Button> backButton_;

    SharedPtr<Button> forwardButton_;

    SharedPtr<Slider> slider_;

    float scrollStep_;

    float stepFactor_;

    IntRect leftRect_;

    IntRect rightRect_;

    IntRect upRect_;

    IntRect downRect_;

private:

    void HandleBackButtonPressed(StringHash eventType, VariantMap& eventData);

    void HandleForwardButtonPressed(StringHash eventType, VariantMap& eventData);

    void HandleSliderChanged(StringHash eventType, VariantMap& eventData);

    void HandleSliderPaged(StringHash eventType, VariantMap& eventData);
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) Slider : public BorderImage
{
    public: using ClassName = Slider; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Slider", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Slider(Context* context);

    ~Slider() override;

    static void RegisterObject(Context* context);


    void Update(float timeStep) override;

    void OnHover(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor) override;

    void OnClickBegin
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor) override;

    void OnClickEnd
        (const IntVector2& position, const IntVector2& screenPosition, int button, int buttons, int qualifiers, Cursor* cursor,
            UIElement* beginElement) override;

    void
        OnDragBegin(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor) override;

    void OnDragMove
        (const IntVector2& position, const IntVector2& screenPosition, const IntVector2& deltaPos, int buttons, int qualifiers,
            Cursor* cursor) override;

    void
        OnDragEnd(const IntVector2& position, const IntVector2& screenPosition, int dragButtons, int buttons, Cursor* cursor) override;

    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;


    void SetOrientation(Orientation orientation);

    void SetRange(float range);

    void SetValue(float value);

    void ChangeValue(float delta);

    void SetRepeatRate(float rate);


    Orientation GetOrientation() const { return orientation_; }


    float GetRange() const { return range_; }


    float GetValue() const { return value_; }


    BorderImage* GetKnob() const { return knob_; }


    float GetRepeatRate() const { return repeatRate_; }

protected:

    bool FilterImplicitAttributes(XMLElement& dest) const override;

    void UpdateSlider();

    void Page(const IntVector2& position, bool pressed);


    SharedPtr<BorderImage> knob_;

    Orientation orientation_;

    float range_;

    float value_;

    bool dragSlider_;

    IntVector2 dragBeginCursor_;

    IntVector2 dragBeginPosition_;

    float repeatRate_;

    Timer repeatTimer_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) Sprite : public UIElement
{
    public: using ClassName = Sprite; using BaseClassName = UIElement; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Sprite", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Sprite(Context* context);

    ~Sprite() override;

    static void RegisterObject(Context* context);


    bool IsWithinScissor(const IntRect& currentScissor) override;

    const IntVector2& GetScreenPosition() const override;

    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;

    void OnPositionSet(const IntVector2& newPosition) override;

    IntVector2 ScreenToElement(const IntVector2& screenPosition) override;

    IntVector2 ElementToScreen(const IntVector2& position) override;


    void SetPosition(const Vector2& position);

    void SetPosition(float x, float y);

    void SetHotSpot(const IntVector2& hotSpot);

    void SetHotSpot(int x, int y);

    void SetScale(const Vector2& scale);

    void SetScale(float x, float y);

    void SetScale(float scale);

    void SetRotation(float angle);

    void SetTexture(Texture* texture);

    void SetImageRect(const IntRect& rect);

    void SetFullImageRect();

    void SetBlendMode(BlendMode mode);


    const Vector2& GetPosition() const { return floatPosition_; }


    const IntVector2& GetHotSpot() const { return hotSpot_; }


    const Vector2& GetScale() const { return scale_; }


    float GetRotation() const { return rotation_; }


    Texture* GetTexture() const { return texture_; }


    const IntRect& GetImageRect() const { return imageRect_; }


    BlendMode GetBlendMode() const { return blendMode_; }


    void SetTextureAttr(const ResourceRef& value);

    ResourceRef GetTextureAttr() const;

    const Matrix3x4& GetTransform() const;

protected:

    Vector2 floatPosition_;

    IntVector2 hotSpot_;

    Vector2 scale_;

    float rotation_;

    SharedPtr<Texture> texture_;

    IntRect imageRect_;

    BlendMode blendMode_;

    mutable Matrix3x4 transform_;
};

}

namespace Urho3D
{

class Text;


class __attribute__((visibility("default"))) Text3D : public Drawable
{
    public: using ClassName = Text3D; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Text3D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Text3D(Context* context);

    ~Text3D() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;


    bool SetFont(const String& fontName, float size = DEFAULT_FONT_SIZE);

    bool SetFont(Font* font, float size = DEFAULT_FONT_SIZE);

    bool SetFontSize(float size);

    void SetMaterial(Material* material);

    void SetText(const String& text);

    void SetAlignment(HorizontalAlignment hAlign, VerticalAlignment vAlign);

    void SetHorizontalAlignment(HorizontalAlignment align);

    void SetVerticalAlignment(VerticalAlignment align);

    void SetTextAlignment(HorizontalAlignment align);

    void SetRowSpacing(float spacing);

    void SetWordwrap(bool enable);

    void SetTextEffect(TextEffect textEffect);

    void SetEffectShadowOffset(const IntVector2& offset);

    void SetEffectStrokeThickness(int thickness);

    void SetEffectRoundStroke(bool roundStroke);

    void SetEffectColor(const Color& effectColor);

    void SetEffectDepthBias(float bias);

    void SetWidth(int width);

    void SetColor(const Color& color);

    void SetColor(Corner corner, const Color& color);

    void SetOpacity(float opacity);

    void SetFixedScreenSize(bool enable);

    void SetFaceCameraMode(FaceCameraMode mode);


    Font* GetFont() const;

    float GetFontSize() const;

    Material* GetMaterial() const;

    const String& GetText() const;

    HorizontalAlignment GetTextAlignment() const;

    HorizontalAlignment GetHorizontalAlignment() const;

    VerticalAlignment GetVerticalAlignment() const;

    float GetRowSpacing() const;

    bool GetWordwrap() const;

    TextEffect GetTextEffect() const;

    const IntVector2& GetEffectShadowOffset() const;

    int GetEffectStrokeThickness() const;

    bool GetEffectRoundStroke() const;

    const Color& GetEffectColor() const;

    float GetEffectDepthBias() const;

    int GetWidth() const;

    int GetHeight() const;

    int GetRowHeight() const;

    unsigned GetNumRows() const;

    unsigned GetNumChars() const;

    int GetRowWidth(unsigned index) const;

    Vector2 GetCharPosition(unsigned index);

    Vector2 GetCharSize(unsigned index);

    const Color& GetColor(Corner corner) const;

    float GetOpacity() const;

    bool IsFixedScreenSize() const { return fixedScreenSize_; }

    FaceCameraMode GetFaceCameraMode() const { return faceCameraMode_; }


    void SetFontAttr(const ResourceRef& value);

    ResourceRef GetFontAttr() const;

    void SetMaterialAttr(const ResourceRef& value);

    ResourceRef GetMaterialAttr() const;

    void SetTextAttr(const String& value);

    String GetTextAttr() const;


    const Color& GetColorAttr() const { return text_.colors_[0]; }

protected:

    void OnNodeSet(Node* node) override;

    void OnWorldBoundingBoxUpdate() override;

    void MarkTextDirty();

    void UpdateTextBatches();

    void UpdateTextMaterials(bool forceUpdate = false);

    void CalculateFixedScreenSize(const FrameInfo& frame);


    Text text_;

    Vector<SharedPtr<Geometry> > geometries_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    SharedPtr<Material> material_;

    PODVector<UIBatch> uiBatches_;

    PODVector<float> uiVertexData_;

    Matrix3x4 customWorldTransform_;

    FaceCameraMode faceCameraMode_;

    float minAngle_;

    bool fixedScreenSize_;

    bool textDirty_;

    bool geometryDirty_;

    bool usingSDFShader_;

    bool fontDataLost_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ToolTip : public UIElement
{
    public: using ClassName = ToolTip; using BaseClassName = UIElement; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ToolTip", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; }

public:

    explicit ToolTip(Context* context);

    ~ToolTip() override;

    static void RegisterObject(Context* context);


    void Update(float timeStep) override;


    void Reset();


    void AddAltTarget(UIElement* target);


    void SetDelay(float delay);


    float GetDelay() const { return delay_; }

private:

    WeakPtr<UIElement> target_;

    Vector<WeakPtr<UIElement> > altTargets_;

    float delay_;

    bool hovered_;

    Timer displayAt_;

    IntVector2 originalPosition_;
};

}
namespace Urho3D
{


enum FontHintLevel
{

    FONT_HINT_LEVEL_NONE = 0,


    FONT_HINT_LEVEL_LIGHT,


    FONT_HINT_LEVEL_NORMAL
};

class Cursor;
class Graphics;
class ResourceCache;
class Timer;
class UIBatch;
class UIElement;
class XMLElement;
class XMLFile;
class RenderSurface;
class UIComponent;


class __attribute__((visibility("default"))) UI : public Object
{
    public: using ClassName = UI; using BaseClassName = Object; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("UI", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit UI(Context* context);

    ~UI() override;


    void SetCursor(Cursor* cursor);

    void SetFocusElement(UIElement* element, bool byKey = false);


    bool SetModalElement(UIElement* modalElement, bool enable);

    void Clear();

    void Update(float timeStep);

    void RenderUpdate();

    void Render(bool renderUICommand = false);

    void DebugDraw(UIElement* element);

    SharedPtr<UIElement> LoadLayout(Deserializer& source, XMLFile* styleFile = nullptr);

    SharedPtr<UIElement> LoadLayout(XMLFile* file, XMLFile* styleFile = nullptr);

    bool SaveLayout(Serializer& dest, UIElement* element);

    void SetClipboardText(const String& text);

    void SetDoubleClickInterval(float interval);

    void SetMaxDoubleClickDistance(float distPixels);

    void SetDragBeginInterval(float interval);

    void SetDragBeginDistance(int pixels);

    void SetDefaultToolTipDelay(float delay);

    void SetMaxFontTextureSize(int size);

    void SetNonFocusedMouseWheel(bool nonFocusedMouseWheel);

    void SetUseSystemClipboard(bool enable);

    void SetUseScreenKeyboard(bool enable);

    void SetUseMutableGlyphs(bool enable);

    void SetForceAutoHint(bool enable);

    void SetFontHintLevel(FontHintLevel level);

    void SetFontSubpixelThreshold(float threshold);

    void SetFontOversampling(int oversampling);

    void SetScale(float scale);

    void SetWidth(float width);

    void SetHeight(float height);

    void SetCustomSize(const IntVector2& size);

    void SetCustomSize(int width, int height);


    UIElement* GetRoot() const { return rootElement_; }


    UIElement* GetRootModalElement() const { return rootModalElement_; }


    Cursor* GetCursor() const { return cursor_; }


    IntVector2 GetCursorPosition() const;

    UIElement* GetElementAt(const IntVector2& position, bool enabledOnly = true);

    UIElement* GetElementAt(int x, int y, bool enabledOnly = true);

    UIElement* GetElementAt(UIElement* root, const IntVector2& position, bool enabledOnly=true);


    UIElement* GetFocusElement() const { return focusElement_; }


    UIElement* GetFrontElement() const;

    const Vector<UIElement*> GetDragElements();


    unsigned GetNumDragElements() const { return (unsigned)dragConfirmedCount_; }


    UIElement* GetDragElement(unsigned index);

    const String& GetClipboardText() const;


    float GetDoubleClickInterval() const { return doubleClickInterval_; }


    float GetMaxDoubleClickDistance() const { return maxDoubleClickDist_;}


    float GetDragBeginInterval() const { return dragBeginInterval_; }


    int GetDragBeginDistance() const { return dragBeginDistance_; }


    float GetDefaultToolTipDelay() const { return defaultToolTipDelay_; }


    int GetMaxFontTextureSize() const { return maxFontTextureSize_; }


    bool IsNonFocusedMouseWheel() const { return nonFocusedMouseWheel_; }


    bool GetUseSystemClipboard() const { return useSystemClipboard_; }


    bool GetUseScreenKeyboard() const { return useScreenKeyboard_; }


    bool GetUseMutableGlyphs() const { return useMutableGlyphs_; }


    bool GetForceAutoHint() const { return forceAutoHint_; }


    FontHintLevel GetFontHintLevel() const { return fontHintLevel_; }


    float GetFontSubpixelThreshold() const { return fontSubpixelThreshold_; }


    int GetFontOversampling() const { return fontOversampling_; }


    bool HasModalElement() const;


    bool IsDragging() const { return dragConfirmedCount_ > 0; };


    float GetScale() const { return uiScale_; }


    const IntVector2& GetCustomSize() const { return customSize_; }


    void SetElementRenderTexture(UIElement* element, Texture2D* texture);


    struct DragData
    {

        MouseButtonFlags dragButtons;

        int numDragButtons;

        IntVector2 sumPos;

        bool dragBeginPending;

        Timer dragBeginTimer;

        IntVector2 dragBeginSumPos;
    };

private:

    struct RenderToTextureData
    {

        WeakPtr<UIElement> rootElement_;

        SharedPtr<Texture2D> texture_;

        PODVector<UIBatch> batches_;

        PODVector<float> vertexData_;

        SharedPtr<VertexBuffer> vertexBuffer_;

        PODVector<UIBatch> debugDrawBatches_;

        PODVector<float> debugVertexData_;

        SharedPtr<VertexBuffer> debugVertexBuffer_;
    };


    void Initialize();

    void Update(float timeStep, UIElement* element);

    void SetVertexData(VertexBuffer* dest, const PODVector<float>& vertexData);

    void Render(VertexBuffer* buffer, const PODVector<UIBatch>& batches, unsigned batchStart, unsigned batchEnd);

    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, UIElement* element, IntRect currentScissor);

    UIElement* GetElementAt(const IntVector2& position, bool enabledOnly, IntVector2* elementScreenPosition);

    void GetElementAt(UIElement*& result, UIElement* current, const IntVector2& position, bool enabledOnly);

    UIElement* GetFocusableElement(UIElement* element);

    void GetCursorPositionAndVisible(IntVector2& pos, bool& visible);

    void SetCursorShape(CursorShape shape);

    void ReleaseFontFaces();

    void ProcessHover(const IntVector2& windowCursorPos, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor);

    void
        ProcessClickBegin(const IntVector2& windowCursorPos, MouseButton button, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor, bool cursorVisible);

    void ProcessClickEnd(const IntVector2& windowCursorPos, MouseButton button, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor, bool cursorVisible);

    void ProcessMove(const IntVector2& windowCursorPos, const IntVector2& cursorDeltaPos, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor,
        bool cursorVisible);

    void SendDragOrHoverEvent
        (StringHash eventType, UIElement* element, const IntVector2& screenPos, const IntVector2& deltaPos, UI::DragData* dragData);

    void SendClickEvent
        (StringHash eventType, UIElement* beginElement, UIElement* endElement, const IntVector2& pos, MouseButton button, MouseButtonFlags buttons,
            QualifierFlags qualifiers);


    void SendDoubleClickEvent(UIElement* beginElement, UIElement* endElement, const IntVector2& firstPos, const IntVector2& secondPos, MouseButton button, MouseButtonFlags buttons, QualifierFlags qualifiers);


    void HandleScreenMode(StringHash eventType, VariantMap& eventData);

    void HandleMouseButtonDown(StringHash eventType, VariantMap& eventData);

    void HandleMouseButtonUp(StringHash eventType, VariantMap& eventData);

    void HandleMouseMove(StringHash eventType, VariantMap& eventData);

    void HandleMouseWheel(StringHash eventType, VariantMap& eventData);

    void HandleTouchBegin(StringHash eventType, VariantMap& eventData);

    void HandleTouchEnd(StringHash eventType, VariantMap& eventData);

    void HandleTouchMove(StringHash eventType, VariantMap& eventData);

    void HandleKeyDown(StringHash eventType, VariantMap& eventData);

    void HandleTextInput(StringHash eventType, VariantMap& eventData);

    void HandleBeginFrame(StringHash eventType, VariantMap& eventData);

    void HandlePostUpdate(StringHash eventType, VariantMap& eventData);

    void HandleRenderUpdate(StringHash eventType, VariantMap& eventData);

    void HandleDropFile(StringHash eventType, VariantMap& eventData);

    HashMap<WeakPtr<UIElement>, DragData*>::Iterator DragElementErase(HashMap<WeakPtr<UIElement>, DragData*>::Iterator i);

    void ProcessDragCancel();

    IntVector2 SumTouchPositions(UI::DragData* dragData, const IntVector2& oldSendPos);

    void ResizeRootElement();

    IntVector2 GetEffectiveRootElementSize(bool applyScale = true) const;


    WeakPtr<Graphics> graphics_;

    SharedPtr<UIElement> rootElement_;

    SharedPtr<UIElement> rootModalElement_;

    SharedPtr<Cursor> cursor_;

    WeakPtr<UIElement> focusElement_;

    PODVector<UIBatch> batches_;

    PODVector<float> vertexData_;

    PODVector<UIBatch> debugDrawBatches_;

    PODVector<float> debugVertexData_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    SharedPtr<VertexBuffer> debugVertexBuffer_;

    PODVector<UIElement*> tempElements_;

    mutable String clipBoard_;

    float doubleClickInterval_;

    float dragBeginInterval_;

    float defaultToolTipDelay_;

    int dragBeginDistance_;

    MouseButtonFlags mouseButtons_;

    MouseButtonFlags lastMouseButtons_;

    QualifierFlags qualifiers_;

    int maxFontTextureSize_;

    bool initialized_;

    bool usingTouchInput_;

    bool nonFocusedMouseWheel_;

    bool useSystemClipboard_;

    bool useScreenKeyboard_;

    bool useMutableGlyphs_;

    bool forceAutoHint_;

    FontHintLevel fontHintLevel_;

    float fontSubpixelThreshold_;

    int fontOversampling_;

    bool uiRendered_;

    unsigned nonModalBatchSize_;

    Timer clickTimer_;

    WeakPtr<UIElement> doubleClickElement_;

    IntVector2 doubleClickFirstPos_;

    float maxDoubleClickDist_;

    HashMap<WeakPtr<UIElement>, bool> hoveredElements_;

    HashMap<WeakPtr<UIElement>, DragData*> dragElements_;

    int dragElementsCount_;

    int dragConfirmedCount_;

    HashMap<WeakPtr<UIElement>, MouseButtonFlags> touchDragElements_;

    Vector<UIElement*> dragElementsConfirmed_;

    float uiScale_;

    IntVector2 customSize_;

    HashMap<UIElement*, RenderToTextureData> renderToTexture_;
};


void __attribute__((visibility("default"))) RegisterUILibrary(Context* context);

}

namespace Urho3D
{

class Material;
class Texture2D;
class StaticModel;
class Viewport;
class UIElement;
class UIBatch;
class VertexBuffer;
class UIElement3D;

class __attribute__((visibility("default"))) UIComponent : public Component
{
    public: using ClassName = UIComponent; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("UIComponent", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit UIComponent(Context* context);

    ~UIComponent() override;

    static void RegisterObject(Context* context);


    UIElement* GetRoot() const;

    Material* GetMaterial() const;

    Texture2D* GetTexture() const;

    void SetViewportIndex(unsigned int index);

protected:

    void OnNodeSet(Node* node) override;

    void OnElementResized(StringHash eventType, VariantMap& args);


    SharedPtr<Material> material_;

    SharedPtr<Texture2D> texture_;

    SharedPtr<StaticModel> model_;

    SharedPtr<UIElement3D> rootElement_;

    unsigned viewportIndex_;
};

}

namespace Urho3D
{


static const Urho3D::StringHash E_UIMOUSECLICK(Urho3D::GetEventNameRegister().RegisterString("UIMouseClick")); namespace UIMouseClick
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_UIMOUSECLICKEND(Urho3D::GetEventNameRegister().RegisterString("UIMouseClickEnd")); namespace UIMouseClickEnd
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_BEGINELEMENT("BeginElement");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_UIMOUSEDOUBLECLICK(Urho3D::GetEventNameRegister().RegisterString("UIMouseDoubleClick")); namespace UIMouseDoubleClick
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_XBEGIN("XBegin");
    static const Urho3D::StringHash P_YBEGIN("YBegin");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_CLICK(Urho3D::GetEventNameRegister().RegisterString("Click")); namespace Click
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_CLICKEND(Urho3D::GetEventNameRegister().RegisterString("ClickEnd")); namespace ClickEnd
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_BEGINELEMENT("BeginElement");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_DOUBLECLICK(Urho3D::GetEventNameRegister().RegisterString("DoubleClick")); namespace DoubleClick
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_XBEGIN("XBegin");
    static const Urho3D::StringHash P_YBEGIN("YBegin");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_DRAGDROPTEST(Urho3D::GetEventNameRegister().RegisterString("DragDropTest")); namespace DragDropTest
{
    static const Urho3D::StringHash P_SOURCE("Source");
    static const Urho3D::StringHash P_TARGET("Target");
    static const Urho3D::StringHash P_ACCEPT("Accept");
}


static const Urho3D::StringHash E_DRAGDROPFINISH(Urho3D::GetEventNameRegister().RegisterString("DragDropFinish")); namespace DragDropFinish
{
    static const Urho3D::StringHash P_SOURCE("Source");
    static const Urho3D::StringHash P_TARGET("Target");
    static const Urho3D::StringHash P_ACCEPT("Accept");
}


static const Urho3D::StringHash E_FOCUSCHANGED(Urho3D::GetEventNameRegister().RegisterString("FocusChanged")); namespace FocusChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_CLICKEDELEMENT("ClickedElement");
}


static const Urho3D::StringHash E_NAMECHANGED(Urho3D::GetEventNameRegister().RegisterString("NameChanged")); namespace NameChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_RESIZED(Urho3D::GetEventNameRegister().RegisterString("Resized")); namespace Resized
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_WIDTH("Width");
    static const Urho3D::StringHash P_HEIGHT("Height");
    static const Urho3D::StringHash P_DX("DX");
    static const Urho3D::StringHash P_DY("DY");
}


static const Urho3D::StringHash E_POSITIONED(Urho3D::GetEventNameRegister().RegisterString("Positioned")); namespace Positioned
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
}


static const Urho3D::StringHash E_VISIBLECHANGED(Urho3D::GetEventNameRegister().RegisterString("VisibleChanged")); namespace VisibleChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_VISIBLE("Visible");
}


static const Urho3D::StringHash E_FOCUSED(Urho3D::GetEventNameRegister().RegisterString("Focused")); namespace Focused
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_BYKEY("ByKey");
}


static const Urho3D::StringHash E_DEFOCUSED(Urho3D::GetEventNameRegister().RegisterString("Defocused")); namespace Defocused
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_LAYOUTUPDATED(Urho3D::GetEventNameRegister().RegisterString("LayoutUpdated")); namespace LayoutUpdated
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_PRESSED(Urho3D::GetEventNameRegister().RegisterString("Pressed")); namespace Pressed
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_RELEASED(Urho3D::GetEventNameRegister().RegisterString("Released")); namespace Released
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_TOGGLED(Urho3D::GetEventNameRegister().RegisterString("Toggled")); namespace Toggled
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_STATE("State");
}


static const Urho3D::StringHash E_SLIDERCHANGED(Urho3D::GetEventNameRegister().RegisterString("SliderChanged")); namespace SliderChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_VALUE("Value");
}


static const Urho3D::StringHash E_SLIDERPAGED(Urho3D::GetEventNameRegister().RegisterString("SliderPaged")); namespace SliderPaged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_OFFSET("Offset");
    static const Urho3D::StringHash P_PRESSED("Pressed");
}


static const Urho3D::StringHash E_PROGRESSBARCHANGED(Urho3D::GetEventNameRegister().RegisterString("ProgressBarChanged")); namespace ProgressBarChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_VALUE("Value");
}


static const Urho3D::StringHash E_SCROLLBARCHANGED(Urho3D::GetEventNameRegister().RegisterString("ScrollBarChanged")); namespace ScrollBarChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_VALUE("Value");
}


static const Urho3D::StringHash E_VIEWCHANGED(Urho3D::GetEventNameRegister().RegisterString("ViewChanged")); namespace ViewChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
}


static const Urho3D::StringHash E_MODALCHANGED(Urho3D::GetEventNameRegister().RegisterString("ModalChanged")); namespace ModalChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_MODAL("Modal");
}


static const Urho3D::StringHash E_TEXTENTRY(Urho3D::GetEventNameRegister().RegisterString("TextEntry")); namespace TextEntry
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_TEXT("Text");
}


static const Urho3D::StringHash E_TEXTCHANGED(Urho3D::GetEventNameRegister().RegisterString("TextChanged")); namespace TextChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_TEXT("Text");
}


static const Urho3D::StringHash E_TEXTFINISHED(Urho3D::GetEventNameRegister().RegisterString("TextFinished")); namespace TextFinished
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_TEXT("Text");
    static const Urho3D::StringHash P_VALUE("Value");
}


static const Urho3D::StringHash E_MENUSELECTED(Urho3D::GetEventNameRegister().RegisterString("MenuSelected")); namespace MenuSelected
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_ITEMSELECTED(Urho3D::GetEventNameRegister().RegisterString("ItemSelected")); namespace ItemSelected
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_SELECTION("Selection");
}


static const Urho3D::StringHash E_ITEMDESELECTED(Urho3D::GetEventNameRegister().RegisterString("ItemDeselected")); namespace ItemDeselected
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_SELECTION("Selection");
}


static const Urho3D::StringHash E_SELECTIONCHANGED(Urho3D::GetEventNameRegister().RegisterString("SelectionChanged")); namespace SelectionChanged
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_ITEMCLICKED(Urho3D::GetEventNameRegister().RegisterString("ItemClicked")); namespace ItemClicked
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_ITEM("Item");
    static const Urho3D::StringHash P_SELECTION("Selection");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_ITEMDOUBLECLICKED(Urho3D::GetEventNameRegister().RegisterString("ItemDoubleClicked")); namespace ItemDoubleClicked
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_ITEM("Item");
    static const Urho3D::StringHash P_SELECTION("Selection");
    static const Urho3D::StringHash P_BUTTON("Button");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_UNHANDLEDKEY(Urho3D::GetEventNameRegister().RegisterString("UnhandledKey")); namespace UnhandledKey
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_KEY("Key");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_QUALIFIERS("Qualifiers");
}


static const Urho3D::StringHash E_FILESELECTED(Urho3D::GetEventNameRegister().RegisterString("FileSelected")); namespace FileSelected
{
    static const Urho3D::StringHash P_FILENAME("FileName");
    static const Urho3D::StringHash P_FILTER("Filter");
    static const Urho3D::StringHash P_OK("OK");
}


static const Urho3D::StringHash E_MESSAGEACK(Urho3D::GetEventNameRegister().RegisterString("MessageACK")); namespace MessageACK
{
    static const Urho3D::StringHash P_OK("OK");
}


static const Urho3D::StringHash E_ELEMENTADDED(Urho3D::GetEventNameRegister().RegisterString("ElementAdded")); namespace ElementAdded
{
    static const Urho3D::StringHash P_ROOT("Root");
    static const Urho3D::StringHash P_PARENT("Parent");
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_ELEMENTREMOVED(Urho3D::GetEventNameRegister().RegisterString("ElementRemoved")); namespace ElementRemoved
{
    static const Urho3D::StringHash P_ROOT("Root");
    static const Urho3D::StringHash P_PARENT("Parent");
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_HOVERBEGIN(Urho3D::GetEventNameRegister().RegisterString("HoverBegin")); namespace HoverBegin
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_ELEMENTX("ElementX");
    static const Urho3D::StringHash P_ELEMENTY("ElementY");
}


static const Urho3D::StringHash E_HOVEREND(Urho3D::GetEventNameRegister().RegisterString("HoverEnd")); namespace HoverEnd
{
    static const Urho3D::StringHash P_ELEMENT("Element");
}


static const Urho3D::StringHash E_DRAGBEGIN(Urho3D::GetEventNameRegister().RegisterString("DragBegin")); namespace DragBegin
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_ELEMENTX("ElementX");
    static const Urho3D::StringHash P_ELEMENTY("ElementY");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_NUMBUTTONS("NumButtons");
}


static const Urho3D::StringHash E_DRAGMOVE(Urho3D::GetEventNameRegister().RegisterString("DragMove")); namespace DragMove
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_DX("DX");
    static const Urho3D::StringHash P_DY("DY");
    static const Urho3D::StringHash P_ELEMENTX("ElementX");
    static const Urho3D::StringHash P_ELEMENTY("ElementY");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_NUMBUTTONS("NumButtons");
}


static const Urho3D::StringHash E_DRAGEND(Urho3D::GetEventNameRegister().RegisterString("DragEnd")); namespace DragEnd
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_ELEMENTX("ElementX");
    static const Urho3D::StringHash P_ELEMENTY("ElementY");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_NUMBUTTONS("NumButtons");
}


static const Urho3D::StringHash E_DRAGCANCEL(Urho3D::GetEventNameRegister().RegisterString("DragCancel")); namespace DragCancel
{
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_ELEMENTX("ElementX");
    static const Urho3D::StringHash P_ELEMENTY("ElementY");
    static const Urho3D::StringHash P_BUTTONS("Buttons");
    static const Urho3D::StringHash P_NUMBUTTONS("NumButtons");
}


static const Urho3D::StringHash E_UIDROPFILE(Urho3D::GetEventNameRegister().RegisterString("UIDropFile")); namespace UIDropFile
{
    static const Urho3D::StringHash P_FILENAME("FileName");
    static const Urho3D::StringHash P_ELEMENT("Element");
    static const Urho3D::StringHash P_X("X");
    static const Urho3D::StringHash P_Y("Y");
    static const Urho3D::StringHash P_ELEMENTX("ElementX");
    static const Urho3D::StringHash P_ELEMENTY("ElementY");
}

}

namespace Urho3D
{


enum WindowDragMode
{
    DRAG_NONE,
    DRAG_MOVE,
    DRAG_RESIZE_TOPLEFT,
    DRAG_RESIZE_TOP,
    DRAG_RESIZE_TOPRIGHT,
    DRAG_RESIZE_RIGHT,
    DRAG_RESIZE_BOTTOMRIGHT,
    DRAG_RESIZE_BOTTOM,
    DRAG_RESIZE_BOTTOMLEFT,
    DRAG_RESIZE_LEFT
};


class __attribute__((visibility("default"))) Window : public BorderImage
{
    public: using ClassName = Window; using BaseClassName = BorderImage; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Window", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Window(Context* context);

    ~Window() override;

    static void RegisterObject(Context* context);


    void GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor) override;


    void OnHover(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor) override;

    void
        OnDragBegin(const IntVector2& position, const IntVector2& screenPosition, int buttons, int qualifiers, Cursor* cursor) override;

    void OnDragMove
        (const IntVector2& position, const IntVector2& screenPosition, const IntVector2& deltaPos, int buttons, int qualifiers,
            Cursor* cursor) override;

    void
        OnDragEnd(const IntVector2& position, const IntVector2& screenPosition, int dragButtons, int buttons, Cursor* cursor) override;

    void
        OnDragCancel(const IntVector2& position, const IntVector2& screenPosition, int dragButtons, int buttons, Cursor* cursor) override;


    void SetMovable(bool enable);

    void SetResizable(bool enable);

    void SetFixedWidthResizing(bool enable);

    void SetFixedHeightResizing(bool enable);

    void SetResizeBorder(const IntRect& rect);

    void SetModal(bool modal);

    void SetModalShadeColor(const Color& color);

    void SetModalFrameColor(const Color& color);

    void SetModalFrameSize(const IntVector2& size);

    void SetModalAutoDismiss(bool enable);


    bool IsMovable() const { return movable_; }


    bool IsResizable() const { return resizable_; }


    bool GetFixedWidthResizing() const { return fixedWidthResizing_; }


    bool GetFixedHeightResizing() const { return fixedHeightResizing_; }


    const IntRect& GetResizeBorder() const { return resizeBorder_; }


    bool IsModal() const { return modal_; }


    const Color& GetModalShadeColor() const { return modalShadeColor_; }


    const Color& GetModalFrameColor() const { return modalFrameColor_; }


    const IntVector2& GetModalFrameSize() const { return modalFrameSize_; }


    bool GetModalAutoDismiss() const { return modalAutoDismiss_; }

protected:

    WindowDragMode GetDragMode(const IntVector2& position) const;

    void SetCursorShape(WindowDragMode mode, Cursor* cursor) const;

    void ValidatePosition();

    bool CheckAlignment() const;


    bool movable_;

    bool resizable_;

    bool fixedWidthResizing_;

    bool fixedHeightResizing_;

    IntRect resizeBorder_;

    WindowDragMode dragMode_;

    IntVector2 dragBeginCursor_;

    IntVector2 dragBeginPosition_;

    IntVector2 dragBeginSize_;

    bool modal_;

    bool modalAutoDismiss_;

    Color modalShadeColor_;

    Color modalFrameColor_;

    IntVector2 modalFrameSize_;
};

}


namespace Urho3D
{

class Camera;
class Node;
class Scene;
class Texture2D;
class Viewport;


class __attribute__((visibility("default"))) View3D : public Window
{
    public: using ClassName = View3D; using BaseClassName = Window; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("View3D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit View3D(Context* context);

    ~View3D() override;

    static void RegisterObject(Context* context);


    void OnResize(const IntVector2& newSize, const IntVector2& delta) override;


    void SetView(Scene* scene, Camera* camera, bool ownScene = true);

    void SetFormat(unsigned format);

    void SetAutoUpdate(bool enable);

    void QueueUpdate();


    unsigned GetFormat() const { return rttFormat_; }


    bool GetAutoUpdate() const { return autoUpdate_; }


    Scene* GetScene() const;

    Node* GetCameraNode() const;

    Texture2D* GetRenderTexture() const;

    Texture2D* GetDepthTexture() const;

    Viewport* GetViewport() const;

private:

    void ResetScene();

    void HandleRenderSurfaceUpdate(StringHash eventType, VariantMap& eventData);


    SharedPtr<Texture2D> renderTexture_;

    SharedPtr<Texture2D> depthTexture_;

    SharedPtr<Viewport> viewport_;

    SharedPtr<Scene> scene_;

    SharedPtr<Node> cameraNode_;

    bool ownScene_;

    unsigned rttFormat_;

    bool autoUpdate_;
};

}


namespace Urho3D
{

class Drawable2D;
class Renderer2D;
class Texture2D;
class VertexBuffer;


struct Vertex2D
{

    Vector3 position_;

    unsigned color_;

    Vector2 uv_;
};


struct SourceBatch2D
{

    SourceBatch2D();


    WeakPtr<Drawable2D> owner_;

    mutable float distance_;

    int drawOrder_;

    SharedPtr<Material> material_;

    Vector<Vertex2D> vertices_;
};


extern __attribute__((visibility("default"))) const float PIXEL_SIZE;


class __attribute__((visibility("default"))) Drawable2D : public Drawable
{
    public: using ClassName = Drawable2D; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Drawable2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Drawable2D(Context* context);

    ~Drawable2D() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    void SetLayer(int layer);

    void SetOrderInLayer(int orderInLayer);


    int GetLayer() const { return layer_; }


    int GetOrderInLayer() const { return orderInLayer_; }


    const Vector<SourceBatch2D>& GetSourceBatches();

protected:

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;

    virtual void OnDrawOrderChanged() = 0;

    virtual void UpdateSourceBatches() = 0;


    int GetDrawOrder() const { return layer_ << 16u | orderInLayer_; }


    int layer_;

    int orderInLayer_;

    Vector<SourceBatch2D> sourceBatches_;

    bool sourceBatchesDirty_;

    WeakPtr<Renderer2D> renderer_;
};

}


namespace Urho3D
{

class Sprite2D;


class __attribute__((visibility("default"))) StaticSprite2D : public Drawable2D
{
    public: using ClassName = StaticSprite2D; using BaseClassName = Drawable2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("StaticSprite2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit StaticSprite2D(Context* context);

    ~StaticSprite2D() override;

    static void RegisterObject(Context* context);


    void SetSprite(Sprite2D* sprite);

    void SetDrawRect(const Rect &rect);

    void SetTextureRect(const Rect &rect);

    void SetBlendMode(BlendMode blendMode);

    void SetFlip(bool flipX, bool flipY, bool swapXY = false);

    void SetFlipX(bool flipX);

    void SetFlipY(bool flipY);

    void SetSwapXY(bool swapXY);

    void SetColor(const Color& color);

    void SetAlpha(float alpha);

    void SetUseHotSpot(bool useHotSpot);

    void SetUseDrawRect(bool useDrawRect);

    void SetUseTextureRect(bool useTextureRect);

    void SetHotSpot(const Vector2& hotspot);

    void SetCustomMaterial(Material* customMaterial);


    Sprite2D* GetSprite() const;


    const Rect& GetDrawRect() const { return drawRect_; }


    const Rect& GetTextureRect() const { return textureRect_; }


    BlendMode GetBlendMode() const { return blendMode_; }


    bool GetFlipX() const { return flipX_; }


    bool GetFlipY() const { return flipY_; }


    bool GetSwapXY() const { return swapXY_; }


    const Color& GetColor() const { return color_; }


    float GetAlpha() const { return color_.a_; }


    bool GetUseHotSpot() const { return useHotSpot_; }


    bool GetUseDrawRect() const { return useDrawRect_; }


    bool GetUseTextureRect() const { return useTextureRect_; }


    const Vector2& GetHotSpot() const { return hotSpot_; }


    Material* GetCustomMaterial() const;


    void SetSpriteAttr(const ResourceRef& value);

    ResourceRef GetSpriteAttr() const;

    void SetCustomMaterialAttr(const ResourceRef& value);

    ResourceRef GetCustomMaterialAttr() const;


protected:


    void OnSceneSet(Scene* scene) override;

    void OnWorldBoundingBoxUpdate() override;

    void OnDrawOrderChanged() override;

    void UpdateSourceBatches() override;

    void UpdateMaterial();

    void UpdateDrawRect();


    SharedPtr<Sprite2D> sprite_;

    BlendMode blendMode_;

    bool flipX_;

    bool flipY_;

    bool swapXY_;

    Color color_;

    bool useHotSpot_;

    bool useDrawRect_;

    bool useTextureRect_;

    Vector2 hotSpot_;

    Rect drawRect_;

    Rect textureRect_;

    SharedPtr<Material> customMaterial_;
};

}








enum LoopMode2D
{

    LM_DEFAULT = 0,

    LM_FORCE_LOOPED,

    LM_FORCE_CLAMPED
};

namespace Urho3D
{

namespace Spriter
{
    class SpriterInstance;
}

class AnimationSet2D;


class __attribute__((visibility("default"))) AnimatedSprite2D : public StaticSprite2D
{
    public: using ClassName = AnimatedSprite2D; using BaseClassName = StaticSprite2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("AnimatedSprite2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit AnimatedSprite2D(Context* context);

    ~AnimatedSprite2D() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    void SetAnimationSet(AnimationSet2D* animationSet);

    void SetEntity(const String& entity);

    void SetAnimation(const String& name, LoopMode2D loopMode = LM_DEFAULT);

    void SetLoopMode(LoopMode2D loopMode);

    void SetSpeed(float speed);


    AnimationSet2D* GetAnimationSet() const;

    const String& GetEntity() const { return entity_; }

    const String& GetAnimation() const { return animationName_; }

    LoopMode2D GetLoopMode() const { return loopMode_; }

    float GetSpeed() const { return speed_; }


    void SetAnimationSetAttr(const ResourceRef& value);

    ResourceRef GetAnimationSetAttr() const;

    void SetAnimationAttr(const String& name);

protected:

    void OnSceneSet(Scene* scene) override;

    void UpdateSourceBatches() override;

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);

    void UpdateAnimation(float timeStep);
    void SetSpriterAnimation();

    void UpdateSpriterAnimation(float timeStep);

    void UpdateSourceBatchesSpriter();

    void Dispose();


    float speed_;

    String entity_;

    SharedPtr<AnimationSet2D> animationSet_;

    String animationName_;

    LoopMode2D loopMode_;
    UniquePtr<Spriter::SpriterInstance> spriterInstance_;
};

}
namespace Urho3D
{

namespace Spriter
{
    struct SpriterData;
}

class Sprite2D;
class SpriteSheet2D;


class __attribute__((visibility("default"))) AnimationSet2D : public Resource
{
    public: using ClassName = AnimationSet2D; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("AnimationSet2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit AnimationSet2D(Context* context);

    ~AnimationSet2D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;


    unsigned GetNumAnimations() const;

    String GetAnimation(unsigned index) const;

    bool HasAnimation(const String& animationName) const;


    Sprite2D* GetSprite() const;







    Spriter::SpriterData* GetSpriterData() const { return spriterData_.Get(); }

    Sprite2D* GetSpriterFileSprite(int folderId, int fileId) const;

private:

    Sprite2D* GetSpriterFileSprite(const StringHash& hash) const;







    bool BeginLoadSpriter(Deserializer& source);

    bool EndLoadSpriter();

    void Dispose();


    SharedPtr<Sprite2D> sprite_;
    UniquePtr<Spriter::SpriterData> spriterData_;

    bool hasSpriteSheet_;

    String spriteSheetFilePath_;

    SharedPtr<SpriteSheet2D> spriteSheet_;

    HashMap<unsigned, SharedPtr<Sprite2D> > spriterFileSprites_;
};

}
typedef signed char int8;
typedef signed short int16;
typedef signed int int32;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef float float32;
typedef double float64;
void* b2Alloc(int32 size);


void b2Free(void* mem);


void b2Log(const char* string, ...);



struct b2Version
{
 int32 major;
 int32 minor;
 int32 revision;
};


extern b2Version b2_version;
inline bool b2IsValid(float32 x)
{
 int32 ix = *reinterpret_cast<int32*>(&x);
 return (ix & 0x7f800000) != 0x7f800000;
}


inline float32 b2InvSqrt(float32 x)
{
 union
 {
  float32 x;
  int32 i;
 } convert;

 convert.x = x;
 float32 xhalf = 0.5f * x;
 convert.i = 0x5f3759df - (convert.i >> 1);
 x = convert.x;
 x = x * (1.5f - xhalf * x * x);
 return x;
}





struct b2Vec2
{

 b2Vec2() {}


 b2Vec2(float32 xIn, float32 yIn) : x(xIn), y(yIn) {}


 void SetZero() { x = 0.0f; y = 0.0f; }


 void Set(float32 x_, float32 y_) { x = x_; y = y_; }


 b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }


 float32 operator () (int32 i) const
 {
  return (&x)[i];
 }


 float32& operator () (int32 i)
 {
  return (&x)[i];
 }


 void operator += (const b2Vec2& v)
 {
  x += v.x; y += v.y;
 }


 void operator -= (const b2Vec2& v)
 {
  x -= v.x; y -= v.y;
 }


 void operator *= (float32 a)
 {
  x *= a; y *= a;
 }


 float32 Length() const
 {
  return sqrtf(x * x + y * y);
 }



 float32 LengthSquared() const
 {
  return x * x + y * y;
 }


 float32 Normalize()
 {
  float32 length = Length();
  if (length < 1.19209290e-7F)
  {
   return 0.0f;
  }
  float32 invLength = 1.0f / length;
  x *= invLength;
  y *= invLength;

  return length;
 }


 bool IsValid() const
 {
  return b2IsValid(x) && b2IsValid(y);
 }


 b2Vec2 Skew() const
 {
  return b2Vec2(-y, x);
 }

 float32 x, y;
};


struct b2Vec3
{

 b2Vec3() {}


 b2Vec3(float32 xIn, float32 yIn, float32 zIn) : x(xIn), y(yIn), z(zIn) {}


 void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }


 void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }


 b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }


 void operator += (const b2Vec3& v)
 {
  x += v.x; y += v.y; z += v.z;
 }


 void operator -= (const b2Vec3& v)
 {
  x -= v.x; y -= v.y; z -= v.z;
 }


 void operator *= (float32 s)
 {
  x *= s; y *= s; z *= s;
 }

 float32 x, y, z;
};


struct b2Mat22
{

 b2Mat22() {}


 b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
 {
  ex.x = a11; ex.y = a21;
  ey.x = a12; ey.y = a22;
 }


 void Set(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 void SetIdentity()
 {
  ex.x = 1.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 1.0f;
 }


 void SetZero()
 {
  ex.x = 0.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 0.0f;
 }

 b2Mat22 GetInverse() const
 {
  float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
  b2Mat22 B;
  float32 det = a * d - b * c;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  B.ex.x = det * d; B.ey.x = -det * b;
  B.ex.y = -det * c; B.ey.y = det * a;
  return B;
 }



 b2Vec2 Solve(const b2Vec2& b) const
 {
  float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
  float32 det = a11 * a22 - a12 * a21;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  b2Vec2 x;
  x.x = det * (a22 * b.x - a12 * b.y);
  x.y = det * (a11 * b.y - a21 * b.x);
  return x;
 }

 b2Vec2 ex, ey;
};


struct b2Mat33
{

 b2Mat33() {}


 b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
 {
  ex = c1;
  ey = c2;
  ez = c3;
 }


 void SetZero()
 {
  ex.SetZero();
  ey.SetZero();
  ez.SetZero();
 }



 b2Vec3 Solve33(const b2Vec3& b) const;




 b2Vec2 Solve22(const b2Vec2& b) const;



 void GetInverse22(b2Mat33* M) const;



 void GetSymInverse33(b2Mat33* M) const;

 b2Vec3 ex, ey, ez;
};


struct b2Rot
{
 b2Rot() {}


 explicit b2Rot(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void Set(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void SetIdentity()
 {
  s = 0.0f;
  c = 1.0f;
 }


 float32 GetAngle() const
 {
  return atan2f(s, c);
 }


 b2Vec2 GetXAxis() const
 {
  return b2Vec2(c, s);
 }


 b2Vec2 GetYAxis() const
 {
  return b2Vec2(-s, c);
 }


 float32 s, c;
};



struct b2Transform
{

 b2Transform() {}


 b2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}


 void SetIdentity()
 {
  p.SetZero();
  q.SetIdentity();
 }


 void Set(const b2Vec2& position, float32 angle)
 {
  p = position;
  q.Set(angle);
 }

 b2Vec2 p;
 b2Rot q;
};





struct b2Sweep
{


 void GetTransform(b2Transform* xfb, float32 beta) const;



 void Advance(float32 alpha);


 void Normalize();

 b2Vec2 localCenter;
 b2Vec2 c0, c;
 float32 a0, a;



 float32 alpha0;
};


extern const b2Vec2 b2Vec2_zero;


inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.x + a.y * b.y;
}


inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.y - a.y * b.x;
}



inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
{
 return b2Vec2(s * a.y, -s * a.x);
}



inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
{
 return b2Vec2(-s * a.y, s * a.x);
}



inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}



inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));
}


inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x + b.x, a.y + b.y);
}


inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x - b.x, a.y - b.y);
}

inline b2Vec2 operator * (float32 s, const b2Vec2& a)
{
 return b2Vec2(s * a.x, s * a.y);
}

inline bool operator == (const b2Vec2& a, const b2Vec2& b)
{
 return a.x == b.x && a.y == b.y;
}

inline bool operator != (const b2Vec2& a, const b2Vec2& b)
{
 return a.x != b.x || a.y != b.y;
}

inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return c.Length();
}

inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return b2Dot(c, c);
}

inline b2Vec3 operator * (float32 s, const b2Vec3& a)
{
 return b2Vec3(s * a.x, s * a.y, s * a.z);
}


inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
}


inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
}


inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
{
 return a.x * b.x + a.y * b.y + a.z * b.z;
}


inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(A.ex + B.ex, A.ey + B.ey);
}


inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));
}


inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
{
 b2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));
 b2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));
 return b2Mat22(c1, c2);
}


inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
{
 return v.x * A.ex + v.y * A.ey + v.z * A.ez;
}


inline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}


inline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.s * r.c + q.c * r.s;
 qr.c = q.c * r.c - q.s * r.s;
 return qr;
}


inline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.c * r.s - q.s * r.c;
 qr.c = q.c * r.c + q.s * r.s;
 return qr;
}


inline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
}


inline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
}

inline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)
{
 float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
 float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;

 return b2Vec2(x, y);
}

inline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)
{
 float32 px = v.x - T.p.x;
 float32 py = v.y - T.p.y;
 float32 x = (T.q.c * px + T.q.s * py);
 float32 y = (-T.q.s * px + T.q.c * py);

 return b2Vec2(x, y);
}



inline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2Mul(A.q, B.q);
 C.p = b2Mul(A.q, B.p) + A.p;
 return C;
}



inline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2MulT(A.q, B.q);
 C.p = b2MulT(A.q, B.p - A.p);
 return C;
}

template <typename T>
inline T b2Abs(T a)
{
 return a > T(0) ? a : -a;
}

inline b2Vec2 b2Abs(const b2Vec2& a)
{
 return b2Vec2(b2Abs(a.x), b2Abs(a.y));
}

inline b2Mat22 b2Abs(const b2Mat22& A)
{
 return b2Mat22(b2Abs(A.ex), b2Abs(A.ey));
}

template <typename T>
inline T b2Min(T a, T b)
{
 return a < b ? a : b;
}

inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
}

template <typename T>
inline T b2Max(T a, T b)
{
 return a > b ? a : b;
}

inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
}

template <typename T>
inline T b2Clamp(T a, T low, T high)
{
 return b2Max(low, b2Min(a, high));
}

inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
{
 return b2Max(low, b2Min(a, high));
}

template<typename T> inline void b2Swap(T& a, T& b)
{
 T tmp = a;
 a = b;
 b = tmp;
}






inline uint32 b2NextPowerOfTwo(uint32 x)
{
 x |= (x >> 1);
 x |= (x >> 2);
 x |= (x >> 4);
 x |= (x >> 8);
 x |= (x >> 16);
 return x + 1;
}

inline bool b2IsPowerOfTwo(uint32 x)
{
 bool result = x > 0 && (x & (x - 1)) == 0;
 return result;
}

inline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const
{
 xf->p = (1.0f - beta) * c0 + beta * c;
 float32 angle = (1.0f - beta) * a0 + beta * a;
 xf->q.Set(angle);


 xf->p -= b2Mul(xf->q, localCenter);
}

inline void b2Sweep::Advance(float32 alpha)
{
 ((alpha0 < 1.0f) ? static_cast<void> (0) : __assert_fail ("alpha0 < 1.0f", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Common/b2Math.h", 709, __PRETTY_FUNCTION__));
 float32 beta = (alpha - alpha0) / (1.0f - alpha0);
 c0 += beta * (c - c0);
 a0 += beta * (a - a0);
 alpha0 = alpha;
}


inline void b2Sweep::Normalize()
{
 float32 twoPi = 2.0f * 3.14159265359f;
 float32 d = twoPi * floorf(a0 / twoPi);
 a0 -= d;
 a -= d;
}


struct b2Color
{
 b2Color() {}
 b2Color(float32 rIn, float32 gIn, float32 bIn, float32 aIn = 1.0f)
 {
  r = rIn; g = gIn; b = bIn; a = aIn;
 }

 void Set(float32 rIn, float32 gIn, float32 bIn, float32 aIn = 1.0f)
 {
  r = rIn; g = gIn; b = bIn; a = aIn;
 }

 float32 r, g, b, a;
};



class b2Draw
{
public:
 b2Draw();

 virtual ~b2Draw() {}

 enum
 {
  e_shapeBit = 0x0001,
  e_jointBit = 0x0002,
  e_aabbBit = 0x0004,
  e_pairBit = 0x0008,
  e_centerOfMassBit = 0x0010
 };


 void SetFlags(uint32 flags);


 uint32 GetFlags() const;


 void AppendFlags(uint32 flags);


 void ClearFlags(uint32 flags);


 virtual void DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;


 virtual void DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;


 virtual void DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) = 0;


 virtual void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) = 0;


 virtual void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) = 0;



 virtual void DrawTransform(const b2Transform& xf) = 0;


 virtual void DrawPoint(const b2Vec2& p, float32 size, const b2Color& color) = 0;

protected:
 uint32 m_drawFlags;
};
class b2Timer
{
public:


 b2Timer();


 void Reset();


 float32 GetMilliseconds() const;

private:





 unsigned long m_start_sec;
 unsigned long m_start_usec;

};

const int32 b2_chunkSize = 16 * 1024;
const int32 b2_maxBlockSize = 640;
const int32 b2_blockSizes = 14;
const int32 b2_chunkArrayIncrement = 128;

struct b2Block;
struct b2Chunk;




class b2BlockAllocator
{
public:
 b2BlockAllocator();
 ~b2BlockAllocator();


 void* Allocate(int32 size);


 void Free(void* p, int32 size);

 void Clear();

private:

 b2Chunk* m_chunks;
 int32 m_chunkCount;
 int32 m_chunkSpace;

 b2Block* m_freeLists[b2_blockSizes];

 static int32 s_blockSizes[b2_blockSizes];
 static uint8 s_blockSizeLookup[b2_maxBlockSize + 1];
 static bool s_blockSizeLookupInitialized;
};

class b2Shape;
class b2CircleShape;
class b2EdgeShape;
class b2PolygonShape;

const uint8 b2_nullFeature = (127*2 +1);



struct b2ContactFeature
{
 enum Type
 {
  e_vertex = 0,
  e_face = 1
 };

 uint8 indexA;
 uint8 indexB;
 uint8 typeA;
 uint8 typeB;
};


union b2ContactID
{
 b2ContactFeature cf;
 uint32 key;
};
struct b2ManifoldPoint
{
 b2Vec2 localPoint;
 float32 normalImpulse;
 float32 tangentImpulse;
 b2ContactID id;
};
struct b2Manifold
{
 enum Type
 {
  e_circles,
  e_faceA,
  e_faceB
 };

 b2ManifoldPoint points[2];
 b2Vec2 localNormal;
 b2Vec2 localPoint;
 Type type;
 int32 pointCount;
};


struct b2WorldManifold
{




 void Initialize(const b2Manifold* manifold,
     const b2Transform& xfA, float32 radiusA,
     const b2Transform& xfB, float32 radiusB);

 b2Vec2 normal;
 b2Vec2 points[2];
 float32 separations[2];
};


enum b2PointState
{
 b2_nullState,
 b2_addState,
 b2_persistState,
 b2_removeState
};



void b2GetPointStates(b2PointState state1[2], b2PointState state2[2],
       const b2Manifold* manifold1, const b2Manifold* manifold2);


struct b2ClipVertex
{
 b2Vec2 v;
 b2ContactID id;
};


struct b2RayCastInput
{
 b2Vec2 p1, p2;
 float32 maxFraction;
};



struct b2RayCastOutput
{
 b2Vec2 normal;
 float32 fraction;
};


struct b2AABB
{

 bool IsValid() const;


 b2Vec2 GetCenter() const
 {
  return 0.5f * (lowerBound + upperBound);
 }


 b2Vec2 GetExtents() const
 {
  return 0.5f * (upperBound - lowerBound);
 }


 float32 GetPerimeter() const
 {
  float32 wx = upperBound.x - lowerBound.x;
  float32 wy = upperBound.y - lowerBound.y;
  return 2.0f * (wx + wy);
 }


 void Combine(const b2AABB& aabb)
 {
  lowerBound = b2Min(lowerBound, aabb.lowerBound);
  upperBound = b2Max(upperBound, aabb.upperBound);
 }


 void Combine(const b2AABB& aabb1, const b2AABB& aabb2)
 {
  lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
  upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
 }


 bool Contains(const b2AABB& aabb) const
 {
  bool result = true;
  result = result && lowerBound.x <= aabb.lowerBound.x;
  result = result && lowerBound.y <= aabb.lowerBound.y;
  result = result && aabb.upperBound.x <= upperBound.x;
  result = result && aabb.upperBound.y <= upperBound.y;
  return result;
 }

 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;

 b2Vec2 lowerBound;
 b2Vec2 upperBound;
};


void b2CollideCircles(b2Manifold* manifold,
       const b2CircleShape* circleA, const b2Transform& xfA,
       const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygonAndCircle(b2Manifold* manifold,
          const b2PolygonShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygons(b2Manifold* manifold,
        const b2PolygonShape* polygonA, const b2Transform& xfA,
        const b2PolygonShape* polygonB, const b2Transform& xfB);


void b2CollideEdgeAndCircle(b2Manifold* manifold,
          const b2EdgeShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollideEdgeAndPolygon(b2Manifold* manifold,
          const b2EdgeShape* edgeA, const b2Transform& xfA,
          const b2PolygonShape* circleB, const b2Transform& xfB);


int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
       const b2Vec2& normal, float32 offset, int32 vertexIndexA);


bool b2TestOverlap( const b2Shape* shapeA, int32 indexA,
     const b2Shape* shapeB, int32 indexB,
     const b2Transform& xfA, const b2Transform& xfB);



inline bool b2AABB::IsValid() const
{
 b2Vec2 d = upperBound - lowerBound;
 bool valid = d.x >= 0.0f && d.y >= 0.0f;
 valid = valid && lowerBound.IsValid() && upperBound.IsValid();
 return valid;
}

inline bool b2TestOverlap(const b2AABB& a, const b2AABB& b)
{
 b2Vec2 d1, d2;
 d1 = b.lowerBound - a.upperBound;
 d2 = a.lowerBound - b.upperBound;

 if (d1.x > 0.0f || d1.y > 0.0f)
  return false;

 if (d2.x > 0.0f || d2.y > 0.0f)
  return false;

 return true;
}


struct b2MassData
{

 float32 mass;


 b2Vec2 center;


 float32 I;
};




class b2Shape
{
public:

 enum Type
 {
  e_circle = 0,
  e_edge = 1,
  e_polygon = 2,
  e_chain = 3,
  e_typeCount = 4
 };

 virtual ~b2Shape() {}


 virtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;



 Type GetType() const;


 virtual int32 GetChildCount() const = 0;




 virtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;






 virtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
      const b2Transform& transform, int32 childIndex) const = 0;





 virtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;





 virtual void ComputeMass(b2MassData* massData, float32 density) const = 0;

 Type m_type;
 float32 m_radius;
};

inline b2Shape::Type b2Shape::GetType() const
{
 return m_type;
}


class b2CircleShape : public b2Shape
{
public:
 b2CircleShape();


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
    const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 int32 GetSupport(const b2Vec2& d) const;


 const b2Vec2& GetSupportVertex(const b2Vec2& d) const;


 int32 GetVertexCount() const { return 1; }


 const b2Vec2& GetVertex(int32 index) const;


 b2Vec2 m_p;
};

inline b2CircleShape::b2CircleShape()
{
 m_type = e_circle;
 m_radius = 0.0f;
 m_p.SetZero();
}

inline int32 b2CircleShape::GetSupport(const b2Vec2 &d) const
{
 ((void)(d));
 return 0;
}

inline const b2Vec2& b2CircleShape::GetSupportVertex(const b2Vec2 &d) const
{
 ((void)(d));
 return m_p;
}

inline const b2Vec2& b2CircleShape::GetVertex(int32 index) const
{
 ((void)(index));
 ((index == 0) ? static_cast<void> (0) : __assert_fail ("index == 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Collision/Shapes/b2CircleShape.h", 87, __PRETTY_FUNCTION__));
 return m_p;
}
class b2EdgeShape : public b2Shape
{
public:
 b2EdgeShape();


 void Set(const b2Vec2& v1, const b2Vec2& v2);


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
    const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 b2Vec2 m_vertex1, m_vertex2;


 b2Vec2 m_vertex0, m_vertex3;
 bool m_hasVertex0, m_hasVertex3;
};

inline b2EdgeShape::b2EdgeShape()
{
 m_type = e_edge;
 m_radius = (2.0f * 0.005f);
 m_vertex0.x = 0.0f;
 m_vertex0.y = 0.0f;
 m_vertex3.x = 0.0f;
 m_vertex3.y = 0.0f;
 m_hasVertex0 = false;
 m_hasVertex3 = false;
}
class b2EdgeShape;







class b2ChainShape : public b2Shape
{
public:
 b2ChainShape();


 ~b2ChainShape();


 void Clear();




 void CreateLoop(const b2Vec2* vertices, int32 count);




 void CreateChain(const b2Vec2* vertices, int32 count);



 void SetPrevVertex(const b2Vec2& prevVertex);



 void SetNextVertex(const b2Vec2& nextVertex);


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 void GetChildEdge(b2EdgeShape* edge, int32 index) const;



 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
     const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;



 void ComputeMass(b2MassData* massData, float32 density) const;


 b2Vec2* m_vertices;


 int32 m_count;

 b2Vec2 m_prevVertex, m_nextVertex;
 bool m_hasPrevVertex, m_hasNextVertex;
};

inline b2ChainShape::b2ChainShape()
{
 m_type = e_chain;
 m_radius = (2.0f * 0.005f);
 m_vertices = __null;
 m_count = 0;
 m_hasPrevVertex = false;
 m_hasNextVertex = false;
}
class b2PolygonShape : public b2Shape
{
public:
 b2PolygonShape();


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;






 void Set(const b2Vec2* points, int32 count);




 void SetAsBox(float32 hx, float32 hy);






 void SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle);


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
     const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 int32 GetVertexCount() const { return m_count; }


 const b2Vec2& GetVertex(int32 index) const;



 bool Validate() const;

 b2Vec2 m_centroid;
 b2Vec2 m_vertices[8];
 b2Vec2 m_normals[8];
 int32 m_count;
};

inline b2PolygonShape::b2PolygonShape()
{
 m_type = e_polygon;
 m_radius = (2.0f * 0.005f);
 m_count = 0;
 m_centroid.SetZero();
}

inline const b2Vec2& b2PolygonShape::GetVertex(int32 index) const
{
 ((0 <= index && index < m_count) ? static_cast<void> (0) : __assert_fail ("0 <= index && index < m_count", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Collision/Shapes/b2PolygonShape.h", 97, __PRETTY_FUNCTION__));
 return m_vertices[index];
}

template <typename T, int32 N>
class b2GrowableStack
{
public:
 b2GrowableStack()
 {
  m_stack = m_array;
  m_count = 0;
  m_capacity = N;
 }

 ~b2GrowableStack()
 {
  if (m_stack != m_array)
  {
   b2Free(m_stack);
   m_stack = __null;
  }
 }

 void Push(const T& element)
 {
  if (m_count == m_capacity)
  {
   T* old = m_stack;
   m_capacity *= 2;
   m_stack = (T*)b2Alloc(m_capacity * sizeof(T));
   memcpy(m_stack, old, m_count * sizeof(T));
   if (old != m_array)
   {
    b2Free(old);
   }
  }

  m_stack[m_count] = element;
  ++m_count;
 }

 T Pop()
 {
  ((m_count > 0) ? static_cast<void> (0) : __assert_fail ("m_count > 0", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Common/b2GrowableStack.h", 67, __PRETTY_FUNCTION__));
  --m_count;
  return m_stack[m_count];
 }

 int32 GetCount()
 {
  return m_count;
 }

private:
 T* m_stack;
 T m_array[N];
 int32 m_count;
 int32 m_capacity;
};




struct b2TreeNode
{
 bool IsLeaf() const
 {
  return child1 == (-1);
 }


 b2AABB aabb;

 void* userData;

 union
 {
  int32 parent;
  int32 next;
 };

 int32 child1;
 int32 child2;


 int32 height;
};
class b2DynamicTree
{
public:

 b2DynamicTree();


 ~b2DynamicTree();


 int32 CreateProxy(const b2AABB& aabb, void* userData);


 void DestroyProxy(int32 proxyId);





 bool MoveProxy(int32 proxyId, const b2AABB& aabb1, const b2Vec2& displacement);



 void* GetUserData(int32 proxyId) const;


 const b2AABB& GetFatAABB(int32 proxyId) const;



 template <typename T>
 void Query(T* callback, const b2AABB& aabb) const;
 template <typename T>
 void RayCast(T* callback, const b2RayCastInput& input) const;


 void Validate() const;



 int32 GetHeight() const;



 int32 GetMaxBalance() const;


 float32 GetAreaRatio() const;


 void RebuildBottomUp();




 void ShiftOrigin(const b2Vec2& newOrigin);

private:

 int32 AllocateNode();
 void FreeNode(int32 node);

 void InsertLeaf(int32 node);
 void RemoveLeaf(int32 node);

 int32 Balance(int32 index);

 int32 ComputeHeight() const;
 int32 ComputeHeight(int32 nodeId) const;

 void ValidateStructure(int32 index) const;
 void ValidateMetrics(int32 index) const;

 int32 m_root;

 b2TreeNode* m_nodes;
 int32 m_nodeCount;
 int32 m_nodeCapacity;

 int32 m_freeList;


 uint32 m_path;

 int32 m_insertionCount;
};

inline void* b2DynamicTree::GetUserData(int32 proxyId) const
{
 ((0 <= proxyId && proxyId < m_nodeCapacity) ? static_cast<void> (0) : __assert_fail ("0 <= proxyId && proxyId < m_nodeCapacity", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Collision/b2DynamicTree.h", 158, __PRETTY_FUNCTION__));
 return m_nodes[proxyId].userData;
}

inline const b2AABB& b2DynamicTree::GetFatAABB(int32 proxyId) const
{
 ((0 <= proxyId && proxyId < m_nodeCapacity) ? static_cast<void> (0) : __assert_fail ("0 <= proxyId && proxyId < m_nodeCapacity", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Collision/b2DynamicTree.h", 164, __PRETTY_FUNCTION__));
 return m_nodes[proxyId].aabb;
}

template <typename T>
inline void b2DynamicTree::Query(T* callback, const b2AABB& aabb) const
{
 b2GrowableStack<int32, 256> stack;
 stack.Push(m_root);

 while (stack.GetCount() > 0)
 {
  int32 nodeId = stack.Pop();
  if (nodeId == (-1))
  {
   continue;
  }

  const b2TreeNode* node = m_nodes + nodeId;

  if (b2TestOverlap(node->aabb, aabb))
  {
   if (node->IsLeaf())
   {
    bool proceed = callback->QueryCallback(nodeId);
    if (proceed == false)
    {
     return;
    }
   }
   else
   {
    stack.Push(node->child1);
    stack.Push(node->child2);
   }
  }
 }
}

template <typename T>
inline void b2DynamicTree::RayCast(T* callback, const b2RayCastInput& input) const
{
 b2Vec2 p1 = input.p1;
 b2Vec2 p2 = input.p2;
 b2Vec2 r = p2 - p1;
 ((r.LengthSquared() > 0.0f) ? static_cast<void> (0) : __assert_fail ("r.LengthSquared() > 0.0f", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Collision/b2DynamicTree.h", 209, __PRETTY_FUNCTION__));
 r.Normalize();


 b2Vec2 v = b2Cross(1.0f, r);
 b2Vec2 abs_v = b2Abs(v);




 float32 maxFraction = input.maxFraction;


 b2AABB segmentAABB;
 {
  b2Vec2 t = p1 + maxFraction * (p2 - p1);
  segmentAABB.lowerBound = b2Min(p1, t);
  segmentAABB.upperBound = b2Max(p1, t);
 }

 b2GrowableStack<int32, 256> stack;
 stack.Push(m_root);

 while (stack.GetCount() > 0)
 {
  int32 nodeId = stack.Pop();
  if (nodeId == (-1))
  {
   continue;
  }

  const b2TreeNode* node = m_nodes + nodeId;

  if (b2TestOverlap(node->aabb, segmentAABB) == false)
  {
   continue;
  }



  b2Vec2 c = node->aabb.GetCenter();
  b2Vec2 h = node->aabb.GetExtents();
  float32 separation = b2Abs(b2Dot(v, p1 - c)) - b2Dot(abs_v, h);
  if (separation > 0.0f)
  {
   continue;
  }

  if (node->IsLeaf())
  {
   b2RayCastInput subInput;
   subInput.p1 = input.p1;
   subInput.p2 = input.p2;
   subInput.maxFraction = maxFraction;

   float32 value = callback->RayCastCallback(subInput, nodeId);

   if (value == 0.0f)
   {

    return;
   }

   if (value > 0.0f)
   {

    maxFraction = value;
    b2Vec2 t = p1 + maxFraction * (p2 - p1);
    segmentAABB.lowerBound = b2Min(p1, t);
    segmentAABB.upperBound = b2Max(p1, t);
   }
  }
  else
  {
   stack.Push(node->child1);
   stack.Push(node->child2);
  }
 }
}


struct b2Pair
{
 int32 proxyIdA;
 int32 proxyIdB;
};




class b2BroadPhase
{
public:

 enum
 {
  e_nullProxy = -1
 };

 b2BroadPhase();
 ~b2BroadPhase();



 int32 CreateProxy(const b2AABB& aabb, void* userData);


 void DestroyProxy(int32 proxyId);



 void MoveProxy(int32 proxyId, const b2AABB& aabb, const b2Vec2& displacement);


 void TouchProxy(int32 proxyId);


 const b2AABB& GetFatAABB(int32 proxyId) const;


 void* GetUserData(int32 proxyId) const;


 bool TestOverlap(int32 proxyIdA, int32 proxyIdB) const;


 int32 GetProxyCount() const;


 template <typename T>
 void UpdatePairs(T* callback);



 template <typename T>
 void Query(T* callback, const b2AABB& aabb) const;
 template <typename T>
 void RayCast(T* callback, const b2RayCastInput& input) const;


 int32 GetTreeHeight() const;


 int32 GetTreeBalance() const;


 float32 GetTreeQuality() const;




 void ShiftOrigin(const b2Vec2& newOrigin);

private:

 friend class b2DynamicTree;

 void BufferMove(int32 proxyId);
 void UnBufferMove(int32 proxyId);

 bool QueryCallback(int32 proxyId);

 b2DynamicTree m_tree;

 int32 m_proxyCount;

 int32* m_moveBuffer;
 int32 m_moveCapacity;
 int32 m_moveCount;

 b2Pair* m_pairBuffer;
 int32 m_pairCapacity;
 int32 m_pairCount;

 int32 m_queryProxyId;
};


inline bool b2PairLessThan(const b2Pair& pair1, const b2Pair& pair2)
{
 if (pair1.proxyIdA < pair2.proxyIdA)
 {
  return true;
 }

 if (pair1.proxyIdA == pair2.proxyIdA)
 {
  return pair1.proxyIdB < pair2.proxyIdB;
 }

 return false;
}

inline void* b2BroadPhase::GetUserData(int32 proxyId) const
{
 return m_tree.GetUserData(proxyId);
}

inline bool b2BroadPhase::TestOverlap(int32 proxyIdA, int32 proxyIdB) const
{
 const b2AABB& aabbA = m_tree.GetFatAABB(proxyIdA);
 const b2AABB& aabbB = m_tree.GetFatAABB(proxyIdB);
 return b2TestOverlap(aabbA, aabbB);
}

inline const b2AABB& b2BroadPhase::GetFatAABB(int32 proxyId) const
{
 return m_tree.GetFatAABB(proxyId);
}

inline int32 b2BroadPhase::GetProxyCount() const
{
 return m_proxyCount;
}

inline int32 b2BroadPhase::GetTreeHeight() const
{
 return m_tree.GetHeight();
}

inline int32 b2BroadPhase::GetTreeBalance() const
{
 return m_tree.GetMaxBalance();
}

inline float32 b2BroadPhase::GetTreeQuality() const
{
 return m_tree.GetAreaRatio();
}

template <typename T>
void b2BroadPhase::UpdatePairs(T* callback)
{

 m_pairCount = 0;


 for (int32 i = 0; i < m_moveCount; ++i)
 {
  m_queryProxyId = m_moveBuffer[i];
  if (m_queryProxyId == e_nullProxy)
  {
   continue;
  }



  const b2AABB& fatAABB = m_tree.GetFatAABB(m_queryProxyId);


  m_tree.Query(this, fatAABB);
 }


 m_moveCount = 0;


 std::sort(m_pairBuffer, m_pairBuffer + m_pairCount, b2PairLessThan);


 int32 i = 0;
 while (i < m_pairCount)
 {
  b2Pair* primaryPair = m_pairBuffer + i;
  void* userDataA = m_tree.GetUserData(primaryPair->proxyIdA);
  void* userDataB = m_tree.GetUserData(primaryPair->proxyIdB);

  callback->AddPair(userDataA, userDataB);
  ++i;


  while (i < m_pairCount)
  {
   b2Pair* pair = m_pairBuffer + i;
   if (pair->proxyIdA != primaryPair->proxyIdA || pair->proxyIdB != primaryPair->proxyIdB)
   {
    break;
   }
   ++i;
  }
 }



}

template <typename T>
inline void b2BroadPhase::Query(T* callback, const b2AABB& aabb) const
{
 m_tree.Query(callback, aabb);
}

template <typename T>
inline void b2BroadPhase::RayCast(T* callback, const b2RayCastInput& input) const
{
 m_tree.RayCast(callback, input);
}

inline void b2BroadPhase::ShiftOrigin(const b2Vec2& newOrigin)
{
 m_tree.ShiftOrigin(newOrigin);
}
class b2Shape;



struct b2DistanceProxy
{
 b2DistanceProxy() : m_vertices(__null), m_count(0), m_radius(0.0f) {}



 void Set(const b2Shape* shape, int32 index);


 int32 GetSupport(const b2Vec2& d) const;


 const b2Vec2& GetSupportVertex(const b2Vec2& d) const;


 int32 GetVertexCount() const;


 const b2Vec2& GetVertex(int32 index) const;

 b2Vec2 m_buffer[2];
 const b2Vec2* m_vertices;
 int32 m_count;
 float32 m_radius;
};



struct b2SimplexCache
{
 float32 metric;
 uint16 count;
 uint8 indexA[3];
 uint8 indexB[3];
};




struct b2DistanceInput
{
 b2DistanceProxy proxyA;
 b2DistanceProxy proxyB;
 b2Transform transformA;
 b2Transform transformB;
 bool useRadii;
};


struct b2DistanceOutput
{
 b2Vec2 pointA;
 b2Vec2 pointB;
 float32 distance;
 int32 iterations;
};




void b2Distance(b2DistanceOutput* output,
    b2SimplexCache* cache,
    const b2DistanceInput* input);




inline int32 b2DistanceProxy::GetVertexCount() const
{
 return m_count;
}

inline const b2Vec2& b2DistanceProxy::GetVertex(int32 index) const
{
 ((0 <= index && index < m_count) ? static_cast<void> (0) : __assert_fail ("0 <= index && index < m_count", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Collision/b2Distance.h", 103, __PRETTY_FUNCTION__));
 return m_vertices[index];
}

inline int32 b2DistanceProxy::GetSupport(const b2Vec2& d) const
{
 int32 bestIndex = 0;
 float32 bestValue = b2Dot(m_vertices[0], d);
 for (int32 i = 1; i < m_count; ++i)
 {
  float32 value = b2Dot(m_vertices[i], d);
  if (value > bestValue)
  {
   bestIndex = i;
   bestValue = value;
  }
 }

 return bestIndex;
}

inline const b2Vec2& b2DistanceProxy::GetSupportVertex(const b2Vec2& d) const
{
 int32 bestIndex = 0;
 float32 bestValue = b2Dot(m_vertices[0], d);
 for (int32 i = 1; i < m_count; ++i)
 {
  float32 value = b2Dot(m_vertices[i], d);
  if (value > bestValue)
  {
   bestIndex = i;
   bestValue = value;
  }
 }

 return m_vertices[bestIndex];
}

struct b2TOIInput
{
 b2DistanceProxy proxyA;
 b2DistanceProxy proxyB;
 b2Sweep sweepA;
 b2Sweep sweepB;
 float32 tMax;
};


struct b2TOIOutput
{
 enum State
 {
  e_unknown,
  e_failed,
  e_overlapped,
  e_touching,
  e_separated
 };

 State state;
 float32 t;
};






void b2TimeOfImpact(b2TOIOutput* output, const b2TOIInput* input);

class b2Fixture;
class b2Joint;
class b2Contact;
class b2Controller;
class b2World;
struct b2FixtureDef;
struct b2JointEdge;
struct b2ContactEdge;





enum b2BodyType
{
 b2_staticBody = 0,
 b2_kinematicBody,
 b2_dynamicBody



};



struct b2BodyDef
{

 b2BodyDef()
 {
  userData = __null;
  position.Set(0.0f, 0.0f);
  angle = 0.0f;
  linearVelocity.Set(0.0f, 0.0f);
  angularVelocity = 0.0f;
  linearDamping = 0.0f;
  angularDamping = 0.0f;
  allowSleep = true;
  awake = true;
  fixedRotation = false;
  bullet = false;
  type = b2_staticBody;
  active = true;
  gravityScale = 1.0f;
 }



 b2BodyType type;



 b2Vec2 position;


 float32 angle;


 b2Vec2 linearVelocity;


 float32 angularVelocity;




 float32 linearDamping;




 float32 angularDamping;



 bool allowSleep;


 bool awake;


 bool fixedRotation;





 bool bullet;


 bool active;


 void* userData;


 float32 gravityScale;
};


class b2Body
{
public:







 b2Fixture* CreateFixture(const b2FixtureDef* def);
 b2Fixture* CreateFixture(const b2Shape* shape, float32 density);
 void DestroyFixture(b2Fixture* fixture);






 void SetTransform(const b2Vec2& position, float32 angle);



 const b2Transform& GetTransform() const;



 const b2Vec2& GetPosition() const;



 float32 GetAngle() const;


 const b2Vec2& GetWorldCenter() const;


 const b2Vec2& GetLocalCenter() const;



 void SetLinearVelocity(const b2Vec2& v);



 const b2Vec2& GetLinearVelocity() const;



 void SetAngularVelocity(float32 omega);



 float32 GetAngularVelocity() const;







 void ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake);




 void ApplyForceToCenter(const b2Vec2& force, bool wake);





 void ApplyTorque(float32 torque, bool wake);







 void ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake);




 void ApplyLinearImpulseToCenter(const b2Vec2& impulse, bool wake);




 void ApplyAngularImpulse(float32 impulse, bool wake);



 float32 GetMass() const;



 float32 GetInertia() const;



 void GetMassData(b2MassData* data) const;






 void SetMassData(const b2MassData* data);




 void ResetMassData();




 b2Vec2 GetWorldPoint(const b2Vec2& localPoint) const;




 b2Vec2 GetWorldVector(const b2Vec2& localVector) const;




 b2Vec2 GetLocalPoint(const b2Vec2& worldPoint) const;




 b2Vec2 GetLocalVector(const b2Vec2& worldVector) const;




 b2Vec2 GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const;




 b2Vec2 GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const;


 float32 GetLinearDamping() const;


 void SetLinearDamping(float32 linearDamping);


 float32 GetAngularDamping() const;


 void SetAngularDamping(float32 angularDamping);


 float32 GetGravityScale() const;


 void SetGravityScale(float32 scale);


 void SetType(b2BodyType type);


 b2BodyType GetType() const;


 void SetBullet(bool flag);


 bool IsBullet() const;



 void SetSleepingAllowed(bool flag);


 bool IsSleepingAllowed() const;




 void SetAwake(bool flag);



 bool IsAwake() const;
 void SetActive(bool flag);


 bool IsActive() const;



 void SetFixedRotation(bool flag);


 bool IsFixedRotation() const;


 b2Fixture* GetFixtureList();
 const b2Fixture* GetFixtureList() const;


 b2JointEdge* GetJointList();
 const b2JointEdge* GetJointList() const;




 b2ContactEdge* GetContactList();
 const b2ContactEdge* GetContactList() const;


 b2Body* GetNext();
 const b2Body* GetNext() const;


 void* GetUserData() const;


 void SetUserData(void* data);


 b2World* GetWorld();
 const b2World* GetWorld() const;


 void Dump();

private:

 friend class b2World;
 friend class b2Island;
 friend class b2ContactManager;
 friend class b2ContactSolver;
 friend class b2Contact;

 friend class b2DistanceJoint;
 friend class b2FrictionJoint;
 friend class b2GearJoint;
 friend class b2MotorJoint;
 friend class b2MouseJoint;
 friend class b2PrismaticJoint;
 friend class b2PulleyJoint;
 friend class b2RevoluteJoint;
 friend class b2RopeJoint;
 friend class b2WeldJoint;
 friend class b2WheelJoint;


 enum
 {
  e_islandFlag = 0x0001,
  e_awakeFlag = 0x0002,
  e_autoSleepFlag = 0x0004,
  e_bulletFlag = 0x0008,
  e_fixedRotationFlag = 0x0010,
  e_activeFlag = 0x0020,
  e_toiFlag = 0x0040
 };

 b2Body(const b2BodyDef* bd, b2World* world);
 ~b2Body();

 void SynchronizeFixtures();
 void SynchronizeTransform();



 bool ShouldCollide(const b2Body* other) const;

 void Advance(float32 t);

 b2BodyType m_type;

 uint16 m_flags;

 int32 m_islandIndex;

 b2Transform m_xf;
 b2Sweep m_sweep;

 b2Vec2 m_linearVelocity;
 float32 m_angularVelocity;

 b2Vec2 m_force;
 float32 m_torque;

 b2World* m_world;
 b2Body* m_prev;
 b2Body* m_next;

 b2Fixture* m_fixtureList;
 int32 m_fixtureCount;

 b2JointEdge* m_jointList;
 b2ContactEdge* m_contactList;

 float32 m_mass, m_invMass;


 float32 m_I, m_invI;

 float32 m_linearDamping;
 float32 m_angularDamping;
 float32 m_gravityScale;

 float32 m_sleepTime;

 void* m_userData;
};

inline b2BodyType b2Body::GetType() const
{
 return m_type;
}

inline const b2Transform& b2Body::GetTransform() const
{
 return m_xf;
}

inline const b2Vec2& b2Body::GetPosition() const
{
 return m_xf.p;
}

inline float32 b2Body::GetAngle() const
{
 return m_sweep.a;
}

inline const b2Vec2& b2Body::GetWorldCenter() const
{
 return m_sweep.c;
}

inline const b2Vec2& b2Body::GetLocalCenter() const
{
 return m_sweep.localCenter;
}

inline void b2Body::SetLinearVelocity(const b2Vec2& v)
{
 if (m_type == b2_staticBody)
 {
  return;
 }

 if (b2Dot(v,v) > 0.0f)
 {
  SetAwake(true);
 }

 m_linearVelocity = v;
}

inline const b2Vec2& b2Body::GetLinearVelocity() const
{
 return m_linearVelocity;
}

inline void b2Body::SetAngularVelocity(float32 w)
{
 if (m_type == b2_staticBody)
 {
  return;
 }

 if (w * w > 0.0f)
 {
  SetAwake(true);
 }

 m_angularVelocity = w;
}

inline float32 b2Body::GetAngularVelocity() const
{
 return m_angularVelocity;
}

inline float32 b2Body::GetMass() const
{
 return m_mass;
}

inline float32 b2Body::GetInertia() const
{
 return m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
}

inline void b2Body::GetMassData(b2MassData* data) const
{
 data->mass = m_mass;
 data->I = m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
 data->center = m_sweep.localCenter;
}

inline b2Vec2 b2Body::GetWorldPoint(const b2Vec2& localPoint) const
{
 return b2Mul(m_xf, localPoint);
}

inline b2Vec2 b2Body::GetWorldVector(const b2Vec2& localVector) const
{
 return b2Mul(m_xf.q, localVector);
}

inline b2Vec2 b2Body::GetLocalPoint(const b2Vec2& worldPoint) const
{
 return b2MulT(m_xf, worldPoint);
}

inline b2Vec2 b2Body::GetLocalVector(const b2Vec2& worldVector) const
{
 return b2MulT(m_xf.q, worldVector);
}

inline b2Vec2 b2Body::GetLinearVelocityFromWorldPoint(const b2Vec2& worldPoint) const
{
 return m_linearVelocity + b2Cross(m_angularVelocity, worldPoint - m_sweep.c);
}

inline b2Vec2 b2Body::GetLinearVelocityFromLocalPoint(const b2Vec2& localPoint) const
{
 return GetLinearVelocityFromWorldPoint(GetWorldPoint(localPoint));
}

inline float32 b2Body::GetLinearDamping() const
{
 return m_linearDamping;
}

inline void b2Body::SetLinearDamping(float32 linearDamping)
{
 m_linearDamping = linearDamping;
}

inline float32 b2Body::GetAngularDamping() const
{
 return m_angularDamping;
}

inline void b2Body::SetAngularDamping(float32 angularDamping)
{
 m_angularDamping = angularDamping;
}

inline float32 b2Body::GetGravityScale() const
{
 return m_gravityScale;
}

inline void b2Body::SetGravityScale(float32 scale)
{
 m_gravityScale = scale;
}

inline void b2Body::SetBullet(bool flag)
{
 if (flag)
 {
  m_flags |= e_bulletFlag;
 }
 else
 {
  m_flags &= ~e_bulletFlag;
 }
}

inline bool b2Body::IsBullet() const
{
 return (m_flags & e_bulletFlag) == e_bulletFlag;
}

inline void b2Body::SetAwake(bool flag)
{
 if (flag)
 {
  if ((m_flags & e_awakeFlag) == 0)
  {
   m_flags |= e_awakeFlag;
   m_sleepTime = 0.0f;
  }
 }
 else
 {
  m_flags &= ~e_awakeFlag;
  m_sleepTime = 0.0f;
  m_linearVelocity.SetZero();
  m_angularVelocity = 0.0f;
  m_force.SetZero();
  m_torque = 0.0f;
 }
}

inline bool b2Body::IsAwake() const
{
 return (m_flags & e_awakeFlag) == e_awakeFlag;
}

inline bool b2Body::IsActive() const
{
 return (m_flags & e_activeFlag) == e_activeFlag;
}

inline bool b2Body::IsFixedRotation() const
{
 return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
}

inline void b2Body::SetSleepingAllowed(bool flag)
{
 if (flag)
 {
  m_flags |= e_autoSleepFlag;
 }
 else
 {
  m_flags &= ~e_autoSleepFlag;
  SetAwake(true);
 }
}

inline bool b2Body::IsSleepingAllowed() const
{
 return (m_flags & e_autoSleepFlag) == e_autoSleepFlag;
}

inline b2Fixture* b2Body::GetFixtureList()
{
 return m_fixtureList;
}

inline const b2Fixture* b2Body::GetFixtureList() const
{
 return m_fixtureList;
}

inline b2JointEdge* b2Body::GetJointList()
{
 return m_jointList;
}

inline const b2JointEdge* b2Body::GetJointList() const
{
 return m_jointList;
}

inline b2ContactEdge* b2Body::GetContactList()
{
 return m_contactList;
}

inline const b2ContactEdge* b2Body::GetContactList() const
{
 return m_contactList;
}

inline b2Body* b2Body::GetNext()
{
 return m_next;
}

inline const b2Body* b2Body::GetNext() const
{
 return m_next;
}

inline void b2Body::SetUserData(void* data)
{
 m_userData = data;
}

inline void* b2Body::GetUserData() const
{
 return m_userData;
}

inline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_force += force;
  m_torque += b2Cross(point - m_sweep.c, force);
 }
}

inline void b2Body::ApplyForceToCenter(const b2Vec2& force, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_force += force;
 }
}

inline void b2Body::ApplyTorque(float32 torque, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_torque += torque;
 }
}

inline void b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_linearVelocity += m_invMass * impulse;
  m_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);
 }
}

inline void b2Body::ApplyLinearImpulseToCenter(const b2Vec2& impulse, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_linearVelocity += m_invMass * impulse;
 }
}

inline void b2Body::ApplyAngularImpulse(float32 impulse, bool wake)
{
 if (m_type != b2_dynamicBody)
 {
  return;
 }

 if (wake && (m_flags & e_awakeFlag) == 0)
 {
  SetAwake(true);
 }


 if (m_flags & e_awakeFlag)
 {
  m_angularVelocity += m_invI * impulse;
 }
}

inline void b2Body::SynchronizeTransform()
{
 m_xf.q.Set(m_sweep.a);
 m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
}

inline void b2Body::Advance(float32 alpha)
{

 m_sweep.Advance(alpha);
 m_sweep.c = m_sweep.c0;
 m_sweep.a = m_sweep.a0;
 m_xf.q.Set(m_sweep.a);
 m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
}

inline b2World* b2Body::GetWorld()
{
 return m_world;
}

inline const b2World* b2Body::GetWorld() const
{
 return m_world;
}
class b2BlockAllocator;
class b2Body;
class b2BroadPhase;
class b2Fixture;


struct b2Filter
{
 b2Filter()
 {
  categoryBits = 0x0001;
  maskBits = 0xFFFF;
  groupIndex = 0;
 }


 uint16 categoryBits;



 uint16 maskBits;




 int16 groupIndex;
};



struct b2FixtureDef
{

 b2FixtureDef()
 {
  shape = __null;
  userData = __null;
  friction = 0.2f;
  restitution = 0.0f;
  density = 0.0f;
  isSensor = false;
 }



 const b2Shape* shape;


 void* userData;


 float32 friction;


 float32 restitution;


 float32 density;



 bool isSensor;


 b2Filter filter;
};


struct b2FixtureProxy
{
 b2AABB aabb;
 b2Fixture* fixture;
 int32 childIndex;
 int32 proxyId;
};






class b2Fixture
{
public:


 b2Shape::Type GetType() const;




 b2Shape* GetShape();
 const b2Shape* GetShape() const;


 void SetSensor(bool sensor);



 bool IsSensor() const;




 void SetFilterData(const b2Filter& filter);


 const b2Filter& GetFilterData() const;


 void Refilter();



 b2Body* GetBody();
 const b2Body* GetBody() const;



 b2Fixture* GetNext();
 const b2Fixture* GetNext() const;



 void* GetUserData() const;


 void SetUserData(void* data);



 bool TestPoint(const b2Vec2& p) const;




 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input, int32 childIndex) const;




 void GetMassData(b2MassData* massData) const;



 void SetDensity(float32 density);


 float32 GetDensity() const;


 float32 GetFriction() const;



 void SetFriction(float32 friction);


 float32 GetRestitution() const;



 void SetRestitution(float32 restitution);




 const b2AABB& GetAABB(int32 childIndex) const;


 void Dump(int32 bodyIndex);

protected:

 friend class b2Body;
 friend class b2World;
 friend class b2Contact;
 friend class b2ContactManager;

 b2Fixture();



 void Create(b2BlockAllocator* allocator, b2Body* body, const b2FixtureDef* def);
 void Destroy(b2BlockAllocator* allocator);


 void CreateProxies(b2BroadPhase* broadPhase, const b2Transform& xf);
 void DestroyProxies(b2BroadPhase* broadPhase);

 void Synchronize(b2BroadPhase* broadPhase, const b2Transform& xf1, const b2Transform& xf2);

 float32 m_density;

 b2Fixture* m_next;
 b2Body* m_body;

 b2Shape* m_shape;

 float32 m_friction;
 float32 m_restitution;

 b2FixtureProxy* m_proxies;
 int32 m_proxyCount;

 b2Filter m_filter;

 bool m_isSensor;

 void* m_userData;
};

inline b2Shape::Type b2Fixture::GetType() const
{
 return m_shape->GetType();
}

inline b2Shape* b2Fixture::GetShape()
{
 return m_shape;
}

inline const b2Shape* b2Fixture::GetShape() const
{
 return m_shape;
}

inline bool b2Fixture::IsSensor() const
{
 return m_isSensor;
}

inline const b2Filter& b2Fixture::GetFilterData() const
{
 return m_filter;
}

inline void* b2Fixture::GetUserData() const
{
 return m_userData;
}

inline void b2Fixture::SetUserData(void* data)
{
 m_userData = data;
}

inline b2Body* b2Fixture::GetBody()
{
 return m_body;
}

inline const b2Body* b2Fixture::GetBody() const
{
 return m_body;
}

inline b2Fixture* b2Fixture::GetNext()
{
 return m_next;
}

inline const b2Fixture* b2Fixture::GetNext() const
{
 return m_next;
}

inline void b2Fixture::SetDensity(float32 density)
{
 ((b2IsValid(density) && density >= 0.0f) ? static_cast<void> (0) : __assert_fail ("b2IsValid(density) && density >= 0.0f", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Dynamics/b2Fixture.h", 295, __PRETTY_FUNCTION__));
 m_density = density;
}

inline float32 b2Fixture::GetDensity() const
{
 return m_density;
}

inline float32 b2Fixture::GetFriction() const
{
 return m_friction;
}

inline void b2Fixture::SetFriction(float32 friction)
{
 m_friction = friction;
}

inline float32 b2Fixture::GetRestitution() const
{
 return m_restitution;
}

inline void b2Fixture::SetRestitution(float32 restitution)
{
 m_restitution = restitution;
}

inline bool b2Fixture::TestPoint(const b2Vec2& p) const
{
 return m_shape->TestPoint(m_body->GetTransform(), p);
}

inline bool b2Fixture::RayCast(b2RayCastOutput* output, const b2RayCastInput& input, int32 childIndex) const
{
 return m_shape->RayCast(output, input, m_body->GetTransform(), childIndex);
}

inline void b2Fixture::GetMassData(b2MassData* massData) const
{
 m_shape->ComputeMass(massData, m_density);
}

inline const b2AABB& b2Fixture::GetAABB(int32 childIndex) const
{
 ((0 <= childIndex && childIndex < m_proxyCount) ? static_cast<void> (0) : __assert_fail ("0 <= childIndex && childIndex < m_proxyCount", "/home/nathan/Projects/Urho/Urho3D/Build/include/Urho3D/ThirdParty/Box2D/Dynamics/b2Fixture.h", 341, __PRETTY_FUNCTION__));
 return m_proxies[childIndex].aabb;
}
struct b2Vec2;
struct b2Transform;
class b2Fixture;
class b2Body;
class b2Joint;
class b2Contact;
struct b2ContactResult;
struct b2Manifold;




class b2DestructionListener
{
public:
 virtual ~b2DestructionListener() {}



 virtual void SayGoodbye(b2Joint* joint) = 0;



 virtual void SayGoodbye(b2Fixture* fixture) = 0;
};



class b2ContactFilter
{
public:
 virtual ~b2ContactFilter() {}



 virtual bool ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB);
};




struct b2ContactImpulse
{
 float32 normalImpulses[2];
 float32 tangentImpulses[2];
 int32 count;
};
class b2ContactListener
{
public:
 virtual ~b2ContactListener() {}


 virtual void BeginContact(b2Contact* contact) { ((void)(contact)); }


 virtual void EndContact(b2Contact* contact) { ((void)(contact)); }
 virtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)
 {
  ((void)(contact));
  ((void)(oldManifold));
 }







 virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)
 {
  ((void)(contact));
  ((void)(impulse));
 }
};



class b2QueryCallback
{
public:
 virtual ~b2QueryCallback() {}



 virtual bool ReportFixture(b2Fixture* fixture) = 0;
};



class b2RayCastCallback
{
public:
 virtual ~b2RayCastCallback() {}
 virtual float32 ReportFixture( b2Fixture* fixture, const b2Vec2& point,
         const b2Vec2& normal, float32 fraction) = 0;
};
struct b2Profile
{
 float32 step;
 float32 collide;
 float32 solve;
 float32 solveInit;
 float32 solveVelocity;
 float32 solvePosition;
 float32 broadphase;
 float32 solveTOI;
};


struct b2TimeStep
{
 float32 dt;
 float32 inv_dt;
 float32 dtRatio;
 int32 velocityIterations;
 int32 positionIterations;
 bool warmStarting;
};


struct b2Position
{
 b2Vec2 c;
 float32 a;
};


struct b2Velocity
{
 b2Vec2 v;
 float32 w;
};


struct b2SolverData
{
 b2TimeStep step;
 b2Position* positions;
 b2Velocity* velocities;
};
const int32 b2_stackSize = 100 * 1024;
const int32 b2_maxStackEntries = 32;

struct b2StackEntry
{
 char* data;
 int32 size;
 bool usedMalloc;
};




class b2StackAllocator
{
public:
 b2StackAllocator();
 ~b2StackAllocator();

 void* Allocate(int32 size);
 void Free(void* p);

 int32 GetMaxAllocation() const;

private:

 char m_data[b2_stackSize];
 int32 m_index;

 int32 m_allocation;
 int32 m_maxAllocation;

 b2StackEntry m_entries[b2_maxStackEntries];
 int32 m_entryCount;
};
class b2Contact;
class b2ContactFilter;
class b2ContactListener;
class b2BlockAllocator;


class b2ContactManager
{
public:
 b2ContactManager();


 void AddPair(void* proxyUserDataA, void* proxyUserDataB);

 void FindNewContacts();

 void Destroy(b2Contact* c);

 void Collide();

 b2BroadPhase m_broadPhase;
 b2Contact* m_contactList;
 int32 m_contactCount;
 b2ContactFilter* m_contactFilter;
 b2ContactListener* m_contactListener;
 b2BlockAllocator* m_allocator;
};



struct b2AABB;
struct b2BodyDef;
struct b2Color;
struct b2JointDef;
class b2Body;
class b2Draw;
class b2Fixture;
class b2Joint;




class b2World
{
public:


 b2World(const b2Vec2& gravity);


 ~b2World();



 void SetDestructionListener(b2DestructionListener* listener);




 void SetContactFilter(b2ContactFilter* filter);



 void SetContactListener(b2ContactListener* listener);




 void SetDebugDraw(b2Draw* debugDraw);




 b2Body* CreateBody(const b2BodyDef* def);





 void DestroyBody(b2Body* body);




 b2Joint* CreateJoint(const b2JointDef* def);



 void DestroyJoint(b2Joint* joint);






 void Step( float32 timeStep,
    int32 velocityIterations,
    int32 positionIterations);
 void ClearForces();


 void DrawDebugData();





 void QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const;







 void RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const;




 b2Body* GetBodyList();
 const b2Body* GetBodyList() const;




 b2Joint* GetJointList();
 const b2Joint* GetJointList() const;






 b2Contact* GetContactList();
 const b2Contact* GetContactList() const;


 void SetAllowSleeping(bool flag);
 bool GetAllowSleeping() const { return m_allowSleep; }


 void SetWarmStarting(bool flag) { m_warmStarting = flag; }
 bool GetWarmStarting() const { return m_warmStarting; }


 void SetContinuousPhysics(bool flag) { m_continuousPhysics = flag; }
 bool GetContinuousPhysics() const { return m_continuousPhysics; }


 void SetSubStepping(bool flag) { m_subStepping = flag; }
 bool GetSubStepping() const { return m_subStepping; }


 int32 GetProxyCount() const;


 int32 GetBodyCount() const;


 int32 GetJointCount() const;


 int32 GetContactCount() const;


 int32 GetTreeHeight() const;


 int32 GetTreeBalance() const;



 float32 GetTreeQuality() const;


 void SetGravity(const b2Vec2& gravity);


 b2Vec2 GetGravity() const;


 bool IsLocked() const;


 void SetAutoClearForces(bool flag);


 bool GetAutoClearForces() const;




 void ShiftOrigin(const b2Vec2& newOrigin);


 const b2ContactManager& GetContactManager() const;


 const b2Profile& GetProfile() const;



 void Dump();

private:


 enum
 {
  e_newFixture = 0x0001,
  e_locked = 0x0002,
  e_clearForces = 0x0004
 };

 friend class b2Body;
 friend class b2Fixture;
 friend class b2ContactManager;
 friend class b2Controller;

 void Solve(const b2TimeStep& step);
 void SolveTOI(const b2TimeStep& step);

 void DrawJoint(b2Joint* joint);
 void DrawShape(b2Fixture* shape, const b2Transform& xf, const b2Color& color);

 b2BlockAllocator m_blockAllocator;
 b2StackAllocator m_stackAllocator;

 int32 m_flags;

 b2ContactManager m_contactManager;

 b2Body* m_bodyList;
 b2Joint* m_jointList;

 int32 m_bodyCount;
 int32 m_jointCount;

 b2Vec2 m_gravity;
 bool m_allowSleep;

 b2DestructionListener* m_destructionListener;
 b2Draw* g_debugDraw;



 float32 m_inv_dt0;


 bool m_warmStarting;
 bool m_continuousPhysics;
 bool m_subStepping;

 bool m_stepComplete;

 b2Profile m_profile;
};

inline b2Body* b2World::GetBodyList()
{
 return m_bodyList;
}

inline const b2Body* b2World::GetBodyList() const
{
 return m_bodyList;
}

inline b2Joint* b2World::GetJointList()
{
 return m_jointList;
}

inline const b2Joint* b2World::GetJointList() const
{
 return m_jointList;
}

inline b2Contact* b2World::GetContactList()
{
 return m_contactManager.m_contactList;
}

inline const b2Contact* b2World::GetContactList() const
{
 return m_contactManager.m_contactList;
}

inline int32 b2World::GetBodyCount() const
{
 return m_bodyCount;
}

inline int32 b2World::GetJointCount() const
{
 return m_jointCount;
}

inline int32 b2World::GetContactCount() const
{
 return m_contactManager.m_contactCount;
}

inline void b2World::SetGravity(const b2Vec2& gravity)
{
 m_gravity = gravity;
}

inline b2Vec2 b2World::GetGravity() const
{
 return m_gravity;
}

inline bool b2World::IsLocked() const
{
 return (m_flags & e_locked) == e_locked;
}

inline void b2World::SetAutoClearForces(bool flag)
{
 if (flag)
 {
  m_flags |= e_clearForces;
 }
 else
 {
  m_flags &= ~e_clearForces;
 }
}


inline bool b2World::GetAutoClearForces() const
{
 return (m_flags & e_clearForces) == e_clearForces;
}

inline const b2ContactManager& b2World::GetContactManager() const
{
 return m_contactManager;
}

inline const b2Profile& b2World::GetProfile() const
{
 return m_profile;
}

class b2Body;
class b2Contact;
class b2Fixture;
class b2World;
class b2BlockAllocator;
class b2StackAllocator;
class b2ContactListener;



inline float32 b2MixFriction(float32 friction1, float32 friction2)
{
 return sqrtf(friction1 * friction2);
}



inline float32 b2MixRestitution(float32 restitution1, float32 restitution2)
{
 return restitution1 > restitution2 ? restitution1 : restitution2;
}

typedef b2Contact* b2ContactCreateFcn( b2Fixture* fixtureA, int32 indexA,
          b2Fixture* fixtureB, int32 indexB,
          b2BlockAllocator* allocator);
typedef void b2ContactDestroyFcn(b2Contact* contact, b2BlockAllocator* allocator);

struct b2ContactRegister
{
 b2ContactCreateFcn* createFcn;
 b2ContactDestroyFcn* destroyFcn;
 bool primary;
};






struct b2ContactEdge
{
 b2Body* other;
 b2Contact* contact;
 b2ContactEdge* prev;
 b2ContactEdge* next;
};




class b2Contact
{
public:



 b2Manifold* GetManifold();
 const b2Manifold* GetManifold() const;


 void GetWorldManifold(b2WorldManifold* worldManifold) const;


 bool IsTouching() const;




 void SetEnabled(bool flag);


 bool IsEnabled() const;


 b2Contact* GetNext();
 const b2Contact* GetNext() const;


 b2Fixture* GetFixtureA();
 const b2Fixture* GetFixtureA() const;


 int32 GetChildIndexA() const;


 b2Fixture* GetFixtureB();
 const b2Fixture* GetFixtureB() const;


 int32 GetChildIndexB() const;



 void SetFriction(float32 friction);


 float32 GetFriction() const;


 void ResetFriction();



 void SetRestitution(float32 restitution);


 float32 GetRestitution() const;


 void ResetRestitution();


 void SetTangentSpeed(float32 speed);


 float32 GetTangentSpeed() const;


 virtual void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB) = 0;

protected:
 friend class b2ContactManager;
 friend class b2World;
 friend class b2ContactSolver;
 friend class b2Body;
 friend class b2Fixture;


 enum
 {

  e_islandFlag = 0x0001,


  e_touchingFlag = 0x0002,


  e_enabledFlag = 0x0004,


  e_filterFlag = 0x0008,


  e_bulletHitFlag = 0x0010,


  e_toiFlag = 0x0020
 };


 void FlagForFiltering();

 static void AddType(b2ContactCreateFcn* createFcn, b2ContactDestroyFcn* destroyFcn,
      b2Shape::Type typeA, b2Shape::Type typeB);
 static void InitializeRegisters();
 static b2Contact* Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
 static void Destroy(b2Contact* contact, b2Shape::Type typeA, b2Shape::Type typeB, b2BlockAllocator* allocator);
 static void Destroy(b2Contact* contact, b2BlockAllocator* allocator);

 b2Contact() : m_fixtureA(__null), m_fixtureB(__null) {}
 b2Contact(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB);
 virtual ~b2Contact() {}

 void Update(b2ContactListener* listener);

 static b2ContactRegister s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];
 static bool s_initialized;

 uint32 m_flags;


 b2Contact* m_prev;
 b2Contact* m_next;


 b2ContactEdge m_nodeA;
 b2ContactEdge m_nodeB;

 b2Fixture* m_fixtureA;
 b2Fixture* m_fixtureB;

 int32 m_indexA;
 int32 m_indexB;

 b2Manifold m_manifold;

 int32 m_toiCount;
 float32 m_toi;

 float32 m_friction;
 float32 m_restitution;

 float32 m_tangentSpeed;
};

inline b2Manifold* b2Contact::GetManifold()
{
 return &m_manifold;
}

inline const b2Manifold* b2Contact::GetManifold() const
{
 return &m_manifold;
}

inline void b2Contact::GetWorldManifold(b2WorldManifold* worldManifold) const
{
 const b2Body* bodyA = m_fixtureA->GetBody();
 const b2Body* bodyB = m_fixtureB->GetBody();
 const b2Shape* shapeA = m_fixtureA->GetShape();
 const b2Shape* shapeB = m_fixtureB->GetShape();

 worldManifold->Initialize(&m_manifold, bodyA->GetTransform(), shapeA->m_radius, bodyB->GetTransform(), shapeB->m_radius);
}

inline void b2Contact::SetEnabled(bool flag)
{
 if (flag)
 {
  m_flags |= e_enabledFlag;
 }
 else
 {
  m_flags &= ~e_enabledFlag;
 }
}

inline bool b2Contact::IsEnabled() const
{
 return (m_flags & e_enabledFlag) == e_enabledFlag;
}

inline bool b2Contact::IsTouching() const
{
 return (m_flags & e_touchingFlag) == e_touchingFlag;
}

inline b2Contact* b2Contact::GetNext()
{
 return m_next;
}

inline const b2Contact* b2Contact::GetNext() const
{
 return m_next;
}

inline b2Fixture* b2Contact::GetFixtureA()
{
 return m_fixtureA;
}

inline const b2Fixture* b2Contact::GetFixtureA() const
{
 return m_fixtureA;
}

inline b2Fixture* b2Contact::GetFixtureB()
{
 return m_fixtureB;
}

inline int32 b2Contact::GetChildIndexA() const
{
 return m_indexA;
}

inline const b2Fixture* b2Contact::GetFixtureB() const
{
 return m_fixtureB;
}

inline int32 b2Contact::GetChildIndexB() const
{
 return m_indexB;
}

inline void b2Contact::FlagForFiltering()
{
 m_flags |= e_filterFlag;
}

inline void b2Contact::SetFriction(float32 friction)
{
 m_friction = friction;
}

inline float32 b2Contact::GetFriction() const
{
 return m_friction;
}

inline void b2Contact::ResetFriction()
{
 m_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);
}

inline void b2Contact::SetRestitution(float32 restitution)
{
 m_restitution = restitution;
}

inline float32 b2Contact::GetRestitution() const
{
 return m_restitution;
}

inline void b2Contact::ResetRestitution()
{
 m_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);
}

inline void b2Contact::SetTangentSpeed(float32 speed)
{
 m_tangentSpeed = speed;
}

inline float32 b2Contact::GetTangentSpeed() const
{
 return m_tangentSpeed;
}

class b2Body;
class b2Joint;
struct b2SolverData;
class b2BlockAllocator;

enum b2JointType
{
 e_unknownJoint,
 e_revoluteJoint,
 e_prismaticJoint,
 e_distanceJoint,
 e_pulleyJoint,
 e_mouseJoint,
 e_gearJoint,
 e_wheelJoint,
    e_weldJoint,
 e_frictionJoint,
 e_ropeJoint,
 e_motorJoint
};

enum b2LimitState
{
 e_inactiveLimit,
 e_atLowerLimit,
 e_atUpperLimit,
 e_equalLimits
};

struct b2Jacobian
{
 b2Vec2 linear;
 float32 angularA;
 float32 angularB;
};






struct b2JointEdge
{
 b2Body* other;
 b2Joint* joint;
 b2JointEdge* prev;
 b2JointEdge* next;
};


struct b2JointDef
{
 b2JointDef()
 {
  type = e_unknownJoint;
  userData = __null;
  bodyA = __null;
  bodyB = __null;
  collideConnected = false;
 }


 b2JointType type;


 void* userData;


 b2Body* bodyA;


 b2Body* bodyB;


 bool collideConnected;
};



class b2Joint
{
public:


 b2JointType GetType() const;


 b2Body* GetBodyA();


 b2Body* GetBodyB();


 virtual b2Vec2 GetAnchorA() const = 0;


 virtual b2Vec2 GetAnchorB() const = 0;


 virtual b2Vec2 GetReactionForce(float32 inv_dt) const = 0;


 virtual float32 GetReactionTorque(float32 inv_dt) const = 0;


 b2Joint* GetNext();
 const b2Joint* GetNext() const;


 void* GetUserData() const;


 void SetUserData(void* data);


 bool IsActive() const;




 bool GetCollideConnected() const;


 virtual void Dump() { b2Log("// Dump is not supported for this joint type.\n"); }


 virtual void ShiftOrigin(const b2Vec2& newOrigin) { ((void)(newOrigin)); }

protected:
 friend class b2World;
 friend class b2Body;
 friend class b2Island;
 friend class b2GearJoint;

 static b2Joint* Create(const b2JointDef* def, b2BlockAllocator* allocator);
 static void Destroy(b2Joint* joint, b2BlockAllocator* allocator);

 b2Joint(const b2JointDef* def);
 virtual ~b2Joint() {}

 virtual void InitVelocityConstraints(const b2SolverData& data) = 0;
 virtual void SolveVelocityConstraints(const b2SolverData& data) = 0;


 virtual bool SolvePositionConstraints(const b2SolverData& data) = 0;

 b2JointType m_type;
 b2Joint* m_prev;
 b2Joint* m_next;
 b2JointEdge m_edgeA;
 b2JointEdge m_edgeB;
 b2Body* m_bodyA;
 b2Body* m_bodyB;

 int32 m_index;

 bool m_islandFlag;
 bool m_collideConnected;

 void* m_userData;
};

inline b2JointType b2Joint::GetType() const
{
 return m_type;
}

inline b2Body* b2Joint::GetBodyA()
{
 return m_bodyA;
}

inline b2Body* b2Joint::GetBodyB()
{
 return m_bodyB;
}

inline b2Joint* b2Joint::GetNext()
{
 return m_next;
}

inline const b2Joint* b2Joint::GetNext() const
{
 return m_next;
}

inline void* b2Joint::GetUserData() const
{
 return m_userData;
}

inline void b2Joint::SetUserData(void* data)
{
 m_userData = data;
}

inline bool b2Joint::GetCollideConnected() const
{
 return m_collideConnected;
}







struct b2DistanceJointDef : public b2JointDef
{
 b2DistanceJointDef()
 {
  type = e_distanceJoint;
  localAnchorA.Set(0.0f, 0.0f);
  localAnchorB.Set(0.0f, 0.0f);
  length = 1.0f;
  frequencyHz = 0.0f;
  dampingRatio = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB,
     const b2Vec2& anchorA, const b2Vec2& anchorB);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 length;



 float32 frequencyHz;


 float32 dampingRatio;
};




class b2DistanceJoint : public b2Joint
{
public:

 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;



 b2Vec2 GetReactionForce(float32 inv_dt) const;



 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }



 void SetLength(float32 length);
 float32 GetLength() const;


 void SetFrequency(float32 hz);
 float32 GetFrequency() const;


 void SetDampingRatio(float32 ratio);
 float32 GetDampingRatio() const;


 void Dump();

protected:

 friend class b2Joint;
 b2DistanceJoint(const b2DistanceJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 float32 m_frequencyHz;
 float32 m_dampingRatio;
 float32 m_bias;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_gamma;
 float32 m_impulse;
 float32 m_length;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_u;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 float32 m_mass;
};

inline void b2DistanceJoint::SetLength(float32 length)
{
 m_length = length;
}

inline float32 b2DistanceJoint::GetLength() const
{
 return m_length;
}

inline void b2DistanceJoint::SetFrequency(float32 hz)
{
 m_frequencyHz = hz;
}

inline float32 b2DistanceJoint::GetFrequency() const
{
 return m_frequencyHz;
}

inline void b2DistanceJoint::SetDampingRatio(float32 ratio)
{
 m_dampingRatio = ratio;
}

inline float32 b2DistanceJoint::GetDampingRatio() const
{
 return m_dampingRatio;
}
struct b2FrictionJointDef : public b2JointDef
{
 b2FrictionJointDef()
 {
  type = e_frictionJoint;
  localAnchorA.SetZero();
  localAnchorB.SetZero();
  maxForce = 0.0f;
  maxTorque = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 maxForce;


 float32 maxTorque;
};



class b2FrictionJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 void SetMaxForce(float32 force);


 float32 GetMaxForce() const;


 void SetMaxTorque(float32 torque);


 float32 GetMaxTorque() const;


 void Dump();

protected:

 friend class b2Joint;

 b2FrictionJoint(const b2FrictionJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;


 b2Vec2 m_linearImpulse;
 float32 m_angularImpulse;
 float32 m_maxForce;
 float32 m_maxTorque;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat22 m_linearMass;
 float32 m_angularMass;
};
struct b2GearJointDef : public b2JointDef
{
 b2GearJointDef()
 {
  type = e_gearJoint;
  joint1 = __null;
  joint2 = __null;
  ratio = 1.0f;
 }


 b2Joint* joint1;


 b2Joint* joint2;



 float32 ratio;
};
class b2GearJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 b2Joint* GetJoint1() { return m_joint1; }


 b2Joint* GetJoint2() { return m_joint2; }


 void SetRatio(float32 ratio);
 float32 GetRatio() const;


 void Dump();

protected:

 friend class b2Joint;
 b2GearJoint(const b2GearJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Joint* m_joint1;
 b2Joint* m_joint2;

 b2JointType m_typeA;
 b2JointType m_typeB;



 b2Body* m_bodyC;
 b2Body* m_bodyD;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec2 m_localAnchorC;
 b2Vec2 m_localAnchorD;

 b2Vec2 m_localAxisC;
 b2Vec2 m_localAxisD;

 float32 m_referenceAngleA;
 float32 m_referenceAngleB;

 float32 m_constant;
 float32 m_ratio;

 float32 m_impulse;


 int32 m_indexA, m_indexB, m_indexC, m_indexD;
 b2Vec2 m_lcA, m_lcB, m_lcC, m_lcD;
 float32 m_mA, m_mB, m_mC, m_mD;
 float32 m_iA, m_iB, m_iC, m_iD;
 b2Vec2 m_JvAC, m_JvBD;
 float32 m_JwA, m_JwB, m_JwC, m_JwD;
 float32 m_mass;
};
struct b2MotorJointDef : public b2JointDef
{
 b2MotorJointDef()
 {
  type = e_motorJoint;
  linearOffset.SetZero();
  angularOffset = 0.0f;
  maxForce = 1.0f;
  maxTorque = 1.0f;
  correctionFactor = 0.3f;
 }


 void Initialize(b2Body* bodyA, b2Body* bodyB);


 b2Vec2 linearOffset;


 float32 angularOffset;


 float32 maxForce;


 float32 maxTorque;


 float32 correctionFactor;
};




class b2MotorJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 void SetLinearOffset(const b2Vec2& linearOffset);
 const b2Vec2& GetLinearOffset() const;


 void SetAngularOffset(float32 angularOffset);
 float32 GetAngularOffset() const;


 void SetMaxForce(float32 force);


 float32 GetMaxForce() const;


 void SetMaxTorque(float32 torque);


 float32 GetMaxTorque() const;


 void SetCorrectionFactor(float32 factor);


 float32 GetCorrectionFactor() const;


 void Dump();

protected:

 friend class b2Joint;

 b2MotorJoint(const b2MotorJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_linearOffset;
 float32 m_angularOffset;
 b2Vec2 m_linearImpulse;
 float32 m_angularImpulse;
 float32 m_maxForce;
 float32 m_maxTorque;
 float32 m_correctionFactor;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 b2Vec2 m_linearError;
 float32 m_angularError;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat22 m_linearMass;
 float32 m_angularMass;
};
struct b2MouseJointDef : public b2JointDef
{
 b2MouseJointDef()
 {
  type = e_mouseJoint;
  target.Set(0.0f, 0.0f);
  maxForce = 0.0f;
  frequencyHz = 5.0f;
  dampingRatio = 0.7f;
 }



 b2Vec2 target;




 float32 maxForce;


 float32 frequencyHz;


 float32 dampingRatio;
};
class b2MouseJoint : public b2Joint
{
public:


 b2Vec2 GetAnchorA() const;


 b2Vec2 GetAnchorB() const;


 b2Vec2 GetReactionForce(float32 inv_dt) const;


 float32 GetReactionTorque(float32 inv_dt) const;


 void SetTarget(const b2Vec2& target);
 const b2Vec2& GetTarget() const;


 void SetMaxForce(float32 force);
 float32 GetMaxForce() const;


 void SetFrequency(float32 hz);
 float32 GetFrequency() const;


 void SetDampingRatio(float32 ratio);
 float32 GetDampingRatio() const;


 void Dump() { b2Log("Mouse joint dumping is not supported.\n"); }


 void ShiftOrigin(const b2Vec2& newOrigin);

protected:
 friend class b2Joint;

 b2MouseJoint(const b2MouseJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Vec2 m_localAnchorB;
 b2Vec2 m_targetA;
 float32 m_frequencyHz;
 float32 m_dampingRatio;
 float32 m_beta;


 b2Vec2 m_impulse;
 float32 m_maxForce;
 float32 m_gamma;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterB;
 float32 m_invMassB;
 float32 m_invIB;
 b2Mat22 m_mass;
 b2Vec2 m_C;
};
struct b2PrismaticJointDef : public b2JointDef
{
 b2PrismaticJointDef()
 {
  type = e_prismaticJoint;
  localAnchorA.SetZero();
  localAnchorB.SetZero();
  localAxisA.Set(1.0f, 0.0f);
  referenceAngle = 0.0f;
  enableLimit = false;
  lowerTranslation = 0.0f;
  upperTranslation = 0.0f;
  enableMotor = false;
  maxMotorForce = 0.0f;
  motorSpeed = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 b2Vec2 localAxisA;


 float32 referenceAngle;


 bool enableLimit;


 float32 lowerTranslation;


 float32 upperTranslation;


 bool enableMotor;


 float32 maxMotorForce;


 float32 motorSpeed;
};





class b2PrismaticJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 const b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }


 float32 GetReferenceAngle() const { return m_referenceAngle; }


 float32 GetJointTranslation() const;


 float32 GetJointSpeed() const;


 bool IsLimitEnabled() const;


 void EnableLimit(bool flag);


 float32 GetLowerLimit() const;


 float32 GetUpperLimit() const;


 void SetLimits(float32 lower, float32 upper);


 bool IsMotorEnabled() const;


 void EnableMotor(bool flag);


 void SetMotorSpeed(float32 speed);


 float32 GetMotorSpeed() const;


 void SetMaxMotorForce(float32 force);
 float32 GetMaxMotorForce() const { return m_maxMotorForce; }


 float32 GetMotorForce(float32 inv_dt) const;


 void Dump();

protected:
 friend class b2Joint;
 friend class b2GearJoint;
 b2PrismaticJoint(const b2PrismaticJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec2 m_localXAxisA;
 b2Vec2 m_localYAxisA;
 float32 m_referenceAngle;
 b2Vec3 m_impulse;
 float32 m_motorImpulse;
 float32 m_lowerTranslation;
 float32 m_upperTranslation;
 float32 m_maxMotorForce;
 float32 m_motorSpeed;
 bool m_enableLimit;
 bool m_enableMotor;
 b2LimitState m_limitState;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Vec2 m_axis, m_perp;
 float32 m_s1, m_s2;
 float32 m_a1, m_a2;
 b2Mat33 m_K;
 float32 m_motorMass;
};

inline float32 b2PrismaticJoint::GetMotorSpeed() const
{
 return m_motorSpeed;
}
const float32 b2_minPulleyLength = 2.0f;



struct b2PulleyJointDef : public b2JointDef
{
 b2PulleyJointDef()
 {
  type = e_pulleyJoint;
  groundAnchorA.Set(-1.0f, 1.0f);
  groundAnchorB.Set(1.0f, 1.0f);
  localAnchorA.Set(-1.0f, 0.0f);
  localAnchorB.Set(1.0f, 0.0f);
  lengthA = 0.0f;
  lengthB = 0.0f;
  ratio = 1.0f;
  collideConnected = true;
 }


 void Initialize(b2Body* bodyA, b2Body* bodyB,
     const b2Vec2& groundAnchorA, const b2Vec2& groundAnchorB,
     const b2Vec2& anchorA, const b2Vec2& anchorB,
     float32 ratio);


 b2Vec2 groundAnchorA;


 b2Vec2 groundAnchorB;


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 lengthA;


 float32 lengthB;


 float32 ratio;
};
class b2PulleyJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 b2Vec2 GetGroundAnchorA() const;


 b2Vec2 GetGroundAnchorB() const;


 float32 GetLengthA() const;


 float32 GetLengthB() const;


 float32 GetRatio() const;


 float32 GetCurrentLengthA() const;


 float32 GetCurrentLengthB() const;


 void Dump();


 void ShiftOrigin(const b2Vec2& newOrigin);

protected:

 friend class b2Joint;
 b2PulleyJoint(const b2PulleyJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 b2Vec2 m_groundAnchorA;
 b2Vec2 m_groundAnchorB;
 float32 m_lengthA;
 float32 m_lengthB;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_constant;
 float32 m_ratio;
 float32 m_impulse;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_uA;
 b2Vec2 m_uB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 float32 m_mass;
};
struct b2RevoluteJointDef : public b2JointDef
{
 b2RevoluteJointDef()
 {
  type = e_revoluteJoint;
  localAnchorA.Set(0.0f, 0.0f);
  localAnchorB.Set(0.0f, 0.0f);
  referenceAngle = 0.0f;
  lowerAngle = 0.0f;
  upperAngle = 0.0f;
  maxMotorTorque = 0.0f;
  motorSpeed = 0.0f;
  enableLimit = false;
  enableMotor = false;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 referenceAngle;


 bool enableLimit;


 float32 lowerAngle;


 float32 upperAngle;


 bool enableMotor;


 float32 motorSpeed;



 float32 maxMotorTorque;
};







class b2RevoluteJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 float32 GetReferenceAngle() const { return m_referenceAngle; }


 float32 GetJointAngle() const;


 float32 GetJointSpeed() const;


 bool IsLimitEnabled() const;


 void EnableLimit(bool flag);


 float32 GetLowerLimit() const;


 float32 GetUpperLimit() const;


 void SetLimits(float32 lower, float32 upper);


 bool IsMotorEnabled() const;


 void EnableMotor(bool flag);


 void SetMotorSpeed(float32 speed);


 float32 GetMotorSpeed() const;


 void SetMaxMotorTorque(float32 torque);
 float32 GetMaxMotorTorque() const { return m_maxMotorTorque; }



 b2Vec2 GetReactionForce(float32 inv_dt) const;



 float32 GetReactionTorque(float32 inv_dt) const;



 float32 GetMotorTorque(float32 inv_dt) const;


 void Dump();

protected:

 friend class b2Joint;
 friend class b2GearJoint;

 b2RevoluteJoint(const b2RevoluteJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec3 m_impulse;
 float32 m_motorImpulse;

 bool m_enableMotor;
 float32 m_maxMotorTorque;
 float32 m_motorSpeed;

 bool m_enableLimit;
 float32 m_referenceAngle;
 float32 m_lowerAngle;
 float32 m_upperAngle;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat33 m_mass;
 float32 m_motorMass;
 b2LimitState m_limitState;
};

inline float32 b2RevoluteJoint::GetMotorSpeed() const
{
 return m_motorSpeed;
}
struct b2RopeJointDef : public b2JointDef
{
 b2RopeJointDef()
 {
  type = e_ropeJoint;
  localAnchorA.Set(-1.0f, 0.0f);
  localAnchorB.Set(1.0f, 0.0f);
  maxLength = 0.0f;
 }


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;




 float32 maxLength;
};
class b2RopeJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 void SetMaxLength(float32 length) { m_maxLength = length; }
 float32 GetMaxLength() const;

 b2LimitState GetLimitState() const;


 void Dump();

protected:

 friend class b2Joint;
 b2RopeJoint(const b2RopeJointDef* data);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_maxLength;
 float32 m_length;
 float32 m_impulse;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_u;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 float32 m_mass;
 b2LimitState m_state;
};
struct b2WeldJointDef : public b2JointDef
{
 b2WeldJointDef()
 {
  type = e_weldJoint;
  localAnchorA.Set(0.0f, 0.0f);
  localAnchorB.Set(0.0f, 0.0f);
  referenceAngle = 0.0f;
  frequencyHz = 0.0f;
  dampingRatio = 0.0f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 float32 referenceAngle;



 float32 frequencyHz;


 float32 dampingRatio;
};



class b2WeldJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 float32 GetReferenceAngle() const { return m_referenceAngle; }


 void SetFrequency(float32 hz) { m_frequencyHz = hz; }
 float32 GetFrequency() const { return m_frequencyHz; }


 void SetDampingRatio(float32 ratio) { m_dampingRatio = ratio; }
 float32 GetDampingRatio() const { return m_dampingRatio; }


 void Dump();

protected:

 friend class b2Joint;

 b2WeldJoint(const b2WeldJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 float32 m_frequencyHz;
 float32 m_dampingRatio;
 float32 m_bias;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 float32 m_referenceAngle;
 float32 m_gamma;
 b2Vec3 m_impulse;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_rA;
 b2Vec2 m_rB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;
 b2Mat33 m_mass;
};
struct b2WheelJointDef : public b2JointDef
{
 b2WheelJointDef()
 {
  type = e_wheelJoint;
  localAnchorA.SetZero();
  localAnchorB.SetZero();
  localAxisA.Set(1.0f, 0.0f);
  enableMotor = false;
  maxMotorTorque = 0.0f;
  motorSpeed = 0.0f;
  frequencyHz = 2.0f;
  dampingRatio = 0.7f;
 }



 void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);


 b2Vec2 localAnchorA;


 b2Vec2 localAnchorB;


 b2Vec2 localAxisA;


 bool enableMotor;


 float32 maxMotorTorque;


 float32 motorSpeed;


 float32 frequencyHz;


 float32 dampingRatio;
};





class b2WheelJoint : public b2Joint
{
public:
 b2Vec2 GetAnchorA() const;
 b2Vec2 GetAnchorB() const;

 b2Vec2 GetReactionForce(float32 inv_dt) const;
 float32 GetReactionTorque(float32 inv_dt) const;


 const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }


 const b2Vec2& GetLocalAnchorB() const { return m_localAnchorB; }


 const b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }


 float32 GetJointTranslation() const;


 float32 GetJointLinearSpeed() const;


 float32 GetJointAngle() const;


 float32 GetJointAngularSpeed() const;


 bool IsMotorEnabled() const;


 void EnableMotor(bool flag);


 void SetMotorSpeed(float32 speed);


 float32 GetMotorSpeed() const;


 void SetMaxMotorTorque(float32 torque);
 float32 GetMaxMotorTorque() const;


 float32 GetMotorTorque(float32 inv_dt) const;


 void SetSpringFrequencyHz(float32 hz);
 float32 GetSpringFrequencyHz() const;


 void SetSpringDampingRatio(float32 ratio);
 float32 GetSpringDampingRatio() const;


 void Dump();

protected:

 friend class b2Joint;
 b2WheelJoint(const b2WheelJointDef* def);

 void InitVelocityConstraints(const b2SolverData& data);
 void SolveVelocityConstraints(const b2SolverData& data);
 bool SolvePositionConstraints(const b2SolverData& data);

 float32 m_frequencyHz;
 float32 m_dampingRatio;


 b2Vec2 m_localAnchorA;
 b2Vec2 m_localAnchorB;
 b2Vec2 m_localXAxisA;
 b2Vec2 m_localYAxisA;

 float32 m_impulse;
 float32 m_motorImpulse;
 float32 m_springImpulse;

 float32 m_maxMotorTorque;
 float32 m_motorSpeed;
 bool m_enableMotor;


 int32 m_indexA;
 int32 m_indexB;
 b2Vec2 m_localCenterA;
 b2Vec2 m_localCenterB;
 float32 m_invMassA;
 float32 m_invMassB;
 float32 m_invIA;
 float32 m_invIB;

 b2Vec2 m_ax, m_ay;
 float32 m_sAx, m_sBx;
 float32 m_sAy, m_sBy;

 float32 m_mass;
 float32 m_motorMass;
 float32 m_springMass;

 float32 m_bias;
 float32 m_gamma;
};

inline float32 b2WheelJoint::GetMotorSpeed() const
{
 return m_motorSpeed;
}

inline float32 b2WheelJoint::GetMaxMotorTorque() const
{
 return m_maxMotorTorque;
}

inline void b2WheelJoint::SetSpringFrequencyHz(float32 hz)
{
 m_frequencyHz = hz;
}

inline float32 b2WheelJoint::GetSpringFrequencyHz() const
{
 return m_frequencyHz;
}

inline void b2WheelJoint::SetSpringDampingRatio(float32 ratio)
{
 m_dampingRatio = ratio;
}

inline float32 b2WheelJoint::GetSpringDampingRatio() const
{
 return m_dampingRatio;
}

namespace Urho3D
{

class RigidBody2D;


class __attribute__((visibility("default"))) CollisionShape2D : public Component
{
    public: using ClassName = CollisionShape2D; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionShape2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionShape2D(Context* context);

    ~CollisionShape2D() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    void SetTrigger(bool trigger);

    void SetCategoryBits(int categoryBits);

    void SetMaskBits(int maskBits);

    void SetGroupIndex(int groupIndex);

    void SetDensity(float density);

    void SetFriction(float friction);

    void SetRestitution(float restitution);


    void CreateFixture();

    void ReleaseFixture();


    bool IsTrigger() const { return fixtureDef_.isSensor; }


    int GetCategoryBits() const { return fixtureDef_.filter.categoryBits; }


    int GetMaskBits() const { return fixtureDef_.filter.maskBits; }


    int GetGroupIndex() const { return fixtureDef_.filter.groupIndex; }


    float GetDensity() const { return fixtureDef_.density; }


    float GetFriction() const { return fixtureDef_.friction; }


    float GetRestitution() const { return fixtureDef_.restitution; }


    float GetMass() const;

    float GetInertia() const;

    Vector2 GetMassCenter() const;


    b2Fixture* GetFixture() const { return fixture_; }

protected:

    void OnNodeSet(Node* node) override;

    void OnMarkedDirty(Node* node) override;

    virtual void ApplyNodeWorldScale() = 0;


    WeakPtr<RigidBody2D> rigidBody_;

    b2FixtureDef fixtureDef_;

    b2Fixture* fixture_;

    Vector3 cachedWorldScale_;
};

}

namespace Urho3D
{


class __attribute__((visibility("default"))) CollisionBox2D : public CollisionShape2D
{
    public: using ClassName = CollisionBox2D; using BaseClassName = CollisionShape2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionBox2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionBox2D(Context* context);

    ~CollisionBox2D() override;

    static void RegisterObject(Context* context);


    void SetSize(const Vector2& size);

    void SetSize(float width, float height);

    void SetCenter(const Vector2& center);

    void SetCenter(float x, float y);

    void SetAngle(float angle);


    const Vector2& GetSize() const { return size_; }


    const Vector2& GetCenter() const { return center_; }


    float GetAngle() const { return angle_; }

private:

    void ApplyNodeWorldScale() override;

    void RecreateFixture();


    b2PolygonShape boxShape_;

    Vector2 size_;

    Vector2 center_;

    float angle_;
};

}
namespace Urho3D
{

class __attribute__((visibility("default"))) CollisionChain2D : public CollisionShape2D
{
    public: using ClassName = CollisionChain2D; using BaseClassName = CollisionShape2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionChain2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionChain2D(Context* context);

    ~CollisionChain2D() override;

    static void RegisterObject(Context* context);


    void SetLoop(bool loop);

    void SetVertexCount(unsigned count);

    void SetVertex(unsigned index, const Vector2& vertex);

    void SetVertices(const PODVector<Vector2>& vertices);

    void SetVerticesAttr(const PODVector<unsigned char>& value);


    bool GetLoop() const { return loop_; }


    unsigned GetVertexCount() const { return vertices_.Size(); }


    const Vector2& GetVertex(unsigned index) const { return (index < vertices_.Size()) ? vertices_[index] : Vector2::ZERO; }


    const PODVector<Vector2>& GetVertices() const { return vertices_; }


    PODVector<unsigned char> GetVerticesAttr() const;

private:

    void ApplyNodeWorldScale() override;

    void RecreateFixture();


    b2ChainShape chainShape_;

    bool loop_;

    PODVector<Vector2> vertices_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) CollisionCircle2D : public CollisionShape2D
{
    public: using ClassName = CollisionCircle2D; using BaseClassName = CollisionShape2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionCircle2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionCircle2D(Context* context);

    ~CollisionCircle2D() override;

    static void RegisterObject(Context* context);


    void SetRadius(float radius);

    void SetCenter(const Vector2& center);

    void SetCenter(float x, float y);


    float GetRadius() const { return radius_; }


    const Vector2& GetCenter() const { return center_; }

private:

    void ApplyNodeWorldScale() override;

    void RecreateFixture();


    b2CircleShape circleShape_;

    float radius_;

    Vector2 center_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) CollisionEdge2D : public CollisionShape2D
{
    public: using ClassName = CollisionEdge2D; using BaseClassName = CollisionShape2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionEdge2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionEdge2D(Context* context);

    ~CollisionEdge2D() override;

    static void RegisterObject(Context* context);


    void SetVertex1(const Vector2& vertex);

    void SetVertex2(const Vector2& vertex);

    void SetVertices(const Vector2& vertex1, const Vector2& vertex2);


    const Vector2& GetVertex1() const { return vertex1_; }


    const Vector2& GetVertex2() const { return vertex2_; }

private:

    void ApplyNodeWorldScale() override;

    void RecreateFixture();


    b2EdgeShape edgeShape_;

    Vector2 vertex1_;

    Vector2 vertex2_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) CollisionPolygon2D : public CollisionShape2D
{
    public: using ClassName = CollisionPolygon2D; using BaseClassName = CollisionShape2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("CollisionPolygon2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit CollisionPolygon2D(Context* context);

    ~CollisionPolygon2D() override;

    static void RegisterObject(Context* context);


    void SetVertexCount(unsigned count);

    void SetVertex(unsigned index, const Vector2& vertex);

    void SetVertices(const PODVector<Vector2>& vertices);


    unsigned GetVertexCount() const { return vertices_.Size(); }


    const Vector2& GetVertex(unsigned index) const { return (index < vertices_.Size()) ? vertices_[index] : Vector2::ZERO; }


    const PODVector<Vector2>& GetVertices() const { return vertices_; }


    void SetVerticesAttr(const PODVector<unsigned char>& value);

    PODVector<unsigned char> GetVerticesAttr() const;

private:

    void ApplyNodeWorldScale() override;

    void RecreateFixture();


    b2PolygonShape polygonShape_;

    PODVector<Vector2> vertices_;
};

}

namespace Urho3D
{

class RigidBody2D;
class PhysicsWorld2D;


class __attribute__((visibility("default"))) Constraint2D : public Component
{
    public: using ClassName = Constraint2D; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Constraint2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Constraint2D(Context* context);

    ~Constraint2D() override;

    static void RegisterObject(Context* context);


    void ApplyAttributes() override;

    void OnSetEnabled() override;

    void CreateJoint();

    void ReleaseJoint();


    void SetOtherBody(RigidBody2D* body);

    void SetCollideConnected(bool collideConnected);

    void SetAttachedConstraint(Constraint2D* constraint);


    RigidBody2D* GetOwnerBody() const { return ownerBody_; }


    RigidBody2D* GetOtherBody() const { return otherBody_; }


    bool GetCollideConnected() const { return collideConnected_; }


    Constraint2D* GetAttachedConstraint() const { return attachedConstraint_; }


    b2Joint* GetJoint() const { return joint_; }

protected:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    virtual b2JointDef* GetJointDef() { return nullptr; };

    void RecreateJoint();

    void InitializeJointDef(b2JointDef* jointDef);

    void MarkOtherBodyNodeIDDirty() { otherBodyNodeIDDirty_ = true; }


    WeakPtr<PhysicsWorld2D> physicsWorld_;

    b2Joint* joint_{};

    WeakPtr<RigidBody2D> ownerBody_;

    WeakPtr<RigidBody2D> otherBody_;

    unsigned otherBodyNodeID_{};

    bool collideConnected_{};

    bool otherBodyNodeIDDirty_{};

    WeakPtr<Constraint2D> attachedConstraint_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintDistance2D : public Constraint2D
{
    public: using ClassName = ConstraintDistance2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintDistance2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintDistance2D(Context* context);

    ~ConstraintDistance2D() override;

    static void RegisterObject(Context* context);


    void SetOwnerBodyAnchor(const Vector2& anchor);

    void SetOtherBodyAnchor(const Vector2& anchor);

    void SetFrequencyHz(float frequencyHz);

    void SetDampingRatio(float dampingRatio);

    void SetLength(float length);


    const Vector2& GetOwnerBodyAnchor() const { return ownerBodyAnchor_; }


    const Vector2& GetOtherBodyAnchor() const { return otherBodyAnchor_; }


    float GetFrequencyHz() const { return jointDef_.frequencyHz; }


    float GetDampingRatio() const { return jointDef_.dampingRatio; }


    float GetLength() const { return jointDef_.length; }

private:

    b2JointDef* GetJointDef() override;

    b2DistanceJointDef jointDef_;

    Vector2 ownerBodyAnchor_;

    Vector2 otherBodyAnchor_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintFriction2D : public Constraint2D
{
    public: using ClassName = ConstraintFriction2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintFriction2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintFriction2D(Context* context);

    ~ConstraintFriction2D() override;

    static void RegisterObject(Context* context);


    void SetAnchor(const Vector2& anchor);

    void SetMaxForce(float maxForce);

    void SetMaxTorque(float maxTorque);


    const Vector2& GetAnchor() const { return anchor_; }


    float GetMaxForce() const { return jointDef_.maxForce; }


    float GetMaxTorque() const { return jointDef_.maxTorque; }

private:

    b2JointDef* GetJointDef() override;


    b2FrictionJointDef jointDef_;

    Vector2 anchor_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintGear2D : public Constraint2D
{
    public: using ClassName = ConstraintGear2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintGear2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintGear2D(Context* context);

    ~ConstraintGear2D() override;

    static void RegisterObject(Context* context);


    void SetOwnerConstraint(Constraint2D* constraint);

    void SetOtherConstraint(Constraint2D* constraint);

    void SetRatio(float ratio);


    Constraint2D* GetOwnerConstraint() const { return ownerConstraint_; }


    Constraint2D* GetOtherConstraint() const { return otherConstraint_; }


    float GetRatio() const { return jointDef_.ratio; }

private:

    b2JointDef* GetJointDef() override;


    b2GearJointDef jointDef_;

    WeakPtr<Constraint2D> ownerConstraint_;

    WeakPtr<Constraint2D> otherConstraint_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintMotor2D : public Constraint2D
{
    public: using ClassName = ConstraintMotor2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintMotor2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintMotor2D(Context* context);

    ~ConstraintMotor2D() override;

    static void RegisterObject(Context* context);


    void SetLinearOffset(const Vector2& linearOffset);

    void SetAngularOffset(float angularOffset);

    void SetMaxForce(float maxForce);

    void SetMaxTorque(float maxTorque);

    void SetCorrectionFactor(float correctionFactor);


    const Vector2& GetLinearOffset() const { return linearOffset_; }


    float GetAngularOffset() const { return jointDef_.angularOffset; }


    float GetMaxForce() const { return jointDef_.maxForce; }


    float GetMaxTorque() const { return jointDef_.maxTorque; }


    float GetCorrectionFactor() const { return jointDef_.correctionFactor; }

private:

    b2JointDef* GetJointDef() override;


    b2MotorJointDef jointDef_;

    Vector2 linearOffset_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintMouse2D : public Constraint2D
{
    public: using ClassName = ConstraintMouse2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintMouse2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintMouse2D(Context* context);

    ~ConstraintMouse2D() override;

    static void RegisterObject(Context* context);


    void SetTarget(const Vector2& target);

    void SetMaxForce(float maxForce);

    void SetFrequencyHz(float frequencyHz);

    void SetDampingRatio(float dampingRatio);


    const Vector2& GetTarget() const { return target_; }


    float GetMaxForce() const { return jointDef_.maxForce; }


    float GetFrequencyHz() const { return jointDef_.frequencyHz; }


    float GetDampingRatio() const { return jointDef_.dampingRatio; }

private:

    b2JointDef* GetJointDef() override;


    b2MouseJointDef jointDef_;

    Vector2 target_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintPrismatic2D : public Constraint2D
{
    public: using ClassName = ConstraintPrismatic2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintPrismatic2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintPrismatic2D(Context* context);

    ~ConstraintPrismatic2D() override;

    static void RegisterObject(Context* context);


    void SetAnchor(const Vector2& anchor);

    void SetAxis(const Vector2& axis);

    void SetEnableLimit(bool enableLimit);

    void SetLowerTranslation(float lowerTranslation);

    void SetUpperTranslation(float upperTranslation);

    void SetEnableMotor(bool enableMotor);

    void SetMaxMotorForce(float maxMotorForce);

    void SetMotorSpeed(float motorSpeed);


    const Vector2& GetAnchor() const { return anchor_; }


    const Vector2& GetAxis() const { return axis_; }


    bool GetEnableLimit() const { return jointDef_.enableLimit; }


    float GetLowerTranslation() const { return jointDef_.lowerTranslation; }


    float GetUpperTranslation() const { return jointDef_.upperTranslation; }


    bool GetEnableMotor() const { return jointDef_.enableMotor; }


    float GetMaxMotorForce() const { return jointDef_.maxMotorForce; }


    float GetMotorSpeed() const { return jointDef_.motorSpeed; }

private:

    b2JointDef* GetJointDef() override;


    b2PrismaticJointDef jointDef_;

    Vector2 anchor_;

    Vector2 axis_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintPulley2D : public Constraint2D
{
    public: using ClassName = ConstraintPulley2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintPulley2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintPulley2D(Context* context);

    ~ConstraintPulley2D() override;

    static void RegisterObject(Context* context);


    void SetOwnerBodyGroundAnchor(const Vector2& groundAnchor);

    void SetOtherBodyGroundAnchor(const Vector2& groundAnchor);

    void SetOwnerBodyAnchor(const Vector2& anchor);

    void SetOtherBodyAnchor(const Vector2& anchor);

    void SetRatio(float ratio);


    const Vector2& GetOwnerBodyGroundAnchor() const { return ownerBodyGroundAnchor_; }


    const Vector2& GetOtherBodyGroundAnchor() const { return otherBodyGroundAnchor_; }


    const Vector2& GetOwnerBodyAnchor() const { return ownerBodyAnchor_; }


    const Vector2& GetOtherBodyAnchor() const { return otherBodyAnchor_; }


    float GetRatio() const { return jointDef_.ratio; }


private:

    b2JointDef* GetJointDef() override;


    b2PulleyJointDef jointDef_;

    Vector2 ownerBodyGroundAnchor_;

    Vector2 otherBodyGroundAnchor_;

    Vector2 ownerBodyAnchor_;

    Vector2 otherBodyAnchor_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintRevolute2D : public Constraint2D
{
    public: using ClassName = ConstraintRevolute2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintRevolute2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintRevolute2D(Context* context);

    ~ConstraintRevolute2D() override;

    static void RegisterObject(Context* context);


    void SetAnchor(const Vector2& anchor);

    void SetEnableLimit(bool enableLimit);

    void SetLowerAngle(float lowerAngle);

    void SetUpperAngle(float upperAngle);

    void SetEnableMotor(bool enableMotor);

    void SetMotorSpeed(float motorSpeed);

    void SetMaxMotorTorque(float maxMotorTorque);


    const Vector2& GetAnchor() const { return anchor_; }


    bool GetEnableLimit() const { return jointDef_.enableLimit; }


    float GetLowerAngle() const { return jointDef_.lowerAngle; }


    float GetUpperAngle() const { return jointDef_.upperAngle; }


    bool GetEnableMotor() const { return jointDef_.enableMotor; }


    float GetMotorSpeed() const { return jointDef_.motorSpeed; }


    float GetMaxMotorTorque() const { return jointDef_.maxMotorTorque; }

private:

    b2JointDef* GetJointDef() override;


    b2RevoluteJointDef jointDef_;

    Vector2 anchor_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintRope2D : public Constraint2D
{
    public: using ClassName = ConstraintRope2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintRope2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintRope2D(Context* context);

    ~ConstraintRope2D() override;

    static void RegisterObject(Context* context);


    void SetOwnerBodyAnchor(const Vector2& anchor);

    void SetOtherBodyAnchor(const Vector2& anchor);

    void SetMaxLength(float maxLength);


    const Vector2& GetOwnerBodyAnchor() const { return ownerBodyAnchor_; }


    const Vector2& GetOtherBodyAnchor() const { return otherBodyAnchor_; }


    float GetMaxLength() const { return jointDef_.maxLength; }

private:

    b2JointDef* GetJointDef() override;


    b2RopeJointDef jointDef_;

    Vector2 ownerBodyAnchor_;

    Vector2 otherBodyAnchor_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintWeld2D : public Constraint2D
{
    public: using ClassName = ConstraintWeld2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintWeld2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintWeld2D(Context* context);

    ~ConstraintWeld2D() override;

    static void RegisterObject(Context* context);


    void SetAnchor(const Vector2& anchor);

    void SetFrequencyHz(float frequencyHz);

    void SetDampingRatio(float dampingRatio);


    const Vector2& GetAnchor() const { return anchor_; }


    float GetFrequencyHz() const { return jointDef_.frequencyHz; }


    float GetDampingRatio() const { return jointDef_.dampingRatio; }

private:

    b2JointDef* GetJointDef() override;


    b2WeldJointDef jointDef_;

    Vector2 anchor_;
};

}
namespace Urho3D
{


class __attribute__((visibility("default"))) ConstraintWheel2D : public Constraint2D
{
    public: using ClassName = ConstraintWheel2D; using BaseClassName = Constraint2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ConstraintWheel2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ConstraintWheel2D(Context* context);

    ~ConstraintWheel2D() override;

    static void RegisterObject(Context* context);


    void SetAnchor(const Vector2& anchor);

    void SetAxis(const Vector2& axis);

    void SetEnableMotor(bool enableMotor);

    void SetMaxMotorTorque(float maxMotorTorque);

    void SetMotorSpeed(float motorSpeed);

    void SetFrequencyHz(float frequencyHz);

    void SetDampingRatio(float dampingRatio);


    const Vector2& GetAnchor() const { return anchor_; }


    const Vector2& GetAxis() const { return axis_; }


    bool GetEnableMotor() const { return jointDef_.enableMotor; }


    float GetMaxMotorTorque() const { return jointDef_.maxMotorTorque; }


    float GetMotorSpeed() const { return jointDef_.motorSpeed; }


    float GetFrequencyHz() const { return jointDef_.frequencyHz; }


    float GetDampingRatio() const { return jointDef_.dampingRatio; }

private:

    b2JointDef* GetJointDef() override;


    b2WheelJointDef jointDef_;

    Vector2 anchor_;

    Vector2 axis_;
};

}

namespace Urho3D
{

class XMLElement;
class Sprite2D;


enum EmitterType2D
{
    EMITTER_TYPE_GRAVITY = 0,
    EMITTER_TYPE_RADIAL
};


class __attribute__((visibility("default"))) ParticleEffect2D : public Resource
{
    public: using ClassName = ParticleEffect2D; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ParticleEffect2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ParticleEffect2D(Context* context);

    ~ParticleEffect2D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;

    bool Save(Serializer& dest) const override;


    void SetSprite(Sprite2D* sprite);

    void SetSourcePositionVariance(const Vector2& sourcePositionVariance);

    void SetSpeed(float speed);

    void SetSpeedVariance(float speedVariance);

    void SetParticleLifeSpan(float particleLifeSpan);

    void SetParticleLifespanVariance(float particleLifespanVariance);

    void SetAngle(float angle);

    void SetAngleVariance(float angleVariance);

    void SetGravity(const Vector2& gravity);

    void SetRadialAcceleration(float radialAcceleration);

    void SetTangentialAcceleration(float tangentialAcceleration);

    void SetRadialAccelVariance(float radialAccelVariance);

    void SetTangentialAccelVariance(float tangentialAccelVariance);

    void SetStartColor(const Color& startColor);

    void SetStartColorVariance(const Color& startColorVariance);

    void SetFinishColor(const Color& finishColor);

    void SetFinishColorVariance(const Color& finishColorVariance);

    void SetMaxParticles(int maxParticles);

    void SetStartParticleSize(float startParticleSize);

    void SetStartParticleSizeVariance(float startParticleSizeVariance);

    void SetFinishParticleSize(float finishParticleSize);

    void SetFinishParticleSizeVariance(float finishParticleSizeVariance);

    void SetDuration(float duration);

    void SetEmitterType(EmitterType2D emitterType);

    void SetMaxRadius(float maxRadius);

    void SetMaxRadiusVariance(float maxRadiusVariance);

    void SetMinRadius(float minRadius);

    void SetMinRadiusVariance(float minRadiusVariance);

    void SetRotatePerSecond(float rotatePerSecond);

    void SetRotatePerSecondVariance(float rotatePerSecondVariance);

    void SetBlendMode(BlendMode blendMode);

    void SetRotationStart(float rotationStart);

    void SetRotationStartVariance(float rotationStartVariance);

    void SetRotationEnd(float rotationEnd);

    void SetRotationEndVariance(float rotationEndVariance);

    SharedPtr<ParticleEffect2D> Clone(const String& cloneName = String::EMPTY) const;


    Sprite2D* GetSprite() const { return sprite_; }


    const Vector2& GetSourcePositionVariance() const { return sourcePositionVariance_; }


    float GetSpeed() const { return speed_; }


    float GetSpeedVariance() const { return speedVariance_; }


    float GetParticleLifeSpan() const { return particleLifeSpan_; }


    float GetParticleLifespanVariance() const { return particleLifespanVariance_; }


    float GetAngle() const { return angle_; }


    float GetAngleVariance() const { return angleVariance_; }


    const Vector2& GetGravity() const { return gravity_; }


    float GetRadialAcceleration() const { return radialAcceleration_; }


    float GetTangentialAcceleration() const { return tangentialAcceleration_; }


    float GetRadialAccelVariance() const { return radialAccelVariance_; }


    float GetTangentialAccelVariance() const { return tangentialAccelVariance_; }


    const Color& GetStartColor() const { return startColor_; }


    const Color& GetStartColorVariance() const { return startColorVariance_; }


    const Color& GetFinishColor() const { return finishColor_; }


    const Color& GetFinishColorVariance() const { return finishColorVariance_; }


    int GetMaxParticles() const { return maxParticles_; }


    float GetStartParticleSize() const { return startParticleSize_; }


    float GetStartParticleSizeVariance() const { return startParticleSizeVariance_; }


    float GetFinishParticleSize() const { return finishParticleSize_; }


    float GetFinishParticleSizeVariance() const { return finishParticleSizeVariance_; }


    float GetDuration() const { return duration_; }


    EmitterType2D GetEmitterType() const { return emitterType_; }


    float GetMaxRadius() const { return maxRadius_; }


    float GetMaxRadiusVariance() const { return maxRadiusVariance_; }


    float GetMinRadius() const { return minRadius_; }


    float GetMinRadiusVariance() const { return minRadiusVariance_; }


    float GetRotatePerSecond() const { return rotatePerSecond_; }


    float GetRotatePerSecondVariance() const { return rotatePerSecondVariance_; }


    BlendMode GetBlendMode() const { return blendMode_; }


    float GetRotationStart() const { return rotationStart_; }


    float GetRotationStartVariance() const { return rotationStartVariance_; }


    float GetRotationEnd() const { return rotationEnd_; }


    float GetRotationEndVariance() const { return rotationEndVariance_; }

private:

    int ReadInt(const XMLElement& element, const String& name) const;

    float ReadFloat(const XMLElement& element, const String& name) const;

    Color ReadColor(const XMLElement& element, const String& name) const;

    Vector2 ReadVector2(const XMLElement& element, const String& name) const;

    void WriteInt(XMLElement& element, const String& name, int value) const;

    void WriteFloat(XMLElement& element, const String& name, float value) const;

    void WriteColor(XMLElement& element, const String& name, const Color& color) const;

    void WriteVector2(XMLElement& element, const String& name, const Vector2& value) const;


    SharedPtr<Sprite2D> sprite_;

    Vector2 sourcePositionVariance_;

    float speed_;

    float speedVariance_;

    float particleLifeSpan_;

    float particleLifespanVariance_;

    float angle_;

    float angleVariance_;

    Vector2 gravity_;

    float radialAcceleration_;

    float tangentialAcceleration_;

    float radialAccelVariance_;

    float tangentialAccelVariance_;

    Color startColor_;

    Color startColorVariance_;

    Color finishColor_;

    Color finishColorVariance_;

    int maxParticles_;

    float startParticleSize_;

    float startParticleSizeVariance_;

    float finishParticleSize_;

    float finishParticleSizeVariance_;

    float duration_;

    EmitterType2D emitterType_;

    float maxRadius_;

    float maxRadiusVariance_;

    float minRadius_;

    float minRadiusVariance_;

    float rotatePerSecond_;

    float rotatePerSecondVariance_;

    BlendMode blendMode_;

    float rotationStart_;

    float rotationStartVariance_;

    float rotationEnd_;

    float rotationEndVariance_;

    String loadSpriteName_;
};

}
namespace Urho3D
{

class ParticleEffect2D;
class Sprite2D;


struct Particle2D
{

    float timeToLive_;


    Vector3 position_;

    float size_;

    float sizeDelta_;

    float rotation_;

    float rotationDelta_;

    Color color_;

    Color colorDelta_;



    Vector2 startPos_;

    Vector2 velocity_;

    float radialAcceleration_;

    float tangentialAcceleration_;



    float emitRadius_;

    float emitRadiusDelta_;

    float emitRotation_;

    float emitRotationDelta_;
};


class __attribute__((visibility("default"))) ParticleEmitter2D : public Drawable2D
{
    public: using ClassName = ParticleEmitter2D; using BaseClassName = Drawable2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("ParticleEmitter2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit ParticleEmitter2D(Context* context);

    ~ParticleEmitter2D() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    void SetEffect(ParticleEffect2D* effect);

    void SetSprite(Sprite2D* sprite);

    void SetBlendMode(BlendMode blendMode);

    void SetMaxParticles(unsigned maxParticles);

    void SetEmitting(bool enable);


    ParticleEffect2D* GetEffect() const;

    Sprite2D* GetSprite() const;


    BlendMode GetBlendMode() const { return blendMode_; }


    unsigned GetMaxParticles() const { return particles_.Size(); }


    void SetParticleEffectAttr(const ResourceRef& value);

    ResourceRef GetParticleEffectAttr() const;

    void SetSpriteAttr(const ResourceRef& value);

    ResourceRef GetSpriteAttr() const;

    bool IsEmitting() const { return emitting_; }

private:

    void OnSceneSet(Scene* scene) override;

    void OnWorldBoundingBoxUpdate() override;

    void OnDrawOrderChanged() override;

    void UpdateSourceBatches() override;

    void UpdateMaterial();

    void HandleScenePostUpdate(StringHash eventType, VariantMap& eventData);

    void Update(float timeStep);

    bool EmitParticle(const Vector3& worldPosition, float worldAngle, float worldScale);

    void UpdateParticle(Particle2D& particle, float timeStep, const Vector3& worldPosition, float worldScale);


    SharedPtr<ParticleEffect2D> effect_;

    SharedPtr<Sprite2D> sprite_;

    BlendMode blendMode_;

    unsigned numParticles_;

    float emissionTime_;

    float emitParticleTime_;

    bool emitting_;

    Vector<Particle2D> particles_;

    Vector3 boundingBoxMinPoint_;

    Vector3 boundingBoxMaxPoint_;
};

}
namespace Urho3D
{


static const Urho3D::StringHash E_PHYSICSUPDATECONTACT2D(Urho3D::GetEventNameRegister().RegisterString("PhysicsUpdateContact2D")); namespace PhysicsUpdateContact2D
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_BODYA("BodyA");
    static const Urho3D::StringHash P_BODYB("BodyB");
    static const Urho3D::StringHash P_NODEA("NodeA");
    static const Urho3D::StringHash P_NODEB("NodeB");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
    static const Urho3D::StringHash P_SHAPEA("ShapeA");
    static const Urho3D::StringHash P_SHAPEB("ShapeB");
    static const Urho3D::StringHash P_ENABLED("Enabled");
}


static const Urho3D::StringHash E_PHYSICSBEGINCONTACT2D(Urho3D::GetEventNameRegister().RegisterString("PhysicsBeginContact2D")); namespace PhysicsBeginContact2D
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_BODYA("BodyA");
    static const Urho3D::StringHash P_BODYB("BodyB");
    static const Urho3D::StringHash P_NODEA("NodeA");
    static const Urho3D::StringHash P_NODEB("NodeB");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
    static const Urho3D::StringHash P_SHAPEA("ShapeA");
    static const Urho3D::StringHash P_SHAPEB("ShapeB");
}


static const Urho3D::StringHash E_PHYSICSENDCONTACT2D(Urho3D::GetEventNameRegister().RegisterString("PhysicsEndContact2D")); namespace PhysicsEndContact2D
{
    static const Urho3D::StringHash P_WORLD("World");
    static const Urho3D::StringHash P_BODYA("BodyA");
    static const Urho3D::StringHash P_BODYB("BodyB");
    static const Urho3D::StringHash P_NODEA("NodeA");
    static const Urho3D::StringHash P_NODEB("NodeB");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
    static const Urho3D::StringHash P_SHAPEA("ShapeA");
    static const Urho3D::StringHash P_SHAPEB("ShapeB");
}


static const Urho3D::StringHash E_NODEUPDATECONTACT2D(Urho3D::GetEventNameRegister().RegisterString("NodeUpdateContact2D")); namespace NodeUpdateContact2D
{
    static const Urho3D::StringHash P_BODY("Body");
    static const Urho3D::StringHash P_OTHERNODE("OtherNode");
    static const Urho3D::StringHash P_OTHERBODY("OtherBody");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
    static const Urho3D::StringHash P_SHAPE("Shape");
    static const Urho3D::StringHash P_OTHERSHAPE("OtherShape");
    static const Urho3D::StringHash P_ENABLED("Enabled");
}


static const Urho3D::StringHash E_NODEBEGINCONTACT2D(Urho3D::GetEventNameRegister().RegisterString("NodeBeginContact2D")); namespace NodeBeginContact2D
{
    static const Urho3D::StringHash P_BODY("Body");
    static const Urho3D::StringHash P_OTHERNODE("OtherNode");
    static const Urho3D::StringHash P_OTHERBODY("OtherBody");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
    static const Urho3D::StringHash P_SHAPE("Shape");
    static const Urho3D::StringHash P_OTHERSHAPE("OtherShape");
}


static const Urho3D::StringHash E_NODEENDCONTACT2D(Urho3D::GetEventNameRegister().RegisterString("NodeEndContact2D")); namespace NodeEndContact2D
{
    static const Urho3D::StringHash P_BODY("Body");
    static const Urho3D::StringHash P_OTHERNODE("OtherNode");
    static const Urho3D::StringHash P_OTHERBODY("OtherBody");
    static const Urho3D::StringHash P_CONTACTS("Contacts");
    static const Urho3D::StringHash P_SHAPE("Shape");
    static const Urho3D::StringHash P_OTHERSHAPE("OtherShape");
}

}
namespace Urho3D
{

inline Color ToColor(const b2Color& color)
{
    return Color(color.r, color.g, color.b);
}

inline b2Vec2 ToB2Vec2(const Vector2& vector)
{
    return {vector.x_, vector.y_};
}

inline Vector2 ToVector2(const b2Vec2& vec2)
{
    return Vector2(vec2.x, vec2.y);
}

inline b2Vec2 ToB2Vec2(const Vector3& vector)
{
    return {vector.x_, vector.y_};
}

inline Vector3 ToVector3(const b2Vec2& vec2)
{
    return Vector3(vec2.x, vec2.y, 0.0f);
}

}
namespace Urho3D
{

class Camera;
class CollisionShape2D;
class RigidBody2D;


struct __attribute__((visibility("default"))) PhysicsRaycastResult2D
{

    bool operator !=(const PhysicsRaycastResult2D& rhs) const
    {
        return position_ != rhs.position_ || normal_ != rhs.normal_ || distance_ != rhs.distance_ || body_ != rhs.body_;
    }


    Vector2 position_;

    Vector2 normal_;

    float distance_{};

    RigidBody2D* body_{};
};


struct DelayedWorldTransform2D
{

    RigidBody2D* rigidBody_;

    RigidBody2D* parentRigidBody_;

    Vector3 worldPosition_;

    Quaternion worldRotation_;
};


class __attribute__((visibility("default"))) PhysicsWorld2D : public Component, public b2ContactListener, public b2Draw
{
    public: using ClassName = PhysicsWorld2D; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("PhysicsWorld2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit PhysicsWorld2D(Context* context);

    ~PhysicsWorld2D() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;



    void BeginContact(b2Contact* contact) override;

    void EndContact(b2Contact* contact) override;

    void PreSolve(b2Contact* contact, const b2Manifold* oldManifold) override;



    void DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) override;

    void DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) override;

    void DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) override;

    void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) override;

    void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) override;

    void DrawTransform(const b2Transform& xf) override;

    void DrawPoint(const b2Vec2& p, float32 size, const b2Color& color) override;


    void Update(float timeStep);

    void DrawDebugGeometry();

    void SetUpdateEnabled(bool enable);

    void SetDrawShape(bool drawShape);

    void SetDrawJoint(bool drawJoint);

    void SetDrawAabb(bool drawAabb);

    void SetDrawPair(bool drawPair);

    void SetDrawCenterOfMass(bool drawCenterOfMass);

    void SetAllowSleeping(bool enable);

    void SetWarmStarting(bool enable);

    void SetContinuousPhysics(bool enable);

    void SetSubStepping(bool enable);

    void SetGravity(const Vector2& gravity);

    void SetAutoClearForces(bool enable);

    void SetVelocityIterations(int velocityIterations);

    void SetPositionIterations(int positionIterations);

    void AddRigidBody(RigidBody2D* rigidBody);

    void RemoveRigidBody(RigidBody2D* rigidBody);

    void AddDelayedWorldTransform(const DelayedWorldTransform2D& transform);


    void Raycast(PODVector<PhysicsRaycastResult2D>& results, const Vector2& startPoint, const Vector2& endPoint,
        unsigned collisionMask = M_MAX_UNSIGNED);

    void RaycastSingle(PhysicsRaycastResult2D& result, const Vector2& startPoint, const Vector2& endPoint,
        unsigned collisionMask = M_MAX_UNSIGNED);

    RigidBody2D* GetRigidBody(const Vector2& point, unsigned collisionMask = M_MAX_UNSIGNED);

    RigidBody2D* GetRigidBody(int screenX, int screenY, unsigned collisionMask = M_MAX_UNSIGNED);

    void GetRigidBodies(PODVector<RigidBody2D*>& results, const Rect& aabb, unsigned collisionMask = M_MAX_UNSIGNED);


    bool IsUpdateEnabled() const { return updateEnabled_; }


    bool GetDrawShape() const { return (m_drawFlags & e_shapeBit) != 0; }


    bool GetDrawJoint() const { return (m_drawFlags & e_jointBit) != 0; }


    bool GetDrawAabb() const { return (m_drawFlags & e_aabbBit) != 0; }


    bool GetDrawPair() const { return (m_drawFlags & e_pairBit) != 0; }


    bool GetDrawCenterOfMass() const { return (m_drawFlags & e_centerOfMassBit) != 0; }


    bool GetAllowSleeping() const;

    bool GetWarmStarting() const;

    bool GetContinuousPhysics() const;

    bool GetSubStepping() const;

    bool GetAutoClearForces() const;


    const Vector2& GetGravity() const { return gravity_; }


    int GetVelocityIterations() const { return velocityIterations_; }


    int GetPositionIterations() const { return positionIterations_; }


    b2World* GetWorld() { return world_.Get(); }


    void SetApplyingTransforms(bool enable) { applyingTransforms_ = enable; }


    bool IsApplyingTransforms() const { return applyingTransforms_; }

protected:

    void OnSceneSet(Scene* scene) override;


    void HandleSceneSubsystemUpdate(StringHash eventType, VariantMap& eventData);

    void SendBeginContactEvents();

    void SendEndContactEvents();


    UniquePtr<b2World> world_;

    Vector2 gravity_;

    int velocityIterations_{};

    int positionIterations_{};


    WeakPtr<Scene> scene_;

    DebugRenderer* debugRenderer_{};

    bool debugDepthTest_{};


    bool updateEnabled_{true};

    bool physicsStepping_{};

    bool applyingTransforms_{};

    Vector<WeakPtr<RigidBody2D> > rigidBodies_;

    HashMap<RigidBody2D*, DelayedWorldTransform2D> delayedWorldTransforms_;


    struct ContactInfo
    {

        ContactInfo();

        explicit ContactInfo(b2Contact* contact);

        const PODVector<unsigned char>& Serialize(VectorBuffer& buffer) const;


        SharedPtr<RigidBody2D> bodyA_;

        SharedPtr<RigidBody2D> bodyB_;

        SharedPtr<Node> nodeA_;

        SharedPtr<Node> nodeB_;

        SharedPtr<CollisionShape2D> shapeA_;

        SharedPtr<CollisionShape2D> shapeB_;

        int numPoints_{};

        Vector2 worldNormal_;

        Vector2 worldPositions_[2];

        float separations_[2]{};
    };

    Vector<ContactInfo> beginContactInfos_;

    Vector<ContactInfo> endContactInfos_;

    VectorBuffer contacts_;
};

}
namespace Urho3D
{

class Drawable2D;
class IndexBuffer;
class Material;
class Technique;
class VertexBuffer;
struct FrameInfo;
struct SourceBatch2D;


struct ViewBatchInfo2D
{

    ViewBatchInfo2D();


    unsigned vertexBufferUpdateFrameNumber_;

    unsigned indexCount_;

    unsigned vertexCount_;

    SharedPtr<VertexBuffer> vertexBuffer_;

    unsigned batchUpdatedFrameNumber_;

    PODVector<const SourceBatch2D*> sourceBatches_;

    unsigned batchCount_;

    PODVector<float> distances_;

    Vector<SharedPtr<Material> > materials_;

    Vector<SharedPtr<Geometry> > geometries_;
};


class __attribute__((visibility("default"))) Renderer2D : public Drawable
{
    public: using ClassName = Renderer2D; using BaseClassName = Drawable; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Renderer2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

    friend void CheckDrawableVisibilityWork(const WorkItem* item, unsigned threadIndex);

public:

    explicit Renderer2D(Context* context);

    ~Renderer2D() override;

    static void RegisterObject(Context* context);


    void ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results) override;

    void UpdateBatches(const FrameInfo& frame) override;

    void UpdateGeometry(const FrameInfo& frame) override;

    UpdateGeometryType GetUpdateGeometryType() override;


    void AddDrawable(Drawable2D* drawable);

    void RemoveDrawable(Drawable2D* drawable);

    Material* GetMaterial(Texture2D* texture, BlendMode blendMode);


    bool CheckVisibility(Drawable2D* drawable) const;

private:

    void OnWorldBoundingBoxUpdate() override;

    SharedPtr<Material> CreateMaterial(Texture2D* texture, BlendMode blendMode);

    void HandleBeginViewUpdate(StringHash eventType, VariantMap& eventData);

    void GetDrawables(PODVector<Drawable2D*>& drawables, Node* node);

    void UpdateViewBatchInfo(ViewBatchInfo2D& viewBatchInfo, Camera* camera);

    void AddViewBatch(ViewBatchInfo2D& viewBatchInfo, Material* material,
        unsigned indexStart, unsigned indexCount, unsigned vertexStart, unsigned vertexCount, float distance);


    SharedPtr<IndexBuffer> indexBuffer_;

    SharedPtr<Material> material_;

    PODVector<Drawable2D*> drawables_;

    FrameInfo frame_;

    HashMap<Camera*, ViewBatchInfo2D> viewBatchInfos_;

    Frustum frustum_;

    unsigned viewMask_;

    HashMap<Texture2D*, HashMap<int, SharedPtr<Material> > > cachedMaterials_;

    HashMap<int, SharedPtr<Technique> > cachedTechniques_;
};

}
namespace Urho3D
{

class CollisionShape2D;
class Constraint2D;
class PhysicsWorld2D;


enum BodyType2D
{
    BT_STATIC = b2_staticBody,
    BT_KINEMATIC = b2_kinematicBody,
    BT_DYNAMIC = b2_dynamicBody
};


class __attribute__((visibility("default"))) RigidBody2D : public Component
{
    public: using ClassName = RigidBody2D; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("RigidBody2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit RigidBody2D(Context* context);

    ~RigidBody2D() override;

    static void RegisterObject(Context* context);


    void OnSetEnabled() override;


    void SetBodyType(BodyType2D type);

    void SetMass(float mass);

    void SetInertia(float inertia);

    void SetMassCenter(const Vector2& center);

    void SetUseFixtureMass(bool useFixtureMass);

    void SetLinearDamping(float linearDamping);

    void SetAngularDamping(float angularDamping);

    void SetAllowSleep(bool allowSleep);

    void SetFixedRotation(bool fixedRotation);

    void SetBullet(bool bullet);

    void SetGravityScale(float gravityScale);

    void SetAwake(bool awake);

    void SetLinearVelocity(const Vector2& linearVelocity);

    void SetAngularVelocity(float angularVelocity);

    void ApplyForce(const Vector2& force, const Vector2& point, bool wake);

    void ApplyForceToCenter(const Vector2& force, bool wake);

    void ApplyTorque(float torque, bool wake);

    void ApplyLinearImpulse(const Vector2& impulse, const Vector2& point, bool wake);

    void ApplyLinearImpulseToCenter(const Vector2& impulse, bool wake);

    void ApplyAngularImpulse(float impulse, bool wake);


    void CreateBody();

    void ReleaseBody();


    void ApplyWorldTransform();

    void ApplyWorldTransform(const Vector3& newWorldPosition, const Quaternion& newWorldRotation);

    void AddCollisionShape2D(CollisionShape2D* collisionShape);

    void RemoveCollisionShape2D(CollisionShape2D* collisionShape);

    void AddConstraint2D(Constraint2D* constraint);

    void RemoveConstraint2D(Constraint2D* constraint);


    BodyType2D GetBodyType() const { return body_ ? (BodyType2D)body_->GetType() : (BodyType2D)bodyDef_.type; }


    float GetMass() const;

    float GetInertia() const;

    Vector2 GetMassCenter() const;


    bool GetUseFixtureMass() const { return useFixtureMass_; }


    float GetLinearDamping() const { return body_ ? body_->GetLinearDamping() : bodyDef_.linearDamping; }


    float GetAngularDamping() const { return body_ ? body_->GetAngularDamping() : bodyDef_.angularDamping; }


    bool IsAllowSleep() const { return body_ ? body_->IsSleepingAllowed() : bodyDef_.allowSleep; }


    bool IsFixedRotation() const { return body_ ? body_->IsFixedRotation() : bodyDef_.fixedRotation; }


    bool IsBullet() const { return body_ ? body_->IsBullet() : bodyDef_.bullet; }


    float GetGravityScale() const { return body_ ? body_->GetGravityScale() : bodyDef_.gravityScale; }


    bool IsAwake() const;

    Vector2 GetLinearVelocity() const;

    float GetAngularVelocity() const;


    b2Body* GetBody() const { return body_; }

private:

    void OnNodeSet(Node* node) override;

    void OnSceneSet(Scene* scene) override;

    void OnMarkedDirty(Node* node) override;


    WeakPtr<PhysicsWorld2D> physicsWorld_;

    b2BodyDef bodyDef_;

    b2MassData massData_;

    bool useFixtureMass_;

    b2Body* body_;

    Vector<WeakPtr<CollisionShape2D> > collisionShapes_;

    Vector<WeakPtr<Constraint2D> > constraints_;
};

}
namespace Urho3D
{

class SpriteSheet2D;
class Texture2D;


class __attribute__((visibility("default"))) Sprite2D : public Resource
{
    public: using ClassName = Sprite2D; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("Sprite2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit Sprite2D(Context* context);

    ~Sprite2D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;


    void SetTexture(Texture2D* texture);

    void SetRectangle(const IntRect& rectangle);

    void SetHotSpot(const Vector2& hotSpot);

    void SetOffset(const IntVector2& offset);

    void SetTextureEdgeOffset(float offset);

    void SetSpriteSheet(SpriteSheet2D* spriteSheet);


    Texture2D* GetTexture() const { return texture_; }


    const IntRect& GetRectangle() const { return rectangle_; }


    const Vector2& GetHotSpot() const { return hotSpot_; }


    const IntVector2& GetOffset() const { return offset_; }


    float GetTextureEdgeOffset() const { return edgeOffset_; }


    SpriteSheet2D* GetSpriteSheet() const { return spriteSheet_; }



    bool GetDrawRectangle(Rect& rect, bool flipX = false, bool flipY = false) const;

    bool GetDrawRectangle(Rect& rect, const Vector2& hotSpot, bool flipX = false, bool flipY = false) const;

    bool GetTextureRectangle(Rect& rect, bool flipX = false, bool flipY = false) const;


    static ResourceRef SaveToResourceRef(Sprite2D* sprite);

    static Sprite2D* LoadFromResourceRef(Object* object, const ResourceRef& value, const String& basePath);

private:

    SharedPtr<Texture2D> texture_;

    IntRect rectangle_;

    Vector2 hotSpot_;

    IntVector2 offset_;

    WeakPtr<SpriteSheet2D> spriteSheet_;

    SharedPtr<Texture2D> loadTexture_;

    float edgeOffset_;
};

}
namespace Urho3D
{

class PListFile;
class Sprite2D;
class Texture2D;
class XMLFile;
class JSONFile;


class __attribute__((visibility("default"))) SpriteSheet2D : public Resource
{
    public: using ClassName = SpriteSheet2D; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("SpriteSheet2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit SpriteSheet2D(Context* context);

    ~SpriteSheet2D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;


    void SetTexture(Texture2D* texture);

    void DefineSprite(const String& name, const IntRect& rectangle, const Vector2& hotSpot = Vector2(0.5f, 0.5f),
        const IntVector2& offset = IntVector2::ZERO);


    Texture2D* GetTexture() const { return texture_; }

    Sprite2D* GetSprite(const String& name) const;


    const HashMap<String, SharedPtr<Sprite2D> >& GetSpriteMapping() const { return spriteMapping_; }

private:

    bool BeginLoadFromPListFile(Deserializer& source);

    bool EndLoadFromPListFile();


    bool BeginLoadFromXMLFile(Deserializer& source);

    bool EndLoadFromXMLFile();

    bool BeginLoadFromJSONFile(Deserializer& source);

    bool EndLoadFromJSONFile();


    SharedPtr<Texture2D> texture_;

    HashMap<String, SharedPtr<Sprite2D> > spriteMapping_;

    SharedPtr<PListFile> loadPListFile_;

    SharedPtr<XMLFile> loadXMLFile_;

    SharedPtr<JSONFile> loadJSONFile_;

    String loadTextureName_;
};

}
namespace pugi
{
class xml_node;
}

namespace Urho3D
{

namespace Spriter
{

struct Animation;
struct BoneTimelineKey;
struct CharacterMap;
struct Entity;
struct File;
struct Folder;
struct MainlineKey;
struct MapInstruction;
struct Ref;
struct SpatialInfo;
struct SpatialTimelineKey;
struct SpriterData;
struct SpriteTimelineKey;
struct Timeline;
struct TimelineKey;


struct SpriterData
{
    SpriterData() = default;
    ~SpriterData();

    void Reset();
    bool Load(const pugi::xml_node& node);
    bool Load(const void* data, size_t size);

    int scmlVersion_{};
    String generator_;
    String generatorVersion_;
    PODVector<Folder*> folders_;
    PODVector<Entity*> entities_;
};


struct Folder
{
    Folder() = default;
    ~Folder();

    void Reset();
    bool Load(const pugi::xml_node& node);

    int id_{};
    String name_;
    PODVector<File*> files_;
};


struct File
{
    explicit File(Folder* folder);
    ~File() = default;

    bool Load(const pugi::xml_node& node);

    Folder* folder_{};
    int id_{};
    String name_;
    float width_{};
    float height_{};
    float pivotX_{};
    float pivotY_{};
};


struct Entity
{
    Entity() = default;
    ~Entity();

    void Reset();
    bool Load(const pugi::xml_node& node);

    int id_{};
    String name_;
    PODVector<CharacterMap*> characterMaps_;
    PODVector<Animation*> animations_;
};


struct CharacterMap
{
    CharacterMap() = default;
    ~CharacterMap();

    void Reset();
    bool Load(const pugi::xml_node& node);

    int id_{};
    String name_;
    PODVector<MapInstruction*> maps_;
};


struct MapInstruction
{
    MapInstruction() = default;
    ~MapInstruction() = default;

    bool Load(const pugi::xml_node& node);

    int folder_{};
    int file_{};
    int targetFolder_{};
    int targetFile_{};
};


struct Animation
{
    Animation() = default;
    ~Animation();

    void Reset();
    bool Load(const pugi::xml_node& node);

    int id_{};
    String name_;
    float length_{};
    bool looping_{};
    PODVector<MainlineKey*> mainlineKeys_;
    PODVector<Timeline*> timelines_;
};


struct MainlineKey
{
    MainlineKey() = default;
    ~MainlineKey();

    void Reset();
    bool Load(const pugi::xml_node& node);

    int id_{};
    float time_{};
    PODVector<Ref*> boneRefs_;
    PODVector<Ref*> objectRefs_;
};


struct Ref
{
    Ref() = default;
    ~Ref() = default;

    bool Load(const pugi::xml_node& node);

    int id_{};
    int parent_{};
    int timeline_{};
    int key_{};
    int zIndex_{};
};


enum ObjectType
{
    BONE = 0,
    SPRITE
};


struct Timeline
{
    Timeline() = default;
    ~Timeline();

    void Reset();
    bool Load(const pugi::xml_node& node);

    int id_{};
    String name_;
    ObjectType objectType_;
    PODVector<SpatialTimelineKey*> keys_;
};


enum CurveType
{
    INSTANT = 0,
    LINEAR,
    QUADRATIC,
    CUBIC
};


struct TimelineKey
{
    explicit TimelineKey(Timeline* timeline);
    virtual ~TimelineKey() = default;

    virtual ObjectType GetObjectType() const = 0;
    virtual TimelineKey* Clone() const = 0;
    virtual bool Load(const pugi::xml_node& node);
    virtual void Interpolate(const TimelineKey& other, float t) = 0;
    TimelineKey& operator=(const TimelineKey& rhs);
    float GetTByCurveType(float currentTime, float nextTimelineTime) const;

    Timeline* timeline_{};
    int id_{};
    float time_{};
    CurveType curveType_{};
    float c1_{};
    float c2_{};
};


struct SpatialInfo
{
    SpatialInfo(float x, float y, float angle, float scale_x, float scale_y, float alpha = 1, int spin = 1);

    SpatialInfo UnmapFromParent(const SpatialInfo& parentInfo) const;
    void Interpolate(const SpatialInfo& other, float t);

    float x_;
    float y_;
    float angle_;
    float scaleX_;
    float scaleY_;
    float alpha_;
    int spin_;
};


struct SpatialTimelineKey : TimelineKey
{
    explicit SpatialTimelineKey(Timeline* timeline);
    ~SpatialTimelineKey() override = default;

    bool Load(const pugi::xml_node& node) override;
    void Interpolate(const TimelineKey& other, float t) override;
    SpatialTimelineKey& operator=(const SpatialTimelineKey& rhs) = default;

    SpatialInfo info_;
};


struct BoneTimelineKey : SpatialTimelineKey
{
    explicit BoneTimelineKey(Timeline* timeline);
    ~BoneTimelineKey() override = default;

    ObjectType GetObjectType() const override { return BONE; }

    TimelineKey* Clone() const override;
    bool Load(const pugi::xml_node& node) override;
    void Interpolate(const TimelineKey& other, float t) override;
    BoneTimelineKey& operator=(const BoneTimelineKey& rhs) = default;

    float length_{};
    float width_{};
};


struct SpriteTimelineKey : SpatialTimelineKey
{
    explicit SpriteTimelineKey(Timeline* timeline);
    ~SpriteTimelineKey() override = default;

    ObjectType GetObjectType() const override { return SPRITE; }

    TimelineKey* Clone() const override;
    bool Load(const pugi::xml_node& node) override;
    void Interpolate(const TimelineKey& other, float t) override;
    SpriteTimelineKey& operator=(const SpriteTimelineKey& rhs);

    int folderId_{};
    int fileId_{};
    bool useDefaultPivot_{};
    float pivotX_{};
    float pivotY_{};


    int zIndex_{};
};

}

}
namespace Urho3D
{

class Component;

namespace Spriter
{


enum LoopMode
{
    Default = 0,
    ForceLooped,
    ForceClamped,
};


class SpriterInstance
{
public:

    SpriterInstance(Component* owner, SpriterData* spriteData);

    ~SpriterInstance();


    bool SetEntity(int index);

    bool SetEntity(const String& entityName);

    bool SetAnimation(int index, LoopMode loopMode = Default);

    bool SetAnimation(const String& animationName, LoopMode loopMode = Default);

    void setSpatialInfo(const SpatialInfo& spatialInfo);

    void setSpatialInfo(float x, float y, float angle, float scaleX, float scaleY);

    void Update(float deltaTime);


    Entity* GetEntity() const { return entity_; }

    Animation* GetAnimation() const { return animation_; }

    const SpatialInfo& GetSpatialInfo() const { return spatialInfo_; }

    const PODVector<SpatialTimelineKey*>& GetTimelineKeys() const { return timelineKeys_; }

private:

    void OnSetEntity(Entity* entity);

    void OnSetAnimation(Animation* animation, LoopMode loopMode = Default);

    void UpdateMainlineKey();

    void UpdateTimelineKeys();

    TimelineKey* GetTimelineKey(Ref* ref) const;

    void Clear();


    Component* owner_{};

    SpriterData* spriterData_{};

    Entity* entity_{};

    Animation* animation_{};

    bool looping_{};

    SpatialInfo spatialInfo_;

    float currentTime_{};

    MainlineKey* mainlineKey_{};

    PODVector<SpatialTimelineKey*> timelineKeys_;
};

}

}

namespace Urho3D
{

class __attribute__((visibility("default"))) StretchableSprite2D : public StaticSprite2D
{
    public: using ClassName = StretchableSprite2D; using BaseClassName = StaticSprite2D; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("StretchableSprite2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit StretchableSprite2D(Context* context);

    static void RegisterObject(Context* context);


    void SetBorder(const IntRect& border);

    const IntRect& GetBorder() const { return border_; }

protected:

    void UpdateSourceBatches() override;


    IntRect border_;
};

}
namespace Urho3D
{

class XMLElement;


enum Orientation2D
{

    O_ORTHOGONAL = 0,

    O_ISOMETRIC,

    O_STAGGERED,

    O_HEXAGONAL
};


struct __attribute__((visibility("default"))) TileMapInfo2D
{

    Orientation2D orientation_;

    int width_;

    int height_;

    float tileWidth_;

    float tileHeight_;


    float GetMapWidth() const;

    float GetMapHeight() const;

    Vector2 ConvertPosition(const Vector2& position) const;

    Vector2 TileIndexToPosition(int x, int y) const;

    bool PositionToTileIndex(int& x, int& y, const Vector2& position) const;
};


enum TileMapLayerType2D
{

    LT_TILE_LAYER = 0,

    LT_OBJECT_GROUP,

    LT_IMAGE_LAYER,

    LT_INVALID = 0xffff
};


enum TileMapObjectType2D
{

    OT_RECTANGLE = 0,

    OT_ELLIPSE,

    OT_POLYGON,

    OT_POLYLINE,

    OT_TILE,

    OT_INVALID = 0xffff
};


class __attribute__((visibility("default"))) PropertySet2D : public RefCounted
{
public:
    PropertySet2D();
    ~PropertySet2D() override;


    void Load(const XMLElement& element);

    bool HasProperty(const String& name) const;

    const String& GetProperty(const String& name) const;

protected:

    HashMap<String, String> nameToValueMapping_;
};


static const unsigned FLIP_HORIZONTAL = 0x80000000u;
static const unsigned FLIP_VERTICAL = 0x40000000u;
static const unsigned FLIP_DIAGONAL = 0x20000000u;
static const unsigned FLIP_RESERVED = 0x10000000u;
static const unsigned FLIP_ALL = FLIP_HORIZONTAL | FLIP_VERTICAL | FLIP_DIAGONAL | FLIP_RESERVED;


class __attribute__((visibility("default"))) Tile2D : public RefCounted
{
public:

    Tile2D();


    unsigned GetGid() const { return gid_ & ~FLIP_ALL; }

    bool GetFlipX() const { return gid_ & FLIP_HORIZONTAL; }

    bool GetFlipY() const { return gid_ & FLIP_VERTICAL; }

    bool GetSwapXY() const { return gid_ & FLIP_DIAGONAL; }


    Sprite2D* GetSprite() const;

    bool HasProperty(const String& name) const;

    const String& GetProperty(const String& name) const;

private:
    friend class TmxTileLayer2D;


    unsigned gid_;

    SharedPtr<Sprite2D> sprite_;

    SharedPtr<PropertySet2D> propertySet_;
};


class __attribute__((visibility("default"))) TileMapObject2D : public RefCounted
{
public:
    TileMapObject2D();


    TileMapObjectType2D GetObjectType() const { return objectType_; }


    const String& GetName() const { return name_; }


    const String& GetType() const { return type_; }


    const Vector2& GetPosition() const { return position_; }


    const Vector2& GetSize() const { return size_; }


    unsigned GetNumPoints() const;

    const Vector2& GetPoint(unsigned index) const;


    unsigned GetTileGid() const { return gid_ & ~FLIP_ALL; }

    bool GetTileFlipX() const { return gid_ & FLIP_HORIZONTAL; }

    bool GetTileFlipY() const { return gid_ & FLIP_VERTICAL; }

    bool GetTileSwapXY() const { return gid_ & FLIP_DIAGONAL; }


    Sprite2D* GetTileSprite() const;

    bool HasProperty(const String& name) const;

    const String& GetProperty(const String& name) const;

private:
    friend class TmxObjectGroup2D;


    TileMapObjectType2D objectType_{};

    String name_;

    String type_;

    Vector2 position_;

    Vector2 size_;

    Vector<Vector2> points_;

    unsigned gid_{};

    SharedPtr<Sprite2D> sprite_;

    SharedPtr<PropertySet2D> propertySet_;
};

}

namespace Urho3D
{

class TileMapLayer2D;
class TmxFile2D;


class __attribute__((visibility("default"))) TileMap2D : public Component
{
    public: using ClassName = TileMap2D; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("TileMap2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit TileMap2D(Context* context);

    ~TileMap2D() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void SetTmxFile(TmxFile2D* tmxFile);

    void DrawDebugGeometry();


    TmxFile2D* GetTmxFile() const;


    const TileMapInfo2D& GetInfo() const { return info_; }


    unsigned GetNumLayers() const { return layers_.Size(); }


    TileMapLayer2D* GetLayer(unsigned index) const;

    Vector2 TileIndexToPosition(int x, int y) const;

    bool PositionToTileIndex(int& x, int& y, const Vector2& position) const;


    void SetTmxFileAttr(const ResourceRef& value);

    ResourceRef GetTmxFileAttr() const;

    Vector<SharedPtr<TileMapObject2D> > GetTileCollisionShapes(unsigned gid) const;
private:

    SharedPtr<TmxFile2D> tmxFile_;

    TileMapInfo2D info_{};

    SharedPtr<Node> rootNode_;

    Vector<WeakPtr<TileMapLayer2D> > layers_;
};

}

namespace Urho3D
{

class DebugRenderer;
class Node;
class TileMap2D;
class TmxImageLayer2D;
class TmxLayer2D;
class TmxObjectGroup2D;
class TmxTileLayer2D;


class __attribute__((visibility("default"))) TileMapLayer2D : public Component
{
    public: using ClassName = TileMapLayer2D; using BaseClassName = Component; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("TileMapLayer2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit TileMapLayer2D(Context* context);

    ~TileMapLayer2D() override;

    static void RegisterObject(Context* context);


    void DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override;


    void Initialize(TileMap2D* tileMap, const TmxLayer2D* tmxLayer);

    void SetDrawOrder(int drawOrder);

    void SetVisible(bool visible);


    TileMap2D* GetTileMap() const;


    const TmxLayer2D* GetTmxLayer() const { return tmxLayer_; }


    int GetDrawOrder() const { return drawOrder_; }


    bool IsVisible() const { return visible_; }


    bool HasProperty(const String& name) const;

    const String& GetProperty(const String& name) const;

    TileMapLayerType2D GetLayerType() const;


    int GetWidth() const;

    int GetHeight() const;

    Node* GetTileNode(int x, int y) const;

    Tile2D* GetTile(int x, int y) const;


    unsigned GetNumObjects() const;

    TileMapObject2D* GetObject(unsigned index) const;

    Node* GetObjectNode(unsigned index) const;


    Node* GetImageNode() const;

private:

    void SetTileLayer(const TmxTileLayer2D* tileLayer);

    void SetObjectGroup(const TmxObjectGroup2D* objectGroup);

    void SetImageLayer(const TmxImageLayer2D* imageLayer);


    WeakPtr<TileMap2D> tileMap_;

    const TmxLayer2D* tmxLayer_{};

    const TmxTileLayer2D* tileLayer_{};

    const TmxObjectGroup2D* objectGroup_{};

    const TmxImageLayer2D* imageLayer_{};

    int drawOrder_{};

    bool visible_{true};

    Vector<SharedPtr<Node> > nodes_;
};

}
namespace Urho3D
{

class Sprite2D;
class Texture2D;
class TmxFile2D;
class XMLElement;
class XMLFile;


class TmxLayer2D : public RefCounted
{
public:
    TmxLayer2D(TmxFile2D* tmxFile, TileMapLayerType2D type);
    ~TmxLayer2D() override = default;


    TmxFile2D* GetTmxFile() const;


    TileMapLayerType2D GetType() const { return type_; }


    const String& GetName() const { return name_; }


    int GetWidth() const { return width_; }


    int GetHeight() const { return height_; }


    bool IsVisible() const { return visible_; }


    bool HasProperty(const String& name) const;

    const String& GetProperty(const String& name) const;


protected:

    void LoadInfo(const XMLElement& element);

    void LoadPropertySet(const XMLElement& element);


    WeakPtr<TmxFile2D> tmxFile_;

    TileMapLayerType2D type_;

    String name_;

    int width_{};

    int height_{};

    bool visible_{};

    SharedPtr<PropertySet2D> propertySet_;
};


class TmxTileLayer2D : public TmxLayer2D
{
public:
    explicit TmxTileLayer2D(TmxFile2D* tmxFile);


    bool Load(const XMLElement& element, const TileMapInfo2D& info);

    Tile2D* GetTile(int x, int y) const;

protected:

    Vector<SharedPtr<Tile2D> > tiles_;
};


class TmxObjectGroup2D : public TmxLayer2D
{
public:
    explicit TmxObjectGroup2D(TmxFile2D* tmxFile);


    bool Load(const XMLElement& element, const TileMapInfo2D& info);


    void StoreObject(const XMLElement& objectElem, const SharedPtr<TileMapObject2D>& object, const TileMapInfo2D& info, bool isTile = false);


    unsigned GetNumObjects() const { return objects_.Size(); }


    TileMapObject2D* GetObject(unsigned index) const;

private:

    Vector<SharedPtr<TileMapObject2D> > objects_;
};


class TmxImageLayer2D : public TmxLayer2D
{
public:
    explicit TmxImageLayer2D(TmxFile2D* tmxFile);


    bool Load(const XMLElement& element, const TileMapInfo2D& info);


    const Vector2& GetPosition() const { return position_; }


    const String& GetSource() const { return source_; }


    Sprite2D* GetSprite() const;

private:

    Vector2 position_;

    String source_;

    SharedPtr<Sprite2D> sprite_;
};


class __attribute__((visibility("default"))) TmxFile2D : public Resource
{
    public: using ClassName = TmxFile2D; using BaseClassName = Resource; virtual Urho3D::StringHash GetType() const override { return GetTypeInfoStatic()->GetType(); } virtual const Urho3D::String& GetTypeName() const override { return GetTypeInfoStatic()->GetTypeName(); } virtual const Urho3D::TypeInfo* GetTypeInfo() const override { return GetTypeInfoStatic(); } static Urho3D::StringHash GetTypeStatic() { return GetTypeInfoStatic()->GetType(); } static const Urho3D::String& GetTypeNameStatic() { return GetTypeInfoStatic()->GetTypeName(); } static const Urho3D::TypeInfo* GetTypeInfoStatic() { static const Urho3D::TypeInfo typeInfoStatic("TmxFile2D", BaseClassName::GetTypeInfoStatic()); return &typeInfoStatic; };

public:

    explicit TmxFile2D(Context* context);

    ~TmxFile2D() override;

    static void RegisterObject(Context* context);


    bool BeginLoad(Deserializer& source) override;

    bool EndLoad() override;


    bool SetInfo(Orientation2D orientation, int width, int height, float tileWidth, float tileHeight);


    void AddLayer(unsigned index, TmxLayer2D *layer);


    void AddLayer(Urho3D::TmxLayer2D* layer);


    const TileMapInfo2D& GetInfo() const { return info_; }


    Sprite2D* GetTileSprite(unsigned gid) const;


    Vector<SharedPtr<TileMapObject2D> > GetTileCollisionShapes(unsigned gid) const;


    PropertySet2D* GetTilePropertySet(unsigned gid) const;


    unsigned GetNumLayers() const { return layers_.Size(); }


    const TmxLayer2D* GetLayer(unsigned index) const;


    void SetSpriteTextureEdgeOffset(float offset);


    float GetSpriteTextureEdgeOffset() const { return edgeOffset_; }

private:

    SharedPtr<XMLFile> LoadTSXFile(const String& source);

    bool LoadTileSet(const XMLElement& element);


    SharedPtr<XMLFile> loadXMLFile_;

    HashMap<String, SharedPtr<XMLFile> > tsxXMLFiles_;

    TileMapInfo2D info_{};

    HashMap<unsigned, SharedPtr<Sprite2D> > gidToSpriteMapping_;

    HashMap<unsigned, SharedPtr<PropertySet2D> > gidToPropertySetMapping_;

    HashMap<unsigned, Vector<SharedPtr<TileMapObject2D> > > gidToCollisionShapeMapping_;

    Vector<TmxLayer2D*> layers_;

    float edgeOffset_;
};

}
namespace Urho3D
{


void __attribute__((visibility("default"))) RegisterUrho2DLibrary(Context* context);

}
namespace Urho3D
{


static const Urho3D::StringHash E_PARTICLESEND(Urho3D::GetEventNameRegister().RegisterString("ParticlesEnd")); namespace ParticlesEnd
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_EFFECT("Effect");
}


static const Urho3D::StringHash E_PARTICLESDURATION(Urho3D::GetEventNameRegister().RegisterString("ParticlesDuration")); namespace ParticlesDuration
{
    static const Urho3D::StringHash P_NODE("Node");
    static const Urho3D::StringHash P_EFFECT("Effect");
}

}



using namespace Urho3D;
